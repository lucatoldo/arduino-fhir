// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "medicinalproduct-pskel.hxx"

namespace fhir
{
  // MedicinalProduct_pskel
  //

  void MedicinalProduct_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  domain_parser (::fhir::Coding_pskel& p)
  {
    this->domain_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  combinedPharmaceuticalDoseForm_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->combinedPharmaceuticalDoseForm_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  legalStatusOfSupply_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->legalStatusOfSupply_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  additionalMonitoringIndicator_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->additionalMonitoringIndicator_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  specialMeasures_parser (::fhir::string_pskel& p)
  {
    this->specialMeasures_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  paediatricUseIndicator_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->paediatricUseIndicator_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  productClassification_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->productClassification_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  marketingStatus_parser (::fhir::MarketingStatus_pskel& p)
  {
    this->marketingStatus_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  pharmaceuticalProduct_parser (::fhir::Reference_pskel& p)
  {
    this->pharmaceuticalProduct_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  packagedMedicinalProduct_parser (::fhir::Reference_pskel& p)
  {
    this->packagedMedicinalProduct_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  attachedDocument_parser (::fhir::Reference_pskel& p)
  {
    this->attachedDocument_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  masterFile_parser (::fhir::Reference_pskel& p)
  {
    this->masterFile_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  contact_parser (::fhir::Reference_pskel& p)
  {
    this->contact_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  clinicalTrial_parser (::fhir::Reference_pskel& p)
  {
    this->clinicalTrial_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  name_parser (::fhir::MedicinalProduct_Name_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  crossReference_parser (::fhir::Identifier_pskel& p)
  {
    this->crossReference_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  manufacturingBusinessOperation_parser (::fhir::MedicinalProduct_ManufacturingBusinessOperation_pskel& p)
  {
    this->manufacturingBusinessOperation_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  specialDesignation_parser (::fhir::MedicinalProduct_SpecialDesignation_pskel& p)
  {
    this->specialDesignation_parser_ = &p;
  }

  void MedicinalProduct_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Coding_pskel& domain,
           ::fhir::CodeableConcept_pskel& combinedPharmaceuticalDoseForm,
           ::fhir::CodeableConcept_pskel& legalStatusOfSupply,
           ::fhir::CodeableConcept_pskel& additionalMonitoringIndicator,
           ::fhir::string_pskel& specialMeasures,
           ::fhir::CodeableConcept_pskel& paediatricUseIndicator,
           ::fhir::CodeableConcept_pskel& productClassification,
           ::fhir::MarketingStatus_pskel& marketingStatus,
           ::fhir::Reference_pskel& pharmaceuticalProduct,
           ::fhir::Reference_pskel& packagedMedicinalProduct,
           ::fhir::Reference_pskel& attachedDocument,
           ::fhir::Reference_pskel& masterFile,
           ::fhir::Reference_pskel& contact,
           ::fhir::Reference_pskel& clinicalTrial,
           ::fhir::MedicinalProduct_Name_pskel& name,
           ::fhir::Identifier_pskel& crossReference,
           ::fhir::MedicinalProduct_ManufacturingBusinessOperation_pskel& manufacturingBusinessOperation,
           ::fhir::MedicinalProduct_SpecialDesignation_pskel& specialDesignation)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->identifier_parser_ = &identifier;
    this->type_parser_ = &type;
    this->domain_parser_ = &domain;
    this->combinedPharmaceuticalDoseForm_parser_ = &combinedPharmaceuticalDoseForm;
    this->legalStatusOfSupply_parser_ = &legalStatusOfSupply;
    this->additionalMonitoringIndicator_parser_ = &additionalMonitoringIndicator;
    this->specialMeasures_parser_ = &specialMeasures;
    this->paediatricUseIndicator_parser_ = &paediatricUseIndicator;
    this->productClassification_parser_ = &productClassification;
    this->marketingStatus_parser_ = &marketingStatus;
    this->pharmaceuticalProduct_parser_ = &pharmaceuticalProduct;
    this->packagedMedicinalProduct_parser_ = &packagedMedicinalProduct;
    this->attachedDocument_parser_ = &attachedDocument;
    this->masterFile_parser_ = &masterFile;
    this->contact_parser_ = &contact;
    this->clinicalTrial_parser_ = &clinicalTrial;
    this->name_parser_ = &name;
    this->crossReference_parser_ = &crossReference;
    this->manufacturingBusinessOperation_parser_ = &manufacturingBusinessOperation;
    this->specialDesignation_parser_ = &specialDesignation;
  }

  MedicinalProduct_pskel::
  MedicinalProduct_pskel (::fhir::DomainResource_pskel* tiein)
  : ::fhir::DomainResource_pskel (tiein, 0),
    MedicinalProduct_impl_ (0),
    identifier_parser_ (0),
    type_parser_ (0),
    domain_parser_ (0),
    combinedPharmaceuticalDoseForm_parser_ (0),
    legalStatusOfSupply_parser_ (0),
    additionalMonitoringIndicator_parser_ (0),
    specialMeasures_parser_ (0),
    paediatricUseIndicator_parser_ (0),
    productClassification_parser_ (0),
    marketingStatus_parser_ (0),
    pharmaceuticalProduct_parser_ (0),
    packagedMedicinalProduct_parser_ (0),
    attachedDocument_parser_ (0),
    masterFile_parser_ (0),
    contact_parser_ (0),
    clinicalTrial_parser_ (0),
    name_parser_ (0),
    crossReference_parser_ (0),
    manufacturingBusinessOperation_parser_ (0),
    specialDesignation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicinalProduct_pskel::
  MedicinalProduct_pskel (MedicinalProduct_pskel* impl, void*)
  : ::fhir::DomainResource_pskel (impl, 0),
    MedicinalProduct_impl_ (impl),
    identifier_parser_ (0),
    type_parser_ (0),
    domain_parser_ (0),
    combinedPharmaceuticalDoseForm_parser_ (0),
    legalStatusOfSupply_parser_ (0),
    additionalMonitoringIndicator_parser_ (0),
    specialMeasures_parser_ (0),
    paediatricUseIndicator_parser_ (0),
    productClassification_parser_ (0),
    marketingStatus_parser_ (0),
    pharmaceuticalProduct_parser_ (0),
    packagedMedicinalProduct_parser_ (0),
    attachedDocument_parser_ (0),
    masterFile_parser_ (0),
    contact_parser_ (0),
    clinicalTrial_parser_ (0),
    name_parser_ (0),
    crossReference_parser_ (0),
    manufacturingBusinessOperation_parser_ (0),
    specialDesignation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicinalProduct_Name_pskel
  //

  void MedicinalProduct_Name_pskel::
  productName_parser (::fhir::string_pskel& p)
  {
    this->productName_parser_ = &p;
  }

  void MedicinalProduct_Name_pskel::
  namePart_parser (::fhir::MedicinalProduct_NamePart_pskel& p)
  {
    this->namePart_parser_ = &p;
  }

  void MedicinalProduct_Name_pskel::
  countryLanguage_parser (::fhir::MedicinalProduct_CountryLanguage_pskel& p)
  {
    this->countryLanguage_parser_ = &p;
  }

  void MedicinalProduct_Name_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& productName,
           ::fhir::MedicinalProduct_NamePart_pskel& namePart,
           ::fhir::MedicinalProduct_CountryLanguage_pskel& countryLanguage)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->productName_parser_ = &productName;
    this->namePart_parser_ = &namePart;
    this->countryLanguage_parser_ = &countryLanguage;
  }

  MedicinalProduct_Name_pskel::
  MedicinalProduct_Name_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicinalProduct_Name_impl_ (0),
    productName_parser_ (0),
    namePart_parser_ (0),
    countryLanguage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicinalProduct_Name_pskel::
  MedicinalProduct_Name_pskel (MedicinalProduct_Name_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicinalProduct_Name_impl_ (impl),
    productName_parser_ (0),
    namePart_parser_ (0),
    countryLanguage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicinalProduct_NamePart_pskel
  //

  void MedicinalProduct_NamePart_pskel::
  part_parser (::fhir::string_pskel& p)
  {
    this->part_parser_ = &p;
  }

  void MedicinalProduct_NamePart_pskel::
  type_parser (::fhir::Coding_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicinalProduct_NamePart_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& part,
           ::fhir::Coding_pskel& type)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->part_parser_ = &part;
    this->type_parser_ = &type;
  }

  MedicinalProduct_NamePart_pskel::
  MedicinalProduct_NamePart_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicinalProduct_NamePart_impl_ (0),
    part_parser_ (0),
    type_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicinalProduct_NamePart_pskel::
  MedicinalProduct_NamePart_pskel (MedicinalProduct_NamePart_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicinalProduct_NamePart_impl_ (impl),
    part_parser_ (0),
    type_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicinalProduct_CountryLanguage_pskel
  //

  void MedicinalProduct_CountryLanguage_pskel::
  country_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->country_parser_ = &p;
  }

  void MedicinalProduct_CountryLanguage_pskel::
  jurisdiction_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->jurisdiction_parser_ = &p;
  }

  void MedicinalProduct_CountryLanguage_pskel::
  language_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->language_parser_ = &p;
  }

  void MedicinalProduct_CountryLanguage_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& country,
           ::fhir::CodeableConcept_pskel& jurisdiction,
           ::fhir::CodeableConcept_pskel& language)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->country_parser_ = &country;
    this->jurisdiction_parser_ = &jurisdiction;
    this->language_parser_ = &language;
  }

  MedicinalProduct_CountryLanguage_pskel::
  MedicinalProduct_CountryLanguage_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicinalProduct_CountryLanguage_impl_ (0),
    country_parser_ (0),
    jurisdiction_parser_ (0),
    language_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicinalProduct_CountryLanguage_pskel::
  MedicinalProduct_CountryLanguage_pskel (MedicinalProduct_CountryLanguage_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicinalProduct_CountryLanguage_impl_ (impl),
    country_parser_ (0),
    jurisdiction_parser_ (0),
    language_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicinalProduct_ManufacturingBusinessOperation_pskel
  //

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  operationType_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->operationType_parser_ = &p;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  authorisationReferenceNumber_parser (::fhir::Identifier_pskel& p)
  {
    this->authorisationReferenceNumber_parser_ = &p;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  effectiveDate_parser (::fhir::dateTime_pskel& p)
  {
    this->effectiveDate_parser_ = &p;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  confidentialityIndicator_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->confidentialityIndicator_parser_ = &p;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  manufacturer_parser (::fhir::Reference_pskel& p)
  {
    this->manufacturer_parser_ = &p;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  regulator_parser (::fhir::Reference_pskel& p)
  {
    this->regulator_parser_ = &p;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& operationType,
           ::fhir::Identifier_pskel& authorisationReferenceNumber,
           ::fhir::dateTime_pskel& effectiveDate,
           ::fhir::CodeableConcept_pskel& confidentialityIndicator,
           ::fhir::Reference_pskel& manufacturer,
           ::fhir::Reference_pskel& regulator)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->operationType_parser_ = &operationType;
    this->authorisationReferenceNumber_parser_ = &authorisationReferenceNumber;
    this->effectiveDate_parser_ = &effectiveDate;
    this->confidentialityIndicator_parser_ = &confidentialityIndicator;
    this->manufacturer_parser_ = &manufacturer;
    this->regulator_parser_ = &regulator;
  }

  MedicinalProduct_ManufacturingBusinessOperation_pskel::
  MedicinalProduct_ManufacturingBusinessOperation_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicinalProduct_ManufacturingBusinessOperation_impl_ (0),
    operationType_parser_ (0),
    authorisationReferenceNumber_parser_ (0),
    effectiveDate_parser_ (0),
    confidentialityIndicator_parser_ (0),
    manufacturer_parser_ (0),
    regulator_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicinalProduct_ManufacturingBusinessOperation_pskel::
  MedicinalProduct_ManufacturingBusinessOperation_pskel (MedicinalProduct_ManufacturingBusinessOperation_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicinalProduct_ManufacturingBusinessOperation_impl_ (impl),
    operationType_parser_ (0),
    authorisationReferenceNumber_parser_ (0),
    effectiveDate_parser_ (0),
    confidentialityIndicator_parser_ (0),
    manufacturer_parser_ (0),
    regulator_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicinalProduct_SpecialDesignation_pskel
  //

  void MedicinalProduct_SpecialDesignation_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  intendedUse_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->intendedUse_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  indicationCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->indicationCodeableConcept_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  indicationReference_parser (::fhir::Reference_pskel& p)
  {
    this->indicationReference_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  status_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  date_parser (::fhir::dateTime_pskel& p)
  {
    this->date_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  species_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->species_parser_ = &p;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::CodeableConcept_pskel& intendedUse,
           ::fhir::CodeableConcept_pskel& indicationCodeableConcept,
           ::fhir::Reference_pskel& indicationReference,
           ::fhir::CodeableConcept_pskel& status,
           ::fhir::dateTime_pskel& date,
           ::fhir::CodeableConcept_pskel& species)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->identifier_parser_ = &identifier;
    this->type_parser_ = &type;
    this->intendedUse_parser_ = &intendedUse;
    this->indicationCodeableConcept_parser_ = &indicationCodeableConcept;
    this->indicationReference_parser_ = &indicationReference;
    this->status_parser_ = &status;
    this->date_parser_ = &date;
    this->species_parser_ = &species;
  }

  MedicinalProduct_SpecialDesignation_pskel::
  MedicinalProduct_SpecialDesignation_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicinalProduct_SpecialDesignation_impl_ (0),
    identifier_parser_ (0),
    type_parser_ (0),
    intendedUse_parser_ (0),
    indicationCodeableConcept_parser_ (0),
    indicationReference_parser_ (0),
    status_parser_ (0),
    date_parser_ (0),
    species_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicinalProduct_SpecialDesignation_pskel::
  MedicinalProduct_SpecialDesignation_pskel (MedicinalProduct_SpecialDesignation_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicinalProduct_SpecialDesignation_impl_ (impl),
    identifier_parser_ (0),
    type_parser_ (0),
    intendedUse_parser_ (0),
    indicationCodeableConcept_parser_ (0),
    indicationReference_parser_ (0),
    status_parser_ (0),
    date_parser_ (0),
    species_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // MedicinalProduct_pskel
  //

  void MedicinalProduct_pskel::
  identifier ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->identifier ();
  }

  void MedicinalProduct_pskel::
  type ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->type ();
  }

  void MedicinalProduct_pskel::
  domain ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->domain ();
  }

  void MedicinalProduct_pskel::
  combinedPharmaceuticalDoseForm ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->combinedPharmaceuticalDoseForm ();
  }

  void MedicinalProduct_pskel::
  legalStatusOfSupply ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->legalStatusOfSupply ();
  }

  void MedicinalProduct_pskel::
  additionalMonitoringIndicator ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->additionalMonitoringIndicator ();
  }

  void MedicinalProduct_pskel::
  specialMeasures ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->specialMeasures ();
  }

  void MedicinalProduct_pskel::
  paediatricUseIndicator ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->paediatricUseIndicator ();
  }

  void MedicinalProduct_pskel::
  productClassification ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->productClassification ();
  }

  void MedicinalProduct_pskel::
  marketingStatus ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->marketingStatus ();
  }

  void MedicinalProduct_pskel::
  pharmaceuticalProduct ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->pharmaceuticalProduct ();
  }

  void MedicinalProduct_pskel::
  packagedMedicinalProduct ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->packagedMedicinalProduct ();
  }

  void MedicinalProduct_pskel::
  attachedDocument ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->attachedDocument ();
  }

  void MedicinalProduct_pskel::
  masterFile ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->masterFile ();
  }

  void MedicinalProduct_pskel::
  contact ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->contact ();
  }

  void MedicinalProduct_pskel::
  clinicalTrial ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->clinicalTrial ();
  }

  void MedicinalProduct_pskel::
  name ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->name ();
  }

  void MedicinalProduct_pskel::
  crossReference ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->crossReference ();
  }

  void MedicinalProduct_pskel::
  manufacturingBusinessOperation ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->manufacturingBusinessOperation ();
  }

  void MedicinalProduct_pskel::
  specialDesignation ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->specialDesignation ();
  }

  void MedicinalProduct_pskel::
  post_MedicinalProduct ()
  {
    if (this->MedicinalProduct_impl_)
      this->MedicinalProduct_impl_->post_MedicinalProduct ();
    else
      post_DomainResource ();
  }

  void MedicinalProduct_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::DomainResource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->domain_parser_)
      this->domain_parser_->_reset ();

    if (this->combinedPharmaceuticalDoseForm_parser_)
      this->combinedPharmaceuticalDoseForm_parser_->_reset ();

    if (this->legalStatusOfSupply_parser_)
      this->legalStatusOfSupply_parser_->_reset ();

    if (this->additionalMonitoringIndicator_parser_)
      this->additionalMonitoringIndicator_parser_->_reset ();

    if (this->specialMeasures_parser_)
      this->specialMeasures_parser_->_reset ();

    if (this->paediatricUseIndicator_parser_)
      this->paediatricUseIndicator_parser_->_reset ();

    if (this->productClassification_parser_)
      this->productClassification_parser_->_reset ();

    if (this->marketingStatus_parser_)
      this->marketingStatus_parser_->_reset ();

    if (this->pharmaceuticalProduct_parser_)
      this->pharmaceuticalProduct_parser_->_reset ();

    if (this->packagedMedicinalProduct_parser_)
      this->packagedMedicinalProduct_parser_->_reset ();

    if (this->attachedDocument_parser_)
      this->attachedDocument_parser_->_reset ();

    if (this->masterFile_parser_)
      this->masterFile_parser_->_reset ();

    if (this->contact_parser_)
      this->contact_parser_->_reset ();

    if (this->clinicalTrial_parser_)
      this->clinicalTrial_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->crossReference_parser_)
      this->crossReference_parser_->_reset ();

    if (this->manufacturingBusinessOperation_parser_)
      this->manufacturingBusinessOperation_parser_->_reset ();

    if (this->specialDesignation_parser_)
      this->specialDesignation_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicinalProduct_Name_pskel
  //

  void MedicinalProduct_Name_pskel::
  productName ()
  {
    if (this->MedicinalProduct_Name_impl_)
      this->MedicinalProduct_Name_impl_->productName ();
  }

  void MedicinalProduct_Name_pskel::
  namePart ()
  {
    if (this->MedicinalProduct_Name_impl_)
      this->MedicinalProduct_Name_impl_->namePart ();
  }

  void MedicinalProduct_Name_pskel::
  countryLanguage ()
  {
    if (this->MedicinalProduct_Name_impl_)
      this->MedicinalProduct_Name_impl_->countryLanguage ();
  }

  void MedicinalProduct_Name_pskel::
  post_MedicinalProduct_Name ()
  {
    if (this->MedicinalProduct_Name_impl_)
      this->MedicinalProduct_Name_impl_->post_MedicinalProduct_Name ();
    else
      post_BackboneElement ();
  }

  void MedicinalProduct_Name_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->productName_parser_)
      this->productName_parser_->_reset ();

    if (this->namePart_parser_)
      this->namePart_parser_->_reset ();

    if (this->countryLanguage_parser_)
      this->countryLanguage_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicinalProduct_NamePart_pskel
  //

  void MedicinalProduct_NamePart_pskel::
  part ()
  {
    if (this->MedicinalProduct_NamePart_impl_)
      this->MedicinalProduct_NamePart_impl_->part ();
  }

  void MedicinalProduct_NamePart_pskel::
  type ()
  {
    if (this->MedicinalProduct_NamePart_impl_)
      this->MedicinalProduct_NamePart_impl_->type ();
  }

  void MedicinalProduct_NamePart_pskel::
  post_MedicinalProduct_NamePart ()
  {
    if (this->MedicinalProduct_NamePart_impl_)
      this->MedicinalProduct_NamePart_impl_->post_MedicinalProduct_NamePart ();
    else
      post_BackboneElement ();
  }

  void MedicinalProduct_NamePart_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->part_parser_)
      this->part_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicinalProduct_CountryLanguage_pskel
  //

  void MedicinalProduct_CountryLanguage_pskel::
  country ()
  {
    if (this->MedicinalProduct_CountryLanguage_impl_)
      this->MedicinalProduct_CountryLanguage_impl_->country ();
  }

  void MedicinalProduct_CountryLanguage_pskel::
  jurisdiction ()
  {
    if (this->MedicinalProduct_CountryLanguage_impl_)
      this->MedicinalProduct_CountryLanguage_impl_->jurisdiction ();
  }

  void MedicinalProduct_CountryLanguage_pskel::
  language ()
  {
    if (this->MedicinalProduct_CountryLanguage_impl_)
      this->MedicinalProduct_CountryLanguage_impl_->language ();
  }

  void MedicinalProduct_CountryLanguage_pskel::
  post_MedicinalProduct_CountryLanguage ()
  {
    if (this->MedicinalProduct_CountryLanguage_impl_)
      this->MedicinalProduct_CountryLanguage_impl_->post_MedicinalProduct_CountryLanguage ();
    else
      post_BackboneElement ();
  }

  void MedicinalProduct_CountryLanguage_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->country_parser_)
      this->country_parser_->_reset ();

    if (this->jurisdiction_parser_)
      this->jurisdiction_parser_->_reset ();

    if (this->language_parser_)
      this->language_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicinalProduct_ManufacturingBusinessOperation_pskel
  //

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  operationType ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->operationType ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  authorisationReferenceNumber ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->authorisationReferenceNumber ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  effectiveDate ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->effectiveDate ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  confidentialityIndicator ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->confidentialityIndicator ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  manufacturer ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->manufacturer ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  regulator ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->regulator ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  post_MedicinalProduct_ManufacturingBusinessOperation ()
  {
    if (this->MedicinalProduct_ManufacturingBusinessOperation_impl_)
      this->MedicinalProduct_ManufacturingBusinessOperation_impl_->post_MedicinalProduct_ManufacturingBusinessOperation ();
    else
      post_BackboneElement ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->operationType_parser_)
      this->operationType_parser_->_reset ();

    if (this->authorisationReferenceNumber_parser_)
      this->authorisationReferenceNumber_parser_->_reset ();

    if (this->effectiveDate_parser_)
      this->effectiveDate_parser_->_reset ();

    if (this->confidentialityIndicator_parser_)
      this->confidentialityIndicator_parser_->_reset ();

    if (this->manufacturer_parser_)
      this->manufacturer_parser_->_reset ();

    if (this->regulator_parser_)
      this->regulator_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicinalProduct_SpecialDesignation_pskel
  //

  void MedicinalProduct_SpecialDesignation_pskel::
  identifier ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->identifier ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  type ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->type ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  intendedUse ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->intendedUse ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  indicationCodeableConcept ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->indicationCodeableConcept ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  indicationReference ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->indicationReference ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  status ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->status ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  date ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->date ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  species ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->species ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  post_MedicinalProduct_SpecialDesignation ()
  {
    if (this->MedicinalProduct_SpecialDesignation_impl_)
      this->MedicinalProduct_SpecialDesignation_impl_->post_MedicinalProduct_SpecialDesignation ();
    else
      post_BackboneElement ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->intendedUse_parser_)
      this->intendedUse_parser_->_reset ();

    if (this->indicationCodeableConcept_parser_)
      this->indicationCodeableConcept_parser_->_reset ();

    if (this->indicationReference_parser_)
      this->indicationReference_parser_->_reset ();

    if (this->status_parser_)
      this->status_parser_->_reset ();

    if (this->date_parser_)
      this->date_parser_->_reset ();

    if (this->species_parser_)
      this->species_parser_->_reset ();

    this->resetting_ = false;
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for MedicinalProduct_pskel.
  //
  bool MedicinalProduct_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "domain" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "combinedPharmaceuticalDoseForm" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "legalStatusOfSupply" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "additionalMonitoringIndicator" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "specialMeasures" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "paediatricUseIndicator" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "productClassification" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "marketingStatus" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "pharmaceuticalProduct" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "packagedMedicinalProduct" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "attachedDocument" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "masterFile" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;
        else if (n == "contact" &&
                 ns == "http://hl7.org/fhir")
          s = 14UL;
        else if (n == "clinicalTrial" &&
                 ns == "http://hl7.org/fhir")
          s = 15UL;
        else if (n == "name" &&
                 ns == "http://hl7.org/fhir")
          s = 16UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicinalProduct_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicinalProduct_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicinalProduct_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::DomainResource_pskel base;
    base::_pre_e_validate ();
  }

  void MedicinalProduct_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::DomainResource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicinalProduct_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "domain" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->domain_parser_)
            {
              this->domain_parser_->pre ();
              ctx.nested_parser (this->domain_parser_);
            }
          }
          else
          {
            if (this->domain_parser_ != 0)
            {
              this->domain_parser_->post_Coding ();
              this->domain ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "combinedPharmaceuticalDoseForm" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->combinedPharmaceuticalDoseForm_parser_)
            {
              this->combinedPharmaceuticalDoseForm_parser_->pre ();
              ctx.nested_parser (this->combinedPharmaceuticalDoseForm_parser_);
            }
          }
          else
          {
            if (this->combinedPharmaceuticalDoseForm_parser_ != 0)
            {
              this->combinedPharmaceuticalDoseForm_parser_->post_CodeableConcept ();
              this->combinedPharmaceuticalDoseForm ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "legalStatusOfSupply" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->legalStatusOfSupply_parser_)
            {
              this->legalStatusOfSupply_parser_->pre ();
              ctx.nested_parser (this->legalStatusOfSupply_parser_);
            }
          }
          else
          {
            if (this->legalStatusOfSupply_parser_ != 0)
            {
              this->legalStatusOfSupply_parser_->post_CodeableConcept ();
              this->legalStatusOfSupply ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "additionalMonitoringIndicator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->additionalMonitoringIndicator_parser_)
            {
              this->additionalMonitoringIndicator_parser_->pre ();
              ctx.nested_parser (this->additionalMonitoringIndicator_parser_);
            }
          }
          else
          {
            if (this->additionalMonitoringIndicator_parser_ != 0)
            {
              this->additionalMonitoringIndicator_parser_->post_CodeableConcept ();
              this->additionalMonitoringIndicator ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "specialMeasures" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->specialMeasures_parser_)
            {
              this->specialMeasures_parser_->pre ();
              ctx.nested_parser (this->specialMeasures_parser_);
            }
          }
          else
          {
            if (this->specialMeasures_parser_ != 0)
            {
              this->specialMeasures_parser_->post_string ();
              this->specialMeasures ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "paediatricUseIndicator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->paediatricUseIndicator_parser_)
            {
              this->paediatricUseIndicator_parser_->pre ();
              ctx.nested_parser (this->paediatricUseIndicator_parser_);
            }
          }
          else
          {
            if (this->paediatricUseIndicator_parser_ != 0)
            {
              this->paediatricUseIndicator_parser_->post_CodeableConcept ();
              this->paediatricUseIndicator ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "productClassification" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->productClassification_parser_)
            {
              this->productClassification_parser_->pre ();
              ctx.nested_parser (this->productClassification_parser_);
            }
          }
          else
          {
            if (this->productClassification_parser_ != 0)
            {
              this->productClassification_parser_->post_CodeableConcept ();
              this->productClassification ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "marketingStatus" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->marketingStatus_parser_)
            {
              this->marketingStatus_parser_->pre ();
              ctx.nested_parser (this->marketingStatus_parser_);
            }
          }
          else
          {
            if (this->marketingStatus_parser_ != 0)
            {
              this->marketingStatus_parser_->post_MarketingStatus ();
              this->marketingStatus ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "pharmaceuticalProduct" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->pharmaceuticalProduct_parser_)
            {
              this->pharmaceuticalProduct_parser_->pre ();
              ctx.nested_parser (this->pharmaceuticalProduct_parser_);
            }
          }
          else
          {
            if (this->pharmaceuticalProduct_parser_ != 0)
            {
              this->pharmaceuticalProduct_parser_->post_Reference ();
              this->pharmaceuticalProduct ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "packagedMedicinalProduct" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->packagedMedicinalProduct_parser_)
            {
              this->packagedMedicinalProduct_parser_->pre ();
              ctx.nested_parser (this->packagedMedicinalProduct_parser_);
            }
          }
          else
          {
            if (this->packagedMedicinalProduct_parser_ != 0)
            {
              this->packagedMedicinalProduct_parser_->post_Reference ();
              this->packagedMedicinalProduct ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "attachedDocument" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->attachedDocument_parser_)
            {
              this->attachedDocument_parser_->pre ();
              ctx.nested_parser (this->attachedDocument_parser_);
            }
          }
          else
          {
            if (this->attachedDocument_parser_ != 0)
            {
              this->attachedDocument_parser_->post_Reference ();
              this->attachedDocument ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "masterFile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->masterFile_parser_)
            {
              this->masterFile_parser_->pre ();
              ctx.nested_parser (this->masterFile_parser_);
            }
          }
          else
          {
            if (this->masterFile_parser_ != 0)
            {
              this->masterFile_parser_->post_Reference ();
              this->masterFile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "contact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contact_parser_)
            {
              this->contact_parser_->pre ();
              ctx.nested_parser (this->contact_parser_);
            }
          }
          else
          {
            if (this->contact_parser_ != 0)
            {
              this->contact_parser_->post_Reference ();
              this->contact ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "clinicalTrial" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->clinicalTrial_parser_)
            {
              this->clinicalTrial_parser_->pre ();
              ctx.nested_parser (this->clinicalTrial_parser_);
            }
          }
          else
          {
            if (this->clinicalTrial_parser_ != 0)
            {
              this->clinicalTrial_parser_->post_Reference ();
              this->clinicalTrial ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_MedicinalProduct_Name ();
              this->name ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "crossReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->crossReference_parser_)
            {
              this->crossReference_parser_->pre ();
              ctx.nested_parser (this->crossReference_parser_);
            }
          }
          else
          {
            if (this->crossReference_parser_ != 0)
            {
              this->crossReference_parser_->post_Identifier ();
              this->crossReference ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "manufacturingBusinessOperation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->manufacturingBusinessOperation_parser_)
            {
              this->manufacturingBusinessOperation_parser_->pre ();
              ctx.nested_parser (this->manufacturingBusinessOperation_parser_);
            }
          }
          else
          {
            if (this->manufacturingBusinessOperation_parser_ != 0)
            {
              this->manufacturingBusinessOperation_parser_->post_MedicinalProduct_ManufacturingBusinessOperation ();
              this->manufacturingBusinessOperation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "specialDesignation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->specialDesignation_parser_)
            {
              this->specialDesignation_parser_->pre ();
              ctx.nested_parser (this->specialDesignation_parser_);
            }
          }
          else
          {
            if (this->specialDesignation_parser_ != 0)
            {
              this->specialDesignation_parser_->post_MedicinalProduct_SpecialDesignation ();
              this->specialDesignation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicinalProduct_Name_pskel.
  //
  bool MedicinalProduct_Name_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "productName" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicinalProduct_Name_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicinalProduct_Name_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicinalProduct_Name_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicinalProduct_Name_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicinalProduct_Name_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "productName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->productName_parser_)
            {
              this->productName_parser_->pre ();
              ctx.nested_parser (this->productName_parser_);
            }
          }
          else
          {
            if (this->productName_parser_ != 0)
            {
              this->productName_parser_->post_string ();
              this->productName ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "namePart" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->namePart_parser_)
            {
              this->namePart_parser_->pre ();
              ctx.nested_parser (this->namePart_parser_);
            }
          }
          else
          {
            if (this->namePart_parser_ != 0)
            {
              this->namePart_parser_->post_MedicinalProduct_NamePart ();
              this->namePart ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "countryLanguage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->countryLanguage_parser_)
            {
              this->countryLanguage_parser_->pre ();
              ctx.nested_parser (this->countryLanguage_parser_);
            }
          }
          else
          {
            if (this->countryLanguage_parser_ != 0)
            {
              this->countryLanguage_parser_->post_MedicinalProduct_CountryLanguage ();
              this->countryLanguage ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicinalProduct_NamePart_pskel.
  //
  bool MedicinalProduct_NamePart_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "part" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicinalProduct_NamePart_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicinalProduct_NamePart_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicinalProduct_NamePart_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicinalProduct_NamePart_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicinalProduct_NamePart_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "part" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->part_parser_)
            {
              this->part_parser_->pre ();
              ctx.nested_parser (this->part_parser_);
            }
          }
          else
          {
            if (this->part_parser_ != 0)
            {
              this->part_parser_->post_string ();
              this->part ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_Coding ();
              this->type ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicinalProduct_CountryLanguage_pskel.
  //
  bool MedicinalProduct_CountryLanguage_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "country" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicinalProduct_CountryLanguage_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicinalProduct_CountryLanguage_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicinalProduct_CountryLanguage_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicinalProduct_CountryLanguage_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicinalProduct_CountryLanguage_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "country" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->country_parser_)
            {
              this->country_parser_->pre ();
              ctx.nested_parser (this->country_parser_);
            }
          }
          else
          {
            if (this->country_parser_ != 0)
            {
              this->country_parser_->post_CodeableConcept ();
              this->country ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "jurisdiction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->jurisdiction_parser_)
            {
              this->jurisdiction_parser_->pre ();
              ctx.nested_parser (this->jurisdiction_parser_);
            }
          }
          else
          {
            if (this->jurisdiction_parser_ != 0)
            {
              this->jurisdiction_parser_->post_CodeableConcept ();
              this->jurisdiction ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "language" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->language_parser_)
            {
              this->language_parser_->pre ();
              ctx.nested_parser (this->language_parser_);
            }
          }
          else
          {
            if (this->language_parser_ != 0)
            {
              this->language_parser_->post_CodeableConcept ();
              this->language ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicinalProduct_ManufacturingBusinessOperation_pskel.
  //
  bool MedicinalProduct_ManufacturingBusinessOperation_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "operationType" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "authorisationReferenceNumber" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "effectiveDate" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "confidentialityIndicator" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "manufacturer" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "regulator" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicinalProduct_ManufacturingBusinessOperation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicinalProduct_ManufacturingBusinessOperation_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicinalProduct_ManufacturingBusinessOperation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "operationType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operationType_parser_)
            {
              this->operationType_parser_->pre ();
              ctx.nested_parser (this->operationType_parser_);
            }
          }
          else
          {
            if (this->operationType_parser_ != 0)
            {
              this->operationType_parser_->post_CodeableConcept ();
              this->operationType ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "authorisationReferenceNumber" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->authorisationReferenceNumber_parser_)
            {
              this->authorisationReferenceNumber_parser_->pre ();
              ctx.nested_parser (this->authorisationReferenceNumber_parser_);
            }
          }
          else
          {
            if (this->authorisationReferenceNumber_parser_ != 0)
            {
              this->authorisationReferenceNumber_parser_->post_Identifier ();
              this->authorisationReferenceNumber ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "effectiveDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->effectiveDate_parser_)
            {
              this->effectiveDate_parser_->pre ();
              ctx.nested_parser (this->effectiveDate_parser_);
            }
          }
          else
          {
            if (this->effectiveDate_parser_ != 0)
            {
              this->effectiveDate_parser_->post_dateTime ();
              this->effectiveDate ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "confidentialityIndicator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->confidentialityIndicator_parser_)
            {
              this->confidentialityIndicator_parser_->pre ();
              ctx.nested_parser (this->confidentialityIndicator_parser_);
            }
          }
          else
          {
            if (this->confidentialityIndicator_parser_ != 0)
            {
              this->confidentialityIndicator_parser_->post_CodeableConcept ();
              this->confidentialityIndicator ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "manufacturer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->manufacturer_parser_)
            {
              this->manufacturer_parser_->pre ();
              ctx.nested_parser (this->manufacturer_parser_);
            }
          }
          else
          {
            if (this->manufacturer_parser_ != 0)
            {
              this->manufacturer_parser_->post_Reference ();
              this->manufacturer ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "regulator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->regulator_parser_)
            {
              this->regulator_parser_->pre ();
              ctx.nested_parser (this->regulator_parser_);
            }
          }
          else
          {
            if (this->regulator_parser_ != 0)
            {
              this->regulator_parser_->post_Reference ();
              this->regulator ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicinalProduct_SpecialDesignation_pskel.
  //
  bool MedicinalProduct_SpecialDesignation_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "intendedUse" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "indicationCodeableConcept" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "indicationReference" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "status" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "date" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "species" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicinalProduct_SpecialDesignation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicinalProduct_SpecialDesignation_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicinalProduct_SpecialDesignation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "intendedUse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->intendedUse_parser_)
            {
              this->intendedUse_parser_->pre ();
              ctx.nested_parser (this->intendedUse_parser_);
            }
          }
          else
          {
            if (this->intendedUse_parser_ != 0)
            {
              this->intendedUse_parser_->post_CodeableConcept ();
              this->intendedUse ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "indicationCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->indicationCodeableConcept_parser_)
            {
              this->indicationCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->indicationCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->indicationCodeableConcept_parser_ != 0)
            {
              this->indicationCodeableConcept_parser_->post_CodeableConcept ();
              this->indicationCodeableConcept ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "indicationReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->indicationReference_parser_)
            {
              this->indicationReference_parser_->pre ();
              ctx.nested_parser (this->indicationReference_parser_);
            }
          }
          else
          {
            if (this->indicationReference_parser_ != 0)
            {
              this->indicationReference_parser_->post_Reference ();
              this->indicationReference ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "status" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->status_parser_)
            {
              this->status_parser_->pre ();
              ctx.nested_parser (this->status_parser_);
            }
          }
          else
          {
            if (this->status_parser_ != 0)
            {
              this->status_parser_->post_CodeableConcept ();
              this->status ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "date" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->date_parser_)
            {
              this->date_parser_->pre ();
              ctx.nested_parser (this->date_parser_);
            }
          }
          else
          {
            if (this->date_parser_ != 0)
            {
              this->date_parser_->post_dateTime ();
              this->date ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "species" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->species_parser_)
            {
              this->species_parser_->pre ();
              ctx.nested_parser (this->species_parser_);
            }
          }
          else
          {
            if (this->species_parser_ != 0)
            {
              this->species_parser_->post_CodeableConcept ();
              this->species ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "testscript-pskel.hxx"

namespace fhir
{
  // TestScript_pskel
  //

  void TestScript_pskel::
  url_parser (::fhir::uri_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void TestScript_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void TestScript_pskel::
  version_parser (::fhir::string_pskel& p)
  {
    this->version_parser_ = &p;
  }

  void TestScript_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void TestScript_pskel::
  title_parser (::fhir::string_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void TestScript_pskel::
  status_parser (::fhir::PublicationStatus_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void TestScript_pskel::
  experimental_parser (::fhir::boolean_pskel& p)
  {
    this->experimental_parser_ = &p;
  }

  void TestScript_pskel::
  date_parser (::fhir::dateTime_pskel& p)
  {
    this->date_parser_ = &p;
  }

  void TestScript_pskel::
  publisher_parser (::fhir::string_pskel& p)
  {
    this->publisher_parser_ = &p;
  }

  void TestScript_pskel::
  contact_parser (::fhir::ContactDetail_pskel& p)
  {
    this->contact_parser_ = &p;
  }

  void TestScript_pskel::
  description_parser (::fhir::markdown_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_pskel::
  useContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->useContext_parser_ = &p;
  }

  void TestScript_pskel::
  jurisdiction_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->jurisdiction_parser_ = &p;
  }

  void TestScript_pskel::
  purpose_parser (::fhir::markdown_pskel& p)
  {
    this->purpose_parser_ = &p;
  }

  void TestScript_pskel::
  copyright_parser (::fhir::markdown_pskel& p)
  {
    this->copyright_parser_ = &p;
  }

  void TestScript_pskel::
  origin_parser (::fhir::TestScript_Origin_pskel& p)
  {
    this->origin_parser_ = &p;
  }

  void TestScript_pskel::
  destination_parser (::fhir::TestScript_Destination_pskel& p)
  {
    this->destination_parser_ = &p;
  }

  void TestScript_pskel::
  metadata_parser (::fhir::TestScript_Metadata_pskel& p)
  {
    this->metadata_parser_ = &p;
  }

  void TestScript_pskel::
  fixture_parser (::fhir::TestScript_Fixture_pskel& p)
  {
    this->fixture_parser_ = &p;
  }

  void TestScript_pskel::
  profile_parser (::fhir::Reference_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void TestScript_pskel::
  variable_parser (::fhir::TestScript_Variable_pskel& p)
  {
    this->variable_parser_ = &p;
  }

  void TestScript_pskel::
  setup_parser (::fhir::TestScript_Setup_pskel& p)
  {
    this->setup_parser_ = &p;
  }

  void TestScript_pskel::
  test_parser (::fhir::TestScript_Test_pskel& p)
  {
    this->test_parser_ = &p;
  }

  void TestScript_pskel::
  teardown_parser (::fhir::TestScript_Teardown_pskel& p)
  {
    this->teardown_parser_ = &p;
  }

  void TestScript_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::uri_pskel& url,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::string_pskel& version,
           ::fhir::string_pskel& name,
           ::fhir::string_pskel& title,
           ::fhir::PublicationStatus_pskel& status,
           ::fhir::boolean_pskel& experimental,
           ::fhir::dateTime_pskel& date,
           ::fhir::string_pskel& publisher,
           ::fhir::ContactDetail_pskel& contact,
           ::fhir::markdown_pskel& description,
           ::fhir::UsageContext_pskel& useContext,
           ::fhir::CodeableConcept_pskel& jurisdiction,
           ::fhir::markdown_pskel& purpose,
           ::fhir::markdown_pskel& copyright,
           ::fhir::TestScript_Origin_pskel& origin,
           ::fhir::TestScript_Destination_pskel& destination,
           ::fhir::TestScript_Metadata_pskel& metadata,
           ::fhir::TestScript_Fixture_pskel& fixture,
           ::fhir::Reference_pskel& profile,
           ::fhir::TestScript_Variable_pskel& variable,
           ::fhir::TestScript_Setup_pskel& setup,
           ::fhir::TestScript_Test_pskel& test,
           ::fhir::TestScript_Teardown_pskel& teardown)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->url_parser_ = &url;
    this->identifier_parser_ = &identifier;
    this->version_parser_ = &version;
    this->name_parser_ = &name;
    this->title_parser_ = &title;
    this->status_parser_ = &status;
    this->experimental_parser_ = &experimental;
    this->date_parser_ = &date;
    this->publisher_parser_ = &publisher;
    this->contact_parser_ = &contact;
    this->description_parser_ = &description;
    this->useContext_parser_ = &useContext;
    this->jurisdiction_parser_ = &jurisdiction;
    this->purpose_parser_ = &purpose;
    this->copyright_parser_ = &copyright;
    this->origin_parser_ = &origin;
    this->destination_parser_ = &destination;
    this->metadata_parser_ = &metadata;
    this->fixture_parser_ = &fixture;
    this->profile_parser_ = &profile;
    this->variable_parser_ = &variable;
    this->setup_parser_ = &setup;
    this->test_parser_ = &test;
    this->teardown_parser_ = &teardown;
  }

  TestScript_pskel::
  TestScript_pskel (::fhir::DomainResource_pskel* tiein)
  : ::fhir::DomainResource_pskel (tiein, 0),
    TestScript_impl_ (0),
    url_parser_ (0),
    identifier_parser_ (0),
    version_parser_ (0),
    name_parser_ (0),
    title_parser_ (0),
    status_parser_ (0),
    experimental_parser_ (0),
    date_parser_ (0),
    publisher_parser_ (0),
    contact_parser_ (0),
    description_parser_ (0),
    useContext_parser_ (0),
    jurisdiction_parser_ (0),
    purpose_parser_ (0),
    copyright_parser_ (0),
    origin_parser_ (0),
    destination_parser_ (0),
    metadata_parser_ (0),
    fixture_parser_ (0),
    profile_parser_ (0),
    variable_parser_ (0),
    setup_parser_ (0),
    test_parser_ (0),
    teardown_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_pskel::
  TestScript_pskel (TestScript_pskel* impl, void*)
  : ::fhir::DomainResource_pskel (impl, 0),
    TestScript_impl_ (impl),
    url_parser_ (0),
    identifier_parser_ (0),
    version_parser_ (0),
    name_parser_ (0),
    title_parser_ (0),
    status_parser_ (0),
    experimental_parser_ (0),
    date_parser_ (0),
    publisher_parser_ (0),
    contact_parser_ (0),
    description_parser_ (0),
    useContext_parser_ (0),
    jurisdiction_parser_ (0),
    purpose_parser_ (0),
    copyright_parser_ (0),
    origin_parser_ (0),
    destination_parser_ (0),
    metadata_parser_ (0),
    fixture_parser_ (0),
    profile_parser_ (0),
    variable_parser_ (0),
    setup_parser_ (0),
    test_parser_ (0),
    teardown_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Origin_pskel
  //

  void TestScript_Origin_pskel::
  index_parser (::fhir::integer_pskel& p)
  {
    this->index_parser_ = &p;
  }

  void TestScript_Origin_pskel::
  profile_parser (::fhir::Coding_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void TestScript_Origin_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& index,
           ::fhir::Coding_pskel& profile)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->index_parser_ = &index;
    this->profile_parser_ = &profile;
  }

  TestScript_Origin_pskel::
  TestScript_Origin_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Origin_impl_ (0),
    index_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Origin_pskel::
  TestScript_Origin_pskel (TestScript_Origin_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Origin_impl_ (impl),
    index_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Destination_pskel
  //

  void TestScript_Destination_pskel::
  index_parser (::fhir::integer_pskel& p)
  {
    this->index_parser_ = &p;
  }

  void TestScript_Destination_pskel::
  profile_parser (::fhir::Coding_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void TestScript_Destination_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& index,
           ::fhir::Coding_pskel& profile)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->index_parser_ = &index;
    this->profile_parser_ = &profile;
  }

  TestScript_Destination_pskel::
  TestScript_Destination_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Destination_impl_ (0),
    index_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Destination_pskel::
  TestScript_Destination_pskel (TestScript_Destination_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Destination_impl_ (impl),
    index_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Metadata_pskel
  //

  void TestScript_Metadata_pskel::
  link_parser (::fhir::TestScript_Link_pskel& p)
  {
    this->link_parser_ = &p;
  }

  void TestScript_Metadata_pskel::
  capability_parser (::fhir::TestScript_Capability_pskel& p)
  {
    this->capability_parser_ = &p;
  }

  void TestScript_Metadata_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TestScript_Link_pskel& link,
           ::fhir::TestScript_Capability_pskel& capability)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->link_parser_ = &link;
    this->capability_parser_ = &capability;
  }

  TestScript_Metadata_pskel::
  TestScript_Metadata_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Metadata_impl_ (0),
    link_parser_ (0),
    capability_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Metadata_pskel::
  TestScript_Metadata_pskel (TestScript_Metadata_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Metadata_impl_ (impl),
    link_parser_ (0),
    capability_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Link_pskel
  //

  void TestScript_Link_pskel::
  url_parser (::fhir::uri_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void TestScript_Link_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_Link_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::uri_pskel& url,
           ::fhir::string_pskel& description)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->url_parser_ = &url;
    this->description_parser_ = &description;
  }

  TestScript_Link_pskel::
  TestScript_Link_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Link_impl_ (0),
    url_parser_ (0),
    description_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Link_pskel::
  TestScript_Link_pskel (TestScript_Link_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Link_impl_ (impl),
    url_parser_ (0),
    description_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Capability_pskel
  //

  void TestScript_Capability_pskel::
  required_parser (::fhir::boolean_pskel& p)
  {
    this->required_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  validated_parser (::fhir::boolean_pskel& p)
  {
    this->validated_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  origin_parser (::fhir::integer_pskel& p)
  {
    this->origin_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  destination_parser (::fhir::integer_pskel& p)
  {
    this->destination_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  link_parser (::fhir::uri_pskel& p)
  {
    this->link_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  capabilities_parser (::fhir::canonical_pskel& p)
  {
    this->capabilities_parser_ = &p;
  }

  void TestScript_Capability_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::boolean_pskel& required,
           ::fhir::boolean_pskel& validated,
           ::fhir::string_pskel& description,
           ::fhir::integer_pskel& origin,
           ::fhir::integer_pskel& destination,
           ::fhir::uri_pskel& link,
           ::fhir::canonical_pskel& capabilities)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->required_parser_ = &required;
    this->validated_parser_ = &validated;
    this->description_parser_ = &description;
    this->origin_parser_ = &origin;
    this->destination_parser_ = &destination;
    this->link_parser_ = &link;
    this->capabilities_parser_ = &capabilities;
  }

  TestScript_Capability_pskel::
  TestScript_Capability_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Capability_impl_ (0),
    required_parser_ (0),
    validated_parser_ (0),
    description_parser_ (0),
    origin_parser_ (0),
    destination_parser_ (0),
    link_parser_ (0),
    capabilities_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Capability_pskel::
  TestScript_Capability_pskel (TestScript_Capability_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Capability_impl_ (impl),
    required_parser_ (0),
    validated_parser_ (0),
    description_parser_ (0),
    origin_parser_ (0),
    destination_parser_ (0),
    link_parser_ (0),
    capabilities_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Fixture_pskel
  //

  void TestScript_Fixture_pskel::
  autocreate_parser (::fhir::boolean_pskel& p)
  {
    this->autocreate_parser_ = &p;
  }

  void TestScript_Fixture_pskel::
  autodelete_parser (::fhir::boolean_pskel& p)
  {
    this->autodelete_parser_ = &p;
  }

  void TestScript_Fixture_pskel::
  resource_parser (::fhir::Reference_pskel& p)
  {
    this->resource_parser_ = &p;
  }

  void TestScript_Fixture_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::boolean_pskel& autocreate,
           ::fhir::boolean_pskel& autodelete,
           ::fhir::Reference_pskel& resource)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->autocreate_parser_ = &autocreate;
    this->autodelete_parser_ = &autodelete;
    this->resource_parser_ = &resource;
  }

  TestScript_Fixture_pskel::
  TestScript_Fixture_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Fixture_impl_ (0),
    autocreate_parser_ (0),
    autodelete_parser_ (0),
    resource_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Fixture_pskel::
  TestScript_Fixture_pskel (TestScript_Fixture_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Fixture_impl_ (impl),
    autocreate_parser_ (0),
    autodelete_parser_ (0),
    resource_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Variable_pskel
  //

  void TestScript_Variable_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  defaultValue_parser (::fhir::string_pskel& p)
  {
    this->defaultValue_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  expression_parser (::fhir::string_pskel& p)
  {
    this->expression_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  headerField_parser (::fhir::string_pskel& p)
  {
    this->headerField_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  hint_parser (::fhir::string_pskel& p)
  {
    this->hint_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  sourceId_parser (::fhir::id_pskel& p)
  {
    this->sourceId_parser_ = &p;
  }

  void TestScript_Variable_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& name,
           ::fhir::string_pskel& defaultValue,
           ::fhir::string_pskel& description,
           ::fhir::string_pskel& expression,
           ::fhir::string_pskel& headerField,
           ::fhir::string_pskel& hint,
           ::fhir::string_pskel& path,
           ::fhir::id_pskel& sourceId)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->name_parser_ = &name;
    this->defaultValue_parser_ = &defaultValue;
    this->description_parser_ = &description;
    this->expression_parser_ = &expression;
    this->headerField_parser_ = &headerField;
    this->hint_parser_ = &hint;
    this->path_parser_ = &path;
    this->sourceId_parser_ = &sourceId;
  }

  TestScript_Variable_pskel::
  TestScript_Variable_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Variable_impl_ (0),
    name_parser_ (0),
    defaultValue_parser_ (0),
    description_parser_ (0),
    expression_parser_ (0),
    headerField_parser_ (0),
    hint_parser_ (0),
    path_parser_ (0),
    sourceId_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Variable_pskel::
  TestScript_Variable_pskel (TestScript_Variable_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Variable_impl_ (impl),
    name_parser_ (0),
    defaultValue_parser_ (0),
    description_parser_ (0),
    expression_parser_ (0),
    headerField_parser_ (0),
    hint_parser_ (0),
    path_parser_ (0),
    sourceId_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Setup_pskel
  //

  void TestScript_Setup_pskel::
  action_parser (::fhir::TestScript_Action_pskel& p)
  {
    this->action_parser_ = &p;
  }

  void TestScript_Setup_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TestScript_Action_pskel& action)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->action_parser_ = &action;
  }

  TestScript_Setup_pskel::
  TestScript_Setup_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Setup_impl_ (0),
    action_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Setup_pskel::
  TestScript_Setup_pskel (TestScript_Setup_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Setup_impl_ (impl),
    action_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Action_pskel
  //

  void TestScript_Action_pskel::
  operation_parser (::fhir::TestScript_Operation_pskel& p)
  {
    this->operation_parser_ = &p;
  }

  void TestScript_Action_pskel::
  assert_parser (::fhir::TestScript_Assert_pskel& p)
  {
    this->assert_parser_ = &p;
  }

  void TestScript_Action_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TestScript_Operation_pskel& operation,
           ::fhir::TestScript_Assert_pskel& assert)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->operation_parser_ = &operation;
    this->assert_parser_ = &assert;
  }

  TestScript_Action_pskel::
  TestScript_Action_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Action_impl_ (0),
    operation_parser_ (0),
    assert_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Action_pskel::
  TestScript_Action_pskel (TestScript_Action_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Action_impl_ (impl),
    operation_parser_ (0),
    assert_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Operation_pskel
  //

  void TestScript_Operation_pskel::
  type_parser (::fhir::Coding_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  resource_parser (::fhir::code_pskel& p)
  {
    this->resource_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  label_parser (::fhir::string_pskel& p)
  {
    this->label_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  accept_parser (::fhir::code_pskel& p)
  {
    this->accept_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  contentType_parser (::fhir::code_pskel& p)
  {
    this->contentType_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  destination_parser (::fhir::integer_pskel& p)
  {
    this->destination_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  encodeRequestUrl_parser (::fhir::boolean_pskel& p)
  {
    this->encodeRequestUrl_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  method_parser (::fhir::TestScriptRequestMethodCode_pskel& p)
  {
    this->method_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  origin_parser (::fhir::integer_pskel& p)
  {
    this->origin_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  params_parser (::fhir::string_pskel& p)
  {
    this->params_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  requestHeader_parser (::fhir::TestScript_RequestHeader_pskel& p)
  {
    this->requestHeader_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  requestId_parser (::fhir::id_pskel& p)
  {
    this->requestId_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  responseId_parser (::fhir::id_pskel& p)
  {
    this->responseId_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  sourceId_parser (::fhir::id_pskel& p)
  {
    this->sourceId_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  targetId_parser (::fhir::id_pskel& p)
  {
    this->targetId_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  url_parser (::fhir::string_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void TestScript_Operation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Coding_pskel& type,
           ::fhir::code_pskel& resource,
           ::fhir::string_pskel& label,
           ::fhir::string_pskel& description,
           ::fhir::code_pskel& accept,
           ::fhir::code_pskel& contentType,
           ::fhir::integer_pskel& destination,
           ::fhir::boolean_pskel& encodeRequestUrl,
           ::fhir::TestScriptRequestMethodCode_pskel& method,
           ::fhir::integer_pskel& origin,
           ::fhir::string_pskel& params,
           ::fhir::TestScript_RequestHeader_pskel& requestHeader,
           ::fhir::id_pskel& requestId,
           ::fhir::id_pskel& responseId,
           ::fhir::id_pskel& sourceId,
           ::fhir::id_pskel& targetId,
           ::fhir::string_pskel& url)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->resource_parser_ = &resource;
    this->label_parser_ = &label;
    this->description_parser_ = &description;
    this->accept_parser_ = &accept;
    this->contentType_parser_ = &contentType;
    this->destination_parser_ = &destination;
    this->encodeRequestUrl_parser_ = &encodeRequestUrl;
    this->method_parser_ = &method;
    this->origin_parser_ = &origin;
    this->params_parser_ = &params;
    this->requestHeader_parser_ = &requestHeader;
    this->requestId_parser_ = &requestId;
    this->responseId_parser_ = &responseId;
    this->sourceId_parser_ = &sourceId;
    this->targetId_parser_ = &targetId;
    this->url_parser_ = &url;
  }

  TestScript_Operation_pskel::
  TestScript_Operation_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Operation_impl_ (0),
    type_parser_ (0),
    resource_parser_ (0),
    label_parser_ (0),
    description_parser_ (0),
    accept_parser_ (0),
    contentType_parser_ (0),
    destination_parser_ (0),
    encodeRequestUrl_parser_ (0),
    method_parser_ (0),
    origin_parser_ (0),
    params_parser_ (0),
    requestHeader_parser_ (0),
    requestId_parser_ (0),
    responseId_parser_ (0),
    sourceId_parser_ (0),
    targetId_parser_ (0),
    url_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Operation_pskel::
  TestScript_Operation_pskel (TestScript_Operation_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Operation_impl_ (impl),
    type_parser_ (0),
    resource_parser_ (0),
    label_parser_ (0),
    description_parser_ (0),
    accept_parser_ (0),
    contentType_parser_ (0),
    destination_parser_ (0),
    encodeRequestUrl_parser_ (0),
    method_parser_ (0),
    origin_parser_ (0),
    params_parser_ (0),
    requestHeader_parser_ (0),
    requestId_parser_ (0),
    responseId_parser_ (0),
    sourceId_parser_ (0),
    targetId_parser_ (0),
    url_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_RequestHeader_pskel
  //

  void TestScript_RequestHeader_pskel::
  field_parser (::fhir::string_pskel& p)
  {
    this->field_parser_ = &p;
  }

  void TestScript_RequestHeader_pskel::
  value_parser (::fhir::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void TestScript_RequestHeader_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& field,
           ::fhir::string_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->field_parser_ = &field;
    this->value_parser_ = &value;
  }

  TestScript_RequestHeader_pskel::
  TestScript_RequestHeader_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_RequestHeader_impl_ (0),
    field_parser_ (0),
    value_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_RequestHeader_pskel::
  TestScript_RequestHeader_pskel (TestScript_RequestHeader_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_RequestHeader_impl_ (impl),
    field_parser_ (0),
    value_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Assert_pskel
  //

  void TestScript_Assert_pskel::
  label_parser (::fhir::string_pskel& p)
  {
    this->label_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  direction_parser (::fhir::AssertionDirectionType_pskel& p)
  {
    this->direction_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  compareToSourceId_parser (::fhir::string_pskel& p)
  {
    this->compareToSourceId_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  compareToSourceExpression_parser (::fhir::string_pskel& p)
  {
    this->compareToSourceExpression_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  compareToSourcePath_parser (::fhir::string_pskel& p)
  {
    this->compareToSourcePath_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  contentType_parser (::fhir::code_pskel& p)
  {
    this->contentType_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  expression_parser (::fhir::string_pskel& p)
  {
    this->expression_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  headerField_parser (::fhir::string_pskel& p)
  {
    this->headerField_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  minimumId_parser (::fhir::string_pskel& p)
  {
    this->minimumId_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  navigationLinks_parser (::fhir::boolean_pskel& p)
  {
    this->navigationLinks_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  operator__parser (::fhir::AssertionOperatorType_pskel& p)
  {
    this->operator__parser_ = &p;
  }

  void TestScript_Assert_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  requestMethod_parser (::fhir::TestScriptRequestMethodCode_pskel& p)
  {
    this->requestMethod_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  requestURL_parser (::fhir::string_pskel& p)
  {
    this->requestURL_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  resource_parser (::fhir::code_pskel& p)
  {
    this->resource_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  response_parser (::fhir::AssertionResponseTypes_pskel& p)
  {
    this->response_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  responseCode_parser (::fhir::string_pskel& p)
  {
    this->responseCode_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  sourceId_parser (::fhir::id_pskel& p)
  {
    this->sourceId_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  validateProfileId_parser (::fhir::id_pskel& p)
  {
    this->validateProfileId_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  value_parser (::fhir::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  warningOnly_parser (::fhir::boolean_pskel& p)
  {
    this->warningOnly_parser_ = &p;
  }

  void TestScript_Assert_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& label,
           ::fhir::string_pskel& description,
           ::fhir::AssertionDirectionType_pskel& direction,
           ::fhir::string_pskel& compareToSourceId,
           ::fhir::string_pskel& compareToSourceExpression,
           ::fhir::string_pskel& compareToSourcePath,
           ::fhir::code_pskel& contentType,
           ::fhir::string_pskel& expression,
           ::fhir::string_pskel& headerField,
           ::fhir::string_pskel& minimumId,
           ::fhir::boolean_pskel& navigationLinks,
           ::fhir::AssertionOperatorType_pskel& operator_,
           ::fhir::string_pskel& path,
           ::fhir::TestScriptRequestMethodCode_pskel& requestMethod,
           ::fhir::string_pskel& requestURL,
           ::fhir::code_pskel& resource,
           ::fhir::AssertionResponseTypes_pskel& response,
           ::fhir::string_pskel& responseCode,
           ::fhir::id_pskel& sourceId,
           ::fhir::id_pskel& validateProfileId,
           ::fhir::string_pskel& value,
           ::fhir::boolean_pskel& warningOnly)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->label_parser_ = &label;
    this->description_parser_ = &description;
    this->direction_parser_ = &direction;
    this->compareToSourceId_parser_ = &compareToSourceId;
    this->compareToSourceExpression_parser_ = &compareToSourceExpression;
    this->compareToSourcePath_parser_ = &compareToSourcePath;
    this->contentType_parser_ = &contentType;
    this->expression_parser_ = &expression;
    this->headerField_parser_ = &headerField;
    this->minimumId_parser_ = &minimumId;
    this->navigationLinks_parser_ = &navigationLinks;
    this->operator__parser_ = &operator_;
    this->path_parser_ = &path;
    this->requestMethod_parser_ = &requestMethod;
    this->requestURL_parser_ = &requestURL;
    this->resource_parser_ = &resource;
    this->response_parser_ = &response;
    this->responseCode_parser_ = &responseCode;
    this->sourceId_parser_ = &sourceId;
    this->validateProfileId_parser_ = &validateProfileId;
    this->value_parser_ = &value;
    this->warningOnly_parser_ = &warningOnly;
  }

  TestScript_Assert_pskel::
  TestScript_Assert_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Assert_impl_ (0),
    label_parser_ (0),
    description_parser_ (0),
    direction_parser_ (0),
    compareToSourceId_parser_ (0),
    compareToSourceExpression_parser_ (0),
    compareToSourcePath_parser_ (0),
    contentType_parser_ (0),
    expression_parser_ (0),
    headerField_parser_ (0),
    minimumId_parser_ (0),
    navigationLinks_parser_ (0),
    operator__parser_ (0),
    path_parser_ (0),
    requestMethod_parser_ (0),
    requestURL_parser_ (0),
    resource_parser_ (0),
    response_parser_ (0),
    responseCode_parser_ (0),
    sourceId_parser_ (0),
    validateProfileId_parser_ (0),
    value_parser_ (0),
    warningOnly_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Assert_pskel::
  TestScript_Assert_pskel (TestScript_Assert_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Assert_impl_ (impl),
    label_parser_ (0),
    description_parser_ (0),
    direction_parser_ (0),
    compareToSourceId_parser_ (0),
    compareToSourceExpression_parser_ (0),
    compareToSourcePath_parser_ (0),
    contentType_parser_ (0),
    expression_parser_ (0),
    headerField_parser_ (0),
    minimumId_parser_ (0),
    navigationLinks_parser_ (0),
    operator__parser_ (0),
    path_parser_ (0),
    requestMethod_parser_ (0),
    requestURL_parser_ (0),
    resource_parser_ (0),
    response_parser_ (0),
    responseCode_parser_ (0),
    sourceId_parser_ (0),
    validateProfileId_parser_ (0),
    value_parser_ (0),
    warningOnly_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Test_pskel
  //

  void TestScript_Test_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void TestScript_Test_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void TestScript_Test_pskel::
  action_parser (::fhir::TestScript_Action1_pskel& p)
  {
    this->action_parser_ = &p;
  }

  void TestScript_Test_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& name,
           ::fhir::string_pskel& description,
           ::fhir::TestScript_Action1_pskel& action)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->name_parser_ = &name;
    this->description_parser_ = &description;
    this->action_parser_ = &action;
  }

  TestScript_Test_pskel::
  TestScript_Test_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Test_impl_ (0),
    name_parser_ (0),
    description_parser_ (0),
    action_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Test_pskel::
  TestScript_Test_pskel (TestScript_Test_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Test_impl_ (impl),
    name_parser_ (0),
    description_parser_ (0),
    action_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Action1_pskel
  //

  void TestScript_Action1_pskel::
  operation_parser (::fhir::TestScript_Operation_pskel& p)
  {
    this->operation_parser_ = &p;
  }

  void TestScript_Action1_pskel::
  assert_parser (::fhir::TestScript_Assert_pskel& p)
  {
    this->assert_parser_ = &p;
  }

  void TestScript_Action1_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TestScript_Operation_pskel& operation,
           ::fhir::TestScript_Assert_pskel& assert)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->operation_parser_ = &operation;
    this->assert_parser_ = &assert;
  }

  TestScript_Action1_pskel::
  TestScript_Action1_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Action1_impl_ (0),
    operation_parser_ (0),
    assert_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Action1_pskel::
  TestScript_Action1_pskel (TestScript_Action1_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Action1_impl_ (impl),
    operation_parser_ (0),
    assert_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Teardown_pskel
  //

  void TestScript_Teardown_pskel::
  action_parser (::fhir::TestScript_Action2_pskel& p)
  {
    this->action_parser_ = &p;
  }

  void TestScript_Teardown_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TestScript_Action2_pskel& action)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->action_parser_ = &action;
  }

  TestScript_Teardown_pskel::
  TestScript_Teardown_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Teardown_impl_ (0),
    action_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Teardown_pskel::
  TestScript_Teardown_pskel (TestScript_Teardown_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Teardown_impl_ (impl),
    action_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TestScript_Action2_pskel
  //

  void TestScript_Action2_pskel::
  operation_parser (::fhir::TestScript_Operation_pskel& p)
  {
    this->operation_parser_ = &p;
  }

  void TestScript_Action2_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TestScript_Operation_pskel& operation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->operation_parser_ = &operation;
  }

  TestScript_Action2_pskel::
  TestScript_Action2_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    TestScript_Action2_impl_ (0),
    operation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TestScript_Action2_pskel::
  TestScript_Action2_pskel (TestScript_Action2_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    TestScript_Action2_impl_ (impl),
    operation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // AssertionDirectionType_list_pskel
  //

  AssertionDirectionType_list_pskel::
  AssertionDirectionType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AssertionDirectionType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AssertionDirectionType_list_pskel_enums_, 2UL);
  }

  AssertionDirectionType_list_pskel::
  AssertionDirectionType_list_pskel (AssertionDirectionType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AssertionDirectionType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AssertionDirectionType_list_pskel_enums_, 2UL);
  }

  // AssertionDirectionType_pskel
  //

  void AssertionDirectionType_pskel::
  value_parser (::fhir::AssertionDirectionType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AssertionDirectionType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AssertionDirectionType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AssertionDirectionType_pskel::
  AssertionDirectionType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AssertionDirectionType_impl_ (0),
    value_parser_ (0)
  {
  }

  AssertionDirectionType_pskel::
  AssertionDirectionType_pskel (AssertionDirectionType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AssertionDirectionType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // AssertionOperatorType_list_pskel
  //

  AssertionOperatorType_list_pskel::
  AssertionOperatorType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AssertionOperatorType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AssertionOperatorType_list_pskel_enums_, 11UL);
  }

  AssertionOperatorType_list_pskel::
  AssertionOperatorType_list_pskel (AssertionOperatorType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AssertionOperatorType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AssertionOperatorType_list_pskel_enums_, 11UL);
  }

  // AssertionOperatorType_pskel
  //

  void AssertionOperatorType_pskel::
  value_parser (::fhir::AssertionOperatorType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AssertionOperatorType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AssertionOperatorType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AssertionOperatorType_pskel::
  AssertionOperatorType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AssertionOperatorType_impl_ (0),
    value_parser_ (0)
  {
  }

  AssertionOperatorType_pskel::
  AssertionOperatorType_pskel (AssertionOperatorType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AssertionOperatorType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // AssertionResponseTypes_list_pskel
  //

  AssertionResponseTypes_list_pskel::
  AssertionResponseTypes_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AssertionResponseTypes_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AssertionResponseTypes_list_pskel_enums_, 12UL);
  }

  AssertionResponseTypes_list_pskel::
  AssertionResponseTypes_list_pskel (AssertionResponseTypes_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AssertionResponseTypes_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AssertionResponseTypes_list_pskel_enums_, 12UL);
  }

  // AssertionResponseTypes_pskel
  //

  void AssertionResponseTypes_pskel::
  value_parser (::fhir::AssertionResponseTypes_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AssertionResponseTypes_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AssertionResponseTypes_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AssertionResponseTypes_pskel::
  AssertionResponseTypes_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AssertionResponseTypes_impl_ (0),
    value_parser_ (0)
  {
  }

  AssertionResponseTypes_pskel::
  AssertionResponseTypes_pskel (AssertionResponseTypes_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AssertionResponseTypes_impl_ (impl),
    value_parser_ (0)
  {
  }

  // TestScriptRequestMethodCode_list_pskel
  //

  TestScriptRequestMethodCode_list_pskel::
  TestScriptRequestMethodCode_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    TestScriptRequestMethodCode_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_TestScriptRequestMethodCode_list_pskel_enums_, 7UL);
  }

  TestScriptRequestMethodCode_list_pskel::
  TestScriptRequestMethodCode_list_pskel (TestScriptRequestMethodCode_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    TestScriptRequestMethodCode_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_TestScriptRequestMethodCode_list_pskel_enums_, 7UL);
  }

  // TestScriptRequestMethodCode_pskel
  //

  void TestScriptRequestMethodCode_pskel::
  value_parser (::fhir::TestScriptRequestMethodCode_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void TestScriptRequestMethodCode_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::TestScriptRequestMethodCode_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  TestScriptRequestMethodCode_pskel::
  TestScriptRequestMethodCode_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    TestScriptRequestMethodCode_impl_ (0),
    value_parser_ (0)
  {
  }

  TestScriptRequestMethodCode_pskel::
  TestScriptRequestMethodCode_pskel (TestScriptRequestMethodCode_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    TestScriptRequestMethodCode_impl_ (impl),
    value_parser_ (0)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // TestScript_pskel
  //

  void TestScript_pskel::
  url ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->url ();
  }

  void TestScript_pskel::
  identifier ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->identifier ();
  }

  void TestScript_pskel::
  version ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->version ();
  }

  void TestScript_pskel::
  name ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->name ();
  }

  void TestScript_pskel::
  title ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->title ();
  }

  void TestScript_pskel::
  status ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->status ();
  }

  void TestScript_pskel::
  experimental ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->experimental ();
  }

  void TestScript_pskel::
  date ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->date ();
  }

  void TestScript_pskel::
  publisher ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->publisher ();
  }

  void TestScript_pskel::
  contact ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->contact ();
  }

  void TestScript_pskel::
  description ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->description ();
  }

  void TestScript_pskel::
  useContext ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->useContext ();
  }

  void TestScript_pskel::
  jurisdiction ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->jurisdiction ();
  }

  void TestScript_pskel::
  purpose ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->purpose ();
  }

  void TestScript_pskel::
  copyright ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->copyright ();
  }

  void TestScript_pskel::
  origin ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->origin ();
  }

  void TestScript_pskel::
  destination ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->destination ();
  }

  void TestScript_pskel::
  metadata ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->metadata ();
  }

  void TestScript_pskel::
  fixture ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->fixture ();
  }

  void TestScript_pskel::
  profile ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->profile ();
  }

  void TestScript_pskel::
  variable ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->variable ();
  }

  void TestScript_pskel::
  setup ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->setup ();
  }

  void TestScript_pskel::
  test ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->test ();
  }

  void TestScript_pskel::
  teardown ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->teardown ();
  }

  void TestScript_pskel::
  post_TestScript ()
  {
    if (this->TestScript_impl_)
      this->TestScript_impl_->post_TestScript ();
    else
      post_DomainResource ();
  }

  void TestScript_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::DomainResource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->version_parser_)
      this->version_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->status_parser_)
      this->status_parser_->_reset ();

    if (this->experimental_parser_)
      this->experimental_parser_->_reset ();

    if (this->date_parser_)
      this->date_parser_->_reset ();

    if (this->publisher_parser_)
      this->publisher_parser_->_reset ();

    if (this->contact_parser_)
      this->contact_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->useContext_parser_)
      this->useContext_parser_->_reset ();

    if (this->jurisdiction_parser_)
      this->jurisdiction_parser_->_reset ();

    if (this->purpose_parser_)
      this->purpose_parser_->_reset ();

    if (this->copyright_parser_)
      this->copyright_parser_->_reset ();

    if (this->origin_parser_)
      this->origin_parser_->_reset ();

    if (this->destination_parser_)
      this->destination_parser_->_reset ();

    if (this->metadata_parser_)
      this->metadata_parser_->_reset ();

    if (this->fixture_parser_)
      this->fixture_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    if (this->variable_parser_)
      this->variable_parser_->_reset ();

    if (this->setup_parser_)
      this->setup_parser_->_reset ();

    if (this->test_parser_)
      this->test_parser_->_reset ();

    if (this->teardown_parser_)
      this->teardown_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Origin_pskel
  //

  void TestScript_Origin_pskel::
  index ()
  {
    if (this->TestScript_Origin_impl_)
      this->TestScript_Origin_impl_->index ();
  }

  void TestScript_Origin_pskel::
  profile ()
  {
    if (this->TestScript_Origin_impl_)
      this->TestScript_Origin_impl_->profile ();
  }

  void TestScript_Origin_pskel::
  post_TestScript_Origin ()
  {
    if (this->TestScript_Origin_impl_)
      this->TestScript_Origin_impl_->post_TestScript_Origin ();
    else
      post_BackboneElement ();
  }

  void TestScript_Origin_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->index_parser_)
      this->index_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Destination_pskel
  //

  void TestScript_Destination_pskel::
  index ()
  {
    if (this->TestScript_Destination_impl_)
      this->TestScript_Destination_impl_->index ();
  }

  void TestScript_Destination_pskel::
  profile ()
  {
    if (this->TestScript_Destination_impl_)
      this->TestScript_Destination_impl_->profile ();
  }

  void TestScript_Destination_pskel::
  post_TestScript_Destination ()
  {
    if (this->TestScript_Destination_impl_)
      this->TestScript_Destination_impl_->post_TestScript_Destination ();
    else
      post_BackboneElement ();
  }

  void TestScript_Destination_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->index_parser_)
      this->index_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Metadata_pskel
  //

  void TestScript_Metadata_pskel::
  link ()
  {
    if (this->TestScript_Metadata_impl_)
      this->TestScript_Metadata_impl_->link ();
  }

  void TestScript_Metadata_pskel::
  capability ()
  {
    if (this->TestScript_Metadata_impl_)
      this->TestScript_Metadata_impl_->capability ();
  }

  void TestScript_Metadata_pskel::
  post_TestScript_Metadata ()
  {
    if (this->TestScript_Metadata_impl_)
      this->TestScript_Metadata_impl_->post_TestScript_Metadata ();
    else
      post_BackboneElement ();
  }

  void TestScript_Metadata_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->link_parser_)
      this->link_parser_->_reset ();

    if (this->capability_parser_)
      this->capability_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Link_pskel
  //

  void TestScript_Link_pskel::
  url ()
  {
    if (this->TestScript_Link_impl_)
      this->TestScript_Link_impl_->url ();
  }

  void TestScript_Link_pskel::
  description ()
  {
    if (this->TestScript_Link_impl_)
      this->TestScript_Link_impl_->description ();
  }

  void TestScript_Link_pskel::
  post_TestScript_Link ()
  {
    if (this->TestScript_Link_impl_)
      this->TestScript_Link_impl_->post_TestScript_Link ();
    else
      post_BackboneElement ();
  }

  void TestScript_Link_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Capability_pskel
  //

  void TestScript_Capability_pskel::
  required ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->required ();
  }

  void TestScript_Capability_pskel::
  validated ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->validated ();
  }

  void TestScript_Capability_pskel::
  description ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->description ();
  }

  void TestScript_Capability_pskel::
  origin ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->origin ();
  }

  void TestScript_Capability_pskel::
  destination ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->destination ();
  }

  void TestScript_Capability_pskel::
  link ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->link ();
  }

  void TestScript_Capability_pskel::
  capabilities ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->capabilities ();
  }

  void TestScript_Capability_pskel::
  post_TestScript_Capability ()
  {
    if (this->TestScript_Capability_impl_)
      this->TestScript_Capability_impl_->post_TestScript_Capability ();
    else
      post_BackboneElement ();
  }

  void TestScript_Capability_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->required_parser_)
      this->required_parser_->_reset ();

    if (this->validated_parser_)
      this->validated_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->origin_parser_)
      this->origin_parser_->_reset ();

    if (this->destination_parser_)
      this->destination_parser_->_reset ();

    if (this->link_parser_)
      this->link_parser_->_reset ();

    if (this->capabilities_parser_)
      this->capabilities_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Fixture_pskel
  //

  void TestScript_Fixture_pskel::
  autocreate ()
  {
    if (this->TestScript_Fixture_impl_)
      this->TestScript_Fixture_impl_->autocreate ();
  }

  void TestScript_Fixture_pskel::
  autodelete ()
  {
    if (this->TestScript_Fixture_impl_)
      this->TestScript_Fixture_impl_->autodelete ();
  }

  void TestScript_Fixture_pskel::
  resource ()
  {
    if (this->TestScript_Fixture_impl_)
      this->TestScript_Fixture_impl_->resource ();
  }

  void TestScript_Fixture_pskel::
  post_TestScript_Fixture ()
  {
    if (this->TestScript_Fixture_impl_)
      this->TestScript_Fixture_impl_->post_TestScript_Fixture ();
    else
      post_BackboneElement ();
  }

  void TestScript_Fixture_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->autocreate_parser_)
      this->autocreate_parser_->_reset ();

    if (this->autodelete_parser_)
      this->autodelete_parser_->_reset ();

    if (this->resource_parser_)
      this->resource_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Variable_pskel
  //

  void TestScript_Variable_pskel::
  name ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->name ();
  }

  void TestScript_Variable_pskel::
  defaultValue ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->defaultValue ();
  }

  void TestScript_Variable_pskel::
  description ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->description ();
  }

  void TestScript_Variable_pskel::
  expression ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->expression ();
  }

  void TestScript_Variable_pskel::
  headerField ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->headerField ();
  }

  void TestScript_Variable_pskel::
  hint ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->hint ();
  }

  void TestScript_Variable_pskel::
  path ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->path ();
  }

  void TestScript_Variable_pskel::
  sourceId ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->sourceId ();
  }

  void TestScript_Variable_pskel::
  post_TestScript_Variable ()
  {
    if (this->TestScript_Variable_impl_)
      this->TestScript_Variable_impl_->post_TestScript_Variable ();
    else
      post_BackboneElement ();
  }

  void TestScript_Variable_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->defaultValue_parser_)
      this->defaultValue_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->expression_parser_)
      this->expression_parser_->_reset ();

    if (this->headerField_parser_)
      this->headerField_parser_->_reset ();

    if (this->hint_parser_)
      this->hint_parser_->_reset ();

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->sourceId_parser_)
      this->sourceId_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Setup_pskel
  //

  void TestScript_Setup_pskel::
  action ()
  {
    if (this->TestScript_Setup_impl_)
      this->TestScript_Setup_impl_->action ();
  }

  void TestScript_Setup_pskel::
  post_TestScript_Setup ()
  {
    if (this->TestScript_Setup_impl_)
      this->TestScript_Setup_impl_->post_TestScript_Setup ();
    else
      post_BackboneElement ();
  }

  void TestScript_Setup_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->action_parser_)
      this->action_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Action_pskel
  //

  void TestScript_Action_pskel::
  operation ()
  {
    if (this->TestScript_Action_impl_)
      this->TestScript_Action_impl_->operation ();
  }

  void TestScript_Action_pskel::
  assert ()
  {
    if (this->TestScript_Action_impl_)
      this->TestScript_Action_impl_->assert ();
  }

  void TestScript_Action_pskel::
  post_TestScript_Action ()
  {
    if (this->TestScript_Action_impl_)
      this->TestScript_Action_impl_->post_TestScript_Action ();
    else
      post_BackboneElement ();
  }

  void TestScript_Action_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->operation_parser_)
      this->operation_parser_->_reset ();

    if (this->assert_parser_)
      this->assert_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Operation_pskel
  //

  void TestScript_Operation_pskel::
  type ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->type ();
  }

  void TestScript_Operation_pskel::
  resource ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->resource ();
  }

  void TestScript_Operation_pskel::
  label ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->label ();
  }

  void TestScript_Operation_pskel::
  description ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->description ();
  }

  void TestScript_Operation_pskel::
  accept ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->accept ();
  }

  void TestScript_Operation_pskel::
  contentType ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->contentType ();
  }

  void TestScript_Operation_pskel::
  destination ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->destination ();
  }

  void TestScript_Operation_pskel::
  encodeRequestUrl ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->encodeRequestUrl ();
  }

  void TestScript_Operation_pskel::
  method ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->method ();
  }

  void TestScript_Operation_pskel::
  origin ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->origin ();
  }

  void TestScript_Operation_pskel::
  params ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->params ();
  }

  void TestScript_Operation_pskel::
  requestHeader ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->requestHeader ();
  }

  void TestScript_Operation_pskel::
  requestId ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->requestId ();
  }

  void TestScript_Operation_pskel::
  responseId ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->responseId ();
  }

  void TestScript_Operation_pskel::
  sourceId ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->sourceId ();
  }

  void TestScript_Operation_pskel::
  targetId ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->targetId ();
  }

  void TestScript_Operation_pskel::
  url ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->url ();
  }

  void TestScript_Operation_pskel::
  post_TestScript_Operation ()
  {
    if (this->TestScript_Operation_impl_)
      this->TestScript_Operation_impl_->post_TestScript_Operation ();
    else
      post_BackboneElement ();
  }

  void TestScript_Operation_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->resource_parser_)
      this->resource_parser_->_reset ();

    if (this->label_parser_)
      this->label_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->accept_parser_)
      this->accept_parser_->_reset ();

    if (this->contentType_parser_)
      this->contentType_parser_->_reset ();

    if (this->destination_parser_)
      this->destination_parser_->_reset ();

    if (this->encodeRequestUrl_parser_)
      this->encodeRequestUrl_parser_->_reset ();

    if (this->method_parser_)
      this->method_parser_->_reset ();

    if (this->origin_parser_)
      this->origin_parser_->_reset ();

    if (this->params_parser_)
      this->params_parser_->_reset ();

    if (this->requestHeader_parser_)
      this->requestHeader_parser_->_reset ();

    if (this->requestId_parser_)
      this->requestId_parser_->_reset ();

    if (this->responseId_parser_)
      this->responseId_parser_->_reset ();

    if (this->sourceId_parser_)
      this->sourceId_parser_->_reset ();

    if (this->targetId_parser_)
      this->targetId_parser_->_reset ();

    if (this->url_parser_)
      this->url_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_RequestHeader_pskel
  //

  void TestScript_RequestHeader_pskel::
  field ()
  {
    if (this->TestScript_RequestHeader_impl_)
      this->TestScript_RequestHeader_impl_->field ();
  }

  void TestScript_RequestHeader_pskel::
  value ()
  {
    if (this->TestScript_RequestHeader_impl_)
      this->TestScript_RequestHeader_impl_->value ();
  }

  void TestScript_RequestHeader_pskel::
  post_TestScript_RequestHeader ()
  {
    if (this->TestScript_RequestHeader_impl_)
      this->TestScript_RequestHeader_impl_->post_TestScript_RequestHeader ();
    else
      post_BackboneElement ();
  }

  void TestScript_RequestHeader_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->field_parser_)
      this->field_parser_->_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Assert_pskel
  //

  void TestScript_Assert_pskel::
  label ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->label ();
  }

  void TestScript_Assert_pskel::
  description ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->description ();
  }

  void TestScript_Assert_pskel::
  direction ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->direction ();
  }

  void TestScript_Assert_pskel::
  compareToSourceId ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->compareToSourceId ();
  }

  void TestScript_Assert_pskel::
  compareToSourceExpression ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->compareToSourceExpression ();
  }

  void TestScript_Assert_pskel::
  compareToSourcePath ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->compareToSourcePath ();
  }

  void TestScript_Assert_pskel::
  contentType ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->contentType ();
  }

  void TestScript_Assert_pskel::
  expression ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->expression ();
  }

  void TestScript_Assert_pskel::
  headerField ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->headerField ();
  }

  void TestScript_Assert_pskel::
  minimumId ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->minimumId ();
  }

  void TestScript_Assert_pskel::
  navigationLinks ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->navigationLinks ();
  }

  void TestScript_Assert_pskel::
  operator_ ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->operator_ ();
  }

  void TestScript_Assert_pskel::
  path ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->path ();
  }

  void TestScript_Assert_pskel::
  requestMethod ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->requestMethod ();
  }

  void TestScript_Assert_pskel::
  requestURL ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->requestURL ();
  }

  void TestScript_Assert_pskel::
  resource ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->resource ();
  }

  void TestScript_Assert_pskel::
  response ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->response ();
  }

  void TestScript_Assert_pskel::
  responseCode ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->responseCode ();
  }

  void TestScript_Assert_pskel::
  sourceId ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->sourceId ();
  }

  void TestScript_Assert_pskel::
  validateProfileId ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->validateProfileId ();
  }

  void TestScript_Assert_pskel::
  value ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->value ();
  }

  void TestScript_Assert_pskel::
  warningOnly ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->warningOnly ();
  }

  void TestScript_Assert_pskel::
  post_TestScript_Assert ()
  {
    if (this->TestScript_Assert_impl_)
      this->TestScript_Assert_impl_->post_TestScript_Assert ();
    else
      post_BackboneElement ();
  }

  void TestScript_Assert_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->label_parser_)
      this->label_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->direction_parser_)
      this->direction_parser_->_reset ();

    if (this->compareToSourceId_parser_)
      this->compareToSourceId_parser_->_reset ();

    if (this->compareToSourceExpression_parser_)
      this->compareToSourceExpression_parser_->_reset ();

    if (this->compareToSourcePath_parser_)
      this->compareToSourcePath_parser_->_reset ();

    if (this->contentType_parser_)
      this->contentType_parser_->_reset ();

    if (this->expression_parser_)
      this->expression_parser_->_reset ();

    if (this->headerField_parser_)
      this->headerField_parser_->_reset ();

    if (this->minimumId_parser_)
      this->minimumId_parser_->_reset ();

    if (this->navigationLinks_parser_)
      this->navigationLinks_parser_->_reset ();

    if (this->operator__parser_)
      this->operator__parser_->_reset ();

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->requestMethod_parser_)
      this->requestMethod_parser_->_reset ();

    if (this->requestURL_parser_)
      this->requestURL_parser_->_reset ();

    if (this->resource_parser_)
      this->resource_parser_->_reset ();

    if (this->response_parser_)
      this->response_parser_->_reset ();

    if (this->responseCode_parser_)
      this->responseCode_parser_->_reset ();

    if (this->sourceId_parser_)
      this->sourceId_parser_->_reset ();

    if (this->validateProfileId_parser_)
      this->validateProfileId_parser_->_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();

    if (this->warningOnly_parser_)
      this->warningOnly_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Test_pskel
  //

  void TestScript_Test_pskel::
  name ()
  {
    if (this->TestScript_Test_impl_)
      this->TestScript_Test_impl_->name ();
  }

  void TestScript_Test_pskel::
  description ()
  {
    if (this->TestScript_Test_impl_)
      this->TestScript_Test_impl_->description ();
  }

  void TestScript_Test_pskel::
  action ()
  {
    if (this->TestScript_Test_impl_)
      this->TestScript_Test_impl_->action ();
  }

  void TestScript_Test_pskel::
  post_TestScript_Test ()
  {
    if (this->TestScript_Test_impl_)
      this->TestScript_Test_impl_->post_TestScript_Test ();
    else
      post_BackboneElement ();
  }

  void TestScript_Test_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->action_parser_)
      this->action_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Action1_pskel
  //

  void TestScript_Action1_pskel::
  operation ()
  {
    if (this->TestScript_Action1_impl_)
      this->TestScript_Action1_impl_->operation ();
  }

  void TestScript_Action1_pskel::
  assert ()
  {
    if (this->TestScript_Action1_impl_)
      this->TestScript_Action1_impl_->assert ();
  }

  void TestScript_Action1_pskel::
  post_TestScript_Action1 ()
  {
    if (this->TestScript_Action1_impl_)
      this->TestScript_Action1_impl_->post_TestScript_Action1 ();
    else
      post_BackboneElement ();
  }

  void TestScript_Action1_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->operation_parser_)
      this->operation_parser_->_reset ();

    if (this->assert_parser_)
      this->assert_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Teardown_pskel
  //

  void TestScript_Teardown_pskel::
  action ()
  {
    if (this->TestScript_Teardown_impl_)
      this->TestScript_Teardown_impl_->action ();
  }

  void TestScript_Teardown_pskel::
  post_TestScript_Teardown ()
  {
    if (this->TestScript_Teardown_impl_)
      this->TestScript_Teardown_impl_->post_TestScript_Teardown ();
    else
      post_BackboneElement ();
  }

  void TestScript_Teardown_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->action_parser_)
      this->action_parser_->_reset ();

    this->resetting_ = false;
  }

  // TestScript_Action2_pskel
  //

  void TestScript_Action2_pskel::
  operation ()
  {
    if (this->TestScript_Action2_impl_)
      this->TestScript_Action2_impl_->operation ();
  }

  void TestScript_Action2_pskel::
  post_TestScript_Action2 ()
  {
    if (this->TestScript_Action2_impl_)
      this->TestScript_Action2_impl_->post_TestScript_Action2 ();
    else
      post_BackboneElement ();
  }

  void TestScript_Action2_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->operation_parser_)
      this->operation_parser_->_reset ();

    this->resetting_ = false;
  }

  // AssertionDirectionType_list_pskel
  //

  void AssertionDirectionType_list_pskel::
  post_AssertionDirectionType_list ()
  {
    if (this->AssertionDirectionType_list_impl_)
      this->AssertionDirectionType_list_impl_->post_AssertionDirectionType_list ();
    else
      post_code_primitive ();
  }

  const char* const AssertionDirectionType_list_pskel::_xsde_AssertionDirectionType_list_pskel_enums_[2UL] = 
  {
    "request",
    "response"
  };

  // AssertionDirectionType_pskel
  //

  void AssertionDirectionType_pskel::
  value ()
  {
    if (this->AssertionDirectionType_impl_)
      this->AssertionDirectionType_impl_->value ();
  }

  void AssertionDirectionType_pskel::
  post_AssertionDirectionType ()
  {
    if (this->AssertionDirectionType_impl_)
      this->AssertionDirectionType_impl_->post_AssertionDirectionType ();
    else
      post_Element ();
  }

  void AssertionDirectionType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // AssertionOperatorType_list_pskel
  //

  void AssertionOperatorType_list_pskel::
  post_AssertionOperatorType_list ()
  {
    if (this->AssertionOperatorType_list_impl_)
      this->AssertionOperatorType_list_impl_->post_AssertionOperatorType_list ();
    else
      post_code_primitive ();
  }

  const char* const AssertionOperatorType_list_pskel::_xsde_AssertionOperatorType_list_pskel_enums_[11UL] = 
  {
    "contains",
    "empty",
    "equals",
    "eval",
    "greaterThan",
    "in",
    "lessThan",
    "notContains",
    "notEmpty",
    "notEquals",
    "notIn"
  };

  // AssertionOperatorType_pskel
  //

  void AssertionOperatorType_pskel::
  value ()
  {
    if (this->AssertionOperatorType_impl_)
      this->AssertionOperatorType_impl_->value ();
  }

  void AssertionOperatorType_pskel::
  post_AssertionOperatorType ()
  {
    if (this->AssertionOperatorType_impl_)
      this->AssertionOperatorType_impl_->post_AssertionOperatorType ();
    else
      post_Element ();
  }

  void AssertionOperatorType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // AssertionResponseTypes_list_pskel
  //

  void AssertionResponseTypes_list_pskel::
  post_AssertionResponseTypes_list ()
  {
    if (this->AssertionResponseTypes_list_impl_)
      this->AssertionResponseTypes_list_impl_->post_AssertionResponseTypes_list ();
    else
      post_code_primitive ();
  }

  const char* const AssertionResponseTypes_list_pskel::_xsde_AssertionResponseTypes_list_pskel_enums_[12UL] = 
  {
    "bad",
    "conflict",
    "created",
    "forbidden",
    "gone",
    "methodNotAllowed",
    "noContent",
    "notFound",
    "notModified",
    "okay",
    "preconditionFailed",
    "unprocessable"
  };

  // AssertionResponseTypes_pskel
  //

  void AssertionResponseTypes_pskel::
  value ()
  {
    if (this->AssertionResponseTypes_impl_)
      this->AssertionResponseTypes_impl_->value ();
  }

  void AssertionResponseTypes_pskel::
  post_AssertionResponseTypes ()
  {
    if (this->AssertionResponseTypes_impl_)
      this->AssertionResponseTypes_impl_->post_AssertionResponseTypes ();
    else
      post_Element ();
  }

  void AssertionResponseTypes_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // TestScriptRequestMethodCode_list_pskel
  //

  void TestScriptRequestMethodCode_list_pskel::
  post_TestScriptRequestMethodCode_list ()
  {
    if (this->TestScriptRequestMethodCode_list_impl_)
      this->TestScriptRequestMethodCode_list_impl_->post_TestScriptRequestMethodCode_list ();
    else
      post_code_primitive ();
  }

  const char* const TestScriptRequestMethodCode_list_pskel::_xsde_TestScriptRequestMethodCode_list_pskel_enums_[7UL] = 
  {
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put"
  };

  // TestScriptRequestMethodCode_pskel
  //

  void TestScriptRequestMethodCode_pskel::
  value ()
  {
    if (this->TestScriptRequestMethodCode_impl_)
      this->TestScriptRequestMethodCode_impl_->value ();
  }

  void TestScriptRequestMethodCode_pskel::
  post_TestScriptRequestMethodCode ()
  {
    if (this->TestScriptRequestMethodCode_impl_)
      this->TestScriptRequestMethodCode_impl_->post_TestScriptRequestMethodCode ();
    else
      post_Element ();
  }

  void TestScriptRequestMethodCode_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for TestScript_pskel.
  //
  bool TestScript_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "url" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::DomainResource_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::DomainResource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_uri ();
              this->url ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "version" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->version_parser_)
            {
              this->version_parser_->pre ();
              ctx.nested_parser (this->version_parser_);
            }
          }
          else
          {
            if (this->version_parser_ != 0)
            {
              this->version_parser_->post_string ();
              this->version ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "title" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->title_parser_)
            {
              this->title_parser_->pre ();
              ctx.nested_parser (this->title_parser_);
            }
          }
          else
          {
            if (this->title_parser_ != 0)
            {
              this->title_parser_->post_string ();
              this->title ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "status" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->status_parser_)
            {
              this->status_parser_->pre ();
              ctx.nested_parser (this->status_parser_);
            }
          }
          else
          {
            if (this->status_parser_ != 0)
            {
              this->status_parser_->post_PublicationStatus ();
              this->status ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "experimental" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->experimental_parser_)
            {
              this->experimental_parser_->pre ();
              ctx.nested_parser (this->experimental_parser_);
            }
          }
          else
          {
            if (this->experimental_parser_ != 0)
            {
              this->experimental_parser_->post_boolean ();
              this->experimental ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "date" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->date_parser_)
            {
              this->date_parser_->pre ();
              ctx.nested_parser (this->date_parser_);
            }
          }
          else
          {
            if (this->date_parser_ != 0)
            {
              this->date_parser_->post_dateTime ();
              this->date ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "publisher" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->publisher_parser_)
            {
              this->publisher_parser_->pre ();
              ctx.nested_parser (this->publisher_parser_);
            }
          }
          else
          {
            if (this->publisher_parser_ != 0)
            {
              this->publisher_parser_->post_string ();
              this->publisher ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "contact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contact_parser_)
            {
              this->contact_parser_->pre ();
              ctx.nested_parser (this->contact_parser_);
            }
          }
          else
          {
            if (this->contact_parser_ != 0)
            {
              this->contact_parser_->post_ContactDetail ();
              this->contact ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_markdown ();
              this->description ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "useContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->useContext_parser_)
            {
              this->useContext_parser_->pre ();
              ctx.nested_parser (this->useContext_parser_);
            }
          }
          else
          {
            if (this->useContext_parser_ != 0)
            {
              this->useContext_parser_->post_UsageContext ();
              this->useContext ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "jurisdiction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->jurisdiction_parser_)
            {
              this->jurisdiction_parser_->pre ();
              ctx.nested_parser (this->jurisdiction_parser_);
            }
          }
          else
          {
            if (this->jurisdiction_parser_ != 0)
            {
              this->jurisdiction_parser_->post_CodeableConcept ();
              this->jurisdiction ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "purpose" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->purpose_parser_)
            {
              this->purpose_parser_->pre ();
              ctx.nested_parser (this->purpose_parser_);
            }
          }
          else
          {
            if (this->purpose_parser_ != 0)
            {
              this->purpose_parser_->post_markdown ();
              this->purpose ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "copyright" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->copyright_parser_)
            {
              this->copyright_parser_->pre ();
              ctx.nested_parser (this->copyright_parser_);
            }
          }
          else
          {
            if (this->copyright_parser_ != 0)
            {
              this->copyright_parser_->post_markdown ();
              this->copyright ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "origin" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->origin_parser_)
            {
              this->origin_parser_->pre ();
              ctx.nested_parser (this->origin_parser_);
            }
          }
          else
          {
            if (this->origin_parser_ != 0)
            {
              this->origin_parser_->post_TestScript_Origin ();
              this->origin ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "destination" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->destination_parser_)
            {
              this->destination_parser_->pre ();
              ctx.nested_parser (this->destination_parser_);
            }
          }
          else
          {
            if (this->destination_parser_ != 0)
            {
              this->destination_parser_->post_TestScript_Destination ();
              this->destination ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "metadata" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->metadata_parser_)
            {
              this->metadata_parser_->pre ();
              ctx.nested_parser (this->metadata_parser_);
            }
          }
          else
          {
            if (this->metadata_parser_ != 0)
            {
              this->metadata_parser_->post_TestScript_Metadata ();
              this->metadata ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "fixture" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixture_parser_)
            {
              this->fixture_parser_->pre ();
              ctx.nested_parser (this->fixture_parser_);
            }
          }
          else
          {
            if (this->fixture_parser_ != 0)
            {
              this->fixture_parser_->post_TestScript_Fixture ();
              this->fixture ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_Reference ();
              this->profile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "variable" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->variable_parser_)
            {
              this->variable_parser_->pre ();
              ctx.nested_parser (this->variable_parser_);
            }
          }
          else
          {
            if (this->variable_parser_ != 0)
            {
              this->variable_parser_->post_TestScript_Variable ();
              this->variable ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "setup" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->setup_parser_)
            {
              this->setup_parser_->pre ();
              ctx.nested_parser (this->setup_parser_);
            }
          }
          else
          {
            if (this->setup_parser_ != 0)
            {
              this->setup_parser_->post_TestScript_Setup ();
              this->setup ();
            }

            count = 0;
            state = 22UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 22UL;
          // Fall through.
        }
      }
      case 22UL:
      {
        if (n == "test" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->test_parser_)
            {
              this->test_parser_->pre ();
              ctx.nested_parser (this->test_parser_);
            }
          }
          else
          {
            if (this->test_parser_ != 0)
            {
              this->test_parser_->post_TestScript_Test ();
              this->test ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 23UL;
          // Fall through.
        }
      }
      case 23UL:
      {
        if (n == "teardown" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->teardown_parser_)
            {
              this->teardown_parser_->pre ();
              ctx.nested_parser (this->teardown_parser_);
            }
          }
          else
          {
            if (this->teardown_parser_ != 0)
            {
              this->teardown_parser_->post_TestScript_Teardown ();
              this->teardown ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Origin_pskel.
  //
  bool TestScript_Origin_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "index" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Origin_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Origin_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Origin_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Origin_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Origin_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "index" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->index_parser_)
            {
              this->index_parser_->pre ();
              ctx.nested_parser (this->index_parser_);
            }
          }
          else
          {
            if (this->index_parser_ != 0)
            {
              this->index_parser_->post_integer ();
              this->index ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_Coding ();
              this->profile ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Destination_pskel.
  //
  bool TestScript_Destination_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "index" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Destination_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Destination_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Destination_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Destination_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Destination_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "index" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->index_parser_)
            {
              this->index_parser_->pre ();
              ctx.nested_parser (this->index_parser_);
            }
          }
          else
          {
            if (this->index_parser_ != 0)
            {
              this->index_parser_->post_integer ();
              this->index ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_Coding ();
              this->profile ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Metadata_pskel.
  //
  bool TestScript_Metadata_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "link" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "capability" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Metadata_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Metadata_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Metadata_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Metadata_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Metadata_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "link" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->link_parser_)
            {
              this->link_parser_->pre ();
              ctx.nested_parser (this->link_parser_);
            }
          }
          else
          {
            if (this->link_parser_ != 0)
            {
              this->link_parser_->post_TestScript_Link ();
              this->link ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "capability" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->capability_parser_)
            {
              this->capability_parser_->pre ();
              ctx.nested_parser (this->capability_parser_);
            }
          }
          else
          {
            if (this->capability_parser_ != 0)
            {
              this->capability_parser_->post_TestScript_Capability ();
              this->capability ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Link_pskel.
  //
  bool TestScript_Link_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "url" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Link_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Link_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Link_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Link_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Link_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_uri ();
              this->url ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Capability_pskel.
  //
  bool TestScript_Capability_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "required" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Capability_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Capability_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Capability_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Capability_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Capability_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "required" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->required_parser_)
            {
              this->required_parser_->pre ();
              ctx.nested_parser (this->required_parser_);
            }
          }
          else
          {
            if (this->required_parser_ != 0)
            {
              this->required_parser_->post_boolean ();
              this->required ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "validated" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->validated_parser_)
            {
              this->validated_parser_->pre ();
              ctx.nested_parser (this->validated_parser_);
            }
          }
          else
          {
            if (this->validated_parser_ != 0)
            {
              this->validated_parser_->post_boolean ();
              this->validated ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "origin" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->origin_parser_)
            {
              this->origin_parser_->pre ();
              ctx.nested_parser (this->origin_parser_);
            }
          }
          else
          {
            if (this->origin_parser_ != 0)
            {
              this->origin_parser_->post_integer ();
              this->origin ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "destination" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->destination_parser_)
            {
              this->destination_parser_->pre ();
              ctx.nested_parser (this->destination_parser_);
            }
          }
          else
          {
            if (this->destination_parser_ != 0)
            {
              this->destination_parser_->post_integer ();
              this->destination ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "link" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->link_parser_)
            {
              this->link_parser_->pre ();
              ctx.nested_parser (this->link_parser_);
            }
          }
          else
          {
            if (this->link_parser_ != 0)
            {
              this->link_parser_->post_uri ();
              this->link ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "capabilities" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->capabilities_parser_)
            {
              this->capabilities_parser_->pre ();
              ctx.nested_parser (this->capabilities_parser_);
            }
          }
          else
          {
            if (this->capabilities_parser_ != 0)
            {
              this->capabilities_parser_->post_canonical ();
              this->capabilities ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Fixture_pskel.
  //
  bool TestScript_Fixture_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "autocreate" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Fixture_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Fixture_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Fixture_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Fixture_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Fixture_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "autocreate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->autocreate_parser_)
            {
              this->autocreate_parser_->pre ();
              ctx.nested_parser (this->autocreate_parser_);
            }
          }
          else
          {
            if (this->autocreate_parser_ != 0)
            {
              this->autocreate_parser_->post_boolean ();
              this->autocreate ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "autodelete" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->autodelete_parser_)
            {
              this->autodelete_parser_->pre ();
              ctx.nested_parser (this->autodelete_parser_);
            }
          }
          else
          {
            if (this->autodelete_parser_ != 0)
            {
              this->autodelete_parser_->post_boolean ();
              this->autodelete ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "resource" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->resource_parser_)
            {
              this->resource_parser_->pre ();
              ctx.nested_parser (this->resource_parser_);
            }
          }
          else
          {
            if (this->resource_parser_ != 0)
            {
              this->resource_parser_->post_Reference ();
              this->resource ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Variable_pskel.
  //
  bool TestScript_Variable_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Variable_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Variable_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Variable_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Variable_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Variable_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "defaultValue" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValue_parser_)
            {
              this->defaultValue_parser_->pre ();
              ctx.nested_parser (this->defaultValue_parser_);
            }
          }
          else
          {
            if (this->defaultValue_parser_ != 0)
            {
              this->defaultValue_parser_->post_string ();
              this->defaultValue ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "expression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->expression_parser_)
            {
              this->expression_parser_->pre ();
              ctx.nested_parser (this->expression_parser_);
            }
          }
          else
          {
            if (this->expression_parser_ != 0)
            {
              this->expression_parser_->post_string ();
              this->expression ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "headerField" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->headerField_parser_)
            {
              this->headerField_parser_->pre ();
              ctx.nested_parser (this->headerField_parser_);
            }
          }
          else
          {
            if (this->headerField_parser_ != 0)
            {
              this->headerField_parser_->post_string ();
              this->headerField ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "hint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->hint_parser_)
            {
              this->hint_parser_->pre ();
              ctx.nested_parser (this->hint_parser_);
            }
          }
          else
          {
            if (this->hint_parser_ != 0)
            {
              this->hint_parser_->post_string ();
              this->hint ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "sourceId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sourceId_parser_)
            {
              this->sourceId_parser_->pre ();
              ctx.nested_parser (this->sourceId_parser_);
            }
          }
          else
          {
            if (this->sourceId_parser_ != 0)
            {
              this->sourceId_parser_->post_id ();
              this->sourceId ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Setup_pskel.
  //
  bool TestScript_Setup_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "action" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Setup_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Setup_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Setup_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Setup_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Setup_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "action" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->action_parser_)
            {
              this->action_parser_->pre ();
              ctx.nested_parser (this->action_parser_);
            }
          }
          else
          {
            if (this->action_parser_ != 0)
            {
              this->action_parser_->post_TestScript_Action ();
              this->action ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Action_pskel.
  //
  bool TestScript_Action_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "assert" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Action_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Action_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Action_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Action_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void TestScript_Action_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operation_parser_)
            {
              this->operation_parser_->pre ();
              ctx.nested_parser (this->operation_parser_);
            }
          }
          else
          {
            if (this->operation_parser_ != 0)
            {
              this->operation_parser_->post_TestScript_Operation ();
              this->operation ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "assert" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->assert_parser_)
            {
              this->assert_parser_->pre ();
              ctx.nested_parser (this->assert_parser_);
            }
          }
          else
          {
            if (this->assert_parser_ != 0)
            {
              this->assert_parser_->post_TestScript_Assert ();
              this->assert ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Operation_pskel.
  //
  bool TestScript_Operation_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "resource" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "label" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "description" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "accept" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "contentType" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "destination" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "encodeRequestUrl" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Operation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Operation_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Operation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Operation_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Operation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_Coding ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "resource" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->resource_parser_)
            {
              this->resource_parser_->pre ();
              ctx.nested_parser (this->resource_parser_);
            }
          }
          else
          {
            if (this->resource_parser_ != 0)
            {
              this->resource_parser_->post_code ();
              this->resource ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "label" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->label_parser_)
            {
              this->label_parser_->pre ();
              ctx.nested_parser (this->label_parser_);
            }
          }
          else
          {
            if (this->label_parser_ != 0)
            {
              this->label_parser_->post_string ();
              this->label ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "accept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->accept_parser_)
            {
              this->accept_parser_->pre ();
              ctx.nested_parser (this->accept_parser_);
            }
          }
          else
          {
            if (this->accept_parser_ != 0)
            {
              this->accept_parser_->post_code ();
              this->accept ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "contentType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contentType_parser_)
            {
              this->contentType_parser_->pre ();
              ctx.nested_parser (this->contentType_parser_);
            }
          }
          else
          {
            if (this->contentType_parser_ != 0)
            {
              this->contentType_parser_->post_code ();
              this->contentType ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "destination" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->destination_parser_)
            {
              this->destination_parser_->pre ();
              ctx.nested_parser (this->destination_parser_);
            }
          }
          else
          {
            if (this->destination_parser_ != 0)
            {
              this->destination_parser_->post_integer ();
              this->destination ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "encodeRequestUrl" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->encodeRequestUrl_parser_)
            {
              this->encodeRequestUrl_parser_->pre ();
              ctx.nested_parser (this->encodeRequestUrl_parser_);
            }
          }
          else
          {
            if (this->encodeRequestUrl_parser_ != 0)
            {
              this->encodeRequestUrl_parser_->post_boolean ();
              this->encodeRequestUrl ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "method" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->method_parser_)
            {
              this->method_parser_->pre ();
              ctx.nested_parser (this->method_parser_);
            }
          }
          else
          {
            if (this->method_parser_ != 0)
            {
              this->method_parser_->post_TestScriptRequestMethodCode ();
              this->method ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "origin" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->origin_parser_)
            {
              this->origin_parser_->pre ();
              ctx.nested_parser (this->origin_parser_);
            }
          }
          else
          {
            if (this->origin_parser_ != 0)
            {
              this->origin_parser_->post_integer ();
              this->origin ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "params" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->params_parser_)
            {
              this->params_parser_->pre ();
              ctx.nested_parser (this->params_parser_);
            }
          }
          else
          {
            if (this->params_parser_ != 0)
            {
              this->params_parser_->post_string ();
              this->params ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "requestHeader" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requestHeader_parser_)
            {
              this->requestHeader_parser_->pre ();
              ctx.nested_parser (this->requestHeader_parser_);
            }
          }
          else
          {
            if (this->requestHeader_parser_ != 0)
            {
              this->requestHeader_parser_->post_TestScript_RequestHeader ();
              this->requestHeader ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "requestId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requestId_parser_)
            {
              this->requestId_parser_->pre ();
              ctx.nested_parser (this->requestId_parser_);
            }
          }
          else
          {
            if (this->requestId_parser_ != 0)
            {
              this->requestId_parser_->post_id ();
              this->requestId ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "responseId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->responseId_parser_)
            {
              this->responseId_parser_->pre ();
              ctx.nested_parser (this->responseId_parser_);
            }
          }
          else
          {
            if (this->responseId_parser_ != 0)
            {
              this->responseId_parser_->post_id ();
              this->responseId ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "sourceId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sourceId_parser_)
            {
              this->sourceId_parser_->pre ();
              ctx.nested_parser (this->sourceId_parser_);
            }
          }
          else
          {
            if (this->sourceId_parser_ != 0)
            {
              this->sourceId_parser_->post_id ();
              this->sourceId ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "targetId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->targetId_parser_)
            {
              this->targetId_parser_->pre ();
              ctx.nested_parser (this->targetId_parser_);
            }
          }
          else
          {
            if (this->targetId_parser_ != 0)
            {
              this->targetId_parser_->post_id ();
              this->targetId ();
            }

            count = 0;
            state = 16UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_string ();
              this->url ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_RequestHeader_pskel.
  //
  bool TestScript_RequestHeader_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "field" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_RequestHeader_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_RequestHeader_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_RequestHeader_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_RequestHeader_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_RequestHeader_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "field" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->field_parser_)
            {
              this->field_parser_->pre ();
              ctx.nested_parser (this->field_parser_);
            }
          }
          else
          {
            if (this->field_parser_ != 0)
            {
              this->field_parser_->post_string ();
              this->field ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_string ();
              this->value ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Assert_pskel.
  //
  bool TestScript_Assert_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "label" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "description" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "direction" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "compareToSourceId" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "compareToSourceExpression" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "compareToSourcePath" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "contentType" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "expression" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "headerField" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "minimumId" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "navigationLinks" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "operator" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "path" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "requestMethod" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;
        else if (n == "requestURL" &&
                 ns == "http://hl7.org/fhir")
          s = 14UL;
        else if (n == "resource" &&
                 ns == "http://hl7.org/fhir")
          s = 15UL;
        else if (n == "response" &&
                 ns == "http://hl7.org/fhir")
          s = 16UL;
        else if (n == "responseCode" &&
                 ns == "http://hl7.org/fhir")
          s = 17UL;
        else if (n == "sourceId" &&
                 ns == "http://hl7.org/fhir")
          s = 18UL;
        else if (n == "validateProfileId" &&
                 ns == "http://hl7.org/fhir")
          s = 19UL;
        else if (n == "value" &&
                 ns == "http://hl7.org/fhir")
          s = 20UL;
        else if (n == "warningOnly" &&
                 ns == "http://hl7.org/fhir")
          s = 21UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Assert_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Assert_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Assert_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Assert_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Assert_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "label" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->label_parser_)
            {
              this->label_parser_->pre ();
              ctx.nested_parser (this->label_parser_);
            }
          }
          else
          {
            if (this->label_parser_ != 0)
            {
              this->label_parser_->post_string ();
              this->label ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "direction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->direction_parser_)
            {
              this->direction_parser_->pre ();
              ctx.nested_parser (this->direction_parser_);
            }
          }
          else
          {
            if (this->direction_parser_ != 0)
            {
              this->direction_parser_->post_AssertionDirectionType ();
              this->direction ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "compareToSourceId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->compareToSourceId_parser_)
            {
              this->compareToSourceId_parser_->pre ();
              ctx.nested_parser (this->compareToSourceId_parser_);
            }
          }
          else
          {
            if (this->compareToSourceId_parser_ != 0)
            {
              this->compareToSourceId_parser_->post_string ();
              this->compareToSourceId ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "compareToSourceExpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->compareToSourceExpression_parser_)
            {
              this->compareToSourceExpression_parser_->pre ();
              ctx.nested_parser (this->compareToSourceExpression_parser_);
            }
          }
          else
          {
            if (this->compareToSourceExpression_parser_ != 0)
            {
              this->compareToSourceExpression_parser_->post_string ();
              this->compareToSourceExpression ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "compareToSourcePath" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->compareToSourcePath_parser_)
            {
              this->compareToSourcePath_parser_->pre ();
              ctx.nested_parser (this->compareToSourcePath_parser_);
            }
          }
          else
          {
            if (this->compareToSourcePath_parser_ != 0)
            {
              this->compareToSourcePath_parser_->post_string ();
              this->compareToSourcePath ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "contentType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contentType_parser_)
            {
              this->contentType_parser_->pre ();
              ctx.nested_parser (this->contentType_parser_);
            }
          }
          else
          {
            if (this->contentType_parser_ != 0)
            {
              this->contentType_parser_->post_code ();
              this->contentType ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "expression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->expression_parser_)
            {
              this->expression_parser_->pre ();
              ctx.nested_parser (this->expression_parser_);
            }
          }
          else
          {
            if (this->expression_parser_ != 0)
            {
              this->expression_parser_->post_string ();
              this->expression ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "headerField" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->headerField_parser_)
            {
              this->headerField_parser_->pre ();
              ctx.nested_parser (this->headerField_parser_);
            }
          }
          else
          {
            if (this->headerField_parser_ != 0)
            {
              this->headerField_parser_->post_string ();
              this->headerField ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "minimumId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minimumId_parser_)
            {
              this->minimumId_parser_->pre ();
              ctx.nested_parser (this->minimumId_parser_);
            }
          }
          else
          {
            if (this->minimumId_parser_ != 0)
            {
              this->minimumId_parser_->post_string ();
              this->minimumId ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "navigationLinks" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->navigationLinks_parser_)
            {
              this->navigationLinks_parser_->pre ();
              ctx.nested_parser (this->navigationLinks_parser_);
            }
          }
          else
          {
            if (this->navigationLinks_parser_ != 0)
            {
              this->navigationLinks_parser_->post_boolean ();
              this->navigationLinks ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "operator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operator__parser_)
            {
              this->operator__parser_->pre ();
              ctx.nested_parser (this->operator__parser_);
            }
          }
          else
          {
            if (this->operator__parser_ != 0)
            {
              this->operator__parser_->post_AssertionOperatorType ();
              this->operator_ ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "requestMethod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requestMethod_parser_)
            {
              this->requestMethod_parser_->pre ();
              ctx.nested_parser (this->requestMethod_parser_);
            }
          }
          else
          {
            if (this->requestMethod_parser_ != 0)
            {
              this->requestMethod_parser_->post_TestScriptRequestMethodCode ();
              this->requestMethod ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "requestURL" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requestURL_parser_)
            {
              this->requestURL_parser_->pre ();
              ctx.nested_parser (this->requestURL_parser_);
            }
          }
          else
          {
            if (this->requestURL_parser_ != 0)
            {
              this->requestURL_parser_->post_string ();
              this->requestURL ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "resource" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->resource_parser_)
            {
              this->resource_parser_->pre ();
              ctx.nested_parser (this->resource_parser_);
            }
          }
          else
          {
            if (this->resource_parser_ != 0)
            {
              this->resource_parser_->post_code ();
              this->resource ();
            }

            count = 0;
            state = 16UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "response" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->response_parser_)
            {
              this->response_parser_->pre ();
              ctx.nested_parser (this->response_parser_);
            }
          }
          else
          {
            if (this->response_parser_ != 0)
            {
              this->response_parser_->post_AssertionResponseTypes ();
              this->response ();
            }

            count = 0;
            state = 17UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "responseCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->responseCode_parser_)
            {
              this->responseCode_parser_->pre ();
              ctx.nested_parser (this->responseCode_parser_);
            }
          }
          else
          {
            if (this->responseCode_parser_ != 0)
            {
              this->responseCode_parser_->post_string ();
              this->responseCode ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "sourceId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sourceId_parser_)
            {
              this->sourceId_parser_->pre ();
              ctx.nested_parser (this->sourceId_parser_);
            }
          }
          else
          {
            if (this->sourceId_parser_ != 0)
            {
              this->sourceId_parser_->post_id ();
              this->sourceId ();
            }

            count = 0;
            state = 19UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "validateProfileId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->validateProfileId_parser_)
            {
              this->validateProfileId_parser_->pre ();
              ctx.nested_parser (this->validateProfileId_parser_);
            }
          }
          else
          {
            if (this->validateProfileId_parser_ != 0)
            {
              this->validateProfileId_parser_->post_id ();
              this->validateProfileId ();
            }

            count = 0;
            state = 20UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_string ();
              this->value ();
            }

            count = 0;
            state = 21UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "warningOnly" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->warningOnly_parser_)
            {
              this->warningOnly_parser_->pre ();
              ctx.nested_parser (this->warningOnly_parser_);
            }
          }
          else
          {
            if (this->warningOnly_parser_ != 0)
            {
              this->warningOnly_parser_->post_boolean ();
              this->warningOnly ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Test_pskel.
  //
  bool TestScript_Test_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "description" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "action" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Test_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Test_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Test_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Test_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Test_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "action" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->action_parser_)
            {
              this->action_parser_->pre ();
              ctx.nested_parser (this->action_parser_);
            }
          }
          else
          {
            if (this->action_parser_ != 0)
            {
              this->action_parser_->post_TestScript_Action1 ();
              this->action ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Action1_pskel.
  //
  bool TestScript_Action1_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "assert" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Action1_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Action1_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Action1_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Action1_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void TestScript_Action1_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operation_parser_)
            {
              this->operation_parser_->pre ();
              ctx.nested_parser (this->operation_parser_);
            }
          }
          else
          {
            if (this->operation_parser_ != 0)
            {
              this->operation_parser_->post_TestScript_Operation ();
              this->operation ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "assert" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->assert_parser_)
            {
              this->assert_parser_->pre ();
              ctx.nested_parser (this->assert_parser_);
            }
          }
          else
          {
            if (this->assert_parser_ != 0)
            {
              this->assert_parser_->post_TestScript_Assert ();
              this->assert ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Teardown_pskel.
  //
  bool TestScript_Teardown_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "action" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Teardown_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Teardown_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Teardown_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Teardown_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Teardown_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "action" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->action_parser_)
            {
              this->action_parser_->pre ();
              ctx.nested_parser (this->action_parser_);
            }
          }
          else
          {
            if (this->action_parser_ != 0)
            {
              this->action_parser_->post_TestScript_Action2 ();
              this->action ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TestScript_Action2_pskel.
  //
  bool TestScript_Action2_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TestScript_Action2_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TestScript_Action2_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TestScript_Action2_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void TestScript_Action2_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TestScript_Action2_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operation_parser_)
            {
              this->operation_parser_->pre ();
              ctx.nested_parser (this->operation_parser_);
            }
          }
          else
          {
            if (this->operation_parser_ != 0)
            {
              this->operation_parser_->post_TestScript_Operation ();
              this->operation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
  // Attribute validation and dispatch functions for AssertionDirectionType_pskel.
  //
  bool AssertionDirectionType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AssertionDirectionType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for AssertionOperatorType_pskel.
  //
  bool AssertionOperatorType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AssertionOperatorType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for AssertionResponseTypes_pskel.
  //
  bool AssertionResponseTypes_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AssertionResponseTypes_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for TestScriptRequestMethodCode_pskel.
  //
  bool TestScriptRequestMethodCode_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_TestScriptRequestMethodCode_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


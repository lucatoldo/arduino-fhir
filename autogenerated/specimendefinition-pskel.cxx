// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "specimendefinition-pskel.hxx"

namespace fhir
{
  // SpecimenDefinition_pskel
  //

  void SpecimenDefinition_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void SpecimenDefinition_pskel::
  typeCollected_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->typeCollected_parser_ = &p;
  }

  void SpecimenDefinition_pskel::
  patientPreparation_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->patientPreparation_parser_ = &p;
  }

  void SpecimenDefinition_pskel::
  timeAspect_parser (::fhir::string_pskel& p)
  {
    this->timeAspect_parser_ = &p;
  }

  void SpecimenDefinition_pskel::
  collection_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->collection_parser_ = &p;
  }

  void SpecimenDefinition_pskel::
  typeTested_parser (::fhir::SpecimenDefinition_TypeTested_pskel& p)
  {
    this->typeTested_parser_ = &p;
  }

  void SpecimenDefinition_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::CodeableConcept_pskel& typeCollected,
           ::fhir::CodeableConcept_pskel& patientPreparation,
           ::fhir::string_pskel& timeAspect,
           ::fhir::CodeableConcept_pskel& collection,
           ::fhir::SpecimenDefinition_TypeTested_pskel& typeTested)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->identifier_parser_ = &identifier;
    this->typeCollected_parser_ = &typeCollected;
    this->patientPreparation_parser_ = &patientPreparation;
    this->timeAspect_parser_ = &timeAspect;
    this->collection_parser_ = &collection;
    this->typeTested_parser_ = &typeTested;
  }

  SpecimenDefinition_pskel::
  SpecimenDefinition_pskel (::fhir::DomainResource_pskel* tiein)
  : ::fhir::DomainResource_pskel (tiein, 0),
    SpecimenDefinition_impl_ (0),
    identifier_parser_ (0),
    typeCollected_parser_ (0),
    patientPreparation_parser_ (0),
    timeAspect_parser_ (0),
    collection_parser_ (0),
    typeTested_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SpecimenDefinition_pskel::
  SpecimenDefinition_pskel (SpecimenDefinition_pskel* impl, void*)
  : ::fhir::DomainResource_pskel (impl, 0),
    SpecimenDefinition_impl_ (impl),
    identifier_parser_ (0),
    typeCollected_parser_ (0),
    patientPreparation_parser_ (0),
    timeAspect_parser_ (0),
    collection_parser_ (0),
    typeTested_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SpecimenDefinition_TypeTested_pskel
  //

  void SpecimenDefinition_TypeTested_pskel::
  isDerived_parser (::fhir::boolean_pskel& p)
  {
    this->isDerived_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  preference_parser (::fhir::SpecimenContainedPreference_pskel& p)
  {
    this->preference_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  container_parser (::fhir::SpecimenDefinition_Container_pskel& p)
  {
    this->container_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  requirement_parser (::fhir::string_pskel& p)
  {
    this->requirement_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  retentionTime_parser (::fhir::Duration_pskel& p)
  {
    this->retentionTime_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  rejectionCriterion_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->rejectionCriterion_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  handling_parser (::fhir::SpecimenDefinition_Handling_pskel& p)
  {
    this->handling_parser_ = &p;
  }

  void SpecimenDefinition_TypeTested_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::boolean_pskel& isDerived,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::SpecimenContainedPreference_pskel& preference,
           ::fhir::SpecimenDefinition_Container_pskel& container,
           ::fhir::string_pskel& requirement,
           ::fhir::Duration_pskel& retentionTime,
           ::fhir::CodeableConcept_pskel& rejectionCriterion,
           ::fhir::SpecimenDefinition_Handling_pskel& handling)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->isDerived_parser_ = &isDerived;
    this->type_parser_ = &type;
    this->preference_parser_ = &preference;
    this->container_parser_ = &container;
    this->requirement_parser_ = &requirement;
    this->retentionTime_parser_ = &retentionTime;
    this->rejectionCriterion_parser_ = &rejectionCriterion;
    this->handling_parser_ = &handling;
  }

  SpecimenDefinition_TypeTested_pskel::
  SpecimenDefinition_TypeTested_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    SpecimenDefinition_TypeTested_impl_ (0),
    isDerived_parser_ (0),
    type_parser_ (0),
    preference_parser_ (0),
    container_parser_ (0),
    requirement_parser_ (0),
    retentionTime_parser_ (0),
    rejectionCriterion_parser_ (0),
    handling_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SpecimenDefinition_TypeTested_pskel::
  SpecimenDefinition_TypeTested_pskel (SpecimenDefinition_TypeTested_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    SpecimenDefinition_TypeTested_impl_ (impl),
    isDerived_parser_ (0),
    type_parser_ (0),
    preference_parser_ (0),
    container_parser_ (0),
    requirement_parser_ (0),
    retentionTime_parser_ (0),
    rejectionCriterion_parser_ (0),
    handling_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SpecimenDefinition_Container_pskel
  //

  void SpecimenDefinition_Container_pskel::
  material_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->material_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  cap_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->cap_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  capacity_parser (::fhir::Quantity_pskel& p)
  {
    this->capacity_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  minimumVolumeQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->minimumVolumeQuantity_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  minimumVolumeString_parser (::fhir::string_pskel& p)
  {
    this->minimumVolumeString_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  additive_parser (::fhir::SpecimenDefinition_Additive_pskel& p)
  {
    this->additive_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  preparation_parser (::fhir::string_pskel& p)
  {
    this->preparation_parser_ = &p;
  }

  void SpecimenDefinition_Container_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& material,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::CodeableConcept_pskel& cap,
           ::fhir::string_pskel& description,
           ::fhir::Quantity_pskel& capacity,
           ::fhir::Quantity_pskel& minimumVolumeQuantity,
           ::fhir::string_pskel& minimumVolumeString,
           ::fhir::SpecimenDefinition_Additive_pskel& additive,
           ::fhir::string_pskel& preparation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->material_parser_ = &material;
    this->type_parser_ = &type;
    this->cap_parser_ = &cap;
    this->description_parser_ = &description;
    this->capacity_parser_ = &capacity;
    this->minimumVolumeQuantity_parser_ = &minimumVolumeQuantity;
    this->minimumVolumeString_parser_ = &minimumVolumeString;
    this->additive_parser_ = &additive;
    this->preparation_parser_ = &preparation;
  }

  SpecimenDefinition_Container_pskel::
  SpecimenDefinition_Container_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    SpecimenDefinition_Container_impl_ (0),
    material_parser_ (0),
    type_parser_ (0),
    cap_parser_ (0),
    description_parser_ (0),
    capacity_parser_ (0),
    minimumVolumeQuantity_parser_ (0),
    minimumVolumeString_parser_ (0),
    additive_parser_ (0),
    preparation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SpecimenDefinition_Container_pskel::
  SpecimenDefinition_Container_pskel (SpecimenDefinition_Container_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    SpecimenDefinition_Container_impl_ (impl),
    material_parser_ (0),
    type_parser_ (0),
    cap_parser_ (0),
    description_parser_ (0),
    capacity_parser_ (0),
    minimumVolumeQuantity_parser_ (0),
    minimumVolumeString_parser_ (0),
    additive_parser_ (0),
    preparation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SpecimenDefinition_Additive_pskel
  //

  void SpecimenDefinition_Additive_pskel::
  additiveCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->additiveCodeableConcept_parser_ = &p;
  }

  void SpecimenDefinition_Additive_pskel::
  additiveReference_parser (::fhir::Reference_pskel& p)
  {
    this->additiveReference_parser_ = &p;
  }

  void SpecimenDefinition_Additive_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& additiveCodeableConcept,
           ::fhir::Reference_pskel& additiveReference)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->additiveCodeableConcept_parser_ = &additiveCodeableConcept;
    this->additiveReference_parser_ = &additiveReference;
  }

  SpecimenDefinition_Additive_pskel::
  SpecimenDefinition_Additive_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    SpecimenDefinition_Additive_impl_ (0),
    additiveCodeableConcept_parser_ (0),
    additiveReference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SpecimenDefinition_Additive_pskel::
  SpecimenDefinition_Additive_pskel (SpecimenDefinition_Additive_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    SpecimenDefinition_Additive_impl_ (impl),
    additiveCodeableConcept_parser_ (0),
    additiveReference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SpecimenDefinition_Handling_pskel
  //

  void SpecimenDefinition_Handling_pskel::
  temperatureQualifier_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->temperatureQualifier_parser_ = &p;
  }

  void SpecimenDefinition_Handling_pskel::
  temperatureRange_parser (::fhir::Range_pskel& p)
  {
    this->temperatureRange_parser_ = &p;
  }

  void SpecimenDefinition_Handling_pskel::
  maxDuration_parser (::fhir::Duration_pskel& p)
  {
    this->maxDuration_parser_ = &p;
  }

  void SpecimenDefinition_Handling_pskel::
  instruction_parser (::fhir::string_pskel& p)
  {
    this->instruction_parser_ = &p;
  }

  void SpecimenDefinition_Handling_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& temperatureQualifier,
           ::fhir::Range_pskel& temperatureRange,
           ::fhir::Duration_pskel& maxDuration,
           ::fhir::string_pskel& instruction)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->temperatureQualifier_parser_ = &temperatureQualifier;
    this->temperatureRange_parser_ = &temperatureRange;
    this->maxDuration_parser_ = &maxDuration;
    this->instruction_parser_ = &instruction;
  }

  SpecimenDefinition_Handling_pskel::
  SpecimenDefinition_Handling_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    SpecimenDefinition_Handling_impl_ (0),
    temperatureQualifier_parser_ (0),
    temperatureRange_parser_ (0),
    maxDuration_parser_ (0),
    instruction_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SpecimenDefinition_Handling_pskel::
  SpecimenDefinition_Handling_pskel (SpecimenDefinition_Handling_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    SpecimenDefinition_Handling_impl_ (impl),
    temperatureQualifier_parser_ (0),
    temperatureRange_parser_ (0),
    maxDuration_parser_ (0),
    instruction_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SpecimenContainedPreference_list_pskel
  //

  SpecimenContainedPreference_list_pskel::
  SpecimenContainedPreference_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    SpecimenContainedPreference_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_SpecimenContainedPreference_list_pskel_enums_, 2UL);
  }

  SpecimenContainedPreference_list_pskel::
  SpecimenContainedPreference_list_pskel (SpecimenContainedPreference_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    SpecimenContainedPreference_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_SpecimenContainedPreference_list_pskel_enums_, 2UL);
  }

  // SpecimenContainedPreference_pskel
  //

  void SpecimenContainedPreference_pskel::
  value_parser (::fhir::SpecimenContainedPreference_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void SpecimenContainedPreference_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::SpecimenContainedPreference_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  SpecimenContainedPreference_pskel::
  SpecimenContainedPreference_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SpecimenContainedPreference_impl_ (0),
    value_parser_ (0)
  {
  }

  SpecimenContainedPreference_pskel::
  SpecimenContainedPreference_pskel (SpecimenContainedPreference_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SpecimenContainedPreference_impl_ (impl),
    value_parser_ (0)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // SpecimenDefinition_pskel
  //

  void SpecimenDefinition_pskel::
  identifier ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->identifier ();
  }

  void SpecimenDefinition_pskel::
  typeCollected ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->typeCollected ();
  }

  void SpecimenDefinition_pskel::
  patientPreparation ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->patientPreparation ();
  }

  void SpecimenDefinition_pskel::
  timeAspect ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->timeAspect ();
  }

  void SpecimenDefinition_pskel::
  collection ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->collection ();
  }

  void SpecimenDefinition_pskel::
  typeTested ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->typeTested ();
  }

  void SpecimenDefinition_pskel::
  post_SpecimenDefinition ()
  {
    if (this->SpecimenDefinition_impl_)
      this->SpecimenDefinition_impl_->post_SpecimenDefinition ();
    else
      post_DomainResource ();
  }

  void SpecimenDefinition_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::DomainResource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->typeCollected_parser_)
      this->typeCollected_parser_->_reset ();

    if (this->patientPreparation_parser_)
      this->patientPreparation_parser_->_reset ();

    if (this->timeAspect_parser_)
      this->timeAspect_parser_->_reset ();

    if (this->collection_parser_)
      this->collection_parser_->_reset ();

    if (this->typeTested_parser_)
      this->typeTested_parser_->_reset ();

    this->resetting_ = false;
  }

  // SpecimenDefinition_TypeTested_pskel
  //

  void SpecimenDefinition_TypeTested_pskel::
  isDerived ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->isDerived ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  type ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->type ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  preference ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->preference ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  container ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->container ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  requirement ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->requirement ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  retentionTime ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->retentionTime ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  rejectionCriterion ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->rejectionCriterion ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  handling ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->handling ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  post_SpecimenDefinition_TypeTested ()
  {
    if (this->SpecimenDefinition_TypeTested_impl_)
      this->SpecimenDefinition_TypeTested_impl_->post_SpecimenDefinition_TypeTested ();
    else
      post_BackboneElement ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->isDerived_parser_)
      this->isDerived_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->preference_parser_)
      this->preference_parser_->_reset ();

    if (this->container_parser_)
      this->container_parser_->_reset ();

    if (this->requirement_parser_)
      this->requirement_parser_->_reset ();

    if (this->retentionTime_parser_)
      this->retentionTime_parser_->_reset ();

    if (this->rejectionCriterion_parser_)
      this->rejectionCriterion_parser_->_reset ();

    if (this->handling_parser_)
      this->handling_parser_->_reset ();

    this->resetting_ = false;
  }

  // SpecimenDefinition_Container_pskel
  //

  void SpecimenDefinition_Container_pskel::
  material ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->material ();
  }

  void SpecimenDefinition_Container_pskel::
  type ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->type ();
  }

  void SpecimenDefinition_Container_pskel::
  cap ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->cap ();
  }

  void SpecimenDefinition_Container_pskel::
  description ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->description ();
  }

  void SpecimenDefinition_Container_pskel::
  capacity ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->capacity ();
  }

  void SpecimenDefinition_Container_pskel::
  minimumVolumeQuantity ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->minimumVolumeQuantity ();
  }

  void SpecimenDefinition_Container_pskel::
  minimumVolumeString ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->minimumVolumeString ();
  }

  void SpecimenDefinition_Container_pskel::
  additive ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->additive ();
  }

  void SpecimenDefinition_Container_pskel::
  preparation ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->preparation ();
  }

  void SpecimenDefinition_Container_pskel::
  post_SpecimenDefinition_Container ()
  {
    if (this->SpecimenDefinition_Container_impl_)
      this->SpecimenDefinition_Container_impl_->post_SpecimenDefinition_Container ();
    else
      post_BackboneElement ();
  }

  void SpecimenDefinition_Container_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->material_parser_)
      this->material_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->cap_parser_)
      this->cap_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->capacity_parser_)
      this->capacity_parser_->_reset ();

    if (this->minimumVolumeQuantity_parser_)
      this->minimumVolumeQuantity_parser_->_reset ();

    if (this->minimumVolumeString_parser_)
      this->minimumVolumeString_parser_->_reset ();

    if (this->additive_parser_)
      this->additive_parser_->_reset ();

    if (this->preparation_parser_)
      this->preparation_parser_->_reset ();

    this->resetting_ = false;
  }

  // SpecimenDefinition_Additive_pskel
  //

  void SpecimenDefinition_Additive_pskel::
  additiveCodeableConcept ()
  {
    if (this->SpecimenDefinition_Additive_impl_)
      this->SpecimenDefinition_Additive_impl_->additiveCodeableConcept ();
  }

  void SpecimenDefinition_Additive_pskel::
  additiveReference ()
  {
    if (this->SpecimenDefinition_Additive_impl_)
      this->SpecimenDefinition_Additive_impl_->additiveReference ();
  }

  void SpecimenDefinition_Additive_pskel::
  post_SpecimenDefinition_Additive ()
  {
    if (this->SpecimenDefinition_Additive_impl_)
      this->SpecimenDefinition_Additive_impl_->post_SpecimenDefinition_Additive ();
    else
      post_BackboneElement ();
  }

  void SpecimenDefinition_Additive_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->additiveCodeableConcept_parser_)
      this->additiveCodeableConcept_parser_->_reset ();

    if (this->additiveReference_parser_)
      this->additiveReference_parser_->_reset ();

    this->resetting_ = false;
  }

  // SpecimenDefinition_Handling_pskel
  //

  void SpecimenDefinition_Handling_pskel::
  temperatureQualifier ()
  {
    if (this->SpecimenDefinition_Handling_impl_)
      this->SpecimenDefinition_Handling_impl_->temperatureQualifier ();
  }

  void SpecimenDefinition_Handling_pskel::
  temperatureRange ()
  {
    if (this->SpecimenDefinition_Handling_impl_)
      this->SpecimenDefinition_Handling_impl_->temperatureRange ();
  }

  void SpecimenDefinition_Handling_pskel::
  maxDuration ()
  {
    if (this->SpecimenDefinition_Handling_impl_)
      this->SpecimenDefinition_Handling_impl_->maxDuration ();
  }

  void SpecimenDefinition_Handling_pskel::
  instruction ()
  {
    if (this->SpecimenDefinition_Handling_impl_)
      this->SpecimenDefinition_Handling_impl_->instruction ();
  }

  void SpecimenDefinition_Handling_pskel::
  post_SpecimenDefinition_Handling ()
  {
    if (this->SpecimenDefinition_Handling_impl_)
      this->SpecimenDefinition_Handling_impl_->post_SpecimenDefinition_Handling ();
    else
      post_BackboneElement ();
  }

  void SpecimenDefinition_Handling_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->temperatureQualifier_parser_)
      this->temperatureQualifier_parser_->_reset ();

    if (this->temperatureRange_parser_)
      this->temperatureRange_parser_->_reset ();

    if (this->maxDuration_parser_)
      this->maxDuration_parser_->_reset ();

    if (this->instruction_parser_)
      this->instruction_parser_->_reset ();

    this->resetting_ = false;
  }

  // SpecimenContainedPreference_list_pskel
  //

  void SpecimenContainedPreference_list_pskel::
  post_SpecimenContainedPreference_list ()
  {
    if (this->SpecimenContainedPreference_list_impl_)
      this->SpecimenContainedPreference_list_impl_->post_SpecimenContainedPreference_list ();
    else
      post_code_primitive ();
  }

  const char* const SpecimenContainedPreference_list_pskel::_xsde_SpecimenContainedPreference_list_pskel_enums_[2UL] = 
  {
    "alternate",
    "preferred"
  };

  // SpecimenContainedPreference_pskel
  //

  void SpecimenContainedPreference_pskel::
  value ()
  {
    if (this->SpecimenContainedPreference_impl_)
      this->SpecimenContainedPreference_impl_->value ();
  }

  void SpecimenContainedPreference_pskel::
  post_SpecimenContainedPreference ()
  {
    if (this->SpecimenContainedPreference_impl_)
      this->SpecimenContainedPreference_impl_->post_SpecimenContainedPreference ();
    else
      post_Element ();
  }

  void SpecimenContainedPreference_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for SpecimenDefinition_pskel.
  //
  bool SpecimenDefinition_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "typeCollected" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "patientPreparation" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "timeAspect" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "collection" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "typeTested" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SpecimenDefinition_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SpecimenDefinition_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SpecimenDefinition_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::DomainResource_pskel base;
    base::_pre_e_validate ();
  }

  void SpecimenDefinition_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::DomainResource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SpecimenDefinition_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "typeCollected" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->typeCollected_parser_)
            {
              this->typeCollected_parser_->pre ();
              ctx.nested_parser (this->typeCollected_parser_);
            }
          }
          else
          {
            if (this->typeCollected_parser_ != 0)
            {
              this->typeCollected_parser_->post_CodeableConcept ();
              this->typeCollected ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "patientPreparation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patientPreparation_parser_)
            {
              this->patientPreparation_parser_->pre ();
              ctx.nested_parser (this->patientPreparation_parser_);
            }
          }
          else
          {
            if (this->patientPreparation_parser_ != 0)
            {
              this->patientPreparation_parser_->post_CodeableConcept ();
              this->patientPreparation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "timeAspect" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timeAspect_parser_)
            {
              this->timeAspect_parser_->pre ();
              ctx.nested_parser (this->timeAspect_parser_);
            }
          }
          else
          {
            if (this->timeAspect_parser_ != 0)
            {
              this->timeAspect_parser_->post_string ();
              this->timeAspect ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "collection" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->collection_parser_)
            {
              this->collection_parser_->pre ();
              ctx.nested_parser (this->collection_parser_);
            }
          }
          else
          {
            if (this->collection_parser_ != 0)
            {
              this->collection_parser_->post_CodeableConcept ();
              this->collection ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "typeTested" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->typeTested_parser_)
            {
              this->typeTested_parser_->pre ();
              ctx.nested_parser (this->typeTested_parser_);
            }
          }
          else
          {
            if (this->typeTested_parser_ != 0)
            {
              this->typeTested_parser_->post_SpecimenDefinition_TypeTested ();
              this->typeTested ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SpecimenDefinition_TypeTested_pskel.
  //
  bool SpecimenDefinition_TypeTested_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "isDerived" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "preference" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SpecimenDefinition_TypeTested_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SpecimenDefinition_TypeTested_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SpecimenDefinition_TypeTested_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void SpecimenDefinition_TypeTested_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "isDerived" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->isDerived_parser_)
            {
              this->isDerived_parser_->pre ();
              ctx.nested_parser (this->isDerived_parser_);
            }
          }
          else
          {
            if (this->isDerived_parser_ != 0)
            {
              this->isDerived_parser_->post_boolean ();
              this->isDerived ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "preference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->preference_parser_)
            {
              this->preference_parser_->pre ();
              ctx.nested_parser (this->preference_parser_);
            }
          }
          else
          {
            if (this->preference_parser_ != 0)
            {
              this->preference_parser_->post_SpecimenContainedPreference ();
              this->preference ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "container" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->container_parser_)
            {
              this->container_parser_->pre ();
              ctx.nested_parser (this->container_parser_);
            }
          }
          else
          {
            if (this->container_parser_ != 0)
            {
              this->container_parser_->post_SpecimenDefinition_Container ();
              this->container ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "requirement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requirement_parser_)
            {
              this->requirement_parser_->pre ();
              ctx.nested_parser (this->requirement_parser_);
            }
          }
          else
          {
            if (this->requirement_parser_ != 0)
            {
              this->requirement_parser_->post_string ();
              this->requirement ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "retentionTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->retentionTime_parser_)
            {
              this->retentionTime_parser_->pre ();
              ctx.nested_parser (this->retentionTime_parser_);
            }
          }
          else
          {
            if (this->retentionTime_parser_ != 0)
            {
              this->retentionTime_parser_->post_Duration ();
              this->retentionTime ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "rejectionCriterion" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rejectionCriterion_parser_)
            {
              this->rejectionCriterion_parser_->pre ();
              ctx.nested_parser (this->rejectionCriterion_parser_);
            }
          }
          else
          {
            if (this->rejectionCriterion_parser_ != 0)
            {
              this->rejectionCriterion_parser_->post_CodeableConcept ();
              this->rejectionCriterion ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "handling" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->handling_parser_)
            {
              this->handling_parser_->pre ();
              ctx.nested_parser (this->handling_parser_);
            }
          }
          else
          {
            if (this->handling_parser_ != 0)
            {
              this->handling_parser_->post_SpecimenDefinition_Handling ();
              this->handling ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SpecimenDefinition_Container_pskel.
  //
  bool SpecimenDefinition_Container_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "material" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "cap" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "description" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "capacity" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "minimumVolumeQuantity" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "minimumVolumeString" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "additive" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "preparation" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SpecimenDefinition_Container_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SpecimenDefinition_Container_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SpecimenDefinition_Container_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void SpecimenDefinition_Container_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SpecimenDefinition_Container_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "material" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->material_parser_)
            {
              this->material_parser_->pre ();
              ctx.nested_parser (this->material_parser_);
            }
          }
          else
          {
            if (this->material_parser_ != 0)
            {
              this->material_parser_->post_CodeableConcept ();
              this->material ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "cap" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->cap_parser_)
            {
              this->cap_parser_->pre ();
              ctx.nested_parser (this->cap_parser_);
            }
          }
          else
          {
            if (this->cap_parser_ != 0)
            {
              this->cap_parser_->post_CodeableConcept ();
              this->cap ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "capacity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->capacity_parser_)
            {
              this->capacity_parser_->pre ();
              ctx.nested_parser (this->capacity_parser_);
            }
          }
          else
          {
            if (this->capacity_parser_ != 0)
            {
              this->capacity_parser_->post_Quantity ();
              this->capacity ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "minimumVolumeQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minimumVolumeQuantity_parser_)
            {
              this->minimumVolumeQuantity_parser_->pre ();
              ctx.nested_parser (this->minimumVolumeQuantity_parser_);
            }
          }
          else
          {
            if (this->minimumVolumeQuantity_parser_ != 0)
            {
              this->minimumVolumeQuantity_parser_->post_Quantity ();
              this->minimumVolumeQuantity ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "minimumVolumeString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minimumVolumeString_parser_)
            {
              this->minimumVolumeString_parser_->pre ();
              ctx.nested_parser (this->minimumVolumeString_parser_);
            }
          }
          else
          {
            if (this->minimumVolumeString_parser_ != 0)
            {
              this->minimumVolumeString_parser_->post_string ();
              this->minimumVolumeString ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "additive" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->additive_parser_)
            {
              this->additive_parser_->pre ();
              ctx.nested_parser (this->additive_parser_);
            }
          }
          else
          {
            if (this->additive_parser_ != 0)
            {
              this->additive_parser_->post_SpecimenDefinition_Additive ();
              this->additive ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "preparation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->preparation_parser_)
            {
              this->preparation_parser_->pre ();
              ctx.nested_parser (this->preparation_parser_);
            }
          }
          else
          {
            if (this->preparation_parser_ != 0)
            {
              this->preparation_parser_->post_string ();
              this->preparation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SpecimenDefinition_Additive_pskel.
  //
  bool SpecimenDefinition_Additive_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "additiveCodeableConcept" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "additiveReference" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SpecimenDefinition_Additive_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SpecimenDefinition_Additive_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SpecimenDefinition_Additive_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void SpecimenDefinition_Additive_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SpecimenDefinition_Additive_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "additiveCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->additiveCodeableConcept_parser_)
            {
              this->additiveCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->additiveCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->additiveCodeableConcept_parser_ != 0)
            {
              this->additiveCodeableConcept_parser_->post_CodeableConcept ();
              this->additiveCodeableConcept ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "additiveReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->additiveReference_parser_)
            {
              this->additiveReference_parser_->pre ();
              ctx.nested_parser (this->additiveReference_parser_);
            }
          }
          else
          {
            if (this->additiveReference_parser_ != 0)
            {
              this->additiveReference_parser_->post_Reference ();
              this->additiveReference ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SpecimenDefinition_Handling_pskel.
  //
  bool SpecimenDefinition_Handling_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "temperatureQualifier" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "temperatureRange" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "maxDuration" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "instruction" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SpecimenDefinition_Handling_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SpecimenDefinition_Handling_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SpecimenDefinition_Handling_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void SpecimenDefinition_Handling_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SpecimenDefinition_Handling_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "temperatureQualifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->temperatureQualifier_parser_)
            {
              this->temperatureQualifier_parser_->pre ();
              ctx.nested_parser (this->temperatureQualifier_parser_);
            }
          }
          else
          {
            if (this->temperatureQualifier_parser_ != 0)
            {
              this->temperatureQualifier_parser_->post_CodeableConcept ();
              this->temperatureQualifier ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "temperatureRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->temperatureRange_parser_)
            {
              this->temperatureRange_parser_->pre ();
              ctx.nested_parser (this->temperatureRange_parser_);
            }
          }
          else
          {
            if (this->temperatureRange_parser_ != 0)
            {
              this->temperatureRange_parser_->post_Range ();
              this->temperatureRange ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "maxDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxDuration_parser_)
            {
              this->maxDuration_parser_->pre ();
              ctx.nested_parser (this->maxDuration_parser_);
            }
          }
          else
          {
            if (this->maxDuration_parser_ != 0)
            {
              this->maxDuration_parser_->post_Duration ();
              this->maxDuration ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "instruction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->instruction_parser_)
            {
              this->instruction_parser_->pre ();
              ctx.nested_parser (this->instruction_parser_);
            }
          }
          else
          {
            if (this->instruction_parser_ != 0)
            {
              this->instruction_parser_->post_string ();
              this->instruction ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
  // Attribute validation and dispatch functions for SpecimenContainedPreference_pskel.
  //
  bool SpecimenContainedPreference_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_SpecimenContainedPreference_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


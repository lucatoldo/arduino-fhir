// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "fhir-xhtml-pskel.hxx"

namespace xhtml
{
  // ContentType_pskel
  //

  ContentType_pskel::
  ContentType_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    ContentType_impl_ (0)
  {
  }

  ContentType_pskel::
  ContentType_pskel (ContentType_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    ContentType_impl_ (impl)
  {
  }

  // ContentTypes_pskel
  //

  ContentTypes_pskel::
  ContentTypes_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    ContentTypes_impl_ (0)
  {
  }

  ContentTypes_pskel::
  ContentTypes_pskel (ContentTypes_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    ContentTypes_impl_ (impl)
  {
  }

  // Charset_pskel
  //

  Charset_pskel::
  Charset_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Charset_impl_ (0)
  {
  }

  Charset_pskel::
  Charset_pskel (Charset_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Charset_impl_ (impl)
  {
  }

  // Charsets_pskel
  //

  Charsets_pskel::
  Charsets_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Charsets_impl_ (0)
  {
  }

  Charsets_pskel::
  Charsets_pskel (Charsets_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Charsets_impl_ (impl)
  {
  }

  // LanguageCode_pskel
  //

  LanguageCode_pskel::
  LanguageCode_pskel (::xml_schema::language_pskel* tiein)
  : ::xml_schema::language_pskel (tiein, 0),
    LanguageCode_impl_ (0)
  {
  }

  LanguageCode_pskel::
  LanguageCode_pskel (LanguageCode_pskel* impl, void*)
  : ::xml_schema::language_pskel (impl, 0),
    LanguageCode_impl_ (impl)
  {
  }

  // Character_pskel
  //

  Character_pskel::
  Character_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Character_impl_ (0)
  {
    this->_length_facet (1UL);
  }

  Character_pskel::
  Character_pskel (Character_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Character_impl_ (impl)
  {
    this->_length_facet (1UL);
  }

  // Number_pskel
  //

  Number_pskel::
  Number_pskel (::xml_schema::non_negative_integer_pskel* tiein)
  : ::xml_schema::non_negative_integer_pskel (tiein, 0),
    Number_impl_ (0)
  {
  }

  Number_pskel::
  Number_pskel (Number_pskel* impl, void*)
  : ::xml_schema::non_negative_integer_pskel (impl, 0),
    Number_impl_ (impl)
  {
  }

  // tabindexNumber_pskel
  //

  tabindexNumber_pskel::
  tabindexNumber_pskel (::xhtml::Number_pskel* tiein)
  : ::xhtml::Number_pskel (tiein, 0),
    tabindexNumber_impl_ (0)
  {
    this->_max_facet (32767UL, true);
    this->_min_facet (0UL, true);
  }

  tabindexNumber_pskel::
  tabindexNumber_pskel (tabindexNumber_pskel* impl, void*)
  : ::xhtml::Number_pskel (impl, 0),
    tabindexNumber_impl_ (impl)
  {
    this->_max_facet (32767UL, true);
    this->_min_facet (0UL, true);
  }

  // LinkTypes_pskel
  //

  LinkTypes_pskel::
  LinkTypes_pskel (::xml_schema::nmtokens_pskel* tiein)
  : ::xml_schema::nmtokens_pskel (tiein, 0),
    LinkTypes_impl_ (0)
  {
  }

  LinkTypes_pskel::
  LinkTypes_pskel (LinkTypes_pskel* impl, void*)
  : ::xml_schema::nmtokens_pskel (impl, 0),
    LinkTypes_impl_ (impl)
  {
  }

  // MediaDesc_pskel
  //

  MediaDesc_pskel::
  MediaDesc_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    MediaDesc_impl_ (0)
  {
    this->_pattern_facet ("[^,]+(,\\s*[^,]+)*");
  }

  MediaDesc_pskel::
  MediaDesc_pskel (MediaDesc_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    MediaDesc_impl_ (impl)
  {
    this->_pattern_facet ("[^,]+(,\\s*[^,]+)*");
  }

  // URI_pskel
  //

  URI_pskel::
  URI_pskel (::xml_schema::uri_pskel* tiein)
  : ::xml_schema::uri_pskel (tiein, 0),
    URI_impl_ (0)
  {
  }

  URI_pskel::
  URI_pskel (URI_pskel* impl, void*)
  : ::xml_schema::uri_pskel (impl, 0),
    URI_impl_ (impl)
  {
  }

  // UriList_pskel
  //

  UriList_pskel::
  UriList_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    UriList_impl_ (0)
  {
  }

  UriList_pskel::
  UriList_pskel (UriList_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    UriList_impl_ (impl)
  {
  }

  // Datetime_pskel
  //

  Datetime_pskel::
  Datetime_pskel (::xml_schema::date_time_pskel* tiein)
  : ::xml_schema::date_time_pskel (tiein, 0),
    Datetime_impl_ (0)
  {
  }

  Datetime_pskel::
  Datetime_pskel (Datetime_pskel* impl, void*)
  : ::xml_schema::date_time_pskel (impl, 0),
    Datetime_impl_ (impl)
  {
  }

  // Script_pskel
  //

  Script_pskel::
  Script_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Script_impl_ (0)
  {
  }

  Script_pskel::
  Script_pskel (Script_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Script_impl_ (impl)
  {
  }

  // StyleSheet_pskel
  //

  StyleSheet_pskel::
  StyleSheet_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    StyleSheet_impl_ (0)
  {
  }

  StyleSheet_pskel::
  StyleSheet_pskel (StyleSheet_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    StyleSheet_impl_ (impl)
  {
  }

  // Text_pskel
  //

  Text_pskel::
  Text_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Text_impl_ (0)
  {
  }

  Text_pskel::
  Text_pskel (Text_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Text_impl_ (impl)
  {
  }

  // Length_pskel
  //

  Length_pskel::
  Length_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Length_impl_ (0)
  {
    this->_pattern_facet ("[-+]?(\\d+|\\d+(\\.\\d+)?%)");
  }

  Length_pskel::
  Length_pskel (Length_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Length_impl_ (impl)
  {
    this->_pattern_facet ("[-+]?(\\d+|\\d+(\\.\\d+)?%)");
  }

  // MultiLength_pskel
  //

  MultiLength_pskel::
  MultiLength_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    MultiLength_impl_ (0)
  {
    this->_pattern_facet ("[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*");
  }

  MultiLength_pskel::
  MultiLength_pskel (MultiLength_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    MultiLength_impl_ (impl)
  {
    this->_pattern_facet ("[-+]?(\\d+|\\d+(\\.\\d+)?%)|[1-9]?(\\d+)?\\*");
  }

  // Pixels_pskel
  //

  Pixels_pskel::
  Pixels_pskel (::xml_schema::non_negative_integer_pskel* tiein)
  : ::xml_schema::non_negative_integer_pskel (tiein, 0),
    Pixels_impl_ (0)
  {
  }

  Pixels_pskel::
  Pixels_pskel (Pixels_pskel* impl, void*)
  : ::xml_schema::non_negative_integer_pskel (impl, 0),
    Pixels_impl_ (impl)
  {
  }

  // Shape_pskel
  //

  Shape_pskel::
  Shape_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    Shape_impl_ (0)
  {
    this->_enumeration_facet (_xsde_Shape_pskel_enums_, 4UL);
  }

  Shape_pskel::
  Shape_pskel (Shape_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    Shape_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_Shape_pskel_enums_, 4UL);
  }

  // Coords_pskel
  //

  Coords_pskel::
  Coords_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    Coords_impl_ (0)
  {
    this->_pattern_facet ("[-+]?(\\d+|\\d+(\\.\\d+)?%)(,\\s*[-+]?(\\d+|\\d+(\\.\\d+)?%))*");
  }

  Coords_pskel::
  Coords_pskel (Coords_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    Coords_impl_ (impl)
  {
    this->_pattern_facet ("[-+]?(\\d+|\\d+(\\.\\d+)?%)(,\\s*[-+]?(\\d+|\\d+(\\.\\d+)?%))*");
  }

  // Inline_pskel
  //

  void Inline_pskel::
  a_parser (::xhtml::a_pskel& p)
  {
    this->a_parser_ = &p;
  }

  void Inline_pskel::
  br_parser (::xhtml::br_pskel& p)
  {
    this->br_parser_ = &p;
  }

  void Inline_pskel::
  span_parser (::xhtml::span_pskel& p)
  {
    this->span_parser_ = &p;
  }

  void Inline_pskel::
  bdo_parser (::xhtml::bdo_pskel& p)
  {
    this->bdo_parser_ = &p;
  }

  void Inline_pskel::
  map_parser (::xhtml::map_pskel& p)
  {
    this->map_parser_ = &p;
  }

  void Inline_pskel::
  img_parser (::xhtml::img_pskel& p)
  {
    this->img_parser_ = &p;
  }

  void Inline_pskel::
  tt_parser (::xhtml::tt_pskel& p)
  {
    this->tt_parser_ = &p;
  }

  void Inline_pskel::
  i_parser (::xhtml::i_pskel& p)
  {
    this->i_parser_ = &p;
  }

  void Inline_pskel::
  b_parser (::xhtml::b_pskel& p)
  {
    this->b_parser_ = &p;
  }

  void Inline_pskel::
  big_parser (::xhtml::big_pskel& p)
  {
    this->big_parser_ = &p;
  }

  void Inline_pskel::
  small_parser (::xhtml::small_pskel& p)
  {
    this->small_parser_ = &p;
  }

  void Inline_pskel::
  em_parser (::xhtml::em_pskel& p)
  {
    this->em_parser_ = &p;
  }

  void Inline_pskel::
  strong_parser (::xhtml::strong_pskel& p)
  {
    this->strong_parser_ = &p;
  }

  void Inline_pskel::
  dfn_parser (::xhtml::dfn_pskel& p)
  {
    this->dfn_parser_ = &p;
  }

  void Inline_pskel::
  code_parser (::xhtml::code_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void Inline_pskel::
  q_parser (::xhtml::q_pskel& p)
  {
    this->q_parser_ = &p;
  }

  void Inline_pskel::
  samp_parser (::xhtml::samp_pskel& p)
  {
    this->samp_parser_ = &p;
  }

  void Inline_pskel::
  kbd_parser (::xhtml::kbd_pskel& p)
  {
    this->kbd_parser_ = &p;
  }

  void Inline_pskel::
  var_parser (::xhtml::var_pskel& p)
  {
    this->var_parser_ = &p;
  }

  void Inline_pskel::
  cite_parser (::xhtml::cite_pskel& p)
  {
    this->cite_parser_ = &p;
  }

  void Inline_pskel::
  abbr_parser (::xhtml::abbr_pskel& p)
  {
    this->abbr_parser_ = &p;
  }

  void Inline_pskel::
  acronym_parser (::xhtml::acronym_pskel& p)
  {
    this->acronym_parser_ = &p;
  }

  void Inline_pskel::
  sub_parser (::xhtml::sub_pskel& p)
  {
    this->sub_parser_ = &p;
  }

  void Inline_pskel::
  sup_parser (::xhtml::sup_pskel& p)
  {
    this->sup_parser_ = &p;
  }

  void Inline_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
  }

  Inline_pskel::
  Inline_pskel ()
  : Inline_impl_ (0),
    a_parser_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    img_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Inline_pskel::
  Inline_pskel (Inline_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    Inline_impl_ (impl),
    a_parser_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    img_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Block_pskel
  //

  void Block_pskel::
  p_parser (::xhtml::p_pskel& p)
  {
    this->p_parser_ = &p;
  }

  void Block_pskel::
  h1_parser (::xhtml::h1_pskel& p)
  {
    this->h1_parser_ = &p;
  }

  void Block_pskel::
  h2_parser (::xhtml::h2_pskel& p)
  {
    this->h2_parser_ = &p;
  }

  void Block_pskel::
  h3_parser (::xhtml::h3_pskel& p)
  {
    this->h3_parser_ = &p;
  }

  void Block_pskel::
  h4_parser (::xhtml::h4_pskel& p)
  {
    this->h4_parser_ = &p;
  }

  void Block_pskel::
  h5_parser (::xhtml::h5_pskel& p)
  {
    this->h5_parser_ = &p;
  }

  void Block_pskel::
  h6_parser (::xhtml::h6_pskel& p)
  {
    this->h6_parser_ = &p;
  }

  void Block_pskel::
  div_parser (::xhtml::div_pskel& p)
  {
    this->div_parser_ = &p;
  }

  void Block_pskel::
  ul_parser (::xhtml::ul_pskel& p)
  {
    this->ul_parser_ = &p;
  }

  void Block_pskel::
  ol_parser (::xhtml::ol_pskel& p)
  {
    this->ol_parser_ = &p;
  }

  void Block_pskel::
  dl_parser (::xhtml::dl_pskel& p)
  {
    this->dl_parser_ = &p;
  }

  void Block_pskel::
  pre_parser (::xhtml::pre_pskel& p)
  {
    this->pre_parser_ = &p;
  }

  void Block_pskel::
  hr_parser (::xhtml::hr_pskel& p)
  {
    this->hr_parser_ = &p;
  }

  void Block_pskel::
  blockquote_parser (::xhtml::blockquote_pskel& p)
  {
    this->blockquote_parser_ = &p;
  }

  void Block_pskel::
  address_parser (::xhtml::address_pskel& p)
  {
    this->address_parser_ = &p;
  }

  void Block_pskel::
  table_parser (::xhtml::table_pskel& p)
  {
    this->table_parser_ = &p;
  }

  void Block_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
  }

  Block_pskel::
  Block_pskel ()
  : Block_impl_ (0),
    p_parser_ (0),
    h1_parser_ (0),
    h2_parser_ (0),
    h3_parser_ (0),
    h4_parser_ (0),
    h5_parser_ (0),
    h6_parser_ (0),
    div_parser_ (0),
    ul_parser_ (0),
    ol_parser_ (0),
    dl_parser_ (0),
    pre_parser_ (0),
    hr_parser_ (0),
    blockquote_parser_ (0),
    address_parser_ (0),
    table_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Block_pskel::
  Block_pskel (Block_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    Block_impl_ (impl),
    p_parser_ (0),
    h1_parser_ (0),
    h2_parser_ (0),
    h3_parser_ (0),
    h4_parser_ (0),
    h5_parser_ (0),
    h6_parser_ (0),
    div_parser_ (0),
    ul_parser_ (0),
    ol_parser_ (0),
    dl_parser_ (0),
    pre_parser_ (0),
    hr_parser_ (0),
    blockquote_parser_ (0),
    address_parser_ (0),
    table_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Flow_pskel
  //

  void Flow_pskel::
  p_parser (::xhtml::p_pskel& p)
  {
    this->p_parser_ = &p;
  }

  void Flow_pskel::
  h1_parser (::xhtml::h1_pskel& p)
  {
    this->h1_parser_ = &p;
  }

  void Flow_pskel::
  h2_parser (::xhtml::h2_pskel& p)
  {
    this->h2_parser_ = &p;
  }

  void Flow_pskel::
  h3_parser (::xhtml::h3_pskel& p)
  {
    this->h3_parser_ = &p;
  }

  void Flow_pskel::
  h4_parser (::xhtml::h4_pskel& p)
  {
    this->h4_parser_ = &p;
  }

  void Flow_pskel::
  h5_parser (::xhtml::h5_pskel& p)
  {
    this->h5_parser_ = &p;
  }

  void Flow_pskel::
  h6_parser (::xhtml::h6_pskel& p)
  {
    this->h6_parser_ = &p;
  }

  void Flow_pskel::
  div_parser (::xhtml::div_pskel& p)
  {
    this->div_parser_ = &p;
  }

  void Flow_pskel::
  ul_parser (::xhtml::ul_pskel& p)
  {
    this->ul_parser_ = &p;
  }

  void Flow_pskel::
  ol_parser (::xhtml::ol_pskel& p)
  {
    this->ol_parser_ = &p;
  }

  void Flow_pskel::
  dl_parser (::xhtml::dl_pskel& p)
  {
    this->dl_parser_ = &p;
  }

  void Flow_pskel::
  pre_parser (::xhtml::pre_pskel& p)
  {
    this->pre_parser_ = &p;
  }

  void Flow_pskel::
  hr_parser (::xhtml::hr_pskel& p)
  {
    this->hr_parser_ = &p;
  }

  void Flow_pskel::
  blockquote_parser (::xhtml::blockquote_pskel& p)
  {
    this->blockquote_parser_ = &p;
  }

  void Flow_pskel::
  address_parser (::xhtml::address_pskel& p)
  {
    this->address_parser_ = &p;
  }

  void Flow_pskel::
  table_parser (::xhtml::table_pskel& p)
  {
    this->table_parser_ = &p;
  }

  void Flow_pskel::
  a_parser (::xhtml::a_pskel& p)
  {
    this->a_parser_ = &p;
  }

  void Flow_pskel::
  br_parser (::xhtml::br_pskel& p)
  {
    this->br_parser_ = &p;
  }

  void Flow_pskel::
  span_parser (::xhtml::span_pskel& p)
  {
    this->span_parser_ = &p;
  }

  void Flow_pskel::
  bdo_parser (::xhtml::bdo_pskel& p)
  {
    this->bdo_parser_ = &p;
  }

  void Flow_pskel::
  map_parser (::xhtml::map_pskel& p)
  {
    this->map_parser_ = &p;
  }

  void Flow_pskel::
  img_parser (::xhtml::img_pskel& p)
  {
    this->img_parser_ = &p;
  }

  void Flow_pskel::
  tt_parser (::xhtml::tt_pskel& p)
  {
    this->tt_parser_ = &p;
  }

  void Flow_pskel::
  i_parser (::xhtml::i_pskel& p)
  {
    this->i_parser_ = &p;
  }

  void Flow_pskel::
  b_parser (::xhtml::b_pskel& p)
  {
    this->b_parser_ = &p;
  }

  void Flow_pskel::
  big_parser (::xhtml::big_pskel& p)
  {
    this->big_parser_ = &p;
  }

  void Flow_pskel::
  small_parser (::xhtml::small_pskel& p)
  {
    this->small_parser_ = &p;
  }

  void Flow_pskel::
  em_parser (::xhtml::em_pskel& p)
  {
    this->em_parser_ = &p;
  }

  void Flow_pskel::
  strong_parser (::xhtml::strong_pskel& p)
  {
    this->strong_parser_ = &p;
  }

  void Flow_pskel::
  dfn_parser (::xhtml::dfn_pskel& p)
  {
    this->dfn_parser_ = &p;
  }

  void Flow_pskel::
  code_parser (::xhtml::code_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void Flow_pskel::
  q_parser (::xhtml::q_pskel& p)
  {
    this->q_parser_ = &p;
  }

  void Flow_pskel::
  samp_parser (::xhtml::samp_pskel& p)
  {
    this->samp_parser_ = &p;
  }

  void Flow_pskel::
  kbd_parser (::xhtml::kbd_pskel& p)
  {
    this->kbd_parser_ = &p;
  }

  void Flow_pskel::
  var_parser (::xhtml::var_pskel& p)
  {
    this->var_parser_ = &p;
  }

  void Flow_pskel::
  cite_parser (::xhtml::cite_pskel& p)
  {
    this->cite_parser_ = &p;
  }

  void Flow_pskel::
  abbr_parser (::xhtml::abbr_pskel& p)
  {
    this->abbr_parser_ = &p;
  }

  void Flow_pskel::
  acronym_parser (::xhtml::acronym_pskel& p)
  {
    this->acronym_parser_ = &p;
  }

  void Flow_pskel::
  sub_parser (::xhtml::sub_pskel& p)
  {
    this->sub_parser_ = &p;
  }

  void Flow_pskel::
  sup_parser (::xhtml::sup_pskel& p)
  {
    this->sup_parser_ = &p;
  }

  void Flow_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
  }

  Flow_pskel::
  Flow_pskel ()
  : Flow_impl_ (0),
    p_parser_ (0),
    h1_parser_ (0),
    h2_parser_ (0),
    h3_parser_ (0),
    h4_parser_ (0),
    h5_parser_ (0),
    h6_parser_ (0),
    div_parser_ (0),
    ul_parser_ (0),
    ol_parser_ (0),
    dl_parser_ (0),
    pre_parser_ (0),
    hr_parser_ (0),
    blockquote_parser_ (0),
    address_parser_ (0),
    table_parser_ (0),
    a_parser_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    img_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Flow_pskel::
  Flow_pskel (Flow_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    Flow_impl_ (impl),
    p_parser_ (0),
    h1_parser_ (0),
    h2_parser_ (0),
    h3_parser_ (0),
    h4_parser_ (0),
    h5_parser_ (0),
    h6_parser_ (0),
    div_parser_ (0),
    ul_parser_ (0),
    ol_parser_ (0),
    dl_parser_ (0),
    pre_parser_ (0),
    hr_parser_ (0),
    blockquote_parser_ (0),
    address_parser_ (0),
    table_parser_ (0),
    a_parser_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    img_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // a_content_pskel
  //

  void a_content_pskel::
  br_parser (::xhtml::br_pskel& p)
  {
    this->br_parser_ = &p;
  }

  void a_content_pskel::
  span_parser (::xhtml::span_pskel& p)
  {
    this->span_parser_ = &p;
  }

  void a_content_pskel::
  bdo_parser (::xhtml::bdo_pskel& p)
  {
    this->bdo_parser_ = &p;
  }

  void a_content_pskel::
  map_parser (::xhtml::map_pskel& p)
  {
    this->map_parser_ = &p;
  }

  void a_content_pskel::
  img_parser (::xhtml::img_pskel& p)
  {
    this->img_parser_ = &p;
  }

  void a_content_pskel::
  tt_parser (::xhtml::tt_pskel& p)
  {
    this->tt_parser_ = &p;
  }

  void a_content_pskel::
  i_parser (::xhtml::i_pskel& p)
  {
    this->i_parser_ = &p;
  }

  void a_content_pskel::
  b_parser (::xhtml::b_pskel& p)
  {
    this->b_parser_ = &p;
  }

  void a_content_pskel::
  big_parser (::xhtml::big_pskel& p)
  {
    this->big_parser_ = &p;
  }

  void a_content_pskel::
  small_parser (::xhtml::small_pskel& p)
  {
    this->small_parser_ = &p;
  }

  void a_content_pskel::
  em_parser (::xhtml::em_pskel& p)
  {
    this->em_parser_ = &p;
  }

  void a_content_pskel::
  strong_parser (::xhtml::strong_pskel& p)
  {
    this->strong_parser_ = &p;
  }

  void a_content_pskel::
  dfn_parser (::xhtml::dfn_pskel& p)
  {
    this->dfn_parser_ = &p;
  }

  void a_content_pskel::
  code_parser (::xhtml::code_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void a_content_pskel::
  q_parser (::xhtml::q_pskel& p)
  {
    this->q_parser_ = &p;
  }

  void a_content_pskel::
  samp_parser (::xhtml::samp_pskel& p)
  {
    this->samp_parser_ = &p;
  }

  void a_content_pskel::
  kbd_parser (::xhtml::kbd_pskel& p)
  {
    this->kbd_parser_ = &p;
  }

  void a_content_pskel::
  var_parser (::xhtml::var_pskel& p)
  {
    this->var_parser_ = &p;
  }

  void a_content_pskel::
  cite_parser (::xhtml::cite_pskel& p)
  {
    this->cite_parser_ = &p;
  }

  void a_content_pskel::
  abbr_parser (::xhtml::abbr_pskel& p)
  {
    this->abbr_parser_ = &p;
  }

  void a_content_pskel::
  acronym_parser (::xhtml::acronym_pskel& p)
  {
    this->acronym_parser_ = &p;
  }

  void a_content_pskel::
  sub_parser (::xhtml::sub_pskel& p)
  {
    this->sub_parser_ = &p;
  }

  void a_content_pskel::
  sup_parser (::xhtml::sup_pskel& p)
  {
    this->sup_parser_ = &p;
  }

  void a_content_pskel::
  parsers (::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup)
  {
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
  }

  a_content_pskel::
  a_content_pskel ()
  : a_content_impl_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    img_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  a_content_pskel::
  a_content_pskel (a_content_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    a_content_impl_ (impl),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    img_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // pre_content_pskel
  //

  void pre_content_pskel::
  a_parser (::xhtml::a_pskel& p)
  {
    this->a_parser_ = &p;
  }

  void pre_content_pskel::
  tt_parser (::xhtml::tt_pskel& p)
  {
    this->tt_parser_ = &p;
  }

  void pre_content_pskel::
  i_parser (::xhtml::i_pskel& p)
  {
    this->i_parser_ = &p;
  }

  void pre_content_pskel::
  b_parser (::xhtml::b_pskel& p)
  {
    this->b_parser_ = &p;
  }

  void pre_content_pskel::
  big_parser (::xhtml::big_pskel& p)
  {
    this->big_parser_ = &p;
  }

  void pre_content_pskel::
  small_parser (::xhtml::small_pskel& p)
  {
    this->small_parser_ = &p;
  }

  void pre_content_pskel::
  em_parser (::xhtml::em_pskel& p)
  {
    this->em_parser_ = &p;
  }

  void pre_content_pskel::
  strong_parser (::xhtml::strong_pskel& p)
  {
    this->strong_parser_ = &p;
  }

  void pre_content_pskel::
  dfn_parser (::xhtml::dfn_pskel& p)
  {
    this->dfn_parser_ = &p;
  }

  void pre_content_pskel::
  code_parser (::xhtml::code_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void pre_content_pskel::
  q_parser (::xhtml::q_pskel& p)
  {
    this->q_parser_ = &p;
  }

  void pre_content_pskel::
  samp_parser (::xhtml::samp_pskel& p)
  {
    this->samp_parser_ = &p;
  }

  void pre_content_pskel::
  kbd_parser (::xhtml::kbd_pskel& p)
  {
    this->kbd_parser_ = &p;
  }

  void pre_content_pskel::
  var_parser (::xhtml::var_pskel& p)
  {
    this->var_parser_ = &p;
  }

  void pre_content_pskel::
  cite_parser (::xhtml::cite_pskel& p)
  {
    this->cite_parser_ = &p;
  }

  void pre_content_pskel::
  abbr_parser (::xhtml::abbr_pskel& p)
  {
    this->abbr_parser_ = &p;
  }

  void pre_content_pskel::
  acronym_parser (::xhtml::acronym_pskel& p)
  {
    this->acronym_parser_ = &p;
  }

  void pre_content_pskel::
  sub_parser (::xhtml::sub_pskel& p)
  {
    this->sub_parser_ = &p;
  }

  void pre_content_pskel::
  sup_parser (::xhtml::sup_pskel& p)
  {
    this->sup_parser_ = &p;
  }

  void pre_content_pskel::
  br_parser (::xhtml::br_pskel& p)
  {
    this->br_parser_ = &p;
  }

  void pre_content_pskel::
  span_parser (::xhtml::span_pskel& p)
  {
    this->span_parser_ = &p;
  }

  void pre_content_pskel::
  bdo_parser (::xhtml::bdo_pskel& p)
  {
    this->bdo_parser_ = &p;
  }

  void pre_content_pskel::
  map_parser (::xhtml::map_pskel& p)
  {
    this->map_parser_ = &p;
  }

  void pre_content_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map)
  {
    this->a_parser_ = &a;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
  }

  pre_content_pskel::
  pre_content_pskel ()
  : pre_content_impl_ (0),
    a_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  pre_content_pskel::
  pre_content_pskel (pre_content_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    pre_content_impl_ (impl),
    a_parser_ (0),
    tt_parser_ (0),
    i_parser_ (0),
    b_parser_ (0),
    big_parser_ (0),
    small_parser_ (0),
    em_parser_ (0),
    strong_parser_ (0),
    dfn_parser_ (0),
    code_parser_ (0),
    q_parser_ (0),
    samp_parser_ (0),
    kbd_parser_ (0),
    var_parser_ (0),
    cite_parser_ (0),
    abbr_parser_ (0),
    acronym_parser_ (0),
    sub_parser_ (0),
    sup_parser_ (0),
    br_parser_ (0),
    span_parser_ (0),
    bdo_parser_ (0),
    map_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TFrame_pskel
  //

  TFrame_pskel::
  TFrame_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    TFrame_impl_ (0)
  {
    this->_enumeration_facet (_xsde_TFrame_pskel_enums_, 9UL);
  }

  TFrame_pskel::
  TFrame_pskel (TFrame_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    TFrame_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_TFrame_pskel_enums_, 9UL);
  }

  // TRules_pskel
  //

  TRules_pskel::
  TRules_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    TRules_impl_ (0)
  {
    this->_enumeration_facet (_xsde_TRules_pskel_enums_, 5UL);
  }

  TRules_pskel::
  TRules_pskel (TRules_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    TRules_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_TRules_pskel_enums_, 5UL);
  }

  // Scope_pskel
  //

  Scope_pskel::
  Scope_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    Scope_impl_ (0)
  {
    this->_enumeration_facet (_xsde_Scope_pskel_enums_, 4UL);
  }

  Scope_pskel::
  Scope_pskel (Scope_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    Scope_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_Scope_pskel_enums_, 4UL);
  }

  // dir_pskel
  //

  dir_pskel::
  dir_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    dir_impl_ (0)
  {
    this->_enumeration_facet (_xsde_dir_pskel_enums_, 2UL);
  }

  dir_pskel::
  dir_pskel (dir_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    dir_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_dir_pskel_enums_, 2UL);
  }

  // div_pskel
  //

  void div_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void div_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void div_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void div_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void div_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void div_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void div_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void div_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  div_pskel::
  div_pskel (::xhtml::Flow_pskel* tiein)
  : ::xhtml::Flow_pskel (tiein, 0),
    div_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  div_pskel::
  div_pskel (div_pskel* impl, void*)
  : ::xhtml::Flow_pskel (impl, 0),
    div_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // p_pskel
  //

  void p_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void p_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void p_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void p_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void p_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void p_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void p_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void p_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  p_pskel::
  p_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    p_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  p_pskel::
  p_pskel (p_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    p_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // h1_pskel
  //

  void h1_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void h1_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void h1_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void h1_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void h1_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void h1_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void h1_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void h1_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  h1_pskel::
  h1_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    h1_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  h1_pskel::
  h1_pskel (h1_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    h1_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // h2_pskel
  //

  void h2_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void h2_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void h2_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void h2_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void h2_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void h2_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void h2_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void h2_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  h2_pskel::
  h2_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    h2_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  h2_pskel::
  h2_pskel (h2_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    h2_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // h3_pskel
  //

  void h3_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void h3_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void h3_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void h3_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void h3_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void h3_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void h3_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void h3_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  h3_pskel::
  h3_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    h3_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  h3_pskel::
  h3_pskel (h3_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    h3_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // h4_pskel
  //

  void h4_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void h4_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void h4_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void h4_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void h4_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void h4_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void h4_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void h4_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  h4_pskel::
  h4_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    h4_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  h4_pskel::
  h4_pskel (h4_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    h4_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // h5_pskel
  //

  void h5_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void h5_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void h5_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void h5_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void h5_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void h5_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void h5_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void h5_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  h5_pskel::
  h5_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    h5_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  h5_pskel::
  h5_pskel (h5_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    h5_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // h6_pskel
  //

  void h6_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void h6_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void h6_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void h6_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void h6_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void h6_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void h6_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void h6_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  h6_pskel::
  h6_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    h6_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  h6_pskel::
  h6_pskel (h6_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    h6_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // ul_pskel
  //

  void ul_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void ul_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void ul_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void ul_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void ul_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void ul_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void ul_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void ul_pskel::
  li_parser (::xhtml::li_pskel& p)
  {
    this->li_parser_ = &p;
  }

  void ul_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::li_pskel& li)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->li_parser_ = &li;
  }

  ul_pskel::
  ul_pskel ()
  : ul_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    li_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ul_pskel::
  ul_pskel (ul_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    ul_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    li_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ol_pskel
  //

  void ol_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void ol_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void ol_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void ol_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void ol_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void ol_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void ol_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void ol_pskel::
  li_parser (::xhtml::li_pskel& p)
  {
    this->li_parser_ = &p;
  }

  void ol_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::li_pskel& li)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->li_parser_ = &li;
  }

  ol_pskel::
  ol_pskel ()
  : ol_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    li_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ol_pskel::
  ol_pskel (ol_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    ol_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    li_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // li_pskel
  //

  void li_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void li_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void li_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void li_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void li_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void li_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void li_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void li_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  li_pskel::
  li_pskel (::xhtml::Flow_pskel* tiein)
  : ::xhtml::Flow_pskel (tiein, 0),
    li_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  li_pskel::
  li_pskel (li_pskel* impl, void*)
  : ::xhtml::Flow_pskel (impl, 0),
    li_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // dl_pskel
  //

  void dl_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void dl_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void dl_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void dl_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void dl_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void dl_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void dl_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void dl_pskel::
  dt_parser (::xhtml::dt_pskel& p)
  {
    this->dt_parser_ = &p;
  }

  void dl_pskel::
  dd_parser (::xhtml::dd_pskel& p)
  {
    this->dd_parser_ = &p;
  }

  void dl_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::dt_pskel& dt,
           ::xhtml::dd_pskel& dd)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->dt_parser_ = &dt;
    this->dd_parser_ = &dd;
  }

  dl_pskel::
  dl_pskel ()
  : dl_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    dt_parser_ (0),
    dd_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  dl_pskel::
  dl_pskel (dl_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    dl_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    dt_parser_ (0),
    dd_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // dt_pskel
  //

  void dt_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void dt_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void dt_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void dt_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void dt_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void dt_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void dt_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void dt_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  dt_pskel::
  dt_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    dt_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  dt_pskel::
  dt_pskel (dt_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    dt_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // dd_pskel
  //

  void dd_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void dd_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void dd_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void dd_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void dd_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void dd_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void dd_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void dd_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  dd_pskel::
  dd_pskel (::xhtml::Flow_pskel* tiein)
  : ::xhtml::Flow_pskel (tiein, 0),
    dd_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  dd_pskel::
  dd_pskel (dd_pskel* impl, void*)
  : ::xhtml::Flow_pskel (impl, 0),
    dd_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // address_pskel
  //

  void address_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void address_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void address_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void address_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void address_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void address_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void address_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void address_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  address_pskel::
  address_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    address_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  address_pskel::
  address_pskel (address_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    address_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // hr_pskel
  //

  void hr_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void hr_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void hr_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void hr_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void hr_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void hr_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void hr_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void hr_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  hr_pskel::
  hr_pskel ()
  : hr_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  hr_pskel::
  hr_pskel (hr_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    hr_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // pre_pskel
  //

  void pre_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void pre_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void pre_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void pre_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void pre_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void pre_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void pre_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void pre_pskel::
  space_parser (::namespace_::space_pskel& p)
  {
    this->space_parser_ = &p;
  }

  void pre_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::namespace_::space_pskel& space)
  {
    this->a_parser_ = &a;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->space_parser_ = &space;
  }

  pre_pskel::
  pre_pskel (::xhtml::pre_content_pskel* tiein)
  : ::xhtml::pre_content_pskel (tiein, 0),
    pre_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    space_parser_ (0)
  {
  }

  pre_pskel::
  pre_pskel (pre_pskel* impl, void*)
  : ::xhtml::pre_content_pskel (impl, 0),
    pre_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    space_parser_ (0)
  {
  }

  // blockquote_pskel
  //

  void blockquote_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void blockquote_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void blockquote_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void blockquote_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void blockquote_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void blockquote_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void blockquote_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void blockquote_pskel::
  cite_parser (::xhtml::URI_pskel& p)
  {
    this->cite_parser_ = &p;
  }

  void blockquote_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::URI_pskel& cite)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->cite_parser_ = &cite;
  }

  blockquote_pskel::
  blockquote_pskel (::xhtml::Block_pskel* tiein)
  : ::xhtml::Block_pskel (tiein, 0),
    blockquote_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    cite_parser_ (0)
  {
  }

  blockquote_pskel::
  blockquote_pskel (blockquote_pskel* impl, void*)
  : ::xhtml::Block_pskel (impl, 0),
    blockquote_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    cite_parser_ (0)
  {
  }

  // a_pskel
  //

  void a_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void a_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void a_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void a_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void a_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void a_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void a_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void a_pskel::
  accesskey_parser (::xhtml::Character_pskel& p)
  {
    this->accesskey_parser_ = &p;
  }

  void a_pskel::
  tabindex_parser (::xhtml::tabindexNumber_pskel& p)
  {
    this->tabindex_parser_ = &p;
  }

  void a_pskel::
  charset_parser (::xhtml::Charset_pskel& p)
  {
    this->charset_parser_ = &p;
  }

  void a_pskel::
  type_parser (::xhtml::ContentType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void a_pskel::
  name_parser (::xml_schema::nmtoken_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void a_pskel::
  href_parser (::xhtml::URI_pskel& p)
  {
    this->href_parser_ = &p;
  }

  void a_pskel::
  hreflang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->hreflang_parser_ = &p;
  }

  void a_pskel::
  rel_parser (::xhtml::LinkTypes_pskel& p)
  {
    this->rel_parser_ = &p;
  }

  void a_pskel::
  rev_parser (::xhtml::LinkTypes_pskel& p)
  {
    this->rev_parser_ = &p;
  }

  void a_pskel::
  shape_parser (::xhtml::Shape_pskel& p)
  {
    this->shape_parser_ = &p;
  }

  void a_pskel::
  coords_parser (::xhtml::Coords_pskel& p)
  {
    this->coords_parser_ = &p;
  }

  void a_pskel::
  parsers (::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Character_pskel& accesskey,
           ::xhtml::tabindexNumber_pskel& tabindex,
           ::xhtml::Charset_pskel& charset,
           ::xhtml::ContentType_pskel& type,
           ::xml_schema::nmtoken_pskel& name,
           ::xhtml::URI_pskel& href,
           ::xhtml::LanguageCode_pskel& hreflang,
           ::xhtml::LinkTypes_pskel& rel,
           ::xhtml::LinkTypes_pskel& rev,
           ::xhtml::Shape_pskel& shape,
           ::xhtml::Coords_pskel& coords)
  {
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->accesskey_parser_ = &accesskey;
    this->tabindex_parser_ = &tabindex;
    this->charset_parser_ = &charset;
    this->type_parser_ = &type;
    this->name_parser_ = &name;
    this->href_parser_ = &href;
    this->hreflang_parser_ = &hreflang;
    this->rel_parser_ = &rel;
    this->rev_parser_ = &rev;
    this->shape_parser_ = &shape;
    this->coords_parser_ = &coords;
  }

  a_pskel::
  a_pskel (::xhtml::a_content_pskel* tiein)
  : ::xhtml::a_content_pskel (tiein, 0),
    a_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    accesskey_parser_ (0),
    tabindex_parser_ (0),
    charset_parser_ (0),
    type_parser_ (0),
    name_parser_ (0),
    href_parser_ (0),
    hreflang_parser_ (0),
    rel_parser_ (0),
    rev_parser_ (0),
    shape_parser_ (0),
    coords_parser_ (0)
  {
  }

  a_pskel::
  a_pskel (a_pskel* impl, void*)
  : ::xhtml::a_content_pskel (impl, 0),
    a_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    accesskey_parser_ (0),
    tabindex_parser_ (0),
    charset_parser_ (0),
    type_parser_ (0),
    name_parser_ (0),
    href_parser_ (0),
    hreflang_parser_ (0),
    rel_parser_ (0),
    rev_parser_ (0),
    shape_parser_ (0),
    coords_parser_ (0)
  {
  }

  // span_pskel
  //

  void span_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void span_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void span_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void span_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void span_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void span_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void span_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void span_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  span_pskel::
  span_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    span_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  span_pskel::
  span_pskel (span_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    span_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // bdo_pskel
  //

  void bdo_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void bdo_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void bdo_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void bdo_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void bdo_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void bdo_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void bdo_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void bdo_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  bdo_pskel::
  bdo_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    bdo_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  bdo_pskel::
  bdo_pskel (bdo_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    bdo_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // br_pskel
  //

  void br_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void br_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void br_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void br_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void br_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
  }

  br_pskel::
  br_pskel ()
  : br_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0)
  {
  }

  br_pskel::
  br_pskel (br_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    br_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0)
  {
  }

  // em_pskel
  //

  void em_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void em_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void em_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void em_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void em_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void em_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void em_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void em_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  em_pskel::
  em_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    em_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  em_pskel::
  em_pskel (em_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    em_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // strong_pskel
  //

  void strong_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void strong_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void strong_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void strong_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void strong_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void strong_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void strong_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void strong_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  strong_pskel::
  strong_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    strong_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  strong_pskel::
  strong_pskel (strong_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    strong_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // dfn_pskel
  //

  void dfn_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void dfn_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void dfn_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void dfn_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void dfn_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void dfn_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void dfn_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void dfn_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  dfn_pskel::
  dfn_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    dfn_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  dfn_pskel::
  dfn_pskel (dfn_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    dfn_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // code_pskel
  //

  void code_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void code_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void code_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void code_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void code_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void code_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void code_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void code_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  code_pskel::
  code_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    code_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  code_pskel::
  code_pskel (code_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    code_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // samp_pskel
  //

  void samp_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void samp_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void samp_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void samp_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void samp_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void samp_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void samp_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void samp_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  samp_pskel::
  samp_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    samp_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  samp_pskel::
  samp_pskel (samp_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    samp_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // kbd_pskel
  //

  void kbd_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void kbd_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void kbd_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void kbd_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void kbd_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void kbd_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void kbd_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void kbd_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  kbd_pskel::
  kbd_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    kbd_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  kbd_pskel::
  kbd_pskel (kbd_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    kbd_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // var_pskel
  //

  void var_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void var_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void var_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void var_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void var_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void var_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void var_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void var_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  var_pskel::
  var_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    var_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  var_pskel::
  var_pskel (var_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    var_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // cite_pskel
  //

  void cite_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void cite_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void cite_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void cite_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void cite_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void cite_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void cite_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void cite_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  cite_pskel::
  cite_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    cite_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  cite_pskel::
  cite_pskel (cite_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    cite_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // abbr_pskel
  //

  void abbr_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void abbr_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void abbr_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void abbr_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void abbr_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void abbr_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void abbr_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void abbr_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  abbr_pskel::
  abbr_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    abbr_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  abbr_pskel::
  abbr_pskel (abbr_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    abbr_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // acronym_pskel
  //

  void acronym_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void acronym_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void acronym_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void acronym_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void acronym_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void acronym_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void acronym_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void acronym_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  acronym_pskel::
  acronym_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    acronym_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  acronym_pskel::
  acronym_pskel (acronym_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    acronym_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // q_pskel
  //

  void q_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void q_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void q_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void q_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void q_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void q_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void q_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void q_pskel::
  cite1_parser (::xhtml::URI_pskel& p)
  {
    this->cite1_parser_ = &p;
  }

  void q_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::URI_pskel& cite1)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->cite1_parser_ = &cite1;
  }

  q_pskel::
  q_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    q_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    cite1_parser_ (0)
  {
  }

  q_pskel::
  q_pskel (q_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    q_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    cite1_parser_ (0)
  {
  }

  // sub_pskel
  //

  void sub_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void sub_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void sub_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void sub_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void sub_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void sub_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void sub_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void sub_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  sub_pskel::
  sub_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    sub_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  sub_pskel::
  sub_pskel (sub_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    sub_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // sup_pskel
  //

  void sup_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void sup_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void sup_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void sup_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void sup_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void sup_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void sup_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void sup_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  sup_pskel::
  sup_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    sup_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  sup_pskel::
  sup_pskel (sup_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    sup_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // tt_pskel
  //

  void tt_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void tt_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void tt_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void tt_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void tt_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void tt_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void tt_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void tt_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  tt_pskel::
  tt_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    tt_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  tt_pskel::
  tt_pskel (tt_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    tt_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // i_pskel
  //

  void i_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void i_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void i_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void i_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void i_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void i_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void i_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void i_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  i_pskel::
  i_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    i_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  i_pskel::
  i_pskel (i_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    i_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // b_pskel
  //

  void b_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void b_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void b_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void b_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void b_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void b_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void b_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void b_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  b_pskel::
  b_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    b_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  b_pskel::
  b_pskel (b_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    b_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // big_pskel
  //

  void big_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void big_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void big_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void big_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void big_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void big_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void big_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void big_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  big_pskel::
  big_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    big_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  big_pskel::
  big_pskel (big_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    big_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // small_pskel
  //

  void small_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void small_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void small_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void small_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void small_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void small_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void small_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void small_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  small_pskel::
  small_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    small_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  small_pskel::
  small_pskel (small_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    small_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // img_pskel
  //

  void img_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void img_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void img_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void img_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void img_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void img_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void img_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void img_pskel::
  src_parser (::xhtml::URI_pskel& p)
  {
    this->src_parser_ = &p;
  }

  void img_pskel::
  alt_parser (::xhtml::Text_pskel& p)
  {
    this->alt_parser_ = &p;
  }

  void img_pskel::
  longdesc_parser (::xhtml::URI_pskel& p)
  {
    this->longdesc_parser_ = &p;
  }

  void img_pskel::
  height_parser (::xhtml::Length_pskel& p)
  {
    this->height_parser_ = &p;
  }

  void img_pskel::
  width_parser (::xhtml::Length_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void img_pskel::
  usemap_parser (::xhtml::URI_pskel& p)
  {
    this->usemap_parser_ = &p;
  }

  void img_pskel::
  ismap_parser (::xhtml::ismap_pskel& p)
  {
    this->ismap_parser_ = &p;
  }

  void img_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::URI_pskel& src,
           ::xhtml::Text_pskel& alt,
           ::xhtml::URI_pskel& longdesc,
           ::xhtml::Length_pskel& height,
           ::xhtml::Length_pskel& width,
           ::xhtml::URI_pskel& usemap,
           ::xhtml::ismap_pskel& ismap)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->src_parser_ = &src;
    this->alt_parser_ = &alt;
    this->longdesc_parser_ = &longdesc;
    this->height_parser_ = &height;
    this->width_parser_ = &width;
    this->usemap_parser_ = &usemap;
    this->ismap_parser_ = &ismap;
  }

  img_pskel::
  img_pskel ()
  : img_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    src_parser_ (0),
    alt_parser_ (0),
    longdesc_parser_ (0),
    height_parser_ (0),
    width_parser_ (0),
    usemap_parser_ (0),
    ismap_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  img_pskel::
  img_pskel (img_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    img_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    src_parser_ (0),
    alt_parser_ (0),
    longdesc_parser_ (0),
    height_parser_ (0),
    width_parser_ (0),
    usemap_parser_ (0),
    ismap_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // map_pskel
  //

  void map_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void map_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void map_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void map_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void map_pskel::
  class__parser (::xml_schema::any_simple_type_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void map_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void map_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void map_pskel::
  name_parser (::xml_schema::nmtoken_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void map_pskel::
  p_parser (::xhtml::p_pskel& p)
  {
    this->p_parser_ = &p;
  }

  void map_pskel::
  h1_parser (::xhtml::h1_pskel& p)
  {
    this->h1_parser_ = &p;
  }

  void map_pskel::
  h2_parser (::xhtml::h2_pskel& p)
  {
    this->h2_parser_ = &p;
  }

  void map_pskel::
  h3_parser (::xhtml::h3_pskel& p)
  {
    this->h3_parser_ = &p;
  }

  void map_pskel::
  h4_parser (::xhtml::h4_pskel& p)
  {
    this->h4_parser_ = &p;
  }

  void map_pskel::
  h5_parser (::xhtml::h5_pskel& p)
  {
    this->h5_parser_ = &p;
  }

  void map_pskel::
  h6_parser (::xhtml::h6_pskel& p)
  {
    this->h6_parser_ = &p;
  }

  void map_pskel::
  div_parser (::xhtml::div_pskel& p)
  {
    this->div_parser_ = &p;
  }

  void map_pskel::
  ul_parser (::xhtml::ul_pskel& p)
  {
    this->ul_parser_ = &p;
  }

  void map_pskel::
  ol_parser (::xhtml::ol_pskel& p)
  {
    this->ol_parser_ = &p;
  }

  void map_pskel::
  dl_parser (::xhtml::dl_pskel& p)
  {
    this->dl_parser_ = &p;
  }

  void map_pskel::
  pre_parser (::xhtml::pre_pskel& p)
  {
    this->pre_parser_ = &p;
  }

  void map_pskel::
  hr_parser (::xhtml::hr_pskel& p)
  {
    this->hr_parser_ = &p;
  }

  void map_pskel::
  blockquote_parser (::xhtml::blockquote_pskel& p)
  {
    this->blockquote_parser_ = &p;
  }

  void map_pskel::
  address_parser (::xhtml::address_pskel& p)
  {
    this->address_parser_ = &p;
  }

  void map_pskel::
  table_parser (::xhtml::table_pskel& p)
  {
    this->table_parser_ = &p;
  }

  void map_pskel::
  area_parser (::xhtml::area_pskel& p)
  {
    this->area_parser_ = &p;
  }

  void map_pskel::
  parsers (::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xml_schema::id_pskel& id,
           ::xml_schema::any_simple_type_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xml_schema::nmtoken_pskel& name,
           ::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::area_pskel& area)
  {
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->name_parser_ = &name;
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->area_parser_ = &area;
  }

  map_pskel::
  map_pskel ()
  : map_impl_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    name_parser_ (0),
    p_parser_ (0),
    h1_parser_ (0),
    h2_parser_ (0),
    h3_parser_ (0),
    h4_parser_ (0),
    h5_parser_ (0),
    h6_parser_ (0),
    div_parser_ (0),
    ul_parser_ (0),
    ol_parser_ (0),
    dl_parser_ (0),
    pre_parser_ (0),
    hr_parser_ (0),
    blockquote_parser_ (0),
    address_parser_ (0),
    table_parser_ (0),
    area_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  map_pskel::
  map_pskel (map_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    map_impl_ (impl),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    name_parser_ (0),
    p_parser_ (0),
    h1_parser_ (0),
    h2_parser_ (0),
    h3_parser_ (0),
    h4_parser_ (0),
    h5_parser_ (0),
    h6_parser_ (0),
    div_parser_ (0),
    ul_parser_ (0),
    ol_parser_ (0),
    dl_parser_ (0),
    pre_parser_ (0),
    hr_parser_ (0),
    blockquote_parser_ (0),
    address_parser_ (0),
    table_parser_ (0),
    area_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // area_pskel
  //

  void area_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void area_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void area_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void area_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void area_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void area_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void area_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void area_pskel::
  accesskey_parser (::xhtml::Character_pskel& p)
  {
    this->accesskey_parser_ = &p;
  }

  void area_pskel::
  tabindex_parser (::xhtml::tabindexNumber_pskel& p)
  {
    this->tabindex_parser_ = &p;
  }

  void area_pskel::
  shape_parser (::xhtml::Shape_pskel& p)
  {
    this->shape_parser_ = &p;
  }

  void area_pskel::
  coords_parser (::xhtml::Coords_pskel& p)
  {
    this->coords_parser_ = &p;
  }

  void area_pskel::
  href_parser (::xhtml::URI_pskel& p)
  {
    this->href_parser_ = &p;
  }

  void area_pskel::
  nohref_parser (::xhtml::nohref_pskel& p)
  {
    this->nohref_parser_ = &p;
  }

  void area_pskel::
  alt_parser (::xhtml::Text_pskel& p)
  {
    this->alt_parser_ = &p;
  }

  void area_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Character_pskel& accesskey,
           ::xhtml::tabindexNumber_pskel& tabindex,
           ::xhtml::Shape_pskel& shape,
           ::xhtml::Coords_pskel& coords,
           ::xhtml::URI_pskel& href,
           ::xhtml::nohref_pskel& nohref,
           ::xhtml::Text_pskel& alt)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->accesskey_parser_ = &accesskey;
    this->tabindex_parser_ = &tabindex;
    this->shape_parser_ = &shape;
    this->coords_parser_ = &coords;
    this->href_parser_ = &href;
    this->nohref_parser_ = &nohref;
    this->alt_parser_ = &alt;
  }

  area_pskel::
  area_pskel ()
  : area_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    accesskey_parser_ (0),
    tabindex_parser_ (0),
    shape_parser_ (0),
    coords_parser_ (0),
    href_parser_ (0),
    nohref_parser_ (0),
    alt_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  area_pskel::
  area_pskel (area_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    area_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    accesskey_parser_ (0),
    tabindex_parser_ (0),
    shape_parser_ (0),
    coords_parser_ (0),
    href_parser_ (0),
    nohref_parser_ (0),
    alt_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // align_pskel
  //

  align_pskel::
  align_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    align_impl_ (0)
  {
    this->_enumeration_facet (_xsde_align_pskel_enums_, 5UL);
  }

  align_pskel::
  align_pskel (align_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    align_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_align_pskel_enums_, 5UL);
  }

  // valign_pskel
  //

  valign_pskel::
  valign_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    valign_impl_ (0)
  {
    this->_enumeration_facet (_xsde_valign_pskel_enums_, 4UL);
  }

  valign_pskel::
  valign_pskel (valign_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    valign_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_valign_pskel_enums_, 4UL);
  }

  // table_pskel
  //

  void table_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void table_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void table_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void table_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void table_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void table_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void table_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void table_pskel::
  summary_parser (::xhtml::Text_pskel& p)
  {
    this->summary_parser_ = &p;
  }

  void table_pskel::
  width_parser (::xhtml::Length_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void table_pskel::
  border_parser (::xhtml::Pixels_pskel& p)
  {
    this->border_parser_ = &p;
  }

  void table_pskel::
  frame_parser (::xhtml::TFrame_pskel& p)
  {
    this->frame_parser_ = &p;
  }

  void table_pskel::
  rules_parser (::xhtml::TRules_pskel& p)
  {
    this->rules_parser_ = &p;
  }

  void table_pskel::
  cellspacing_parser (::xhtml::Length_pskel& p)
  {
    this->cellspacing_parser_ = &p;
  }

  void table_pskel::
  cellpadding_parser (::xhtml::Length_pskel& p)
  {
    this->cellpadding_parser_ = &p;
  }

  void table_pskel::
  caption_parser (::xhtml::caption_pskel& p)
  {
    this->caption_parser_ = &p;
  }

  void table_pskel::
  col_parser (::xhtml::col_pskel& p)
  {
    this->col_parser_ = &p;
  }

  void table_pskel::
  colgroup_parser (::xhtml::colgroup_pskel& p)
  {
    this->colgroup_parser_ = &p;
  }

  void table_pskel::
  thead_parser (::xhtml::thead_pskel& p)
  {
    this->thead_parser_ = &p;
  }

  void table_pskel::
  tfoot_parser (::xhtml::tfoot_pskel& p)
  {
    this->tfoot_parser_ = &p;
  }

  void table_pskel::
  tbody_parser (::xhtml::tbody_pskel& p)
  {
    this->tbody_parser_ = &p;
  }

  void table_pskel::
  tr_parser (::xhtml::tr_pskel& p)
  {
    this->tr_parser_ = &p;
  }

  void table_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Text_pskel& summary,
           ::xhtml::Length_pskel& width,
           ::xhtml::Pixels_pskel& border,
           ::xhtml::TFrame_pskel& frame,
           ::xhtml::TRules_pskel& rules,
           ::xhtml::Length_pskel& cellspacing,
           ::xhtml::Length_pskel& cellpadding,
           ::xhtml::caption_pskel& caption,
           ::xhtml::col_pskel& col,
           ::xhtml::colgroup_pskel& colgroup,
           ::xhtml::thead_pskel& thead,
           ::xhtml::tfoot_pskel& tfoot,
           ::xhtml::tbody_pskel& tbody,
           ::xhtml::tr_pskel& tr)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->summary_parser_ = &summary;
    this->width_parser_ = &width;
    this->border_parser_ = &border;
    this->frame_parser_ = &frame;
    this->rules_parser_ = &rules;
    this->cellspacing_parser_ = &cellspacing;
    this->cellpadding_parser_ = &cellpadding;
    this->caption_parser_ = &caption;
    this->col_parser_ = &col;
    this->colgroup_parser_ = &colgroup;
    this->thead_parser_ = &thead;
    this->tfoot_parser_ = &tfoot;
    this->tbody_parser_ = &tbody;
    this->tr_parser_ = &tr;
  }

  table_pskel::
  table_pskel ()
  : table_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    summary_parser_ (0),
    width_parser_ (0),
    border_parser_ (0),
    frame_parser_ (0),
    rules_parser_ (0),
    cellspacing_parser_ (0),
    cellpadding_parser_ (0),
    caption_parser_ (0),
    col_parser_ (0),
    colgroup_parser_ (0),
    thead_parser_ (0),
    tfoot_parser_ (0),
    tbody_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  table_pskel::
  table_pskel (table_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    table_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    summary_parser_ (0),
    width_parser_ (0),
    border_parser_ (0),
    frame_parser_ (0),
    rules_parser_ (0),
    cellspacing_parser_ (0),
    cellpadding_parser_ (0),
    caption_parser_ (0),
    col_parser_ (0),
    colgroup_parser_ (0),
    thead_parser_ (0),
    tfoot_parser_ (0),
    tbody_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // caption_pskel
  //

  void caption_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void caption_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void caption_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void caption_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void caption_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void caption_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void caption_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void caption_pskel::
  parsers (::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir)
  {
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
  }

  caption_pskel::
  caption_pskel (::xhtml::Inline_pskel* tiein)
  : ::xhtml::Inline_pskel (tiein, 0),
    caption_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  caption_pskel::
  caption_pskel (caption_pskel* impl, void*)
  : ::xhtml::Inline_pskel (impl, 0),
    caption_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0)
  {
  }

  // thead_pskel
  //

  void thead_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void thead_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void thead_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void thead_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void thead_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void thead_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void thead_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void thead_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void thead_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void thead_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void thead_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void thead_pskel::
  tr_parser (::xhtml::tr_pskel& p)
  {
    this->tr_parser_ = &p;
  }

  void thead_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign,
           ::xhtml::tr_pskel& tr)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
    this->tr_parser_ = &tr;
  }

  thead_pskel::
  thead_pskel ()
  : thead_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  thead_pskel::
  thead_pskel (thead_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    thead_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // tfoot_pskel
  //

  void tfoot_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void tfoot_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void tfoot_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void tfoot_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void tfoot_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void tfoot_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void tfoot_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void tfoot_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void tfoot_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void tfoot_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void tfoot_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void tfoot_pskel::
  tr_parser (::xhtml::tr_pskel& p)
  {
    this->tr_parser_ = &p;
  }

  void tfoot_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign,
           ::xhtml::tr_pskel& tr)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
    this->tr_parser_ = &tr;
  }

  tfoot_pskel::
  tfoot_pskel ()
  : tfoot_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  tfoot_pskel::
  tfoot_pskel (tfoot_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    tfoot_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // tbody_pskel
  //

  void tbody_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void tbody_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void tbody_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void tbody_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void tbody_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void tbody_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void tbody_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void tbody_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void tbody_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void tbody_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void tbody_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void tbody_pskel::
  tr_parser (::xhtml::tr_pskel& p)
  {
    this->tr_parser_ = &p;
  }

  void tbody_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign,
           ::xhtml::tr_pskel& tr)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
    this->tr_parser_ = &tr;
  }

  tbody_pskel::
  tbody_pskel ()
  : tbody_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  tbody_pskel::
  tbody_pskel (tbody_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    tbody_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    tr_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // colgroup_pskel
  //

  void colgroup_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void colgroup_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void colgroup_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void colgroup_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void colgroup_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void colgroup_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void colgroup_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void colgroup_pskel::
  span_parser (::xhtml::Number_pskel& p)
  {
    this->span_parser_ = &p;
  }

  void colgroup_pskel::
  width_parser (::xhtml::MultiLength_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void colgroup_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void colgroup_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void colgroup_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void colgroup_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void colgroup_pskel::
  col_parser (::xhtml::col_pskel& p)
  {
    this->col_parser_ = &p;
  }

  void colgroup_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Number_pskel& span,
           ::xhtml::MultiLength_pskel& width,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign,
           ::xhtml::col_pskel& col)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->span_parser_ = &span;
    this->width_parser_ = &width;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
    this->col_parser_ = &col;
  }

  colgroup_pskel::
  colgroup_pskel ()
  : colgroup_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    span_parser_ (0),
    width_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    col_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  colgroup_pskel::
  colgroup_pskel (colgroup_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    colgroup_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    span_parser_ (0),
    width_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    col_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // col_pskel
  //

  void col_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void col_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void col_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void col_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void col_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void col_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void col_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void col_pskel::
  span_parser (::xhtml::Number_pskel& p)
  {
    this->span_parser_ = &p;
  }

  void col_pskel::
  width_parser (::xhtml::MultiLength_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void col_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void col_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void col_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void col_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void col_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Number_pskel& span,
           ::xhtml::MultiLength_pskel& width,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->span_parser_ = &span;
    this->width_parser_ = &width;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
  }

  col_pskel::
  col_pskel ()
  : col_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    span_parser_ (0),
    width_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0)
  {
  }

  col_pskel::
  col_pskel (col_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    col_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    span_parser_ (0),
    width_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0)
  {
  }

  // tr_pskel
  //

  void tr_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void tr_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void tr_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void tr_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void tr_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void tr_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void tr_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void tr_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void tr_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void tr_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void tr_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void tr_pskel::
  th_parser (::xhtml::th_pskel& p)
  {
    this->th_parser_ = &p;
  }

  void tr_pskel::
  td_parser (::xhtml::td_pskel& p)
  {
    this->td_parser_ = &p;
  }

  void tr_pskel::
  parsers (::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign,
           ::xhtml::th_pskel& th,
           ::xhtml::td_pskel& td)
  {
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
    this->th_parser_ = &th;
    this->td_parser_ = &td;
  }

  tr_pskel::
  tr_pskel ()
  : tr_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    th_parser_ (0),
    td_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  tr_pskel::
  tr_pskel (tr_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    tr_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0),
    th_parser_ (0),
    td_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // th_pskel
  //

  void th_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void th_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void th_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void th_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void th_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void th_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void th_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void th_pskel::
  abbr1_parser (::xhtml::Text_pskel& p)
  {
    this->abbr1_parser_ = &p;
  }

  void th_pskel::
  axis_parser (::xml_schema::any_simple_type_pskel& p)
  {
    this->axis_parser_ = &p;
  }

  void th_pskel::
  headers_parser (::xml_schema::idrefs_pskel& p)
  {
    this->headers_parser_ = &p;
  }

  void th_pskel::
  scope_parser (::xhtml::Scope_pskel& p)
  {
    this->scope_parser_ = &p;
  }

  void th_pskel::
  rowspan_parser (::xhtml::Number_pskel& p)
  {
    this->rowspan_parser_ = &p;
  }

  void th_pskel::
  colspan_parser (::xhtml::Number_pskel& p)
  {
    this->colspan_parser_ = &p;
  }

  void th_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void th_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void th_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void th_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void th_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Text_pskel& abbr1,
           ::xml_schema::any_simple_type_pskel& axis,
           ::xml_schema::idrefs_pskel& headers,
           ::xhtml::Scope_pskel& scope,
           ::xhtml::Number_pskel& rowspan,
           ::xhtml::Number_pskel& colspan,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->abbr1_parser_ = &abbr1;
    this->axis_parser_ = &axis;
    this->headers_parser_ = &headers;
    this->scope_parser_ = &scope;
    this->rowspan_parser_ = &rowspan;
    this->colspan_parser_ = &colspan;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
  }

  th_pskel::
  th_pskel (::xhtml::Flow_pskel* tiein)
  : ::xhtml::Flow_pskel (tiein, 0),
    th_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    abbr1_parser_ (0),
    axis_parser_ (0),
    headers_parser_ (0),
    scope_parser_ (0),
    rowspan_parser_ (0),
    colspan_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0)
  {
  }

  th_pskel::
  th_pskel (th_pskel* impl, void*)
  : ::xhtml::Flow_pskel (impl, 0),
    th_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    abbr1_parser_ (0),
    axis_parser_ (0),
    headers_parser_ (0),
    scope_parser_ (0),
    rowspan_parser_ (0),
    colspan_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0)
  {
  }

  // td_pskel
  //

  void td_pskel::
  id_parser (::xml_schema::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void td_pskel::
  class__parser (::xml_schema::nmtokens_pskel& p)
  {
    this->class__parser_ = &p;
  }

  void td_pskel::
  style_parser (::xhtml::StyleSheet_pskel& p)
  {
    this->style_parser_ = &p;
  }

  void td_pskel::
  title_parser (::xhtml::Text_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void td_pskel::
  lang_parser (::xhtml::LanguageCode_pskel& p)
  {
    this->lang_parser_ = &p;
  }

  void td_pskel::
  lang1_parser (::namespace_::lang_pskel& p)
  {
    this->lang1_parser_ = &p;
  }

  void td_pskel::
  dir_parser (::xhtml::dir_pskel& p)
  {
    this->dir_parser_ = &p;
  }

  void td_pskel::
  abbr1_parser (::xhtml::Text_pskel& p)
  {
    this->abbr1_parser_ = &p;
  }

  void td_pskel::
  axis_parser (::xml_schema::any_simple_type_pskel& p)
  {
    this->axis_parser_ = &p;
  }

  void td_pskel::
  headers_parser (::xml_schema::idrefs_pskel& p)
  {
    this->headers_parser_ = &p;
  }

  void td_pskel::
  scope_parser (::xhtml::Scope_pskel& p)
  {
    this->scope_parser_ = &p;
  }

  void td_pskel::
  rowspan_parser (::xhtml::Number_pskel& p)
  {
    this->rowspan_parser_ = &p;
  }

  void td_pskel::
  colspan_parser (::xhtml::Number_pskel& p)
  {
    this->colspan_parser_ = &p;
  }

  void td_pskel::
  align_parser (::xhtml::align_pskel& p)
  {
    this->align_parser_ = &p;
  }

  void td_pskel::
  char__parser (::xhtml::Character_pskel& p)
  {
    this->char__parser_ = &p;
  }

  void td_pskel::
  charoff_parser (::xhtml::Length_pskel& p)
  {
    this->charoff_parser_ = &p;
  }

  void td_pskel::
  valign_parser (::xhtml::valign_pskel& p)
  {
    this->valign_parser_ = &p;
  }

  void td_pskel::
  parsers (::xhtml::p_pskel& p,
           ::xhtml::h1_pskel& h1,
           ::xhtml::h2_pskel& h2,
           ::xhtml::h3_pskel& h3,
           ::xhtml::h4_pskel& h4,
           ::xhtml::h5_pskel& h5,
           ::xhtml::h6_pskel& h6,
           ::xhtml::div_pskel& div,
           ::xhtml::ul_pskel& ul,
           ::xhtml::ol_pskel& ol,
           ::xhtml::dl_pskel& dl,
           ::xhtml::pre_pskel& pre,
           ::xhtml::hr_pskel& hr,
           ::xhtml::blockquote_pskel& blockquote,
           ::xhtml::address_pskel& address,
           ::xhtml::table_pskel& table,
           ::xhtml::a_pskel& a,
           ::xhtml::br_pskel& br,
           ::xhtml::span_pskel& span,
           ::xhtml::bdo_pskel& bdo,
           ::xhtml::map_pskel& map,
           ::xhtml::img_pskel& img,
           ::xhtml::tt_pskel& tt,
           ::xhtml::i_pskel& i,
           ::xhtml::b_pskel& b,
           ::xhtml::big_pskel& big,
           ::xhtml::small_pskel& small,
           ::xhtml::em_pskel& em,
           ::xhtml::strong_pskel& strong,
           ::xhtml::dfn_pskel& dfn,
           ::xhtml::code_pskel& code,
           ::xhtml::q_pskel& q,
           ::xhtml::samp_pskel& samp,
           ::xhtml::kbd_pskel& kbd,
           ::xhtml::var_pskel& var,
           ::xhtml::cite_pskel& cite,
           ::xhtml::abbr_pskel& abbr,
           ::xhtml::acronym_pskel& acronym,
           ::xhtml::sub_pskel& sub,
           ::xhtml::sup_pskel& sup,
           ::xml_schema::id_pskel& id,
           ::xml_schema::nmtokens_pskel& class_,
           ::xhtml::StyleSheet_pskel& style,
           ::xhtml::Text_pskel& title,
           ::xhtml::LanguageCode_pskel& lang,
           ::namespace_::lang_pskel& lang1,
           ::xhtml::dir_pskel& dir,
           ::xhtml::Text_pskel& abbr1,
           ::xml_schema::any_simple_type_pskel& axis,
           ::xml_schema::idrefs_pskel& headers,
           ::xhtml::Scope_pskel& scope,
           ::xhtml::Number_pskel& rowspan,
           ::xhtml::Number_pskel& colspan,
           ::xhtml::align_pskel& align,
           ::xhtml::Character_pskel& char_,
           ::xhtml::Length_pskel& charoff,
           ::xhtml::valign_pskel& valign)
  {
    this->p_parser_ = &p;
    this->h1_parser_ = &h1;
    this->h2_parser_ = &h2;
    this->h3_parser_ = &h3;
    this->h4_parser_ = &h4;
    this->h5_parser_ = &h5;
    this->h6_parser_ = &h6;
    this->div_parser_ = &div;
    this->ul_parser_ = &ul;
    this->ol_parser_ = &ol;
    this->dl_parser_ = &dl;
    this->pre_parser_ = &pre;
    this->hr_parser_ = &hr;
    this->blockquote_parser_ = &blockquote;
    this->address_parser_ = &address;
    this->table_parser_ = &table;
    this->a_parser_ = &a;
    this->br_parser_ = &br;
    this->span_parser_ = &span;
    this->bdo_parser_ = &bdo;
    this->map_parser_ = &map;
    this->img_parser_ = &img;
    this->tt_parser_ = &tt;
    this->i_parser_ = &i;
    this->b_parser_ = &b;
    this->big_parser_ = &big;
    this->small_parser_ = &small;
    this->em_parser_ = &em;
    this->strong_parser_ = &strong;
    this->dfn_parser_ = &dfn;
    this->code_parser_ = &code;
    this->q_parser_ = &q;
    this->samp_parser_ = &samp;
    this->kbd_parser_ = &kbd;
    this->var_parser_ = &var;
    this->cite_parser_ = &cite;
    this->abbr_parser_ = &abbr;
    this->acronym_parser_ = &acronym;
    this->sub_parser_ = &sub;
    this->sup_parser_ = &sup;
    this->id_parser_ = &id;
    this->class__parser_ = &class_;
    this->style_parser_ = &style;
    this->title_parser_ = &title;
    this->lang_parser_ = &lang;
    this->lang1_parser_ = &lang1;
    this->dir_parser_ = &dir;
    this->abbr1_parser_ = &abbr1;
    this->axis_parser_ = &axis;
    this->headers_parser_ = &headers;
    this->scope_parser_ = &scope;
    this->rowspan_parser_ = &rowspan;
    this->colspan_parser_ = &colspan;
    this->align_parser_ = &align;
    this->char__parser_ = &char_;
    this->charoff_parser_ = &charoff;
    this->valign_parser_ = &valign;
  }

  td_pskel::
  td_pskel (::xhtml::Flow_pskel* tiein)
  : ::xhtml::Flow_pskel (tiein, 0),
    td_impl_ (0),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    abbr1_parser_ (0),
    axis_parser_ (0),
    headers_parser_ (0),
    scope_parser_ (0),
    rowspan_parser_ (0),
    colspan_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0)
  {
  }

  td_pskel::
  td_pskel (td_pskel* impl, void*)
  : ::xhtml::Flow_pskel (impl, 0),
    td_impl_ (impl),
    id_parser_ (0),
    class__parser_ (0),
    style_parser_ (0),
    title_parser_ (0),
    lang_parser_ (0),
    lang1_parser_ (0),
    dir_parser_ (0),
    abbr1_parser_ (0),
    axis_parser_ (0),
    headers_parser_ (0),
    scope_parser_ (0),
    rowspan_parser_ (0),
    colspan_parser_ (0),
    align_parser_ (0),
    char__parser_ (0),
    charoff_parser_ (0),
    valign_parser_ (0)
  {
  }

  // ismap_pskel
  //

  ismap_pskel::
  ismap_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    ismap_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ismap_pskel_enums_, 1UL);
  }

  ismap_pskel::
  ismap_pskel (ismap_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    ismap_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ismap_pskel_enums_, 1UL);
  }

  // nohref_pskel
  //

  nohref_pskel::
  nohref_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    nohref_impl_ (0)
  {
    this->_enumeration_facet (_xsde_nohref_pskel_enums_, 1UL);
  }

  nohref_pskel::
  nohref_pskel (nohref_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    nohref_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_nohref_pskel_enums_, 1UL);
  }
}

#include <assert.h>

namespace xhtml
{
  // ContentType_pskel
  //

  void ContentType_pskel::
  post_ContentType ()
  {
    if (this->ContentType_impl_)
      this->ContentType_impl_->post_ContentType ();
  }

  ::std::string ContentType_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // ContentTypes_pskel
  //

  void ContentTypes_pskel::
  post_ContentTypes ()
  {
    if (this->ContentTypes_impl_)
      this->ContentTypes_impl_->post_ContentTypes ();
  }

  ::std::string ContentTypes_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Charset_pskel
  //

  void Charset_pskel::
  post_Charset ()
  {
    if (this->Charset_impl_)
      this->Charset_impl_->post_Charset ();
  }

  ::std::string Charset_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Charsets_pskel
  //

  void Charsets_pskel::
  post_Charsets ()
  {
    if (this->Charsets_impl_)
      this->Charsets_impl_->post_Charsets ();
  }

  ::std::string Charsets_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // LanguageCode_pskel
  //

  void LanguageCode_pskel::
  post_LanguageCode ()
  {
    if (this->LanguageCode_impl_)
      this->LanguageCode_impl_->post_LanguageCode ();
  }

  ::std::string LanguageCode_pskel::
  post_language ()
  {
    assert (this->language_impl_);
    return this->language_impl_->post_language ();
  }

  // Character_pskel
  //

  void Character_pskel::
  post_Character ()
  {
    if (this->Character_impl_)
      this->Character_impl_->post_Character ();
  }

  ::std::string Character_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Number_pskel
  //

  void Number_pskel::
  post_Number ()
  {
    if (this->Number_impl_)
      this->Number_impl_->post_Number ();
  }

  unsigned long Number_pskel::
  post_non_negative_integer ()
  {
    assert (this->non_negative_integer_impl_);
    return this->non_negative_integer_impl_->post_non_negative_integer ();
  }

  // tabindexNumber_pskel
  //

  void tabindexNumber_pskel::
  post_tabindexNumber ()
  {
    if (this->tabindexNumber_impl_)
      this->tabindexNumber_impl_->post_tabindexNumber ();
    else
      post_Number ();
  }

  // LinkTypes_pskel
  //

  void LinkTypes_pskel::
  post_LinkTypes ()
  {
    if (this->LinkTypes_impl_)
      this->LinkTypes_impl_->post_LinkTypes ();
  }

  ::xml_schema::string_sequence* LinkTypes_pskel::
  post_nmtokens ()
  {
    assert (this->nmtokens_impl_);
    return this->nmtokens_impl_->post_nmtokens ();
  }

  // MediaDesc_pskel
  //

  void MediaDesc_pskel::
  post_MediaDesc ()
  {
    if (this->MediaDesc_impl_)
      this->MediaDesc_impl_->post_MediaDesc ();
  }

  ::std::string MediaDesc_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // URI_pskel
  //

  void URI_pskel::
  post_URI ()
  {
    if (this->URI_impl_)
      this->URI_impl_->post_URI ();
  }

  ::std::string URI_pskel::
  post_uri ()
  {
    assert (this->uri_impl_);
    return this->uri_impl_->post_uri ();
  }

  // UriList_pskel
  //

  void UriList_pskel::
  post_UriList ()
  {
    if (this->UriList_impl_)
      this->UriList_impl_->post_UriList ();
  }

  ::std::string UriList_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Datetime_pskel
  //

  void Datetime_pskel::
  post_Datetime ()
  {
    if (this->Datetime_impl_)
      this->Datetime_impl_->post_Datetime ();
  }

  ::xml_schema::date_time Datetime_pskel::
  post_date_time ()
  {
    assert (this->date_time_impl_);
    return this->date_time_impl_->post_date_time ();
  }

  // Script_pskel
  //

  void Script_pskel::
  post_Script ()
  {
    if (this->Script_impl_)
      this->Script_impl_->post_Script ();
  }

  ::std::string Script_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // StyleSheet_pskel
  //

  void StyleSheet_pskel::
  post_StyleSheet ()
  {
    if (this->StyleSheet_impl_)
      this->StyleSheet_impl_->post_StyleSheet ();
  }

  ::std::string StyleSheet_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Text_pskel
  //

  void Text_pskel::
  post_Text ()
  {
    if (this->Text_impl_)
      this->Text_impl_->post_Text ();
  }

  ::std::string Text_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Length_pskel
  //

  void Length_pskel::
  post_Length ()
  {
    if (this->Length_impl_)
      this->Length_impl_->post_Length ();
  }

  ::std::string Length_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // MultiLength_pskel
  //

  void MultiLength_pskel::
  post_MultiLength ()
  {
    if (this->MultiLength_impl_)
      this->MultiLength_impl_->post_MultiLength ();
  }

  ::std::string MultiLength_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Pixels_pskel
  //

  void Pixels_pskel::
  post_Pixels ()
  {
    if (this->Pixels_impl_)
      this->Pixels_impl_->post_Pixels ();
  }

  unsigned long Pixels_pskel::
  post_non_negative_integer ()
  {
    assert (this->non_negative_integer_impl_);
    return this->non_negative_integer_impl_->post_non_negative_integer ();
  }

  // Shape_pskel
  //

  void Shape_pskel::
  post_Shape ()
  {
    if (this->Shape_impl_)
      this->Shape_impl_->post_Shape ();
  }

  ::std::string Shape_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const Shape_pskel::_xsde_Shape_pskel_enums_[4UL] = 
  {
    "circle",
    "default",
    "poly",
    "rect"
  };

  // Coords_pskel
  //

  void Coords_pskel::
  post_Coords ()
  {
    if (this->Coords_impl_)
      this->Coords_impl_->post_Coords ();
  }

  ::std::string Coords_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // Inline_pskel
  //

  void Inline_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->Inline_impl_)
      this->Inline_impl_->choice_arm (x);
  }

  void Inline_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->Inline_impl_)
      this->Inline_impl_->choice1_arm (x);
  }

  void Inline_pskel::
  a ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->a ();
  }

  void Inline_pskel::
  choice2_arm (choice2_arm_tag x)
  {
    if (this->Inline_impl_)
      this->Inline_impl_->choice2_arm (x);
  }

  void Inline_pskel::
  choice3_arm (choice3_arm_tag x)
  {
    if (this->Inline_impl_)
      this->Inline_impl_->choice3_arm (x);
  }

  void Inline_pskel::
  br ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->br ();
  }

  void Inline_pskel::
  span ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->span ();
  }

  void Inline_pskel::
  bdo ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->bdo ();
  }

  void Inline_pskel::
  map ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->map ();
  }

  void Inline_pskel::
  img ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->img ();
  }

  void Inline_pskel::
  choice4_arm (choice4_arm_tag x)
  {
    if (this->Inline_impl_)
      this->Inline_impl_->choice4_arm (x);
  }

  void Inline_pskel::
  tt ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->tt ();
  }

  void Inline_pskel::
  i ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->i ();
  }

  void Inline_pskel::
  b ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->b ();
  }

  void Inline_pskel::
  big ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->big ();
  }

  void Inline_pskel::
  small ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->small ();
  }

  void Inline_pskel::
  choice5_arm (choice5_arm_tag x)
  {
    if (this->Inline_impl_)
      this->Inline_impl_->choice5_arm (x);
  }

  void Inline_pskel::
  em ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->em ();
  }

  void Inline_pskel::
  strong ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->strong ();
  }

  void Inline_pskel::
  dfn ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->dfn ();
  }

  void Inline_pskel::
  code ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->code ();
  }

  void Inline_pskel::
  q ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->q ();
  }

  void Inline_pskel::
  samp ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->samp ();
  }

  void Inline_pskel::
  kbd ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->kbd ();
  }

  void Inline_pskel::
  var ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->var ();
  }

  void Inline_pskel::
  cite ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->cite ();
  }

  void Inline_pskel::
  abbr ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->abbr ();
  }

  void Inline_pskel::
  acronym ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->acronym ();
  }

  void Inline_pskel::
  sub ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->sub ();
  }

  void Inline_pskel::
  sup ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->sup ();
  }

  void Inline_pskel::
  post_Inline ()
  {
    if (this->Inline_impl_)
      this->Inline_impl_->post_Inline ();
  }

  void Inline_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->a_parser_)
      this->a_parser_->_reset ();

    if (this->br_parser_)
      this->br_parser_->_reset ();

    if (this->span_parser_)
      this->span_parser_->_reset ();

    if (this->bdo_parser_)
      this->bdo_parser_->_reset ();

    if (this->map_parser_)
      this->map_parser_->_reset ();

    if (this->img_parser_)
      this->img_parser_->_reset ();

    if (this->tt_parser_)
      this->tt_parser_->_reset ();

    if (this->i_parser_)
      this->i_parser_->_reset ();

    if (this->b_parser_)
      this->b_parser_->_reset ();

    if (this->big_parser_)
      this->big_parser_->_reset ();

    if (this->small_parser_)
      this->small_parser_->_reset ();

    if (this->em_parser_)
      this->em_parser_->_reset ();

    if (this->strong_parser_)
      this->strong_parser_->_reset ();

    if (this->dfn_parser_)
      this->dfn_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->q_parser_)
      this->q_parser_->_reset ();

    if (this->samp_parser_)
      this->samp_parser_->_reset ();

    if (this->kbd_parser_)
      this->kbd_parser_->_reset ();

    if (this->var_parser_)
      this->var_parser_->_reset ();

    if (this->cite_parser_)
      this->cite_parser_->_reset ();

    if (this->abbr_parser_)
      this->abbr_parser_->_reset ();

    if (this->acronym_parser_)
      this->acronym_parser_->_reset ();

    if (this->sub_parser_)
      this->sub_parser_->_reset ();

    if (this->sup_parser_)
      this->sup_parser_->_reset ();

    this->resetting_ = false;
  }

  // Block_pskel
  //

  void Block_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->Block_impl_)
      this->Block_impl_->choice_arm (x);
  }

  void Block_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->Block_impl_)
      this->Block_impl_->choice1_arm (x);
  }

  void Block_pskel::
  p ()
  {
    if (this->Block_impl_)
      this->Block_impl_->p ();
  }

  void Block_pskel::
  choice2_arm (choice2_arm_tag x)
  {
    if (this->Block_impl_)
      this->Block_impl_->choice2_arm (x);
  }

  void Block_pskel::
  h1 ()
  {
    if (this->Block_impl_)
      this->Block_impl_->h1 ();
  }

  void Block_pskel::
  h2 ()
  {
    if (this->Block_impl_)
      this->Block_impl_->h2 ();
  }

  void Block_pskel::
  h3 ()
  {
    if (this->Block_impl_)
      this->Block_impl_->h3 ();
  }

  void Block_pskel::
  h4 ()
  {
    if (this->Block_impl_)
      this->Block_impl_->h4 ();
  }

  void Block_pskel::
  h5 ()
  {
    if (this->Block_impl_)
      this->Block_impl_->h5 ();
  }

  void Block_pskel::
  h6 ()
  {
    if (this->Block_impl_)
      this->Block_impl_->h6 ();
  }

  void Block_pskel::
  div ()
  {
    if (this->Block_impl_)
      this->Block_impl_->div ();
  }

  void Block_pskel::
  choice3_arm (choice3_arm_tag x)
  {
    if (this->Block_impl_)
      this->Block_impl_->choice3_arm (x);
  }

  void Block_pskel::
  ul ()
  {
    if (this->Block_impl_)
      this->Block_impl_->ul ();
  }

  void Block_pskel::
  ol ()
  {
    if (this->Block_impl_)
      this->Block_impl_->ol ();
  }

  void Block_pskel::
  dl ()
  {
    if (this->Block_impl_)
      this->Block_impl_->dl ();
  }

  void Block_pskel::
  choice4_arm (choice4_arm_tag x)
  {
    if (this->Block_impl_)
      this->Block_impl_->choice4_arm (x);
  }

  void Block_pskel::
  pre ()
  {
    if (this->Block_impl_)
      this->Block_impl_->pre ();
  }

  void Block_pskel::
  hr ()
  {
    if (this->Block_impl_)
      this->Block_impl_->hr ();
  }

  void Block_pskel::
  blockquote ()
  {
    if (this->Block_impl_)
      this->Block_impl_->blockquote ();
  }

  void Block_pskel::
  address ()
  {
    if (this->Block_impl_)
      this->Block_impl_->address ();
  }

  void Block_pskel::
  table ()
  {
    if (this->Block_impl_)
      this->Block_impl_->table ();
  }

  void Block_pskel::
  post_Block ()
  {
    if (this->Block_impl_)
      this->Block_impl_->post_Block ();
  }

  void Block_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->p_parser_)
      this->p_parser_->_reset ();

    if (this->h1_parser_)
      this->h1_parser_->_reset ();

    if (this->h2_parser_)
      this->h2_parser_->_reset ();

    if (this->h3_parser_)
      this->h3_parser_->_reset ();

    if (this->h4_parser_)
      this->h4_parser_->_reset ();

    if (this->h5_parser_)
      this->h5_parser_->_reset ();

    if (this->h6_parser_)
      this->h6_parser_->_reset ();

    if (this->div_parser_)
      this->div_parser_->_reset ();

    if (this->ul_parser_)
      this->ul_parser_->_reset ();

    if (this->ol_parser_)
      this->ol_parser_->_reset ();

    if (this->dl_parser_)
      this->dl_parser_->_reset ();

    if (this->pre_parser_)
      this->pre_parser_->_reset ();

    if (this->hr_parser_)
      this->hr_parser_->_reset ();

    if (this->blockquote_parser_)
      this->blockquote_parser_->_reset ();

    if (this->address_parser_)
      this->address_parser_->_reset ();

    if (this->table_parser_)
      this->table_parser_->_reset ();

    this->resetting_ = false;
  }

  // Flow_pskel
  //

  void Flow_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice_arm (x);
  }

  void Flow_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice1_arm (x);
  }

  void Flow_pskel::
  p ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->p ();
  }

  void Flow_pskel::
  choice2_arm (choice2_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice2_arm (x);
  }

  void Flow_pskel::
  h1 ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->h1 ();
  }

  void Flow_pskel::
  h2 ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->h2 ();
  }

  void Flow_pskel::
  h3 ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->h3 ();
  }

  void Flow_pskel::
  h4 ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->h4 ();
  }

  void Flow_pskel::
  h5 ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->h5 ();
  }

  void Flow_pskel::
  h6 ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->h6 ();
  }

  void Flow_pskel::
  div ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->div ();
  }

  void Flow_pskel::
  choice3_arm (choice3_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice3_arm (x);
  }

  void Flow_pskel::
  ul ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->ul ();
  }

  void Flow_pskel::
  ol ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->ol ();
  }

  void Flow_pskel::
  dl ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->dl ();
  }

  void Flow_pskel::
  choice4_arm (choice4_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice4_arm (x);
  }

  void Flow_pskel::
  pre ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->pre ();
  }

  void Flow_pskel::
  hr ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->hr ();
  }

  void Flow_pskel::
  blockquote ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->blockquote ();
  }

  void Flow_pskel::
  address ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->address ();
  }

  void Flow_pskel::
  table ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->table ();
  }

  void Flow_pskel::
  choice5_arm (choice5_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice5_arm (x);
  }

  void Flow_pskel::
  a ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->a ();
  }

  void Flow_pskel::
  choice6_arm (choice6_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice6_arm (x);
  }

  void Flow_pskel::
  choice7_arm (choice7_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice7_arm (x);
  }

  void Flow_pskel::
  br ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->br ();
  }

  void Flow_pskel::
  span ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->span ();
  }

  void Flow_pskel::
  bdo ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->bdo ();
  }

  void Flow_pskel::
  map ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->map ();
  }

  void Flow_pskel::
  img ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->img ();
  }

  void Flow_pskel::
  choice8_arm (choice8_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice8_arm (x);
  }

  void Flow_pskel::
  tt ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->tt ();
  }

  void Flow_pskel::
  i ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->i ();
  }

  void Flow_pskel::
  b ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->b ();
  }

  void Flow_pskel::
  big ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->big ();
  }

  void Flow_pskel::
  small ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->small ();
  }

  void Flow_pskel::
  choice9_arm (choice9_arm_tag x)
  {
    if (this->Flow_impl_)
      this->Flow_impl_->choice9_arm (x);
  }

  void Flow_pskel::
  em ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->em ();
  }

  void Flow_pskel::
  strong ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->strong ();
  }

  void Flow_pskel::
  dfn ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->dfn ();
  }

  void Flow_pskel::
  code ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->code ();
  }

  void Flow_pskel::
  q ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->q ();
  }

  void Flow_pskel::
  samp ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->samp ();
  }

  void Flow_pskel::
  kbd ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->kbd ();
  }

  void Flow_pskel::
  var ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->var ();
  }

  void Flow_pskel::
  cite ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->cite ();
  }

  void Flow_pskel::
  abbr ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->abbr ();
  }

  void Flow_pskel::
  acronym ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->acronym ();
  }

  void Flow_pskel::
  sub ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->sub ();
  }

  void Flow_pskel::
  sup ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->sup ();
  }

  void Flow_pskel::
  post_Flow ()
  {
    if (this->Flow_impl_)
      this->Flow_impl_->post_Flow ();
  }

  void Flow_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->p_parser_)
      this->p_parser_->_reset ();

    if (this->h1_parser_)
      this->h1_parser_->_reset ();

    if (this->h2_parser_)
      this->h2_parser_->_reset ();

    if (this->h3_parser_)
      this->h3_parser_->_reset ();

    if (this->h4_parser_)
      this->h4_parser_->_reset ();

    if (this->h5_parser_)
      this->h5_parser_->_reset ();

    if (this->h6_parser_)
      this->h6_parser_->_reset ();

    if (this->div_parser_)
      this->div_parser_->_reset ();

    if (this->ul_parser_)
      this->ul_parser_->_reset ();

    if (this->ol_parser_)
      this->ol_parser_->_reset ();

    if (this->dl_parser_)
      this->dl_parser_->_reset ();

    if (this->pre_parser_)
      this->pre_parser_->_reset ();

    if (this->hr_parser_)
      this->hr_parser_->_reset ();

    if (this->blockquote_parser_)
      this->blockquote_parser_->_reset ();

    if (this->address_parser_)
      this->address_parser_->_reset ();

    if (this->table_parser_)
      this->table_parser_->_reset ();

    if (this->a_parser_)
      this->a_parser_->_reset ();

    if (this->br_parser_)
      this->br_parser_->_reset ();

    if (this->span_parser_)
      this->span_parser_->_reset ();

    if (this->bdo_parser_)
      this->bdo_parser_->_reset ();

    if (this->map_parser_)
      this->map_parser_->_reset ();

    if (this->img_parser_)
      this->img_parser_->_reset ();

    if (this->tt_parser_)
      this->tt_parser_->_reset ();

    if (this->i_parser_)
      this->i_parser_->_reset ();

    if (this->b_parser_)
      this->b_parser_->_reset ();

    if (this->big_parser_)
      this->big_parser_->_reset ();

    if (this->small_parser_)
      this->small_parser_->_reset ();

    if (this->em_parser_)
      this->em_parser_->_reset ();

    if (this->strong_parser_)
      this->strong_parser_->_reset ();

    if (this->dfn_parser_)
      this->dfn_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->q_parser_)
      this->q_parser_->_reset ();

    if (this->samp_parser_)
      this->samp_parser_->_reset ();

    if (this->kbd_parser_)
      this->kbd_parser_->_reset ();

    if (this->var_parser_)
      this->var_parser_->_reset ();

    if (this->cite_parser_)
      this->cite_parser_->_reset ();

    if (this->abbr_parser_)
      this->abbr_parser_->_reset ();

    if (this->acronym_parser_)
      this->acronym_parser_->_reset ();

    if (this->sub_parser_)
      this->sub_parser_->_reset ();

    if (this->sup_parser_)
      this->sup_parser_->_reset ();

    this->resetting_ = false;
  }

  // a_content_pskel
  //

  void a_content_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->a_content_impl_)
      this->a_content_impl_->choice_arm (x);
  }

  void a_content_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->a_content_impl_)
      this->a_content_impl_->choice1_arm (x);
  }

  void a_content_pskel::
  choice2_arm (choice2_arm_tag x)
  {
    if (this->a_content_impl_)
      this->a_content_impl_->choice2_arm (x);
  }

  void a_content_pskel::
  br ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->br ();
  }

  void a_content_pskel::
  span ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->span ();
  }

  void a_content_pskel::
  bdo ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->bdo ();
  }

  void a_content_pskel::
  map ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->map ();
  }

  void a_content_pskel::
  img ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->img ();
  }

  void a_content_pskel::
  choice3_arm (choice3_arm_tag x)
  {
    if (this->a_content_impl_)
      this->a_content_impl_->choice3_arm (x);
  }

  void a_content_pskel::
  tt ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->tt ();
  }

  void a_content_pskel::
  i ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->i ();
  }

  void a_content_pskel::
  b ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->b ();
  }

  void a_content_pskel::
  big ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->big ();
  }

  void a_content_pskel::
  small ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->small ();
  }

  void a_content_pskel::
  choice4_arm (choice4_arm_tag x)
  {
    if (this->a_content_impl_)
      this->a_content_impl_->choice4_arm (x);
  }

  void a_content_pskel::
  em ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->em ();
  }

  void a_content_pskel::
  strong ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->strong ();
  }

  void a_content_pskel::
  dfn ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->dfn ();
  }

  void a_content_pskel::
  code ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->code ();
  }

  void a_content_pskel::
  q ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->q ();
  }

  void a_content_pskel::
  samp ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->samp ();
  }

  void a_content_pskel::
  kbd ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->kbd ();
  }

  void a_content_pskel::
  var ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->var ();
  }

  void a_content_pskel::
  cite ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->cite ();
  }

  void a_content_pskel::
  abbr ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->abbr ();
  }

  void a_content_pskel::
  acronym ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->acronym ();
  }

  void a_content_pskel::
  sub ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->sub ();
  }

  void a_content_pskel::
  sup ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->sup ();
  }

  void a_content_pskel::
  post_a_content ()
  {
    if (this->a_content_impl_)
      this->a_content_impl_->post_a_content ();
  }

  void a_content_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->br_parser_)
      this->br_parser_->_reset ();

    if (this->span_parser_)
      this->span_parser_->_reset ();

    if (this->bdo_parser_)
      this->bdo_parser_->_reset ();

    if (this->map_parser_)
      this->map_parser_->_reset ();

    if (this->img_parser_)
      this->img_parser_->_reset ();

    if (this->tt_parser_)
      this->tt_parser_->_reset ();

    if (this->i_parser_)
      this->i_parser_->_reset ();

    if (this->b_parser_)
      this->b_parser_->_reset ();

    if (this->big_parser_)
      this->big_parser_->_reset ();

    if (this->small_parser_)
      this->small_parser_->_reset ();

    if (this->em_parser_)
      this->em_parser_->_reset ();

    if (this->strong_parser_)
      this->strong_parser_->_reset ();

    if (this->dfn_parser_)
      this->dfn_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->q_parser_)
      this->q_parser_->_reset ();

    if (this->samp_parser_)
      this->samp_parser_->_reset ();

    if (this->kbd_parser_)
      this->kbd_parser_->_reset ();

    if (this->var_parser_)
      this->var_parser_->_reset ();

    if (this->cite_parser_)
      this->cite_parser_->_reset ();

    if (this->abbr_parser_)
      this->abbr_parser_->_reset ();

    if (this->acronym_parser_)
      this->acronym_parser_->_reset ();

    if (this->sub_parser_)
      this->sub_parser_->_reset ();

    if (this->sup_parser_)
      this->sup_parser_->_reset ();

    this->resetting_ = false;
  }

  // pre_content_pskel
  //

  void pre_content_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->choice_arm (x);
  }

  void pre_content_pskel::
  a ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->a ();
  }

  void pre_content_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->choice1_arm (x);
  }

  void pre_content_pskel::
  tt ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->tt ();
  }

  void pre_content_pskel::
  i ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->i ();
  }

  void pre_content_pskel::
  b ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->b ();
  }

  void pre_content_pskel::
  big ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->big ();
  }

  void pre_content_pskel::
  small ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->small ();
  }

  void pre_content_pskel::
  choice2_arm (choice2_arm_tag x)
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->choice2_arm (x);
  }

  void pre_content_pskel::
  em ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->em ();
  }

  void pre_content_pskel::
  strong ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->strong ();
  }

  void pre_content_pskel::
  dfn ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->dfn ();
  }

  void pre_content_pskel::
  code ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->code ();
  }

  void pre_content_pskel::
  q ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->q ();
  }

  void pre_content_pskel::
  samp ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->samp ();
  }

  void pre_content_pskel::
  kbd ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->kbd ();
  }

  void pre_content_pskel::
  var ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->var ();
  }

  void pre_content_pskel::
  cite ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->cite ();
  }

  void pre_content_pskel::
  abbr ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->abbr ();
  }

  void pre_content_pskel::
  acronym ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->acronym ();
  }

  void pre_content_pskel::
  sub ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->sub ();
  }

  void pre_content_pskel::
  sup ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->sup ();
  }

  void pre_content_pskel::
  choice3_arm (choice3_arm_tag x)
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->choice3_arm (x);
  }

  void pre_content_pskel::
  br ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->br ();
  }

  void pre_content_pskel::
  span ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->span ();
  }

  void pre_content_pskel::
  bdo ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->bdo ();
  }

  void pre_content_pskel::
  map ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->map ();
  }

  void pre_content_pskel::
  post_pre_content ()
  {
    if (this->pre_content_impl_)
      this->pre_content_impl_->post_pre_content ();
  }

  void pre_content_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->a_parser_)
      this->a_parser_->_reset ();

    if (this->tt_parser_)
      this->tt_parser_->_reset ();

    if (this->i_parser_)
      this->i_parser_->_reset ();

    if (this->b_parser_)
      this->b_parser_->_reset ();

    if (this->big_parser_)
      this->big_parser_->_reset ();

    if (this->small_parser_)
      this->small_parser_->_reset ();

    if (this->em_parser_)
      this->em_parser_->_reset ();

    if (this->strong_parser_)
      this->strong_parser_->_reset ();

    if (this->dfn_parser_)
      this->dfn_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->q_parser_)
      this->q_parser_->_reset ();

    if (this->samp_parser_)
      this->samp_parser_->_reset ();

    if (this->kbd_parser_)
      this->kbd_parser_->_reset ();

    if (this->var_parser_)
      this->var_parser_->_reset ();

    if (this->cite_parser_)
      this->cite_parser_->_reset ();

    if (this->abbr_parser_)
      this->abbr_parser_->_reset ();

    if (this->acronym_parser_)
      this->acronym_parser_->_reset ();

    if (this->sub_parser_)
      this->sub_parser_->_reset ();

    if (this->sup_parser_)
      this->sup_parser_->_reset ();

    if (this->br_parser_)
      this->br_parser_->_reset ();

    if (this->span_parser_)
      this->span_parser_->_reset ();

    if (this->bdo_parser_)
      this->bdo_parser_->_reset ();

    if (this->map_parser_)
      this->map_parser_->_reset ();

    this->resetting_ = false;
  }

  // TFrame_pskel
  //

  void TFrame_pskel::
  post_TFrame ()
  {
    if (this->TFrame_impl_)
      this->TFrame_impl_->post_TFrame ();
  }

  ::std::string TFrame_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const TFrame_pskel::_xsde_TFrame_pskel_enums_[9UL] = 
  {
    "above",
    "below",
    "border",
    "box",
    "hsides",
    "lhs",
    "rhs",
    "void",
    "vsides"
  };

  // TRules_pskel
  //

  void TRules_pskel::
  post_TRules ()
  {
    if (this->TRules_impl_)
      this->TRules_impl_->post_TRules ();
  }

  ::std::string TRules_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const TRules_pskel::_xsde_TRules_pskel_enums_[5UL] = 
  {
    "all",
    "cols",
    "groups",
    "none",
    "rows"
  };

  // Scope_pskel
  //

  void Scope_pskel::
  post_Scope ()
  {
    if (this->Scope_impl_)
      this->Scope_impl_->post_Scope ();
  }

  ::std::string Scope_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const Scope_pskel::_xsde_Scope_pskel_enums_[4UL] = 
  {
    "col",
    "colgroup",
    "row",
    "rowgroup"
  };

  // dir_pskel
  //

  void dir_pskel::
  post_dir ()
  {
    if (this->dir_impl_)
      this->dir_impl_->post_dir ();
  }

  ::std::string dir_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const dir_pskel::_xsde_dir_pskel_enums_[2UL] = 
  {
    "ltr",
    "rtl"
  };

  // div_pskel
  //

  void div_pskel::
  id (const ::std::string& x)
  {
    if (this->div_impl_)
      this->div_impl_->id (x);
  }

  void div_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->div_impl_)
      this->div_impl_->class_ (x);
  }

  void div_pskel::
  style ()
  {
    if (this->div_impl_)
      this->div_impl_->style ();
  }

  void div_pskel::
  title ()
  {
    if (this->div_impl_)
      this->div_impl_->title ();
  }

  void div_pskel::
  lang ()
  {
    if (this->div_impl_)
      this->div_impl_->lang ();
  }

  void div_pskel::
  lang1 ()
  {
    if (this->div_impl_)
      this->div_impl_->lang1 ();
  }

  void div_pskel::
  dir ()
  {
    if (this->div_impl_)
      this->div_impl_->dir ();
  }

  void div_pskel::
  post_div ()
  {
    if (this->div_impl_)
      this->div_impl_->post_div ();
    else
      post_Flow ();
  }

  void div_pskel::
  _reset ()
  {
    typedef ::xhtml::Flow_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // p_pskel
  //

  void p_pskel::
  id (const ::std::string& x)
  {
    if (this->p_impl_)
      this->p_impl_->id (x);
  }

  void p_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->p_impl_)
      this->p_impl_->class_ (x);
  }

  void p_pskel::
  style ()
  {
    if (this->p_impl_)
      this->p_impl_->style ();
  }

  void p_pskel::
  title ()
  {
    if (this->p_impl_)
      this->p_impl_->title ();
  }

  void p_pskel::
  lang ()
  {
    if (this->p_impl_)
      this->p_impl_->lang ();
  }

  void p_pskel::
  lang1 ()
  {
    if (this->p_impl_)
      this->p_impl_->lang1 ();
  }

  void p_pskel::
  dir ()
  {
    if (this->p_impl_)
      this->p_impl_->dir ();
  }

  void p_pskel::
  post_p ()
  {
    if (this->p_impl_)
      this->p_impl_->post_p ();
    else
      post_Inline ();
  }

  void p_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // h1_pskel
  //

  void h1_pskel::
  id (const ::std::string& x)
  {
    if (this->h1_impl_)
      this->h1_impl_->id (x);
  }

  void h1_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->h1_impl_)
      this->h1_impl_->class_ (x);
  }

  void h1_pskel::
  style ()
  {
    if (this->h1_impl_)
      this->h1_impl_->style ();
  }

  void h1_pskel::
  title ()
  {
    if (this->h1_impl_)
      this->h1_impl_->title ();
  }

  void h1_pskel::
  lang ()
  {
    if (this->h1_impl_)
      this->h1_impl_->lang ();
  }

  void h1_pskel::
  lang1 ()
  {
    if (this->h1_impl_)
      this->h1_impl_->lang1 ();
  }

  void h1_pskel::
  dir ()
  {
    if (this->h1_impl_)
      this->h1_impl_->dir ();
  }

  void h1_pskel::
  post_h1 ()
  {
    if (this->h1_impl_)
      this->h1_impl_->post_h1 ();
    else
      post_Inline ();
  }

  void h1_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // h2_pskel
  //

  void h2_pskel::
  id (const ::std::string& x)
  {
    if (this->h2_impl_)
      this->h2_impl_->id (x);
  }

  void h2_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->h2_impl_)
      this->h2_impl_->class_ (x);
  }

  void h2_pskel::
  style ()
  {
    if (this->h2_impl_)
      this->h2_impl_->style ();
  }

  void h2_pskel::
  title ()
  {
    if (this->h2_impl_)
      this->h2_impl_->title ();
  }

  void h2_pskel::
  lang ()
  {
    if (this->h2_impl_)
      this->h2_impl_->lang ();
  }

  void h2_pskel::
  lang1 ()
  {
    if (this->h2_impl_)
      this->h2_impl_->lang1 ();
  }

  void h2_pskel::
  dir ()
  {
    if (this->h2_impl_)
      this->h2_impl_->dir ();
  }

  void h2_pskel::
  post_h2 ()
  {
    if (this->h2_impl_)
      this->h2_impl_->post_h2 ();
    else
      post_Inline ();
  }

  void h2_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // h3_pskel
  //

  void h3_pskel::
  id (const ::std::string& x)
  {
    if (this->h3_impl_)
      this->h3_impl_->id (x);
  }

  void h3_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->h3_impl_)
      this->h3_impl_->class_ (x);
  }

  void h3_pskel::
  style ()
  {
    if (this->h3_impl_)
      this->h3_impl_->style ();
  }

  void h3_pskel::
  title ()
  {
    if (this->h3_impl_)
      this->h3_impl_->title ();
  }

  void h3_pskel::
  lang ()
  {
    if (this->h3_impl_)
      this->h3_impl_->lang ();
  }

  void h3_pskel::
  lang1 ()
  {
    if (this->h3_impl_)
      this->h3_impl_->lang1 ();
  }

  void h3_pskel::
  dir ()
  {
    if (this->h3_impl_)
      this->h3_impl_->dir ();
  }

  void h3_pskel::
  post_h3 ()
  {
    if (this->h3_impl_)
      this->h3_impl_->post_h3 ();
    else
      post_Inline ();
  }

  void h3_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // h4_pskel
  //

  void h4_pskel::
  id (const ::std::string& x)
  {
    if (this->h4_impl_)
      this->h4_impl_->id (x);
  }

  void h4_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->h4_impl_)
      this->h4_impl_->class_ (x);
  }

  void h4_pskel::
  style ()
  {
    if (this->h4_impl_)
      this->h4_impl_->style ();
  }

  void h4_pskel::
  title ()
  {
    if (this->h4_impl_)
      this->h4_impl_->title ();
  }

  void h4_pskel::
  lang ()
  {
    if (this->h4_impl_)
      this->h4_impl_->lang ();
  }

  void h4_pskel::
  lang1 ()
  {
    if (this->h4_impl_)
      this->h4_impl_->lang1 ();
  }

  void h4_pskel::
  dir ()
  {
    if (this->h4_impl_)
      this->h4_impl_->dir ();
  }

  void h4_pskel::
  post_h4 ()
  {
    if (this->h4_impl_)
      this->h4_impl_->post_h4 ();
    else
      post_Inline ();
  }

  void h4_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // h5_pskel
  //

  void h5_pskel::
  id (const ::std::string& x)
  {
    if (this->h5_impl_)
      this->h5_impl_->id (x);
  }

  void h5_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->h5_impl_)
      this->h5_impl_->class_ (x);
  }

  void h5_pskel::
  style ()
  {
    if (this->h5_impl_)
      this->h5_impl_->style ();
  }

  void h5_pskel::
  title ()
  {
    if (this->h5_impl_)
      this->h5_impl_->title ();
  }

  void h5_pskel::
  lang ()
  {
    if (this->h5_impl_)
      this->h5_impl_->lang ();
  }

  void h5_pskel::
  lang1 ()
  {
    if (this->h5_impl_)
      this->h5_impl_->lang1 ();
  }

  void h5_pskel::
  dir ()
  {
    if (this->h5_impl_)
      this->h5_impl_->dir ();
  }

  void h5_pskel::
  post_h5 ()
  {
    if (this->h5_impl_)
      this->h5_impl_->post_h5 ();
    else
      post_Inline ();
  }

  void h5_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // h6_pskel
  //

  void h6_pskel::
  id (const ::std::string& x)
  {
    if (this->h6_impl_)
      this->h6_impl_->id (x);
  }

  void h6_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->h6_impl_)
      this->h6_impl_->class_ (x);
  }

  void h6_pskel::
  style ()
  {
    if (this->h6_impl_)
      this->h6_impl_->style ();
  }

  void h6_pskel::
  title ()
  {
    if (this->h6_impl_)
      this->h6_impl_->title ();
  }

  void h6_pskel::
  lang ()
  {
    if (this->h6_impl_)
      this->h6_impl_->lang ();
  }

  void h6_pskel::
  lang1 ()
  {
    if (this->h6_impl_)
      this->h6_impl_->lang1 ();
  }

  void h6_pskel::
  dir ()
  {
    if (this->h6_impl_)
      this->h6_impl_->dir ();
  }

  void h6_pskel::
  post_h6 ()
  {
    if (this->h6_impl_)
      this->h6_impl_->post_h6 ();
    else
      post_Inline ();
  }

  void h6_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // ul_pskel
  //

  void ul_pskel::
  id (const ::std::string& x)
  {
    if (this->ul_impl_)
      this->ul_impl_->id (x);
  }

  void ul_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->ul_impl_)
      this->ul_impl_->class_ (x);
  }

  void ul_pskel::
  style ()
  {
    if (this->ul_impl_)
      this->ul_impl_->style ();
  }

  void ul_pskel::
  title ()
  {
    if (this->ul_impl_)
      this->ul_impl_->title ();
  }

  void ul_pskel::
  lang ()
  {
    if (this->ul_impl_)
      this->ul_impl_->lang ();
  }

  void ul_pskel::
  lang1 ()
  {
    if (this->ul_impl_)
      this->ul_impl_->lang1 ();
  }

  void ul_pskel::
  dir ()
  {
    if (this->ul_impl_)
      this->ul_impl_->dir ();
  }

  void ul_pskel::
  li ()
  {
    if (this->ul_impl_)
      this->ul_impl_->li ();
  }

  void ul_pskel::
  post_ul ()
  {
    if (this->ul_impl_)
      this->ul_impl_->post_ul ();
  }

  void ul_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    this->resetting_ = true;

    if (this->li_parser_)
      this->li_parser_->_reset ();

    this->resetting_ = false;
  }

  // ol_pskel
  //

  void ol_pskel::
  id (const ::std::string& x)
  {
    if (this->ol_impl_)
      this->ol_impl_->id (x);
  }

  void ol_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->ol_impl_)
      this->ol_impl_->class_ (x);
  }

  void ol_pskel::
  style ()
  {
    if (this->ol_impl_)
      this->ol_impl_->style ();
  }

  void ol_pskel::
  title ()
  {
    if (this->ol_impl_)
      this->ol_impl_->title ();
  }

  void ol_pskel::
  lang ()
  {
    if (this->ol_impl_)
      this->ol_impl_->lang ();
  }

  void ol_pskel::
  lang1 ()
  {
    if (this->ol_impl_)
      this->ol_impl_->lang1 ();
  }

  void ol_pskel::
  dir ()
  {
    if (this->ol_impl_)
      this->ol_impl_->dir ();
  }

  void ol_pskel::
  li ()
  {
    if (this->ol_impl_)
      this->ol_impl_->li ();
  }

  void ol_pskel::
  post_ol ()
  {
    if (this->ol_impl_)
      this->ol_impl_->post_ol ();
  }

  void ol_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    this->resetting_ = true;

    if (this->li_parser_)
      this->li_parser_->_reset ();

    this->resetting_ = false;
  }

  // li_pskel
  //

  void li_pskel::
  id (const ::std::string& x)
  {
    if (this->li_impl_)
      this->li_impl_->id (x);
  }

  void li_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->li_impl_)
      this->li_impl_->class_ (x);
  }

  void li_pskel::
  style ()
  {
    if (this->li_impl_)
      this->li_impl_->style ();
  }

  void li_pskel::
  title ()
  {
    if (this->li_impl_)
      this->li_impl_->title ();
  }

  void li_pskel::
  lang ()
  {
    if (this->li_impl_)
      this->li_impl_->lang ();
  }

  void li_pskel::
  lang1 ()
  {
    if (this->li_impl_)
      this->li_impl_->lang1 ();
  }

  void li_pskel::
  dir ()
  {
    if (this->li_impl_)
      this->li_impl_->dir ();
  }

  void li_pskel::
  post_li ()
  {
    if (this->li_impl_)
      this->li_impl_->post_li ();
    else
      post_Flow ();
  }

  void li_pskel::
  _reset ()
  {
    typedef ::xhtml::Flow_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // dl_pskel
  //

  void dl_pskel::
  id (const ::std::string& x)
  {
    if (this->dl_impl_)
      this->dl_impl_->id (x);
  }

  void dl_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->dl_impl_)
      this->dl_impl_->class_ (x);
  }

  void dl_pskel::
  style ()
  {
    if (this->dl_impl_)
      this->dl_impl_->style ();
  }

  void dl_pskel::
  title ()
  {
    if (this->dl_impl_)
      this->dl_impl_->title ();
  }

  void dl_pskel::
  lang ()
  {
    if (this->dl_impl_)
      this->dl_impl_->lang ();
  }

  void dl_pskel::
  lang1 ()
  {
    if (this->dl_impl_)
      this->dl_impl_->lang1 ();
  }

  void dl_pskel::
  dir ()
  {
    if (this->dl_impl_)
      this->dl_impl_->dir ();
  }

  void dl_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->dl_impl_)
      this->dl_impl_->choice_arm (x);
  }

  void dl_pskel::
  dt ()
  {
    if (this->dl_impl_)
      this->dl_impl_->dt ();
  }

  void dl_pskel::
  dd ()
  {
    if (this->dl_impl_)
      this->dl_impl_->dd ();
  }

  void dl_pskel::
  post_dl ()
  {
    if (this->dl_impl_)
      this->dl_impl_->post_dl ();
  }

  void dl_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    this->resetting_ = true;

    if (this->dt_parser_)
      this->dt_parser_->_reset ();

    if (this->dd_parser_)
      this->dd_parser_->_reset ();

    this->resetting_ = false;
  }

  // dt_pskel
  //

  void dt_pskel::
  id (const ::std::string& x)
  {
    if (this->dt_impl_)
      this->dt_impl_->id (x);
  }

  void dt_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->dt_impl_)
      this->dt_impl_->class_ (x);
  }

  void dt_pskel::
  style ()
  {
    if (this->dt_impl_)
      this->dt_impl_->style ();
  }

  void dt_pskel::
  title ()
  {
    if (this->dt_impl_)
      this->dt_impl_->title ();
  }

  void dt_pskel::
  lang ()
  {
    if (this->dt_impl_)
      this->dt_impl_->lang ();
  }

  void dt_pskel::
  lang1 ()
  {
    if (this->dt_impl_)
      this->dt_impl_->lang1 ();
  }

  void dt_pskel::
  dir ()
  {
    if (this->dt_impl_)
      this->dt_impl_->dir ();
  }

  void dt_pskel::
  post_dt ()
  {
    if (this->dt_impl_)
      this->dt_impl_->post_dt ();
    else
      post_Inline ();
  }

  void dt_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // dd_pskel
  //

  void dd_pskel::
  id (const ::std::string& x)
  {
    if (this->dd_impl_)
      this->dd_impl_->id (x);
  }

  void dd_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->dd_impl_)
      this->dd_impl_->class_ (x);
  }

  void dd_pskel::
  style ()
  {
    if (this->dd_impl_)
      this->dd_impl_->style ();
  }

  void dd_pskel::
  title ()
  {
    if (this->dd_impl_)
      this->dd_impl_->title ();
  }

  void dd_pskel::
  lang ()
  {
    if (this->dd_impl_)
      this->dd_impl_->lang ();
  }

  void dd_pskel::
  lang1 ()
  {
    if (this->dd_impl_)
      this->dd_impl_->lang1 ();
  }

  void dd_pskel::
  dir ()
  {
    if (this->dd_impl_)
      this->dd_impl_->dir ();
  }

  void dd_pskel::
  post_dd ()
  {
    if (this->dd_impl_)
      this->dd_impl_->post_dd ();
    else
      post_Flow ();
  }

  void dd_pskel::
  _reset ()
  {
    typedef ::xhtml::Flow_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // address_pskel
  //

  void address_pskel::
  id (const ::std::string& x)
  {
    if (this->address_impl_)
      this->address_impl_->id (x);
  }

  void address_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->address_impl_)
      this->address_impl_->class_ (x);
  }

  void address_pskel::
  style ()
  {
    if (this->address_impl_)
      this->address_impl_->style ();
  }

  void address_pskel::
  title ()
  {
    if (this->address_impl_)
      this->address_impl_->title ();
  }

  void address_pskel::
  lang ()
  {
    if (this->address_impl_)
      this->address_impl_->lang ();
  }

  void address_pskel::
  lang1 ()
  {
    if (this->address_impl_)
      this->address_impl_->lang1 ();
  }

  void address_pskel::
  dir ()
  {
    if (this->address_impl_)
      this->address_impl_->dir ();
  }

  void address_pskel::
  post_address ()
  {
    if (this->address_impl_)
      this->address_impl_->post_address ();
    else
      post_Inline ();
  }

  void address_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // hr_pskel
  //

  void hr_pskel::
  id (const ::std::string& x)
  {
    if (this->hr_impl_)
      this->hr_impl_->id (x);
  }

  void hr_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->hr_impl_)
      this->hr_impl_->class_ (x);
  }

  void hr_pskel::
  style ()
  {
    if (this->hr_impl_)
      this->hr_impl_->style ();
  }

  void hr_pskel::
  title ()
  {
    if (this->hr_impl_)
      this->hr_impl_->title ();
  }

  void hr_pskel::
  lang ()
  {
    if (this->hr_impl_)
      this->hr_impl_->lang ();
  }

  void hr_pskel::
  lang1 ()
  {
    if (this->hr_impl_)
      this->hr_impl_->lang1 ();
  }

  void hr_pskel::
  dir ()
  {
    if (this->hr_impl_)
      this->hr_impl_->dir ();
  }

  void hr_pskel::
  post_hr ()
  {
    if (this->hr_impl_)
      this->hr_impl_->post_hr ();
  }

  void hr_pskel::
  _reset ()
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // pre_pskel
  //

  void pre_pskel::
  id (const ::std::string& x)
  {
    if (this->pre_impl_)
      this->pre_impl_->id (x);
  }

  void pre_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->pre_impl_)
      this->pre_impl_->class_ (x);
  }

  void pre_pskel::
  style ()
  {
    if (this->pre_impl_)
      this->pre_impl_->style ();
  }

  void pre_pskel::
  title ()
  {
    if (this->pre_impl_)
      this->pre_impl_->title ();
  }

  void pre_pskel::
  lang ()
  {
    if (this->pre_impl_)
      this->pre_impl_->lang ();
  }

  void pre_pskel::
  lang1 ()
  {
    if (this->pre_impl_)
      this->pre_impl_->lang1 ();
  }

  void pre_pskel::
  dir ()
  {
    if (this->pre_impl_)
      this->pre_impl_->dir ();
  }

  void pre_pskel::
  space ()
  {
    if (this->pre_impl_)
      this->pre_impl_->space ();
  }

  void pre_pskel::
  post_pre ()
  {
    if (this->pre_impl_)
      this->pre_impl_->post_pre ();
    else
      post_pre_content ();
  }

  void pre_pskel::
  _reset ()
  {
    typedef ::xhtml::pre_content_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->space_parser_)
      this->space_parser_->_reset ();
  }

  // blockquote_pskel
  //

  void blockquote_pskel::
  id (const ::std::string& x)
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->id (x);
  }

  void blockquote_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->class_ (x);
  }

  void blockquote_pskel::
  style ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->style ();
  }

  void blockquote_pskel::
  title ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->title ();
  }

  void blockquote_pskel::
  lang ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->lang ();
  }

  void blockquote_pskel::
  lang1 ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->lang1 ();
  }

  void blockquote_pskel::
  dir ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->dir ();
  }

  void blockquote_pskel::
  cite ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->cite ();
  }

  void blockquote_pskel::
  post_blockquote ()
  {
    if (this->blockquote_impl_)
      this->blockquote_impl_->post_blockquote ();
    else
      post_Block ();
  }

  void blockquote_pskel::
  _reset ()
  {
    typedef ::xhtml::Block_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->cite_parser_)
      this->cite_parser_->_reset ();
  }

  // a_pskel
  //

  void a_pskel::
  id (const ::std::string& x)
  {
    if (this->a_impl_)
      this->a_impl_->id (x);
  }

  void a_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->a_impl_)
      this->a_impl_->class_ (x);
  }

  void a_pskel::
  style ()
  {
    if (this->a_impl_)
      this->a_impl_->style ();
  }

  void a_pskel::
  title ()
  {
    if (this->a_impl_)
      this->a_impl_->title ();
  }

  void a_pskel::
  lang ()
  {
    if (this->a_impl_)
      this->a_impl_->lang ();
  }

  void a_pskel::
  lang1 ()
  {
    if (this->a_impl_)
      this->a_impl_->lang1 ();
  }

  void a_pskel::
  dir ()
  {
    if (this->a_impl_)
      this->a_impl_->dir ();
  }

  void a_pskel::
  accesskey ()
  {
    if (this->a_impl_)
      this->a_impl_->accesskey ();
  }

  void a_pskel::
  tabindex ()
  {
    if (this->a_impl_)
      this->a_impl_->tabindex ();
  }

  void a_pskel::
  charset ()
  {
    if (this->a_impl_)
      this->a_impl_->charset ();
  }

  void a_pskel::
  type ()
  {
    if (this->a_impl_)
      this->a_impl_->type ();
  }

  void a_pskel::
  name (const ::std::string& x)
  {
    if (this->a_impl_)
      this->a_impl_->name (x);
  }

  void a_pskel::
  href ()
  {
    if (this->a_impl_)
      this->a_impl_->href ();
  }

  void a_pskel::
  hreflang ()
  {
    if (this->a_impl_)
      this->a_impl_->hreflang ();
  }

  void a_pskel::
  rel ()
  {
    if (this->a_impl_)
      this->a_impl_->rel ();
  }

  void a_pskel::
  rev ()
  {
    if (this->a_impl_)
      this->a_impl_->rev ();
  }

  void a_pskel::
  shape ()
  {
    if (this->a_impl_)
      this->a_impl_->shape ();
  }

  void a_pskel::
  coords ()
  {
    if (this->a_impl_)
      this->a_impl_->coords ();
  }

  void a_pskel::
  post_a ()
  {
    if (this->a_impl_)
      this->a_impl_->post_a ();
    else
      post_a_content ();
  }

  void a_pskel::
  _reset ()
  {
    typedef ::xhtml::a_content_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->accesskey_parser_)
      this->accesskey_parser_->_reset ();

    if (this->tabindex_parser_)
      this->tabindex_parser_->_reset ();

    if (this->charset_parser_)
      this->charset_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->href_parser_)
      this->href_parser_->_reset ();

    if (this->hreflang_parser_)
      this->hreflang_parser_->_reset ();

    if (this->rel_parser_)
      this->rel_parser_->_reset ();

    if (this->rev_parser_)
      this->rev_parser_->_reset ();

    if (this->shape_parser_)
      this->shape_parser_->_reset ();

    if (this->coords_parser_)
      this->coords_parser_->_reset ();
  }

  // span_pskel
  //

  void span_pskel::
  id (const ::std::string& x)
  {
    if (this->span_impl_)
      this->span_impl_->id (x);
  }

  void span_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->span_impl_)
      this->span_impl_->class_ (x);
  }

  void span_pskel::
  style ()
  {
    if (this->span_impl_)
      this->span_impl_->style ();
  }

  void span_pskel::
  title ()
  {
    if (this->span_impl_)
      this->span_impl_->title ();
  }

  void span_pskel::
  lang ()
  {
    if (this->span_impl_)
      this->span_impl_->lang ();
  }

  void span_pskel::
  lang1 ()
  {
    if (this->span_impl_)
      this->span_impl_->lang1 ();
  }

  void span_pskel::
  dir ()
  {
    if (this->span_impl_)
      this->span_impl_->dir ();
  }

  void span_pskel::
  post_span ()
  {
    if (this->span_impl_)
      this->span_impl_->post_span ();
    else
      post_Inline ();
  }

  void span_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // bdo_pskel
  //

  void bdo_pskel::
  id (const ::std::string& x)
  {
    if (this->bdo_impl_)
      this->bdo_impl_->id (x);
  }

  void bdo_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->bdo_impl_)
      this->bdo_impl_->class_ (x);
  }

  void bdo_pskel::
  style ()
  {
    if (this->bdo_impl_)
      this->bdo_impl_->style ();
  }

  void bdo_pskel::
  title ()
  {
    if (this->bdo_impl_)
      this->bdo_impl_->title ();
  }

  void bdo_pskel::
  lang ()
  {
    if (this->bdo_impl_)
      this->bdo_impl_->lang ();
  }

  void bdo_pskel::
  lang1 ()
  {
    if (this->bdo_impl_)
      this->bdo_impl_->lang1 ();
  }

  void bdo_pskel::
  dir ()
  {
    if (this->bdo_impl_)
      this->bdo_impl_->dir ();
  }

  void bdo_pskel::
  post_bdo ()
  {
    if (this->bdo_impl_)
      this->bdo_impl_->post_bdo ();
    else
      post_Inline ();
  }

  void bdo_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    this->v_state_attr_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // br_pskel
  //

  void br_pskel::
  id (const ::std::string& x)
  {
    if (this->br_impl_)
      this->br_impl_->id (x);
  }

  void br_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->br_impl_)
      this->br_impl_->class_ (x);
  }

  void br_pskel::
  style ()
  {
    if (this->br_impl_)
      this->br_impl_->style ();
  }

  void br_pskel::
  title ()
  {
    if (this->br_impl_)
      this->br_impl_->title ();
  }

  void br_pskel::
  post_br ()
  {
    if (this->br_impl_)
      this->br_impl_->post_br ();
  }

  void br_pskel::
  _reset ()
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();
  }

  // em_pskel
  //

  void em_pskel::
  id (const ::std::string& x)
  {
    if (this->em_impl_)
      this->em_impl_->id (x);
  }

  void em_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->em_impl_)
      this->em_impl_->class_ (x);
  }

  void em_pskel::
  style ()
  {
    if (this->em_impl_)
      this->em_impl_->style ();
  }

  void em_pskel::
  title ()
  {
    if (this->em_impl_)
      this->em_impl_->title ();
  }

  void em_pskel::
  lang ()
  {
    if (this->em_impl_)
      this->em_impl_->lang ();
  }

  void em_pskel::
  lang1 ()
  {
    if (this->em_impl_)
      this->em_impl_->lang1 ();
  }

  void em_pskel::
  dir ()
  {
    if (this->em_impl_)
      this->em_impl_->dir ();
  }

  void em_pskel::
  post_em ()
  {
    if (this->em_impl_)
      this->em_impl_->post_em ();
    else
      post_Inline ();
  }

  void em_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // strong_pskel
  //

  void strong_pskel::
  id (const ::std::string& x)
  {
    if (this->strong_impl_)
      this->strong_impl_->id (x);
  }

  void strong_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->strong_impl_)
      this->strong_impl_->class_ (x);
  }

  void strong_pskel::
  style ()
  {
    if (this->strong_impl_)
      this->strong_impl_->style ();
  }

  void strong_pskel::
  title ()
  {
    if (this->strong_impl_)
      this->strong_impl_->title ();
  }

  void strong_pskel::
  lang ()
  {
    if (this->strong_impl_)
      this->strong_impl_->lang ();
  }

  void strong_pskel::
  lang1 ()
  {
    if (this->strong_impl_)
      this->strong_impl_->lang1 ();
  }

  void strong_pskel::
  dir ()
  {
    if (this->strong_impl_)
      this->strong_impl_->dir ();
  }

  void strong_pskel::
  post_strong ()
  {
    if (this->strong_impl_)
      this->strong_impl_->post_strong ();
    else
      post_Inline ();
  }

  void strong_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // dfn_pskel
  //

  void dfn_pskel::
  id (const ::std::string& x)
  {
    if (this->dfn_impl_)
      this->dfn_impl_->id (x);
  }

  void dfn_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->dfn_impl_)
      this->dfn_impl_->class_ (x);
  }

  void dfn_pskel::
  style ()
  {
    if (this->dfn_impl_)
      this->dfn_impl_->style ();
  }

  void dfn_pskel::
  title ()
  {
    if (this->dfn_impl_)
      this->dfn_impl_->title ();
  }

  void dfn_pskel::
  lang ()
  {
    if (this->dfn_impl_)
      this->dfn_impl_->lang ();
  }

  void dfn_pskel::
  lang1 ()
  {
    if (this->dfn_impl_)
      this->dfn_impl_->lang1 ();
  }

  void dfn_pskel::
  dir ()
  {
    if (this->dfn_impl_)
      this->dfn_impl_->dir ();
  }

  void dfn_pskel::
  post_dfn ()
  {
    if (this->dfn_impl_)
      this->dfn_impl_->post_dfn ();
    else
      post_Inline ();
  }

  void dfn_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // code_pskel
  //

  void code_pskel::
  id (const ::std::string& x)
  {
    if (this->code_impl_)
      this->code_impl_->id (x);
  }

  void code_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->code_impl_)
      this->code_impl_->class_ (x);
  }

  void code_pskel::
  style ()
  {
    if (this->code_impl_)
      this->code_impl_->style ();
  }

  void code_pskel::
  title ()
  {
    if (this->code_impl_)
      this->code_impl_->title ();
  }

  void code_pskel::
  lang ()
  {
    if (this->code_impl_)
      this->code_impl_->lang ();
  }

  void code_pskel::
  lang1 ()
  {
    if (this->code_impl_)
      this->code_impl_->lang1 ();
  }

  void code_pskel::
  dir ()
  {
    if (this->code_impl_)
      this->code_impl_->dir ();
  }

  void code_pskel::
  post_code ()
  {
    if (this->code_impl_)
      this->code_impl_->post_code ();
    else
      post_Inline ();
  }

  void code_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // samp_pskel
  //

  void samp_pskel::
  id (const ::std::string& x)
  {
    if (this->samp_impl_)
      this->samp_impl_->id (x);
  }

  void samp_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->samp_impl_)
      this->samp_impl_->class_ (x);
  }

  void samp_pskel::
  style ()
  {
    if (this->samp_impl_)
      this->samp_impl_->style ();
  }

  void samp_pskel::
  title ()
  {
    if (this->samp_impl_)
      this->samp_impl_->title ();
  }

  void samp_pskel::
  lang ()
  {
    if (this->samp_impl_)
      this->samp_impl_->lang ();
  }

  void samp_pskel::
  lang1 ()
  {
    if (this->samp_impl_)
      this->samp_impl_->lang1 ();
  }

  void samp_pskel::
  dir ()
  {
    if (this->samp_impl_)
      this->samp_impl_->dir ();
  }

  void samp_pskel::
  post_samp ()
  {
    if (this->samp_impl_)
      this->samp_impl_->post_samp ();
    else
      post_Inline ();
  }

  void samp_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // kbd_pskel
  //

  void kbd_pskel::
  id (const ::std::string& x)
  {
    if (this->kbd_impl_)
      this->kbd_impl_->id (x);
  }

  void kbd_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->kbd_impl_)
      this->kbd_impl_->class_ (x);
  }

  void kbd_pskel::
  style ()
  {
    if (this->kbd_impl_)
      this->kbd_impl_->style ();
  }

  void kbd_pskel::
  title ()
  {
    if (this->kbd_impl_)
      this->kbd_impl_->title ();
  }

  void kbd_pskel::
  lang ()
  {
    if (this->kbd_impl_)
      this->kbd_impl_->lang ();
  }

  void kbd_pskel::
  lang1 ()
  {
    if (this->kbd_impl_)
      this->kbd_impl_->lang1 ();
  }

  void kbd_pskel::
  dir ()
  {
    if (this->kbd_impl_)
      this->kbd_impl_->dir ();
  }

  void kbd_pskel::
  post_kbd ()
  {
    if (this->kbd_impl_)
      this->kbd_impl_->post_kbd ();
    else
      post_Inline ();
  }

  void kbd_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // var_pskel
  //

  void var_pskel::
  id (const ::std::string& x)
  {
    if (this->var_impl_)
      this->var_impl_->id (x);
  }

  void var_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->var_impl_)
      this->var_impl_->class_ (x);
  }

  void var_pskel::
  style ()
  {
    if (this->var_impl_)
      this->var_impl_->style ();
  }

  void var_pskel::
  title ()
  {
    if (this->var_impl_)
      this->var_impl_->title ();
  }

  void var_pskel::
  lang ()
  {
    if (this->var_impl_)
      this->var_impl_->lang ();
  }

  void var_pskel::
  lang1 ()
  {
    if (this->var_impl_)
      this->var_impl_->lang1 ();
  }

  void var_pskel::
  dir ()
  {
    if (this->var_impl_)
      this->var_impl_->dir ();
  }

  void var_pskel::
  post_var ()
  {
    if (this->var_impl_)
      this->var_impl_->post_var ();
    else
      post_Inline ();
  }

  void var_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // cite_pskel
  //

  void cite_pskel::
  id (const ::std::string& x)
  {
    if (this->cite_impl_)
      this->cite_impl_->id (x);
  }

  void cite_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->cite_impl_)
      this->cite_impl_->class_ (x);
  }

  void cite_pskel::
  style ()
  {
    if (this->cite_impl_)
      this->cite_impl_->style ();
  }

  void cite_pskel::
  title ()
  {
    if (this->cite_impl_)
      this->cite_impl_->title ();
  }

  void cite_pskel::
  lang ()
  {
    if (this->cite_impl_)
      this->cite_impl_->lang ();
  }

  void cite_pskel::
  lang1 ()
  {
    if (this->cite_impl_)
      this->cite_impl_->lang1 ();
  }

  void cite_pskel::
  dir ()
  {
    if (this->cite_impl_)
      this->cite_impl_->dir ();
  }

  void cite_pskel::
  post_cite ()
  {
    if (this->cite_impl_)
      this->cite_impl_->post_cite ();
    else
      post_Inline ();
  }

  void cite_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // abbr_pskel
  //

  void abbr_pskel::
  id (const ::std::string& x)
  {
    if (this->abbr_impl_)
      this->abbr_impl_->id (x);
  }

  void abbr_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->abbr_impl_)
      this->abbr_impl_->class_ (x);
  }

  void abbr_pskel::
  style ()
  {
    if (this->abbr_impl_)
      this->abbr_impl_->style ();
  }

  void abbr_pskel::
  title ()
  {
    if (this->abbr_impl_)
      this->abbr_impl_->title ();
  }

  void abbr_pskel::
  lang ()
  {
    if (this->abbr_impl_)
      this->abbr_impl_->lang ();
  }

  void abbr_pskel::
  lang1 ()
  {
    if (this->abbr_impl_)
      this->abbr_impl_->lang1 ();
  }

  void abbr_pskel::
  dir ()
  {
    if (this->abbr_impl_)
      this->abbr_impl_->dir ();
  }

  void abbr_pskel::
  post_abbr ()
  {
    if (this->abbr_impl_)
      this->abbr_impl_->post_abbr ();
    else
      post_Inline ();
  }

  void abbr_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // acronym_pskel
  //

  void acronym_pskel::
  id (const ::std::string& x)
  {
    if (this->acronym_impl_)
      this->acronym_impl_->id (x);
  }

  void acronym_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->acronym_impl_)
      this->acronym_impl_->class_ (x);
  }

  void acronym_pskel::
  style ()
  {
    if (this->acronym_impl_)
      this->acronym_impl_->style ();
  }

  void acronym_pskel::
  title ()
  {
    if (this->acronym_impl_)
      this->acronym_impl_->title ();
  }

  void acronym_pskel::
  lang ()
  {
    if (this->acronym_impl_)
      this->acronym_impl_->lang ();
  }

  void acronym_pskel::
  lang1 ()
  {
    if (this->acronym_impl_)
      this->acronym_impl_->lang1 ();
  }

  void acronym_pskel::
  dir ()
  {
    if (this->acronym_impl_)
      this->acronym_impl_->dir ();
  }

  void acronym_pskel::
  post_acronym ()
  {
    if (this->acronym_impl_)
      this->acronym_impl_->post_acronym ();
    else
      post_Inline ();
  }

  void acronym_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // q_pskel
  //

  void q_pskel::
  id (const ::std::string& x)
  {
    if (this->q_impl_)
      this->q_impl_->id (x);
  }

  void q_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->q_impl_)
      this->q_impl_->class_ (x);
  }

  void q_pskel::
  style ()
  {
    if (this->q_impl_)
      this->q_impl_->style ();
  }

  void q_pskel::
  title ()
  {
    if (this->q_impl_)
      this->q_impl_->title ();
  }

  void q_pskel::
  lang ()
  {
    if (this->q_impl_)
      this->q_impl_->lang ();
  }

  void q_pskel::
  lang1 ()
  {
    if (this->q_impl_)
      this->q_impl_->lang1 ();
  }

  void q_pskel::
  dir ()
  {
    if (this->q_impl_)
      this->q_impl_->dir ();
  }

  void q_pskel::
  cite1 ()
  {
    if (this->q_impl_)
      this->q_impl_->cite1 ();
  }

  void q_pskel::
  post_q ()
  {
    if (this->q_impl_)
      this->q_impl_->post_q ();
    else
      post_Inline ();
  }

  void q_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->cite1_parser_)
      this->cite1_parser_->_reset ();
  }

  // sub_pskel
  //

  void sub_pskel::
  id (const ::std::string& x)
  {
    if (this->sub_impl_)
      this->sub_impl_->id (x);
  }

  void sub_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->sub_impl_)
      this->sub_impl_->class_ (x);
  }

  void sub_pskel::
  style ()
  {
    if (this->sub_impl_)
      this->sub_impl_->style ();
  }

  void sub_pskel::
  title ()
  {
    if (this->sub_impl_)
      this->sub_impl_->title ();
  }

  void sub_pskel::
  lang ()
  {
    if (this->sub_impl_)
      this->sub_impl_->lang ();
  }

  void sub_pskel::
  lang1 ()
  {
    if (this->sub_impl_)
      this->sub_impl_->lang1 ();
  }

  void sub_pskel::
  dir ()
  {
    if (this->sub_impl_)
      this->sub_impl_->dir ();
  }

  void sub_pskel::
  post_sub ()
  {
    if (this->sub_impl_)
      this->sub_impl_->post_sub ();
    else
      post_Inline ();
  }

  void sub_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // sup_pskel
  //

  void sup_pskel::
  id (const ::std::string& x)
  {
    if (this->sup_impl_)
      this->sup_impl_->id (x);
  }

  void sup_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->sup_impl_)
      this->sup_impl_->class_ (x);
  }

  void sup_pskel::
  style ()
  {
    if (this->sup_impl_)
      this->sup_impl_->style ();
  }

  void sup_pskel::
  title ()
  {
    if (this->sup_impl_)
      this->sup_impl_->title ();
  }

  void sup_pskel::
  lang ()
  {
    if (this->sup_impl_)
      this->sup_impl_->lang ();
  }

  void sup_pskel::
  lang1 ()
  {
    if (this->sup_impl_)
      this->sup_impl_->lang1 ();
  }

  void sup_pskel::
  dir ()
  {
    if (this->sup_impl_)
      this->sup_impl_->dir ();
  }

  void sup_pskel::
  post_sup ()
  {
    if (this->sup_impl_)
      this->sup_impl_->post_sup ();
    else
      post_Inline ();
  }

  void sup_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // tt_pskel
  //

  void tt_pskel::
  id (const ::std::string& x)
  {
    if (this->tt_impl_)
      this->tt_impl_->id (x);
  }

  void tt_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->tt_impl_)
      this->tt_impl_->class_ (x);
  }

  void tt_pskel::
  style ()
  {
    if (this->tt_impl_)
      this->tt_impl_->style ();
  }

  void tt_pskel::
  title ()
  {
    if (this->tt_impl_)
      this->tt_impl_->title ();
  }

  void tt_pskel::
  lang ()
  {
    if (this->tt_impl_)
      this->tt_impl_->lang ();
  }

  void tt_pskel::
  lang1 ()
  {
    if (this->tt_impl_)
      this->tt_impl_->lang1 ();
  }

  void tt_pskel::
  dir ()
  {
    if (this->tt_impl_)
      this->tt_impl_->dir ();
  }

  void tt_pskel::
  post_tt ()
  {
    if (this->tt_impl_)
      this->tt_impl_->post_tt ();
    else
      post_Inline ();
  }

  void tt_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // i_pskel
  //

  void i_pskel::
  id (const ::std::string& x)
  {
    if (this->i_impl_)
      this->i_impl_->id (x);
  }

  void i_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->i_impl_)
      this->i_impl_->class_ (x);
  }

  void i_pskel::
  style ()
  {
    if (this->i_impl_)
      this->i_impl_->style ();
  }

  void i_pskel::
  title ()
  {
    if (this->i_impl_)
      this->i_impl_->title ();
  }

  void i_pskel::
  lang ()
  {
    if (this->i_impl_)
      this->i_impl_->lang ();
  }

  void i_pskel::
  lang1 ()
  {
    if (this->i_impl_)
      this->i_impl_->lang1 ();
  }

  void i_pskel::
  dir ()
  {
    if (this->i_impl_)
      this->i_impl_->dir ();
  }

  void i_pskel::
  post_i ()
  {
    if (this->i_impl_)
      this->i_impl_->post_i ();
    else
      post_Inline ();
  }

  void i_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // b_pskel
  //

  void b_pskel::
  id (const ::std::string& x)
  {
    if (this->b_impl_)
      this->b_impl_->id (x);
  }

  void b_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->b_impl_)
      this->b_impl_->class_ (x);
  }

  void b_pskel::
  style ()
  {
    if (this->b_impl_)
      this->b_impl_->style ();
  }

  void b_pskel::
  title ()
  {
    if (this->b_impl_)
      this->b_impl_->title ();
  }

  void b_pskel::
  lang ()
  {
    if (this->b_impl_)
      this->b_impl_->lang ();
  }

  void b_pskel::
  lang1 ()
  {
    if (this->b_impl_)
      this->b_impl_->lang1 ();
  }

  void b_pskel::
  dir ()
  {
    if (this->b_impl_)
      this->b_impl_->dir ();
  }

  void b_pskel::
  post_b ()
  {
    if (this->b_impl_)
      this->b_impl_->post_b ();
    else
      post_Inline ();
  }

  void b_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // big_pskel
  //

  void big_pskel::
  id (const ::std::string& x)
  {
    if (this->big_impl_)
      this->big_impl_->id (x);
  }

  void big_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->big_impl_)
      this->big_impl_->class_ (x);
  }

  void big_pskel::
  style ()
  {
    if (this->big_impl_)
      this->big_impl_->style ();
  }

  void big_pskel::
  title ()
  {
    if (this->big_impl_)
      this->big_impl_->title ();
  }

  void big_pskel::
  lang ()
  {
    if (this->big_impl_)
      this->big_impl_->lang ();
  }

  void big_pskel::
  lang1 ()
  {
    if (this->big_impl_)
      this->big_impl_->lang1 ();
  }

  void big_pskel::
  dir ()
  {
    if (this->big_impl_)
      this->big_impl_->dir ();
  }

  void big_pskel::
  post_big ()
  {
    if (this->big_impl_)
      this->big_impl_->post_big ();
    else
      post_Inline ();
  }

  void big_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // small_pskel
  //

  void small_pskel::
  id (const ::std::string& x)
  {
    if (this->small_impl_)
      this->small_impl_->id (x);
  }

  void small_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->small_impl_)
      this->small_impl_->class_ (x);
  }

  void small_pskel::
  style ()
  {
    if (this->small_impl_)
      this->small_impl_->style ();
  }

  void small_pskel::
  title ()
  {
    if (this->small_impl_)
      this->small_impl_->title ();
  }

  void small_pskel::
  lang ()
  {
    if (this->small_impl_)
      this->small_impl_->lang ();
  }

  void small_pskel::
  lang1 ()
  {
    if (this->small_impl_)
      this->small_impl_->lang1 ();
  }

  void small_pskel::
  dir ()
  {
    if (this->small_impl_)
      this->small_impl_->dir ();
  }

  void small_pskel::
  post_small ()
  {
    if (this->small_impl_)
      this->small_impl_->post_small ();
    else
      post_Inline ();
  }

  void small_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // img_pskel
  //

  void img_pskel::
  id (const ::std::string& x)
  {
    if (this->img_impl_)
      this->img_impl_->id (x);
  }

  void img_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->img_impl_)
      this->img_impl_->class_ (x);
  }

  void img_pskel::
  style ()
  {
    if (this->img_impl_)
      this->img_impl_->style ();
  }

  void img_pskel::
  title ()
  {
    if (this->img_impl_)
      this->img_impl_->title ();
  }

  void img_pskel::
  lang ()
  {
    if (this->img_impl_)
      this->img_impl_->lang ();
  }

  void img_pskel::
  lang1 ()
  {
    if (this->img_impl_)
      this->img_impl_->lang1 ();
  }

  void img_pskel::
  dir ()
  {
    if (this->img_impl_)
      this->img_impl_->dir ();
  }

  void img_pskel::
  src ()
  {
    if (this->img_impl_)
      this->img_impl_->src ();
  }

  void img_pskel::
  alt ()
  {
    if (this->img_impl_)
      this->img_impl_->alt ();
  }

  void img_pskel::
  longdesc ()
  {
    if (this->img_impl_)
      this->img_impl_->longdesc ();
  }

  void img_pskel::
  height ()
  {
    if (this->img_impl_)
      this->img_impl_->height ();
  }

  void img_pskel::
  width ()
  {
    if (this->img_impl_)
      this->img_impl_->width ();
  }

  void img_pskel::
  usemap ()
  {
    if (this->img_impl_)
      this->img_impl_->usemap ();
  }

  void img_pskel::
  ismap ()
  {
    if (this->img_impl_)
      this->img_impl_->ismap ();
  }

  void img_pskel::
  post_img ()
  {
    if (this->img_impl_)
      this->img_impl_->post_img ();
  }

  void img_pskel::
  _reset ()
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_attr_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->src_parser_)
      this->src_parser_->_reset ();

    if (this->alt_parser_)
      this->alt_parser_->_reset ();

    if (this->longdesc_parser_)
      this->longdesc_parser_->_reset ();

    if (this->height_parser_)
      this->height_parser_->_reset ();

    if (this->width_parser_)
      this->width_parser_->_reset ();

    if (this->usemap_parser_)
      this->usemap_parser_->_reset ();

    if (this->ismap_parser_)
      this->ismap_parser_->_reset ();
  }

  // map_pskel
  //

  void map_pskel::
  lang ()
  {
    if (this->map_impl_)
      this->map_impl_->lang ();
  }

  void map_pskel::
  lang1 ()
  {
    if (this->map_impl_)
      this->map_impl_->lang1 ();
  }

  void map_pskel::
  dir ()
  {
    if (this->map_impl_)
      this->map_impl_->dir ();
  }

  void map_pskel::
  id (const ::std::string& x)
  {
    if (this->map_impl_)
      this->map_impl_->id (x);
  }

  void map_pskel::
  class_ (const ::std::string& x)
  {
    if (this->map_impl_)
      this->map_impl_->class_ (x);
  }

  void map_pskel::
  style ()
  {
    if (this->map_impl_)
      this->map_impl_->style ();
  }

  void map_pskel::
  title ()
  {
    if (this->map_impl_)
      this->map_impl_->title ();
  }

  void map_pskel::
  name (const ::std::string& x)
  {
    if (this->map_impl_)
      this->map_impl_->name (x);
  }

  void map_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->map_impl_)
      this->map_impl_->choice_arm (x);
  }

  void map_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->map_impl_)
      this->map_impl_->choice1_arm (x);
  }

  void map_pskel::
  choice2_arm (choice2_arm_tag x)
  {
    if (this->map_impl_)
      this->map_impl_->choice2_arm (x);
  }

  void map_pskel::
  p ()
  {
    if (this->map_impl_)
      this->map_impl_->p ();
  }

  void map_pskel::
  choice3_arm (choice3_arm_tag x)
  {
    if (this->map_impl_)
      this->map_impl_->choice3_arm (x);
  }

  void map_pskel::
  h1 ()
  {
    if (this->map_impl_)
      this->map_impl_->h1 ();
  }

  void map_pskel::
  h2 ()
  {
    if (this->map_impl_)
      this->map_impl_->h2 ();
  }

  void map_pskel::
  h3 ()
  {
    if (this->map_impl_)
      this->map_impl_->h3 ();
  }

  void map_pskel::
  h4 ()
  {
    if (this->map_impl_)
      this->map_impl_->h4 ();
  }

  void map_pskel::
  h5 ()
  {
    if (this->map_impl_)
      this->map_impl_->h5 ();
  }

  void map_pskel::
  h6 ()
  {
    if (this->map_impl_)
      this->map_impl_->h6 ();
  }

  void map_pskel::
  div ()
  {
    if (this->map_impl_)
      this->map_impl_->div ();
  }

  void map_pskel::
  choice4_arm (choice4_arm_tag x)
  {
    if (this->map_impl_)
      this->map_impl_->choice4_arm (x);
  }

  void map_pskel::
  ul ()
  {
    if (this->map_impl_)
      this->map_impl_->ul ();
  }

  void map_pskel::
  ol ()
  {
    if (this->map_impl_)
      this->map_impl_->ol ();
  }

  void map_pskel::
  dl ()
  {
    if (this->map_impl_)
      this->map_impl_->dl ();
  }

  void map_pskel::
  choice5_arm (choice5_arm_tag x)
  {
    if (this->map_impl_)
      this->map_impl_->choice5_arm (x);
  }

  void map_pskel::
  pre ()
  {
    if (this->map_impl_)
      this->map_impl_->pre ();
  }

  void map_pskel::
  hr ()
  {
    if (this->map_impl_)
      this->map_impl_->hr ();
  }

  void map_pskel::
  blockquote ()
  {
    if (this->map_impl_)
      this->map_impl_->blockquote ();
  }

  void map_pskel::
  address ()
  {
    if (this->map_impl_)
      this->map_impl_->address ();
  }

  void map_pskel::
  table ()
  {
    if (this->map_impl_)
      this->map_impl_->table ();
  }

  void map_pskel::
  area ()
  {
    if (this->map_impl_)
      this->map_impl_->area ();
  }

  void map_pskel::
  post_map ()
  {
    if (this->map_impl_)
      this->map_impl_->post_map ();
  }

  void map_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->v_state_attr_stack_.clear ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    this->resetting_ = true;

    if (this->p_parser_)
      this->p_parser_->_reset ();

    if (this->h1_parser_)
      this->h1_parser_->_reset ();

    if (this->h2_parser_)
      this->h2_parser_->_reset ();

    if (this->h3_parser_)
      this->h3_parser_->_reset ();

    if (this->h4_parser_)
      this->h4_parser_->_reset ();

    if (this->h5_parser_)
      this->h5_parser_->_reset ();

    if (this->h6_parser_)
      this->h6_parser_->_reset ();

    if (this->div_parser_)
      this->div_parser_->_reset ();

    if (this->ul_parser_)
      this->ul_parser_->_reset ();

    if (this->ol_parser_)
      this->ol_parser_->_reset ();

    if (this->dl_parser_)
      this->dl_parser_->_reset ();

    if (this->pre_parser_)
      this->pre_parser_->_reset ();

    if (this->hr_parser_)
      this->hr_parser_->_reset ();

    if (this->blockquote_parser_)
      this->blockquote_parser_->_reset ();

    if (this->address_parser_)
      this->address_parser_->_reset ();

    if (this->table_parser_)
      this->table_parser_->_reset ();

    if (this->area_parser_)
      this->area_parser_->_reset ();

    this->resetting_ = false;
  }

  // area_pskel
  //

  void area_pskel::
  id (const ::std::string& x)
  {
    if (this->area_impl_)
      this->area_impl_->id (x);
  }

  void area_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->area_impl_)
      this->area_impl_->class_ (x);
  }

  void area_pskel::
  style ()
  {
    if (this->area_impl_)
      this->area_impl_->style ();
  }

  void area_pskel::
  title ()
  {
    if (this->area_impl_)
      this->area_impl_->title ();
  }

  void area_pskel::
  lang ()
  {
    if (this->area_impl_)
      this->area_impl_->lang ();
  }

  void area_pskel::
  lang1 ()
  {
    if (this->area_impl_)
      this->area_impl_->lang1 ();
  }

  void area_pskel::
  dir ()
  {
    if (this->area_impl_)
      this->area_impl_->dir ();
  }

  void area_pskel::
  accesskey ()
  {
    if (this->area_impl_)
      this->area_impl_->accesskey ();
  }

  void area_pskel::
  tabindex ()
  {
    if (this->area_impl_)
      this->area_impl_->tabindex ();
  }

  void area_pskel::
  shape ()
  {
    if (this->area_impl_)
      this->area_impl_->shape ();
  }

  void area_pskel::
  coords ()
  {
    if (this->area_impl_)
      this->area_impl_->coords ();
  }

  void area_pskel::
  href ()
  {
    if (this->area_impl_)
      this->area_impl_->href ();
  }

  void area_pskel::
  nohref ()
  {
    if (this->area_impl_)
      this->area_impl_->nohref ();
  }

  void area_pskel::
  alt ()
  {
    if (this->area_impl_)
      this->area_impl_->alt ();
  }

  void area_pskel::
  post_area ()
  {
    if (this->area_impl_)
      this->area_impl_->post_area ();
  }

  void area_pskel::
  _reset ()
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_attr_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->accesskey_parser_)
      this->accesskey_parser_->_reset ();

    if (this->tabindex_parser_)
      this->tabindex_parser_->_reset ();

    if (this->shape_parser_)
      this->shape_parser_->_reset ();

    if (this->coords_parser_)
      this->coords_parser_->_reset ();

    if (this->href_parser_)
      this->href_parser_->_reset ();

    if (this->nohref_parser_)
      this->nohref_parser_->_reset ();

    if (this->alt_parser_)
      this->alt_parser_->_reset ();
  }

  // align_pskel
  //

  void align_pskel::
  post_align ()
  {
    if (this->align_impl_)
      this->align_impl_->post_align ();
  }

  ::std::string align_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const align_pskel::_xsde_align_pskel_enums_[5UL] = 
  {
    "center",
    "char",
    "justify",
    "left",
    "right"
  };

  // valign_pskel
  //

  void valign_pskel::
  post_valign ()
  {
    if (this->valign_impl_)
      this->valign_impl_->post_valign ();
  }

  ::std::string valign_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const valign_pskel::_xsde_valign_pskel_enums_[4UL] = 
  {
    "baseline",
    "bottom",
    "middle",
    "top"
  };

  // table_pskel
  //

  void table_pskel::
  id (const ::std::string& x)
  {
    if (this->table_impl_)
      this->table_impl_->id (x);
  }

  void table_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->table_impl_)
      this->table_impl_->class_ (x);
  }

  void table_pskel::
  style ()
  {
    if (this->table_impl_)
      this->table_impl_->style ();
  }

  void table_pskel::
  title ()
  {
    if (this->table_impl_)
      this->table_impl_->title ();
  }

  void table_pskel::
  lang ()
  {
    if (this->table_impl_)
      this->table_impl_->lang ();
  }

  void table_pskel::
  lang1 ()
  {
    if (this->table_impl_)
      this->table_impl_->lang1 ();
  }

  void table_pskel::
  dir ()
  {
    if (this->table_impl_)
      this->table_impl_->dir ();
  }

  void table_pskel::
  summary ()
  {
    if (this->table_impl_)
      this->table_impl_->summary ();
  }

  void table_pskel::
  width ()
  {
    if (this->table_impl_)
      this->table_impl_->width ();
  }

  void table_pskel::
  border ()
  {
    if (this->table_impl_)
      this->table_impl_->border ();
  }

  void table_pskel::
  frame ()
  {
    if (this->table_impl_)
      this->table_impl_->frame ();
  }

  void table_pskel::
  rules ()
  {
    if (this->table_impl_)
      this->table_impl_->rules ();
  }

  void table_pskel::
  cellspacing ()
  {
    if (this->table_impl_)
      this->table_impl_->cellspacing ();
  }

  void table_pskel::
  cellpadding ()
  {
    if (this->table_impl_)
      this->table_impl_->cellpadding ();
  }

  void table_pskel::
  caption ()
  {
    if (this->table_impl_)
      this->table_impl_->caption ();
  }

  void table_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->table_impl_)
      this->table_impl_->choice_arm (x);
  }

  void table_pskel::
  col ()
  {
    if (this->table_impl_)
      this->table_impl_->col ();
  }

  void table_pskel::
  colgroup ()
  {
    if (this->table_impl_)
      this->table_impl_->colgroup ();
  }

  void table_pskel::
  thead ()
  {
    if (this->table_impl_)
      this->table_impl_->thead ();
  }

  void table_pskel::
  tfoot ()
  {
    if (this->table_impl_)
      this->table_impl_->tfoot ();
  }

  void table_pskel::
  choice1_arm (choice1_arm_tag x)
  {
    if (this->table_impl_)
      this->table_impl_->choice1_arm (x);
  }

  void table_pskel::
  tbody ()
  {
    if (this->table_impl_)
      this->table_impl_->tbody ();
  }

  void table_pskel::
  tr ()
  {
    if (this->table_impl_)
      this->table_impl_->tr ();
  }

  void table_pskel::
  post_table ()
  {
    if (this->table_impl_)
      this->table_impl_->post_table ();
  }

  void table_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->summary_parser_)
      this->summary_parser_->_reset ();

    if (this->width_parser_)
      this->width_parser_->_reset ();

    if (this->border_parser_)
      this->border_parser_->_reset ();

    if (this->frame_parser_)
      this->frame_parser_->_reset ();

    if (this->rules_parser_)
      this->rules_parser_->_reset ();

    if (this->cellspacing_parser_)
      this->cellspacing_parser_->_reset ();

    if (this->cellpadding_parser_)
      this->cellpadding_parser_->_reset ();

    this->resetting_ = true;

    if (this->caption_parser_)
      this->caption_parser_->_reset ();

    if (this->col_parser_)
      this->col_parser_->_reset ();

    if (this->colgroup_parser_)
      this->colgroup_parser_->_reset ();

    if (this->thead_parser_)
      this->thead_parser_->_reset ();

    if (this->tfoot_parser_)
      this->tfoot_parser_->_reset ();

    if (this->tbody_parser_)
      this->tbody_parser_->_reset ();

    if (this->tr_parser_)
      this->tr_parser_->_reset ();

    this->resetting_ = false;
  }

  // caption_pskel
  //

  void caption_pskel::
  id (const ::std::string& x)
  {
    if (this->caption_impl_)
      this->caption_impl_->id (x);
  }

  void caption_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->caption_impl_)
      this->caption_impl_->class_ (x);
  }

  void caption_pskel::
  style ()
  {
    if (this->caption_impl_)
      this->caption_impl_->style ();
  }

  void caption_pskel::
  title ()
  {
    if (this->caption_impl_)
      this->caption_impl_->title ();
  }

  void caption_pskel::
  lang ()
  {
    if (this->caption_impl_)
      this->caption_impl_->lang ();
  }

  void caption_pskel::
  lang1 ()
  {
    if (this->caption_impl_)
      this->caption_impl_->lang1 ();
  }

  void caption_pskel::
  dir ()
  {
    if (this->caption_impl_)
      this->caption_impl_->dir ();
  }

  void caption_pskel::
  post_caption ()
  {
    if (this->caption_impl_)
      this->caption_impl_->post_caption ();
    else
      post_Inline ();
  }

  void caption_pskel::
  _reset ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();
  }

  // thead_pskel
  //

  void thead_pskel::
  id (const ::std::string& x)
  {
    if (this->thead_impl_)
      this->thead_impl_->id (x);
  }

  void thead_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->thead_impl_)
      this->thead_impl_->class_ (x);
  }

  void thead_pskel::
  style ()
  {
    if (this->thead_impl_)
      this->thead_impl_->style ();
  }

  void thead_pskel::
  title ()
  {
    if (this->thead_impl_)
      this->thead_impl_->title ();
  }

  void thead_pskel::
  lang ()
  {
    if (this->thead_impl_)
      this->thead_impl_->lang ();
  }

  void thead_pskel::
  lang1 ()
  {
    if (this->thead_impl_)
      this->thead_impl_->lang1 ();
  }

  void thead_pskel::
  dir ()
  {
    if (this->thead_impl_)
      this->thead_impl_->dir ();
  }

  void thead_pskel::
  align ()
  {
    if (this->thead_impl_)
      this->thead_impl_->align ();
  }

  void thead_pskel::
  char_ ()
  {
    if (this->thead_impl_)
      this->thead_impl_->char_ ();
  }

  void thead_pskel::
  charoff ()
  {
    if (this->thead_impl_)
      this->thead_impl_->charoff ();
  }

  void thead_pskel::
  valign ()
  {
    if (this->thead_impl_)
      this->thead_impl_->valign ();
  }

  void thead_pskel::
  tr ()
  {
    if (this->thead_impl_)
      this->thead_impl_->tr ();
  }

  void thead_pskel::
  post_thead ()
  {
    if (this->thead_impl_)
      this->thead_impl_->post_thead ();
  }

  void thead_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();

    this->resetting_ = true;

    if (this->tr_parser_)
      this->tr_parser_->_reset ();

    this->resetting_ = false;
  }

  // tfoot_pskel
  //

  void tfoot_pskel::
  id (const ::std::string& x)
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->id (x);
  }

  void tfoot_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->class_ (x);
  }

  void tfoot_pskel::
  style ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->style ();
  }

  void tfoot_pskel::
  title ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->title ();
  }

  void tfoot_pskel::
  lang ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->lang ();
  }

  void tfoot_pskel::
  lang1 ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->lang1 ();
  }

  void tfoot_pskel::
  dir ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->dir ();
  }

  void tfoot_pskel::
  align ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->align ();
  }

  void tfoot_pskel::
  char_ ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->char_ ();
  }

  void tfoot_pskel::
  charoff ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->charoff ();
  }

  void tfoot_pskel::
  valign ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->valign ();
  }

  void tfoot_pskel::
  tr ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->tr ();
  }

  void tfoot_pskel::
  post_tfoot ()
  {
    if (this->tfoot_impl_)
      this->tfoot_impl_->post_tfoot ();
  }

  void tfoot_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();

    this->resetting_ = true;

    if (this->tr_parser_)
      this->tr_parser_->_reset ();

    this->resetting_ = false;
  }

  // tbody_pskel
  //

  void tbody_pskel::
  id (const ::std::string& x)
  {
    if (this->tbody_impl_)
      this->tbody_impl_->id (x);
  }

  void tbody_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->tbody_impl_)
      this->tbody_impl_->class_ (x);
  }

  void tbody_pskel::
  style ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->style ();
  }

  void tbody_pskel::
  title ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->title ();
  }

  void tbody_pskel::
  lang ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->lang ();
  }

  void tbody_pskel::
  lang1 ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->lang1 ();
  }

  void tbody_pskel::
  dir ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->dir ();
  }

  void tbody_pskel::
  align ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->align ();
  }

  void tbody_pskel::
  char_ ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->char_ ();
  }

  void tbody_pskel::
  charoff ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->charoff ();
  }

  void tbody_pskel::
  valign ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->valign ();
  }

  void tbody_pskel::
  tr ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->tr ();
  }

  void tbody_pskel::
  post_tbody ()
  {
    if (this->tbody_impl_)
      this->tbody_impl_->post_tbody ();
  }

  void tbody_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();

    this->resetting_ = true;

    if (this->tr_parser_)
      this->tr_parser_->_reset ();

    this->resetting_ = false;
  }

  // colgroup_pskel
  //

  void colgroup_pskel::
  id (const ::std::string& x)
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->id (x);
  }

  void colgroup_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->class_ (x);
  }

  void colgroup_pskel::
  style ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->style ();
  }

  void colgroup_pskel::
  title ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->title ();
  }

  void colgroup_pskel::
  lang ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->lang ();
  }

  void colgroup_pskel::
  lang1 ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->lang1 ();
  }

  void colgroup_pskel::
  dir ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->dir ();
  }

  void colgroup_pskel::
  span ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->span ();
  }

  void colgroup_pskel::
  width ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->width ();
  }

  void colgroup_pskel::
  align ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->align ();
  }

  void colgroup_pskel::
  char_ ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->char_ ();
  }

  void colgroup_pskel::
  charoff ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->charoff ();
  }

  void colgroup_pskel::
  valign ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->valign ();
  }

  void colgroup_pskel::
  col ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->col ();
  }

  void colgroup_pskel::
  post_colgroup ()
  {
    if (this->colgroup_impl_)
      this->colgroup_impl_->post_colgroup ();
  }

  void colgroup_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->span_parser_)
      this->span_parser_->_reset ();

    if (this->width_parser_)
      this->width_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();

    this->resetting_ = true;

    if (this->col_parser_)
      this->col_parser_->_reset ();

    this->resetting_ = false;
  }

  // col_pskel
  //

  void col_pskel::
  id (const ::std::string& x)
  {
    if (this->col_impl_)
      this->col_impl_->id (x);
  }

  void col_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->col_impl_)
      this->col_impl_->class_ (x);
  }

  void col_pskel::
  style ()
  {
    if (this->col_impl_)
      this->col_impl_->style ();
  }

  void col_pskel::
  title ()
  {
    if (this->col_impl_)
      this->col_impl_->title ();
  }

  void col_pskel::
  lang ()
  {
    if (this->col_impl_)
      this->col_impl_->lang ();
  }

  void col_pskel::
  lang1 ()
  {
    if (this->col_impl_)
      this->col_impl_->lang1 ();
  }

  void col_pskel::
  dir ()
  {
    if (this->col_impl_)
      this->col_impl_->dir ();
  }

  void col_pskel::
  span ()
  {
    if (this->col_impl_)
      this->col_impl_->span ();
  }

  void col_pskel::
  width ()
  {
    if (this->col_impl_)
      this->col_impl_->width ();
  }

  void col_pskel::
  align ()
  {
    if (this->col_impl_)
      this->col_impl_->align ();
  }

  void col_pskel::
  char_ ()
  {
    if (this->col_impl_)
      this->col_impl_->char_ ();
  }

  void col_pskel::
  charoff ()
  {
    if (this->col_impl_)
      this->col_impl_->charoff ();
  }

  void col_pskel::
  valign ()
  {
    if (this->col_impl_)
      this->col_impl_->valign ();
  }

  void col_pskel::
  post_col ()
  {
    if (this->col_impl_)
      this->col_impl_->post_col ();
  }

  void col_pskel::
  _reset ()
  {
    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->span_parser_)
      this->span_parser_->_reset ();

    if (this->width_parser_)
      this->width_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();
  }

  // tr_pskel
  //

  void tr_pskel::
  id (const ::std::string& x)
  {
    if (this->tr_impl_)
      this->tr_impl_->id (x);
  }

  void tr_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->tr_impl_)
      this->tr_impl_->class_ (x);
  }

  void tr_pskel::
  style ()
  {
    if (this->tr_impl_)
      this->tr_impl_->style ();
  }

  void tr_pskel::
  title ()
  {
    if (this->tr_impl_)
      this->tr_impl_->title ();
  }

  void tr_pskel::
  lang ()
  {
    if (this->tr_impl_)
      this->tr_impl_->lang ();
  }

  void tr_pskel::
  lang1 ()
  {
    if (this->tr_impl_)
      this->tr_impl_->lang1 ();
  }

  void tr_pskel::
  dir ()
  {
    if (this->tr_impl_)
      this->tr_impl_->dir ();
  }

  void tr_pskel::
  align ()
  {
    if (this->tr_impl_)
      this->tr_impl_->align ();
  }

  void tr_pskel::
  char_ ()
  {
    if (this->tr_impl_)
      this->tr_impl_->char_ ();
  }

  void tr_pskel::
  charoff ()
  {
    if (this->tr_impl_)
      this->tr_impl_->charoff ();
  }

  void tr_pskel::
  valign ()
  {
    if (this->tr_impl_)
      this->tr_impl_->valign ();
  }

  void tr_pskel::
  choice_arm (choice_arm_tag x)
  {
    if (this->tr_impl_)
      this->tr_impl_->choice_arm (x);
  }

  void tr_pskel::
  th ()
  {
    if (this->tr_impl_)
      this->tr_impl_->th ();
  }

  void tr_pskel::
  td ()
  {
    if (this->tr_impl_)
      this->tr_impl_->td ();
  }

  void tr_pskel::
  post_tr ()
  {
    if (this->tr_impl_)
      this->tr_impl_->post_tr ();
  }

  void tr_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();

    this->resetting_ = true;

    if (this->th_parser_)
      this->th_parser_->_reset ();

    if (this->td_parser_)
      this->td_parser_->_reset ();

    this->resetting_ = false;
  }

  // th_pskel
  //

  void th_pskel::
  id (const ::std::string& x)
  {
    if (this->th_impl_)
      this->th_impl_->id (x);
  }

  void th_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->th_impl_)
      this->th_impl_->class_ (x);
  }

  void th_pskel::
  style ()
  {
    if (this->th_impl_)
      this->th_impl_->style ();
  }

  void th_pskel::
  title ()
  {
    if (this->th_impl_)
      this->th_impl_->title ();
  }

  void th_pskel::
  lang ()
  {
    if (this->th_impl_)
      this->th_impl_->lang ();
  }

  void th_pskel::
  lang1 ()
  {
    if (this->th_impl_)
      this->th_impl_->lang1 ();
  }

  void th_pskel::
  dir ()
  {
    if (this->th_impl_)
      this->th_impl_->dir ();
  }

  void th_pskel::
  abbr1 ()
  {
    if (this->th_impl_)
      this->th_impl_->abbr1 ();
  }

  void th_pskel::
  axis (const ::std::string& x)
  {
    if (this->th_impl_)
      this->th_impl_->axis (x);
  }

  void th_pskel::
  headers (::xml_schema::string_sequence* x)
  {
    if (this->th_impl_)
      this->th_impl_->headers (x);
  }

  void th_pskel::
  scope ()
  {
    if (this->th_impl_)
      this->th_impl_->scope ();
  }

  void th_pskel::
  rowspan ()
  {
    if (this->th_impl_)
      this->th_impl_->rowspan ();
  }

  void th_pskel::
  colspan ()
  {
    if (this->th_impl_)
      this->th_impl_->colspan ();
  }

  void th_pskel::
  align ()
  {
    if (this->th_impl_)
      this->th_impl_->align ();
  }

  void th_pskel::
  char_ ()
  {
    if (this->th_impl_)
      this->th_impl_->char_ ();
  }

  void th_pskel::
  charoff ()
  {
    if (this->th_impl_)
      this->th_impl_->charoff ();
  }

  void th_pskel::
  valign ()
  {
    if (this->th_impl_)
      this->th_impl_->valign ();
  }

  void th_pskel::
  post_th ()
  {
    if (this->th_impl_)
      this->th_impl_->post_th ();
    else
      post_Flow ();
  }

  void th_pskel::
  _reset ()
  {
    typedef ::xhtml::Flow_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->abbr1_parser_)
      this->abbr1_parser_->_reset ();

    if (this->axis_parser_)
      this->axis_parser_->_reset ();

    if (this->headers_parser_)
      this->headers_parser_->_reset ();

    if (this->scope_parser_)
      this->scope_parser_->_reset ();

    if (this->rowspan_parser_)
      this->rowspan_parser_->_reset ();

    if (this->colspan_parser_)
      this->colspan_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();
  }

  // td_pskel
  //

  void td_pskel::
  id (const ::std::string& x)
  {
    if (this->td_impl_)
      this->td_impl_->id (x);
  }

  void td_pskel::
  class_ (::xml_schema::string_sequence* x)
  {
    if (this->td_impl_)
      this->td_impl_->class_ (x);
  }

  void td_pskel::
  style ()
  {
    if (this->td_impl_)
      this->td_impl_->style ();
  }

  void td_pskel::
  title ()
  {
    if (this->td_impl_)
      this->td_impl_->title ();
  }

  void td_pskel::
  lang ()
  {
    if (this->td_impl_)
      this->td_impl_->lang ();
  }

  void td_pskel::
  lang1 ()
  {
    if (this->td_impl_)
      this->td_impl_->lang1 ();
  }

  void td_pskel::
  dir ()
  {
    if (this->td_impl_)
      this->td_impl_->dir ();
  }

  void td_pskel::
  abbr1 ()
  {
    if (this->td_impl_)
      this->td_impl_->abbr1 ();
  }

  void td_pskel::
  axis (const ::std::string& x)
  {
    if (this->td_impl_)
      this->td_impl_->axis (x);
  }

  void td_pskel::
  headers (::xml_schema::string_sequence* x)
  {
    if (this->td_impl_)
      this->td_impl_->headers (x);
  }

  void td_pskel::
  scope ()
  {
    if (this->td_impl_)
      this->td_impl_->scope ();
  }

  void td_pskel::
  rowspan ()
  {
    if (this->td_impl_)
      this->td_impl_->rowspan ();
  }

  void td_pskel::
  colspan ()
  {
    if (this->td_impl_)
      this->td_impl_->colspan ();
  }

  void td_pskel::
  align ()
  {
    if (this->td_impl_)
      this->td_impl_->align ();
  }

  void td_pskel::
  char_ ()
  {
    if (this->td_impl_)
      this->td_impl_->char_ ();
  }

  void td_pskel::
  charoff ()
  {
    if (this->td_impl_)
      this->td_impl_->charoff ();
  }

  void td_pskel::
  valign ()
  {
    if (this->td_impl_)
      this->td_impl_->valign ();
  }

  void td_pskel::
  post_td ()
  {
    if (this->td_impl_)
      this->td_impl_->post_td ();
    else
      post_Flow ();
  }

  void td_pskel::
  _reset ()
  {
    typedef ::xhtml::Flow_pskel base;
    base::_reset ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->class__parser_)
      this->class__parser_->_reset ();

    if (this->style_parser_)
      this->style_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->lang_parser_)
      this->lang_parser_->_reset ();

    if (this->lang1_parser_)
      this->lang1_parser_->_reset ();

    if (this->dir_parser_)
      this->dir_parser_->_reset ();

    if (this->abbr1_parser_)
      this->abbr1_parser_->_reset ();

    if (this->axis_parser_)
      this->axis_parser_->_reset ();

    if (this->headers_parser_)
      this->headers_parser_->_reset ();

    if (this->scope_parser_)
      this->scope_parser_->_reset ();

    if (this->rowspan_parser_)
      this->rowspan_parser_->_reset ();

    if (this->colspan_parser_)
      this->colspan_parser_->_reset ();

    if (this->align_parser_)
      this->align_parser_->_reset ();

    if (this->char__parser_)
      this->char__parser_->_reset ();

    if (this->charoff_parser_)
      this->charoff_parser_->_reset ();

    if (this->valign_parser_)
      this->valign_parser_->_reset ();
  }

  // ismap_pskel
  //

  void ismap_pskel::
  post_ismap ()
  {
    if (this->ismap_impl_)
      this->ismap_impl_->post_ismap ();
  }

  ::std::string ismap_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const ismap_pskel::_xsde_ismap_pskel_enums_[1UL] = 
  {
    "ismap"
  };

  // nohref_pskel
  //

  void nohref_pskel::
  post_nohref ()
  {
    if (this->nohref_impl_)
      this->nohref_impl_->post_nohref ();
  }

  ::std::string nohref_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  const char* const nohref_pskel::_xsde_nohref_pskel_enums_[1UL] = 
  {
    "nohref"
  };
}

#include <assert.h>

namespace xhtml
{
  // Element validation and dispatch functions for Inline_pskel.
  //
  bool Inline_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "a" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "br" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "span" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "bdo" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "map" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "img" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "tt" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "i" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "b" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "big" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "small" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "em" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "strong" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "dfn" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "code" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "q" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "samp" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "kbd" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "var" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "cite" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "abbr" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "acronym" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "sub" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "sup" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &Inline_pskel::choice_5;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_5 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Inline_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Inline_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Inline_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Inline_pskel::
  choice_5 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "a" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "br" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "span" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "bdo" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "map" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "img" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if ((n == "tt" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "i" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "b" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "big" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "small" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 2UL;
        else if ((n == "em" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "strong" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dfn" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "code" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "q" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "samp" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "kbd" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "var" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "cite" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "abbr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "acronym" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sub" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sup" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Inline_pskel::choice_4;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_4 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void Inline_pskel::
  choice_4 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->a_parser_)
          {
            this->a_parser_->pre ();
            ctx.nested_parser (this->a_parser_);
          }
        }
        else
        {
          if (this->a_parser_ != 0)
          {
            this->a_parser_->post_a ();
            this->a ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if ((n == "br" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "span" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "bdo" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "map" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;
        else if (n == "img" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Inline_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice2_arm (static_cast< choice2_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        unsigned long s = ~0UL;

        if (n == "tt" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "i" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "b" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "big" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "small" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Inline_pskel::choice_2;
          vd.state = s;
          vd.count = 0;

          this->choice4_arm (static_cast< choice4_arm_tag > (s));
          this->choice_2 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 3UL:
      {
        unsigned long s = ~0UL;

        if (n == "em" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "strong" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dfn" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "code" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "q" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "samp" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;
        else if (n == "kbd" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 6UL;
        else if (n == "var" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 7UL;
        else if (n == "cite" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 8UL;
        else if (n == "abbr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 9UL;
        else if (n == "acronym" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 10UL;
        else if (n == "sub" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 11UL;
        else if (n == "sup" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 12UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Inline_pskel::choice_3;
          vd.state = s;
          vd.count = 0;

          this->choice5_arm (static_cast< choice5_arm_tag > (s));
          this->choice_3 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void Inline_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "br" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "span" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "bdo" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "map" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Inline_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice3_arm (static_cast< choice3_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->img_parser_)
          {
            this->img_parser_->pre ();
            ctx.nested_parser (this->img_parser_);
          }
        }
        else
        {
          if (this->img_parser_ != 0)
          {
            this->img_parser_->post_img ();
            this->img ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Inline_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->br_parser_)
          {
            this->br_parser_->pre ();
            ctx.nested_parser (this->br_parser_);
          }
        }
        else
        {
          if (this->br_parser_ != 0)
          {
            this->br_parser_->post_br ();
            this->br ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->span_parser_)
          {
            this->span_parser_->pre ();
            ctx.nested_parser (this->span_parser_);
          }
        }
        else
        {
          if (this->span_parser_ != 0)
          {
            this->span_parser_->post_span ();
            this->span ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->bdo_parser_)
          {
            this->bdo_parser_->pre ();
            ctx.nested_parser (this->bdo_parser_);
          }
        }
        else
        {
          if (this->bdo_parser_ != 0)
          {
            this->bdo_parser_->post_bdo ();
            this->bdo ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->map_parser_)
          {
            this->map_parser_->pre ();
            ctx.nested_parser (this->map_parser_);
          }
        }
        else
        {
          if (this->map_parser_ != 0)
          {
            this->map_parser_->post_map ();
            this->map ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Inline_pskel::
  choice_2 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->tt_parser_)
          {
            this->tt_parser_->pre ();
            ctx.nested_parser (this->tt_parser_);
          }
        }
        else
        {
          if (this->tt_parser_ != 0)
          {
            this->tt_parser_->post_tt ();
            this->tt ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->i_parser_)
          {
            this->i_parser_->pre ();
            ctx.nested_parser (this->i_parser_);
          }
        }
        else
        {
          if (this->i_parser_ != 0)
          {
            this->i_parser_->post_i ();
            this->i ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->b_parser_)
          {
            this->b_parser_->pre ();
            ctx.nested_parser (this->b_parser_);
          }
        }
        else
        {
          if (this->b_parser_ != 0)
          {
            this->b_parser_->post_b ();
            this->b ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->big_parser_)
          {
            this->big_parser_->pre ();
            ctx.nested_parser (this->big_parser_);
          }
        }
        else
        {
          if (this->big_parser_ != 0)
          {
            this->big_parser_->post_big ();
            this->big ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->small_parser_)
          {
            this->small_parser_->pre ();
            ctx.nested_parser (this->small_parser_);
          }
        }
        else
        {
          if (this->small_parser_ != 0)
          {
            this->small_parser_->post_small ();
            this->small ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Inline_pskel::
  choice_3 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->em_parser_)
          {
            this->em_parser_->pre ();
            ctx.nested_parser (this->em_parser_);
          }
        }
        else
        {
          if (this->em_parser_ != 0)
          {
            this->em_parser_->post_em ();
            this->em ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->strong_parser_)
          {
            this->strong_parser_->pre ();
            ctx.nested_parser (this->strong_parser_);
          }
        }
        else
        {
          if (this->strong_parser_ != 0)
          {
            this->strong_parser_->post_strong ();
            this->strong ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dfn_parser_)
          {
            this->dfn_parser_->pre ();
            ctx.nested_parser (this->dfn_parser_);
          }
        }
        else
        {
          if (this->dfn_parser_ != 0)
          {
            this->dfn_parser_->post_dfn ();
            this->dfn ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->code_parser_)
          {
            this->code_parser_->pre ();
            ctx.nested_parser (this->code_parser_);
          }
        }
        else
        {
          if (this->code_parser_ != 0)
          {
            this->code_parser_->post_code ();
            this->code ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->q_parser_)
          {
            this->q_parser_->pre ();
            ctx.nested_parser (this->q_parser_);
          }
        }
        else
        {
          if (this->q_parser_ != 0)
          {
            this->q_parser_->post_q ();
            this->q ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->samp_parser_)
          {
            this->samp_parser_->pre ();
            ctx.nested_parser (this->samp_parser_);
          }
        }
        else
        {
          if (this->samp_parser_ != 0)
          {
            this->samp_parser_->post_samp ();
            this->samp ();
          }

          state = ~0UL;
        }

        break;
      }
      case 6UL:
      {
        if (start)
        {
          if (this->kbd_parser_)
          {
            this->kbd_parser_->pre ();
            ctx.nested_parser (this->kbd_parser_);
          }
        }
        else
        {
          if (this->kbd_parser_ != 0)
          {
            this->kbd_parser_->post_kbd ();
            this->kbd ();
          }

          state = ~0UL;
        }

        break;
      }
      case 7UL:
      {
        if (start)
        {
          if (this->var_parser_)
          {
            this->var_parser_->pre ();
            ctx.nested_parser (this->var_parser_);
          }
        }
        else
        {
          if (this->var_parser_ != 0)
          {
            this->var_parser_->post_var ();
            this->var ();
          }

          state = ~0UL;
        }

        break;
      }
      case 8UL:
      {
        if (start)
        {
          if (this->cite_parser_)
          {
            this->cite_parser_->pre ();
            ctx.nested_parser (this->cite_parser_);
          }
        }
        else
        {
          if (this->cite_parser_ != 0)
          {
            this->cite_parser_->post_cite ();
            this->cite ();
          }

          state = ~0UL;
        }

        break;
      }
      case 9UL:
      {
        if (start)
        {
          if (this->abbr_parser_)
          {
            this->abbr_parser_->pre ();
            ctx.nested_parser (this->abbr_parser_);
          }
        }
        else
        {
          if (this->abbr_parser_ != 0)
          {
            this->abbr_parser_->post_abbr ();
            this->abbr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 10UL:
      {
        if (start)
        {
          if (this->acronym_parser_)
          {
            this->acronym_parser_->pre ();
            ctx.nested_parser (this->acronym_parser_);
          }
        }
        else
        {
          if (this->acronym_parser_ != 0)
          {
            this->acronym_parser_->post_acronym ();
            this->acronym ();
          }

          state = ~0UL;
        }

        break;
      }
      case 11UL:
      {
        if (start)
        {
          if (this->sub_parser_)
          {
            this->sub_parser_->pre ();
            ctx.nested_parser (this->sub_parser_);
          }
        }
        else
        {
          if (this->sub_parser_ != 0)
          {
            this->sub_parser_->post_sub ();
            this->sub ();
          }

          state = ~0UL;
        }

        break;
      }
      case 12UL:
      {
        if (start)
        {
          if (this->sup_parser_)
          {
            this->sup_parser_->pre ();
            ctx.nested_parser (this->sup_parser_);
          }
        }
        else
        {
          if (this->sup_parser_ != 0)
          {
            this->sup_parser_->post_sup ();
            this->sup ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for Block_pskel.
  //
  bool Block_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "p" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h1" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h2" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h3" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h4" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h5" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h6" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "div" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ul" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ol" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "dl" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "pre" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "hr" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "blockquote" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "address" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "table" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &Block_pskel::choice_4;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_4 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Block_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Block_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Block_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Block_pskel::
  choice_4 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "p" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "h1" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h2" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h3" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h4" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h5" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h6" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if (n == "div" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if ((n == "ul" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "ol" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dl" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 3UL;
        else if ((n == "pre" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "hr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "blockquote" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "address" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 4UL;
        else if (n == "table" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Block_pskel::choice_3;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_3 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void Block_pskel::
  choice_3 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->p_parser_)
          {
            this->p_parser_->pre ();
            ctx.nested_parser (this->p_parser_);
          }
        }
        else
        {
          if (this->p_parser_ != 0)
          {
            this->p_parser_->post_p ();
            this->p ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "h1" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "h2" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "h3" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "h4" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "h5" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "h6" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Block_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice2_arm (static_cast< choice2_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->div_parser_)
          {
            this->div_parser_->pre ();
            ctx.nested_parser (this->div_parser_);
          }
        }
        else
        {
          if (this->div_parser_ != 0)
          {
            this->div_parser_->post_div ();
            this->div ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        unsigned long s = ~0UL;

        if (n == "ul" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "ol" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dl" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Block_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice3_arm (static_cast< choice3_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 4UL:
      {
        unsigned long s = ~0UL;

        if (n == "pre" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "hr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "blockquote" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "address" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Block_pskel::choice_2;
          vd.state = s;
          vd.count = 0;

          this->choice4_arm (static_cast< choice4_arm_tag > (s));
          this->choice_2 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->table_parser_)
          {
            this->table_parser_->pre ();
            ctx.nested_parser (this->table_parser_);
          }
        }
        else
        {
          if (this->table_parser_ != 0)
          {
            this->table_parser_->post_table ();
            this->table ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Block_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->h1_parser_)
          {
            this->h1_parser_->pre ();
            ctx.nested_parser (this->h1_parser_);
          }
        }
        else
        {
          if (this->h1_parser_ != 0)
          {
            this->h1_parser_->post_h1 ();
            this->h1 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->h2_parser_)
          {
            this->h2_parser_->pre ();
            ctx.nested_parser (this->h2_parser_);
          }
        }
        else
        {
          if (this->h2_parser_ != 0)
          {
            this->h2_parser_->post_h2 ();
            this->h2 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->h3_parser_)
          {
            this->h3_parser_->pre ();
            ctx.nested_parser (this->h3_parser_);
          }
        }
        else
        {
          if (this->h3_parser_ != 0)
          {
            this->h3_parser_->post_h3 ();
            this->h3 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->h4_parser_)
          {
            this->h4_parser_->pre ();
            ctx.nested_parser (this->h4_parser_);
          }
        }
        else
        {
          if (this->h4_parser_ != 0)
          {
            this->h4_parser_->post_h4 ();
            this->h4 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->h5_parser_)
          {
            this->h5_parser_->pre ();
            ctx.nested_parser (this->h5_parser_);
          }
        }
        else
        {
          if (this->h5_parser_ != 0)
          {
            this->h5_parser_->post_h5 ();
            this->h5 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->h6_parser_)
          {
            this->h6_parser_->pre ();
            ctx.nested_parser (this->h6_parser_);
          }
        }
        else
        {
          if (this->h6_parser_ != 0)
          {
            this->h6_parser_->post_h6 ();
            this->h6 ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Block_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->ul_parser_)
          {
            this->ul_parser_->pre ();
            ctx.nested_parser (this->ul_parser_);
          }
        }
        else
        {
          if (this->ul_parser_ != 0)
          {
            this->ul_parser_->post_ul ();
            this->ul ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->ol_parser_)
          {
            this->ol_parser_->pre ();
            ctx.nested_parser (this->ol_parser_);
          }
        }
        else
        {
          if (this->ol_parser_ != 0)
          {
            this->ol_parser_->post_ol ();
            this->ol ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dl_parser_)
          {
            this->dl_parser_->pre ();
            ctx.nested_parser (this->dl_parser_);
          }
        }
        else
        {
          if (this->dl_parser_ != 0)
          {
            this->dl_parser_->post_dl ();
            this->dl ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Block_pskel::
  choice_2 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->pre_parser_)
          {
            this->pre_parser_->pre ();
            ctx.nested_parser (this->pre_parser_);
          }
        }
        else
        {
          if (this->pre_parser_ != 0)
          {
            this->pre_parser_->post_pre ();
            this->pre ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->hr_parser_)
          {
            this->hr_parser_->pre ();
            ctx.nested_parser (this->hr_parser_);
          }
        }
        else
        {
          if (this->hr_parser_ != 0)
          {
            this->hr_parser_->post_hr ();
            this->hr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->blockquote_parser_)
          {
            this->blockquote_parser_->pre ();
            ctx.nested_parser (this->blockquote_parser_);
          }
        }
        else
        {
          if (this->blockquote_parser_ != 0)
          {
            this->blockquote_parser_->post_blockquote ();
            this->blockquote ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->address_parser_)
          {
            this->address_parser_->pre ();
            ctx.nested_parser (this->address_parser_);
          }
        }
        else
        {
          if (this->address_parser_ != 0)
          {
            this->address_parser_->post_address ();
            this->address ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for Flow_pskel.
  //
  bool Flow_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "p" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h1" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h2" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h3" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h4" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h5" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h6" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "div" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ul" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ol" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "dl" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "pre" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "hr" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "blockquote" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "address" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "table" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;
        else if ((n == "a" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "br" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "span" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "bdo" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "map" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "img" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "tt" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "i" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "b" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "big" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "small" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "em" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "strong" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dfn" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "code" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "q" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "samp" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "kbd" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "var" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "cite" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "abbr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "acronym" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sub" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sup" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &Flow_pskel::choice_9;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_9 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Flow_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Flow_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Flow_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Flow_pskel::
  choice_9 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "p" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "h1" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h2" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h3" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h4" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h5" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h6" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if (n == "div" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if ((n == "ul" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "ol" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dl" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 3UL;
        else if ((n == "pre" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "hr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "blockquote" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "address" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 4UL;
        else if (n == "table" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_3;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_3 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "a" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "br" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "span" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "bdo" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "map" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "img" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if ((n == "tt" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "i" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "b" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "big" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "small" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 2UL;
        else if ((n == "em" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "strong" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dfn" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "code" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "q" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "samp" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "kbd" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "var" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "cite" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "abbr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "acronym" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sub" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sup" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_8;
          vd.state = s;
          vd.count = 0;

          this->choice5_arm (static_cast< choice5_arm_tag > (s));
          this->choice_8 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_3 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->p_parser_)
          {
            this->p_parser_->pre ();
            ctx.nested_parser (this->p_parser_);
          }
        }
        else
        {
          if (this->p_parser_ != 0)
          {
            this->p_parser_->post_p ();
            this->p ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "h1" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "h2" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "h3" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "h4" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "h5" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "h6" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice2_arm (static_cast< choice2_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->div_parser_)
          {
            this->div_parser_->pre ();
            ctx.nested_parser (this->div_parser_);
          }
        }
        else
        {
          if (this->div_parser_ != 0)
          {
            this->div_parser_->post_div ();
            this->div ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        unsigned long s = ~0UL;

        if (n == "ul" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "ol" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dl" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice3_arm (static_cast< choice3_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 4UL:
      {
        unsigned long s = ~0UL;

        if (n == "pre" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "hr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "blockquote" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "address" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_2;
          vd.state = s;
          vd.count = 0;

          this->choice4_arm (static_cast< choice4_arm_tag > (s));
          this->choice_2 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->table_parser_)
          {
            this->table_parser_->pre ();
            ctx.nested_parser (this->table_parser_);
          }
        }
        else
        {
          if (this->table_parser_ != 0)
          {
            this->table_parser_->post_table ();
            this->table ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->h1_parser_)
          {
            this->h1_parser_->pre ();
            ctx.nested_parser (this->h1_parser_);
          }
        }
        else
        {
          if (this->h1_parser_ != 0)
          {
            this->h1_parser_->post_h1 ();
            this->h1 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->h2_parser_)
          {
            this->h2_parser_->pre ();
            ctx.nested_parser (this->h2_parser_);
          }
        }
        else
        {
          if (this->h2_parser_ != 0)
          {
            this->h2_parser_->post_h2 ();
            this->h2 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->h3_parser_)
          {
            this->h3_parser_->pre ();
            ctx.nested_parser (this->h3_parser_);
          }
        }
        else
        {
          if (this->h3_parser_ != 0)
          {
            this->h3_parser_->post_h3 ();
            this->h3 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->h4_parser_)
          {
            this->h4_parser_->pre ();
            ctx.nested_parser (this->h4_parser_);
          }
        }
        else
        {
          if (this->h4_parser_ != 0)
          {
            this->h4_parser_->post_h4 ();
            this->h4 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->h5_parser_)
          {
            this->h5_parser_->pre ();
            ctx.nested_parser (this->h5_parser_);
          }
        }
        else
        {
          if (this->h5_parser_ != 0)
          {
            this->h5_parser_->post_h5 ();
            this->h5 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->h6_parser_)
          {
            this->h6_parser_->pre ();
            ctx.nested_parser (this->h6_parser_);
          }
        }
        else
        {
          if (this->h6_parser_ != 0)
          {
            this->h6_parser_->post_h6 ();
            this->h6 ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->ul_parser_)
          {
            this->ul_parser_->pre ();
            ctx.nested_parser (this->ul_parser_);
          }
        }
        else
        {
          if (this->ul_parser_ != 0)
          {
            this->ul_parser_->post_ul ();
            this->ul ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->ol_parser_)
          {
            this->ol_parser_->pre ();
            ctx.nested_parser (this->ol_parser_);
          }
        }
        else
        {
          if (this->ol_parser_ != 0)
          {
            this->ol_parser_->post_ol ();
            this->ol ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dl_parser_)
          {
            this->dl_parser_->pre ();
            ctx.nested_parser (this->dl_parser_);
          }
        }
        else
        {
          if (this->dl_parser_ != 0)
          {
            this->dl_parser_->post_dl ();
            this->dl ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_2 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->pre_parser_)
          {
            this->pre_parser_->pre ();
            ctx.nested_parser (this->pre_parser_);
          }
        }
        else
        {
          if (this->pre_parser_ != 0)
          {
            this->pre_parser_->post_pre ();
            this->pre ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->hr_parser_)
          {
            this->hr_parser_->pre ();
            ctx.nested_parser (this->hr_parser_);
          }
        }
        else
        {
          if (this->hr_parser_ != 0)
          {
            this->hr_parser_->post_hr ();
            this->hr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->blockquote_parser_)
          {
            this->blockquote_parser_->pre ();
            ctx.nested_parser (this->blockquote_parser_);
          }
        }
        else
        {
          if (this->blockquote_parser_ != 0)
          {
            this->blockquote_parser_->post_blockquote ();
            this->blockquote ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->address_parser_)
          {
            this->address_parser_->pre ();
            ctx.nested_parser (this->address_parser_);
          }
        }
        else
        {
          if (this->address_parser_ != 0)
          {
            this->address_parser_->post_address ();
            this->address ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_8 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->a_parser_)
          {
            this->a_parser_->pre ();
            ctx.nested_parser (this->a_parser_);
          }
        }
        else
        {
          if (this->a_parser_ != 0)
          {
            this->a_parser_->post_a ();
            this->a ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if ((n == "br" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "span" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "bdo" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "map" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;
        else if (n == "img" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_5;
          vd.state = s;
          vd.count = 0;

          this->choice6_arm (static_cast< choice6_arm_tag > (s));
          this->choice_5 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        unsigned long s = ~0UL;

        if (n == "tt" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "i" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "b" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "big" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "small" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_6;
          vd.state = s;
          vd.count = 0;

          this->choice8_arm (static_cast< choice8_arm_tag > (s));
          this->choice_6 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 3UL:
      {
        unsigned long s = ~0UL;

        if (n == "em" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "strong" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dfn" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "code" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "q" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "samp" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;
        else if (n == "kbd" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 6UL;
        else if (n == "var" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 7UL;
        else if (n == "cite" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 8UL;
        else if (n == "abbr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 9UL;
        else if (n == "acronym" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 10UL;
        else if (n == "sub" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 11UL;
        else if (n == "sup" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 12UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_7;
          vd.state = s;
          vd.count = 0;

          this->choice9_arm (static_cast< choice9_arm_tag > (s));
          this->choice_7 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_5 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "br" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "span" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "bdo" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "map" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &Flow_pskel::choice_4;
          vd.state = s;
          vd.count = 0;

          this->choice7_arm (static_cast< choice7_arm_tag > (s));
          this->choice_4 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->img_parser_)
          {
            this->img_parser_->pre ();
            ctx.nested_parser (this->img_parser_);
          }
        }
        else
        {
          if (this->img_parser_ != 0)
          {
            this->img_parser_->post_img ();
            this->img ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_4 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->br_parser_)
          {
            this->br_parser_->pre ();
            ctx.nested_parser (this->br_parser_);
          }
        }
        else
        {
          if (this->br_parser_ != 0)
          {
            this->br_parser_->post_br ();
            this->br ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->span_parser_)
          {
            this->span_parser_->pre ();
            ctx.nested_parser (this->span_parser_);
          }
        }
        else
        {
          if (this->span_parser_ != 0)
          {
            this->span_parser_->post_span ();
            this->span ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->bdo_parser_)
          {
            this->bdo_parser_->pre ();
            ctx.nested_parser (this->bdo_parser_);
          }
        }
        else
        {
          if (this->bdo_parser_ != 0)
          {
            this->bdo_parser_->post_bdo ();
            this->bdo ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->map_parser_)
          {
            this->map_parser_->pre ();
            ctx.nested_parser (this->map_parser_);
          }
        }
        else
        {
          if (this->map_parser_ != 0)
          {
            this->map_parser_->post_map ();
            this->map ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_6 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->tt_parser_)
          {
            this->tt_parser_->pre ();
            ctx.nested_parser (this->tt_parser_);
          }
        }
        else
        {
          if (this->tt_parser_ != 0)
          {
            this->tt_parser_->post_tt ();
            this->tt ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->i_parser_)
          {
            this->i_parser_->pre ();
            ctx.nested_parser (this->i_parser_);
          }
        }
        else
        {
          if (this->i_parser_ != 0)
          {
            this->i_parser_->post_i ();
            this->i ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->b_parser_)
          {
            this->b_parser_->pre ();
            ctx.nested_parser (this->b_parser_);
          }
        }
        else
        {
          if (this->b_parser_ != 0)
          {
            this->b_parser_->post_b ();
            this->b ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->big_parser_)
          {
            this->big_parser_->pre ();
            ctx.nested_parser (this->big_parser_);
          }
        }
        else
        {
          if (this->big_parser_ != 0)
          {
            this->big_parser_->post_big ();
            this->big ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->small_parser_)
          {
            this->small_parser_->pre ();
            ctx.nested_parser (this->small_parser_);
          }
        }
        else
        {
          if (this->small_parser_ != 0)
          {
            this->small_parser_->post_small ();
            this->small ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void Flow_pskel::
  choice_7 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->em_parser_)
          {
            this->em_parser_->pre ();
            ctx.nested_parser (this->em_parser_);
          }
        }
        else
        {
          if (this->em_parser_ != 0)
          {
            this->em_parser_->post_em ();
            this->em ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->strong_parser_)
          {
            this->strong_parser_->pre ();
            ctx.nested_parser (this->strong_parser_);
          }
        }
        else
        {
          if (this->strong_parser_ != 0)
          {
            this->strong_parser_->post_strong ();
            this->strong ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dfn_parser_)
          {
            this->dfn_parser_->pre ();
            ctx.nested_parser (this->dfn_parser_);
          }
        }
        else
        {
          if (this->dfn_parser_ != 0)
          {
            this->dfn_parser_->post_dfn ();
            this->dfn ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->code_parser_)
          {
            this->code_parser_->pre ();
            ctx.nested_parser (this->code_parser_);
          }
        }
        else
        {
          if (this->code_parser_ != 0)
          {
            this->code_parser_->post_code ();
            this->code ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->q_parser_)
          {
            this->q_parser_->pre ();
            ctx.nested_parser (this->q_parser_);
          }
        }
        else
        {
          if (this->q_parser_ != 0)
          {
            this->q_parser_->post_q ();
            this->q ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->samp_parser_)
          {
            this->samp_parser_->pre ();
            ctx.nested_parser (this->samp_parser_);
          }
        }
        else
        {
          if (this->samp_parser_ != 0)
          {
            this->samp_parser_->post_samp ();
            this->samp ();
          }

          state = ~0UL;
        }

        break;
      }
      case 6UL:
      {
        if (start)
        {
          if (this->kbd_parser_)
          {
            this->kbd_parser_->pre ();
            ctx.nested_parser (this->kbd_parser_);
          }
        }
        else
        {
          if (this->kbd_parser_ != 0)
          {
            this->kbd_parser_->post_kbd ();
            this->kbd ();
          }

          state = ~0UL;
        }

        break;
      }
      case 7UL:
      {
        if (start)
        {
          if (this->var_parser_)
          {
            this->var_parser_->pre ();
            ctx.nested_parser (this->var_parser_);
          }
        }
        else
        {
          if (this->var_parser_ != 0)
          {
            this->var_parser_->post_var ();
            this->var ();
          }

          state = ~0UL;
        }

        break;
      }
      case 8UL:
      {
        if (start)
        {
          if (this->cite_parser_)
          {
            this->cite_parser_->pre ();
            ctx.nested_parser (this->cite_parser_);
          }
        }
        else
        {
          if (this->cite_parser_ != 0)
          {
            this->cite_parser_->post_cite ();
            this->cite ();
          }

          state = ~0UL;
        }

        break;
      }
      case 9UL:
      {
        if (start)
        {
          if (this->abbr_parser_)
          {
            this->abbr_parser_->pre ();
            ctx.nested_parser (this->abbr_parser_);
          }
        }
        else
        {
          if (this->abbr_parser_ != 0)
          {
            this->abbr_parser_->post_abbr ();
            this->abbr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 10UL:
      {
        if (start)
        {
          if (this->acronym_parser_)
          {
            this->acronym_parser_->pre ();
            ctx.nested_parser (this->acronym_parser_);
          }
        }
        else
        {
          if (this->acronym_parser_ != 0)
          {
            this->acronym_parser_->post_acronym ();
            this->acronym ();
          }

          state = ~0UL;
        }

        break;
      }
      case 11UL:
      {
        if (start)
        {
          if (this->sub_parser_)
          {
            this->sub_parser_->pre ();
            ctx.nested_parser (this->sub_parser_);
          }
        }
        else
        {
          if (this->sub_parser_ != 0)
          {
            this->sub_parser_->post_sub ();
            this->sub ();
          }

          state = ~0UL;
        }

        break;
      }
      case 12UL:
      {
        if (start)
        {
          if (this->sup_parser_)
          {
            this->sup_parser_->pre ();
            ctx.nested_parser (this->sup_parser_);
          }
        }
        else
        {
          if (this->sup_parser_ != 0)
          {
            this->sup_parser_->post_sup ();
            this->sup ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for a_content_pskel.
  //
  bool a_content_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "br" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "span" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "bdo" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "map" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "img" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;
        else if ((n == "tt" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "i" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "b" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "big" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "small" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if ((n == "em" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "strong" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dfn" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "code" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "q" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "samp" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "kbd" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "var" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "cite" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "abbr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "acronym" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sub" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sup" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &a_content_pskel::choice_4;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_4 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool a_content_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void a_content_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void a_content_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void a_content_pskel::
  choice_4 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if ((n == "br" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "span" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "bdo" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "map" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;
        else if (n == "img" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &a_content_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "tt" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "i" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "b" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "big" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "small" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &a_content_pskel::choice_2;
          vd.state = s;
          vd.count = 0;

          this->choice3_arm (static_cast< choice3_arm_tag > (s));
          this->choice_2 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        unsigned long s = ~0UL;

        if (n == "em" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "strong" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dfn" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "code" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "q" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "samp" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;
        else if (n == "kbd" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 6UL;
        else if (n == "var" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 7UL;
        else if (n == "cite" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 8UL;
        else if (n == "abbr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 9UL;
        else if (n == "acronym" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 10UL;
        else if (n == "sub" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 11UL;
        else if (n == "sup" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 12UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &a_content_pskel::choice_3;
          vd.state = s;
          vd.count = 0;

          this->choice4_arm (static_cast< choice4_arm_tag > (s));
          this->choice_3 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void a_content_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "br" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "span" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "bdo" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "map" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &a_content_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice2_arm (static_cast< choice2_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->img_parser_)
          {
            this->img_parser_->pre ();
            ctx.nested_parser (this->img_parser_);
          }
        }
        else
        {
          if (this->img_parser_ != 0)
          {
            this->img_parser_->post_img ();
            this->img ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void a_content_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->br_parser_)
          {
            this->br_parser_->pre ();
            ctx.nested_parser (this->br_parser_);
          }
        }
        else
        {
          if (this->br_parser_ != 0)
          {
            this->br_parser_->post_br ();
            this->br ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->span_parser_)
          {
            this->span_parser_->pre ();
            ctx.nested_parser (this->span_parser_);
          }
        }
        else
        {
          if (this->span_parser_ != 0)
          {
            this->span_parser_->post_span ();
            this->span ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->bdo_parser_)
          {
            this->bdo_parser_->pre ();
            ctx.nested_parser (this->bdo_parser_);
          }
        }
        else
        {
          if (this->bdo_parser_ != 0)
          {
            this->bdo_parser_->post_bdo ();
            this->bdo ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->map_parser_)
          {
            this->map_parser_->pre ();
            ctx.nested_parser (this->map_parser_);
          }
        }
        else
        {
          if (this->map_parser_ != 0)
          {
            this->map_parser_->post_map ();
            this->map ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void a_content_pskel::
  choice_2 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->tt_parser_)
          {
            this->tt_parser_->pre ();
            ctx.nested_parser (this->tt_parser_);
          }
        }
        else
        {
          if (this->tt_parser_ != 0)
          {
            this->tt_parser_->post_tt ();
            this->tt ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->i_parser_)
          {
            this->i_parser_->pre ();
            ctx.nested_parser (this->i_parser_);
          }
        }
        else
        {
          if (this->i_parser_ != 0)
          {
            this->i_parser_->post_i ();
            this->i ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->b_parser_)
          {
            this->b_parser_->pre ();
            ctx.nested_parser (this->b_parser_);
          }
        }
        else
        {
          if (this->b_parser_ != 0)
          {
            this->b_parser_->post_b ();
            this->b ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->big_parser_)
          {
            this->big_parser_->pre ();
            ctx.nested_parser (this->big_parser_);
          }
        }
        else
        {
          if (this->big_parser_ != 0)
          {
            this->big_parser_->post_big ();
            this->big ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->small_parser_)
          {
            this->small_parser_->pre ();
            ctx.nested_parser (this->small_parser_);
          }
        }
        else
        {
          if (this->small_parser_ != 0)
          {
            this->small_parser_->post_small ();
            this->small ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void a_content_pskel::
  choice_3 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->em_parser_)
          {
            this->em_parser_->pre ();
            ctx.nested_parser (this->em_parser_);
          }
        }
        else
        {
          if (this->em_parser_ != 0)
          {
            this->em_parser_->post_em ();
            this->em ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->strong_parser_)
          {
            this->strong_parser_->pre ();
            ctx.nested_parser (this->strong_parser_);
          }
        }
        else
        {
          if (this->strong_parser_ != 0)
          {
            this->strong_parser_->post_strong ();
            this->strong ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dfn_parser_)
          {
            this->dfn_parser_->pre ();
            ctx.nested_parser (this->dfn_parser_);
          }
        }
        else
        {
          if (this->dfn_parser_ != 0)
          {
            this->dfn_parser_->post_dfn ();
            this->dfn ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->code_parser_)
          {
            this->code_parser_->pre ();
            ctx.nested_parser (this->code_parser_);
          }
        }
        else
        {
          if (this->code_parser_ != 0)
          {
            this->code_parser_->post_code ();
            this->code ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->q_parser_)
          {
            this->q_parser_->pre ();
            ctx.nested_parser (this->q_parser_);
          }
        }
        else
        {
          if (this->q_parser_ != 0)
          {
            this->q_parser_->post_q ();
            this->q ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->samp_parser_)
          {
            this->samp_parser_->pre ();
            ctx.nested_parser (this->samp_parser_);
          }
        }
        else
        {
          if (this->samp_parser_ != 0)
          {
            this->samp_parser_->post_samp ();
            this->samp ();
          }

          state = ~0UL;
        }

        break;
      }
      case 6UL:
      {
        if (start)
        {
          if (this->kbd_parser_)
          {
            this->kbd_parser_->pre ();
            ctx.nested_parser (this->kbd_parser_);
          }
        }
        else
        {
          if (this->kbd_parser_ != 0)
          {
            this->kbd_parser_->post_kbd ();
            this->kbd ();
          }

          state = ~0UL;
        }

        break;
      }
      case 7UL:
      {
        if (start)
        {
          if (this->var_parser_)
          {
            this->var_parser_->pre ();
            ctx.nested_parser (this->var_parser_);
          }
        }
        else
        {
          if (this->var_parser_ != 0)
          {
            this->var_parser_->post_var ();
            this->var ();
          }

          state = ~0UL;
        }

        break;
      }
      case 8UL:
      {
        if (start)
        {
          if (this->cite_parser_)
          {
            this->cite_parser_->pre ();
            ctx.nested_parser (this->cite_parser_);
          }
        }
        else
        {
          if (this->cite_parser_ != 0)
          {
            this->cite_parser_->post_cite ();
            this->cite ();
          }

          state = ~0UL;
        }

        break;
      }
      case 9UL:
      {
        if (start)
        {
          if (this->abbr_parser_)
          {
            this->abbr_parser_->pre ();
            ctx.nested_parser (this->abbr_parser_);
          }
        }
        else
        {
          if (this->abbr_parser_ != 0)
          {
            this->abbr_parser_->post_abbr ();
            this->abbr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 10UL:
      {
        if (start)
        {
          if (this->acronym_parser_)
          {
            this->acronym_parser_->pre ();
            ctx.nested_parser (this->acronym_parser_);
          }
        }
        else
        {
          if (this->acronym_parser_ != 0)
          {
            this->acronym_parser_->post_acronym ();
            this->acronym ();
          }

          state = ~0UL;
        }

        break;
      }
      case 11UL:
      {
        if (start)
        {
          if (this->sub_parser_)
          {
            this->sub_parser_->pre ();
            ctx.nested_parser (this->sub_parser_);
          }
        }
        else
        {
          if (this->sub_parser_ != 0)
          {
            this->sub_parser_->post_sub ();
            this->sub ();
          }

          state = ~0UL;
        }

        break;
      }
      case 12UL:
      {
        if (start)
        {
          if (this->sup_parser_)
          {
            this->sup_parser_->pre ();
            ctx.nested_parser (this->sup_parser_);
          }
        }
        else
        {
          if (this->sup_parser_ != 0)
          {
            this->sup_parser_->post_sup ();
            this->sup ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for pre_content_pskel.
  //
  bool pre_content_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "a" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "tt" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "i" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "b" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "big" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "small" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if ((n == "em" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "strong" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dfn" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "code" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "q" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "samp" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "kbd" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "var" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "cite" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "abbr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "acronym" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sub" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "sup" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 2UL;
        else if ((n == "br" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "span" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "bdo" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "map" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &pre_content_pskel::choice_3;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_3 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool pre_content_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void pre_content_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void pre_content_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void pre_content_pskel::
  choice_3 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->a_parser_)
          {
            this->a_parser_->pre ();
            ctx.nested_parser (this->a_parser_);
          }
        }
        else
        {
          if (this->a_parser_ != 0)
          {
            this->a_parser_->post_a ();
            this->a ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "tt" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "i" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "b" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "big" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "small" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &pre_content_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        unsigned long s = ~0UL;

        if (n == "em" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "strong" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dfn" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "code" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "q" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "samp" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;
        else if (n == "kbd" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 6UL;
        else if (n == "var" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 7UL;
        else if (n == "cite" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 8UL;
        else if (n == "abbr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 9UL;
        else if (n == "acronym" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 10UL;
        else if (n == "sub" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 11UL;
        else if (n == "sup" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 12UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &pre_content_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice2_arm (static_cast< choice2_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 3UL:
      {
        unsigned long s = ~0UL;

        if (n == "br" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "span" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "bdo" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "map" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &pre_content_pskel::choice_2;
          vd.state = s;
          vd.count = 0;

          this->choice3_arm (static_cast< choice3_arm_tag > (s));
          this->choice_2 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void pre_content_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->tt_parser_)
          {
            this->tt_parser_->pre ();
            ctx.nested_parser (this->tt_parser_);
          }
        }
        else
        {
          if (this->tt_parser_ != 0)
          {
            this->tt_parser_->post_tt ();
            this->tt ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->i_parser_)
          {
            this->i_parser_->pre ();
            ctx.nested_parser (this->i_parser_);
          }
        }
        else
        {
          if (this->i_parser_ != 0)
          {
            this->i_parser_->post_i ();
            this->i ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->b_parser_)
          {
            this->b_parser_->pre ();
            ctx.nested_parser (this->b_parser_);
          }
        }
        else
        {
          if (this->b_parser_ != 0)
          {
            this->b_parser_->post_b ();
            this->b ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->big_parser_)
          {
            this->big_parser_->pre ();
            ctx.nested_parser (this->big_parser_);
          }
        }
        else
        {
          if (this->big_parser_ != 0)
          {
            this->big_parser_->post_big ();
            this->big ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->small_parser_)
          {
            this->small_parser_->pre ();
            ctx.nested_parser (this->small_parser_);
          }
        }
        else
        {
          if (this->small_parser_ != 0)
          {
            this->small_parser_->post_small ();
            this->small ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void pre_content_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->em_parser_)
          {
            this->em_parser_->pre ();
            ctx.nested_parser (this->em_parser_);
          }
        }
        else
        {
          if (this->em_parser_ != 0)
          {
            this->em_parser_->post_em ();
            this->em ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->strong_parser_)
          {
            this->strong_parser_->pre ();
            ctx.nested_parser (this->strong_parser_);
          }
        }
        else
        {
          if (this->strong_parser_ != 0)
          {
            this->strong_parser_->post_strong ();
            this->strong ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dfn_parser_)
          {
            this->dfn_parser_->pre ();
            ctx.nested_parser (this->dfn_parser_);
          }
        }
        else
        {
          if (this->dfn_parser_ != 0)
          {
            this->dfn_parser_->post_dfn ();
            this->dfn ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->code_parser_)
          {
            this->code_parser_->pre ();
            ctx.nested_parser (this->code_parser_);
          }
        }
        else
        {
          if (this->code_parser_ != 0)
          {
            this->code_parser_->post_code ();
            this->code ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->q_parser_)
          {
            this->q_parser_->pre ();
            ctx.nested_parser (this->q_parser_);
          }
        }
        else
        {
          if (this->q_parser_ != 0)
          {
            this->q_parser_->post_q ();
            this->q ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->samp_parser_)
          {
            this->samp_parser_->pre ();
            ctx.nested_parser (this->samp_parser_);
          }
        }
        else
        {
          if (this->samp_parser_ != 0)
          {
            this->samp_parser_->post_samp ();
            this->samp ();
          }

          state = ~0UL;
        }

        break;
      }
      case 6UL:
      {
        if (start)
        {
          if (this->kbd_parser_)
          {
            this->kbd_parser_->pre ();
            ctx.nested_parser (this->kbd_parser_);
          }
        }
        else
        {
          if (this->kbd_parser_ != 0)
          {
            this->kbd_parser_->post_kbd ();
            this->kbd ();
          }

          state = ~0UL;
        }

        break;
      }
      case 7UL:
      {
        if (start)
        {
          if (this->var_parser_)
          {
            this->var_parser_->pre ();
            ctx.nested_parser (this->var_parser_);
          }
        }
        else
        {
          if (this->var_parser_ != 0)
          {
            this->var_parser_->post_var ();
            this->var ();
          }

          state = ~0UL;
        }

        break;
      }
      case 8UL:
      {
        if (start)
        {
          if (this->cite_parser_)
          {
            this->cite_parser_->pre ();
            ctx.nested_parser (this->cite_parser_);
          }
        }
        else
        {
          if (this->cite_parser_ != 0)
          {
            this->cite_parser_->post_cite ();
            this->cite ();
          }

          state = ~0UL;
        }

        break;
      }
      case 9UL:
      {
        if (start)
        {
          if (this->abbr_parser_)
          {
            this->abbr_parser_->pre ();
            ctx.nested_parser (this->abbr_parser_);
          }
        }
        else
        {
          if (this->abbr_parser_ != 0)
          {
            this->abbr_parser_->post_abbr ();
            this->abbr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 10UL:
      {
        if (start)
        {
          if (this->acronym_parser_)
          {
            this->acronym_parser_->pre ();
            ctx.nested_parser (this->acronym_parser_);
          }
        }
        else
        {
          if (this->acronym_parser_ != 0)
          {
            this->acronym_parser_->post_acronym ();
            this->acronym ();
          }

          state = ~0UL;
        }

        break;
      }
      case 11UL:
      {
        if (start)
        {
          if (this->sub_parser_)
          {
            this->sub_parser_->pre ();
            ctx.nested_parser (this->sub_parser_);
          }
        }
        else
        {
          if (this->sub_parser_ != 0)
          {
            this->sub_parser_->post_sub ();
            this->sub ();
          }

          state = ~0UL;
        }

        break;
      }
      case 12UL:
      {
        if (start)
        {
          if (this->sup_parser_)
          {
            this->sup_parser_->pre ();
            ctx.nested_parser (this->sup_parser_);
          }
        }
        else
        {
          if (this->sup_parser_ != 0)
          {
            this->sup_parser_->post_sup ();
            this->sup ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void pre_content_pskel::
  choice_2 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->br_parser_)
          {
            this->br_parser_->pre ();
            ctx.nested_parser (this->br_parser_);
          }
        }
        else
        {
          if (this->br_parser_ != 0)
          {
            this->br_parser_->post_br ();
            this->br ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->span_parser_)
          {
            this->span_parser_->pre ();
            ctx.nested_parser (this->span_parser_);
          }
        }
        else
        {
          if (this->span_parser_ != 0)
          {
            this->span_parser_->post_span ();
            this->span ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->bdo_parser_)
          {
            this->bdo_parser_->pre ();
            ctx.nested_parser (this->bdo_parser_);
          }
        }
        else
        {
          if (this->bdo_parser_ != 0)
          {
            this->bdo_parser_->post_bdo ();
            this->bdo ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->map_parser_)
          {
            this->map_parser_->pre ();
            ctx.nested_parser (this->map_parser_);
          }
        }
        else
        {
          if (this->map_parser_ != 0)
          {
            this->map_parser_->post_map ();
            this->map ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for ul_pskel.
  //
  bool ul_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "li" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ul_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ul_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ul_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ul_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ul_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "li" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->li_parser_)
            {
              this->li_parser_->pre ();
              ctx.nested_parser (this->li_parser_);
            }
          }
          else
          {
            if (this->li_parser_ != 0)
            {
              this->li_parser_->post_li ();
              this->li ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ol_pskel.
  //
  bool ol_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "li" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ol_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ol_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ol_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ol_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ol_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "li" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->li_parser_)
            {
              this->li_parser_->pre ();
              ctx.nested_parser (this->li_parser_);
            }
          }
          else
          {
            if (this->li_parser_ != 0)
            {
              this->li_parser_->post_li ();
              this->li ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for dl_pskel.
  //
  bool dl_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "dt" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "dd" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &dl_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool dl_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void dl_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void dl_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void dl_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->dt_parser_)
          {
            this->dt_parser_->pre ();
            ctx.nested_parser (this->dt_parser_);
          }
        }
        else
        {
          if (this->dt_parser_ != 0)
          {
            this->dt_parser_->post_dt ();
            this->dt ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->dd_parser_)
          {
            this->dd_parser_->pre ();
            ctx.nested_parser (this->dd_parser_);
          }
        }
        else
        {
          if (this->dd_parser_ != 0)
          {
            this->dd_parser_->post_dd ();
            this->dd ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for map_pskel.
  //
  bool map_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if ((n == "p" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h1" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h2" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h3" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h4" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h5" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h6" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "div" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ul" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ol" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "dl" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "pre" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "hr" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "blockquote" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "address" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "table" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;
        else if (n == "area" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &map_pskel::choice_5;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_5 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool map_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void map_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void map_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void map_pskel::
  choice_5 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if ((n == "p" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h1" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h2" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h3" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h4" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h5" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "h6" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "div" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ul" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "ol" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "dl" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "pre" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "hr" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "blockquote" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "address" &&
             ns == "http://www.w3.org/1999/xhtml") ||
            (n == "table" &&
             ns == "http://www.w3.org/1999/xhtml"))
          s = 0UL;

        if (s != ~0UL)
        {
          assert (start);
          count++;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &map_pskel::choice_4;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_4 (vd.state, vd.count, ns, n, true);
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (n == "area" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->area_parser_)
            {
              this->area_parser_->pre ();
              ctx.nested_parser (this->area_parser_);
            }
          }
          else
          {
            if (this->area_parser_ != 0)
            {
              this->area_parser_->post_area ();
              this->area ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
    }
  }

  void map_pskel::
  choice_4 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        unsigned long s = ~0UL;

        if (n == "p" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "h1" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h2" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h3" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h4" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h5" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "h6" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if (n == "div" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if ((n == "ul" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "ol" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "dl" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 3UL;
        else if ((n == "pre" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "hr" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "blockquote" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "address" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 4UL;
        else if (n == "table" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &map_pskel::choice_3;
          vd.state = s;
          vd.count = 0;

          this->choice2_arm (static_cast< choice2_arm_tag > (s));
          this->choice_3 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
    }
  }

  void map_pskel::
  choice_3 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->p_parser_)
          {
            this->p_parser_->pre ();
            ctx.nested_parser (this->p_parser_);
          }
        }
        else
        {
          if (this->p_parser_ != 0)
          {
            this->p_parser_->post_p ();
            this->p ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "h1" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "h2" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "h3" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "h4" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if (n == "h5" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 4UL;
        else if (n == "h6" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 5UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &map_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice3_arm (static_cast< choice3_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->div_parser_)
          {
            this->div_parser_->pre ();
            ctx.nested_parser (this->div_parser_);
          }
        }
        else
        {
          if (this->div_parser_ != 0)
          {
            this->div_parser_->post_div ();
            this->div ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        unsigned long s = ~0UL;

        if (n == "ul" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "ol" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "dl" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &map_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice4_arm (static_cast< choice4_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 4UL:
      {
        unsigned long s = ~0UL;

        if (n == "pre" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "hr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;
        else if (n == "blockquote" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "address" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;

        if (s != ~0UL)
        {
          assert (start);
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &map_pskel::choice_2;
          vd.state = s;
          vd.count = 0;

          this->choice5_arm (static_cast< choice5_arm_tag > (s));
          this->choice_2 (vd.state, vd.count, ns, n, true);
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->table_parser_)
          {
            this->table_parser_->pre ();
            ctx.nested_parser (this->table_parser_);
          }
        }
        else
        {
          if (this->table_parser_ != 0)
          {
            this->table_parser_->post_table ();
            this->table ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void map_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->h1_parser_)
          {
            this->h1_parser_->pre ();
            ctx.nested_parser (this->h1_parser_);
          }
        }
        else
        {
          if (this->h1_parser_ != 0)
          {
            this->h1_parser_->post_h1 ();
            this->h1 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->h2_parser_)
          {
            this->h2_parser_->pre ();
            ctx.nested_parser (this->h2_parser_);
          }
        }
        else
        {
          if (this->h2_parser_ != 0)
          {
            this->h2_parser_->post_h2 ();
            this->h2 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->h3_parser_)
          {
            this->h3_parser_->pre ();
            ctx.nested_parser (this->h3_parser_);
          }
        }
        else
        {
          if (this->h3_parser_ != 0)
          {
            this->h3_parser_->post_h3 ();
            this->h3 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->h4_parser_)
          {
            this->h4_parser_->pre ();
            ctx.nested_parser (this->h4_parser_);
          }
        }
        else
        {
          if (this->h4_parser_ != 0)
          {
            this->h4_parser_->post_h4 ();
            this->h4 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          if (this->h5_parser_)
          {
            this->h5_parser_->pre ();
            ctx.nested_parser (this->h5_parser_);
          }
        }
        else
        {
          if (this->h5_parser_ != 0)
          {
            this->h5_parser_->post_h5 ();
            this->h5 ();
          }

          state = ~0UL;
        }

        break;
      }
      case 5UL:
      {
        if (start)
        {
          if (this->h6_parser_)
          {
            this->h6_parser_->pre ();
            ctx.nested_parser (this->h6_parser_);
          }
        }
        else
        {
          if (this->h6_parser_ != 0)
          {
            this->h6_parser_->post_h6 ();
            this->h6 ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void map_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->ul_parser_)
          {
            this->ul_parser_->pre ();
            ctx.nested_parser (this->ul_parser_);
          }
        }
        else
        {
          if (this->ul_parser_ != 0)
          {
            this->ul_parser_->post_ul ();
            this->ul ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->ol_parser_)
          {
            this->ol_parser_->pre ();
            ctx.nested_parser (this->ol_parser_);
          }
        }
        else
        {
          if (this->ol_parser_ != 0)
          {
            this->ol_parser_->post_ol ();
            this->ol ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->dl_parser_)
          {
            this->dl_parser_->pre ();
            ctx.nested_parser (this->dl_parser_);
          }
        }
        else
        {
          if (this->dl_parser_ != 0)
          {
            this->dl_parser_->post_dl ();
            this->dl ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  void map_pskel::
  choice_2 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->pre_parser_)
          {
            this->pre_parser_->pre ();
            ctx.nested_parser (this->pre_parser_);
          }
        }
        else
        {
          if (this->pre_parser_ != 0)
          {
            this->pre_parser_->post_pre ();
            this->pre ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->hr_parser_)
          {
            this->hr_parser_->pre ();
            ctx.nested_parser (this->hr_parser_);
          }
        }
        else
        {
          if (this->hr_parser_ != 0)
          {
            this->hr_parser_->post_hr ();
            this->hr ();
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          if (this->blockquote_parser_)
          {
            this->blockquote_parser_->pre ();
            ctx.nested_parser (this->blockquote_parser_);
          }
        }
        else
        {
          if (this->blockquote_parser_ != 0)
          {
            this->blockquote_parser_->post_blockquote ();
            this->blockquote ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          if (this->address_parser_)
          {
            this->address_parser_->pre ();
            ctx.nested_parser (this->address_parser_);
          }
        }
        else
        {
          if (this->address_parser_ != 0)
          {
            this->address_parser_->post_address ();
            this->address ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for table_pskel.
  //
  bool table_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "caption" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if ((n == "col" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "colgroup" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 1UL;
        else if (n == "thead" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 2UL;
        else if (n == "tfoot" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 3UL;
        else if ((n == "tbody" &&
                  ns == "http://www.w3.org/1999/xhtml") ||
                 (n == "tr" &&
                  ns == "http://www.w3.org/1999/xhtml"))
          s = 4UL;

        if (s > 1UL)
        {
          this->choice_arm (col_tag);
        }


        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &table_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool table_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void table_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void table_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void table_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "caption" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->caption_parser_)
            {
              this->caption_parser_->pre ();
              ctx.nested_parser (this->caption_parser_);
            }
          }
          else
          {
            if (this->caption_parser_ != 0)
            {
              this->caption_parser_->post_caption ();
              this->caption ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        unsigned long s = ~0UL;

        if (n == "col" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "colgroup" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          assert (start);
          count = 0;
          state = 2UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &table_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_0 (vd.state, vd.count, ns, n, true);
          break;
        }
        else
        {
          assert (start);
          this->choice_arm (col_tag);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "thead" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->thead_parser_)
            {
              this->thead_parser_->pre ();
              ctx.nested_parser (this->thead_parser_);
            }
          }
          else
          {
            if (this->thead_parser_ != 0)
            {
              this->thead_parser_->post_thead ();
              this->thead ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "tfoot" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->tfoot_parser_)
            {
              this->tfoot_parser_->pre ();
              ctx.nested_parser (this->tfoot_parser_);
            }
          }
          else
          {
            if (this->tfoot_parser_ != 0)
            {
              this->tfoot_parser_->post_tfoot ();
              this->tfoot ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        unsigned long s = ~0UL;

        if (n == "tbody" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "tr" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          assert (start);
          count = 0;
          state = ~0UL;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &table_pskel::choice_1;
          vd.state = s;
          vd.count = 0;

          this->choice1_arm (static_cast< choice1_arm_tag > (s));
          this->choice_1 (vd.state, vd.count, ns, n, true);
          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  void table_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "col" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->col_parser_)
            {
              this->col_parser_->pre ();
              ctx.nested_parser (this->col_parser_);
            }
          }
          else
          {
            if (this->col_parser_ != 0)
            {
              this->col_parser_->post_col ();
              this->col ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (n == "colgroup" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->colgroup_parser_)
            {
              this->colgroup_parser_->pre ();
              ctx.nested_parser (this->colgroup_parser_);
            }
          }
          else
          {
            if (this->colgroup_parser_ != 0)
            {
              this->colgroup_parser_->post_colgroup ();
              this->colgroup ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
    }
  }

  void table_pskel::
  choice_1 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "tbody" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->tbody_parser_)
            {
              this->tbody_parser_->pre ();
              ctx.nested_parser (this->tbody_parser_);
            }
          }
          else
          {
            if (this->tbody_parser_ != 0)
            {
              this->tbody_parser_->post_tbody ();
              this->tbody ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->tr_parser_)
            {
              this->tr_parser_->pre ();
              ctx.nested_parser (this->tr_parser_);
            }
          }
          else
          {
            if (this->tr_parser_ != 0)
            {
              this->tr_parser_->post_tr ();
              this->tr ();
            }

            count++;
          }
        }
        else
        {
          assert (start);
          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for thead_pskel.
  //
  bool thead_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &thead_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool thead_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void thead_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void thead_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void thead_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->tr_parser_)
            {
              this->tr_parser_->pre ();
              ctx.nested_parser (this->tr_parser_);
            }
          }
          else
          {
            if (this->tr_parser_ != 0)
            {
              this->tr_parser_->post_tr ();
              this->tr ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for tfoot_pskel.
  //
  bool tfoot_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &tfoot_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool tfoot_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void tfoot_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void tfoot_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void tfoot_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->tr_parser_)
            {
              this->tr_parser_->pre ();
              ctx.nested_parser (this->tr_parser_);
            }
          }
          else
          {
            if (this->tr_parser_ != 0)
            {
              this->tr_parser_->post_tr ();
              this->tr ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for tbody_pskel.
  //
  bool tbody_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &tbody_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool tbody_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void tbody_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void tbody_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void tbody_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "tr" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->tr_parser_)
            {
              this->tr_parser_->pre ();
              ctx.nested_parser (this->tr_parser_);
            }
          }
          else
          {
            if (this->tr_parser_ != 0)
            {
              this->tr_parser_->post_tr ();
              this->tr ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for colgroup_pskel.
  //
  bool colgroup_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "col" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &colgroup_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool colgroup_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void colgroup_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void colgroup_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void colgroup_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "col" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->col_parser_)
            {
              this->col_parser_->pre ();
              ctx.nested_parser (this->col_parser_);
            }
          }
          else
          {
            if (this->col_parser_ != 0)
            {
              this->col_parser_->post_col ();
              this->col ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for tr_pskel.
  //
  bool tr_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "th" &&
            ns == "http://www.w3.org/1999/xhtml")
          s = 0UL;
        else if (n == "td" &&
                 ns == "http://www.w3.org/1999/xhtml")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;

          vd = vs.data + vs.size++;
          vd->func = &tr_pskel::choice_0;
          vd->state = s;
          vd->count = 0;

          this->choice_arm (static_cast< choice_arm_tag > (s));
          this->choice_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool tr_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void tr_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void tr_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void tr_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xsde::cxx::ro_string& ns,
            const ::xsde::cxx::ro_string& n,
            bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (count);
    XSDE_UNUSED (ns);
    XSDE_UNUSED (n);
    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          if (this->th_parser_)
          {
            this->th_parser_->pre ();
            ctx.nested_parser (this->th_parser_);
          }
        }
        else
        {
          if (this->th_parser_ != 0)
          {
            this->th_parser_->post_th ();
            this->th ();
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          if (this->td_parser_)
          {
            this->td_parser_->pre ();
            ctx.nested_parser (this->td_parser_);
          }
        }
        else
        {
          if (this->td_parser_ != 0)
          {
            this->td_parser_->post_td ();
            this->td ();
          }

          state = ~0UL;
        }

        break;
      }
    }
  }
}

namespace xhtml
{
  // Attribute validation and dispatch functions for div_pskel.
  //
  bool div_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Flow_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for p_pskel.
  //
  bool p_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for h1_pskel.
  //
  bool h1_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for h2_pskel.
  //
  bool h2_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for h3_pskel.
  //
  bool h3_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for h4_pskel.
  //
  bool h4_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for h5_pskel.
  //
  bool h5_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for h6_pskel.
  //
  bool h6_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ul_pskel.
  //
  bool ul_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for ol_pskel.
  //
  bool ol_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for li_pskel.
  //
  bool li_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Flow_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for dl_pskel.
  //
  bool dl_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for dt_pskel.
  //
  bool dt_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for dd_pskel.
  //
  bool dd_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Flow_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for address_pskel.
  //
  bool address_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for hr_pskel.
  //
  bool hr_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for pre_pskel.
  //
  bool pre_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "space" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->space_parser_)
      {
        this->space_parser_->pre ();

        this->space_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->space_parser_->_characters (s);

        if (!ctx.error_type ())
          this->space_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->space_parser_->post_space ();

        this->space ();
      }

      return true;
    }

    typedef ::xhtml::pre_content_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for blockquote_pskel.
  //
  bool blockquote_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "cite" && ns.empty ())
    {
      if (this->cite_parser_)
      {
        this->cite_parser_->pre ();

        this->cite_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->cite_parser_->_characters (s);

        if (!ctx.error_type ())
          this->cite_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->cite_parser_->post_URI ();

        this->cite ();
      }

      return true;
    }

    typedef ::xhtml::Block_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for a_pskel.
  //
  bool a_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "accesskey" && ns.empty ())
    {
      if (this->accesskey_parser_)
      {
        this->accesskey_parser_->pre ();

        this->accesskey_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->accesskey_parser_->_characters (s);

        if (!ctx.error_type ())
          this->accesskey_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->accesskey_parser_->post_Character ();

        this->accesskey ();
      }

      return true;
    }

    if (n == "tabindex" && ns.empty ())
    {
      if (this->tabindex_parser_)
      {
        this->tabindex_parser_->pre ();

        this->tabindex_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->tabindex_parser_->_characters (s);

        if (!ctx.error_type ())
          this->tabindex_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->tabindex_parser_->post_tabindexNumber ();

        this->tabindex ();
      }

      return true;
    }

    if (n == "charset" && ns.empty ())
    {
      if (this->charset_parser_)
      {
        this->charset_parser_->pre ();

        this->charset_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charset_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charset_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charset_parser_->post_Charset ();

        this->charset ();
      }

      return true;
    }

    if (n == "type" && ns.empty ())
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();

        this->type_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->type_parser_->_characters (s);

        if (!ctx.error_type ())
          this->type_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->type_parser_->post_ContentType ();

        this->type ();
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();

        this->name_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->name_parser_->_characters (s);

        if (!ctx.error_type ())
          this->name_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->name_parser_->post_nmtoken ();

          this->name (tmp);
        }
      }

      return true;
    }

    if (n == "href" && ns.empty ())
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();

        this->href_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->href_parser_->_characters (s);

        if (!ctx.error_type ())
          this->href_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->href_parser_->post_URI ();

        this->href ();
      }

      return true;
    }

    if (n == "hreflang" && ns.empty ())
    {
      if (this->hreflang_parser_)
      {
        this->hreflang_parser_->pre ();

        this->hreflang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->hreflang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->hreflang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->hreflang_parser_->post_LanguageCode ();

        this->hreflang ();
      }

      return true;
    }

    if (n == "rel" && ns.empty ())
    {
      if (this->rel_parser_)
      {
        this->rel_parser_->pre ();

        this->rel_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->rel_parser_->_characters (s);

        if (!ctx.error_type ())
          this->rel_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->rel_parser_->post_LinkTypes ();

        this->rel ();
      }

      return true;
    }

    if (n == "rev" && ns.empty ())
    {
      if (this->rev_parser_)
      {
        this->rev_parser_->pre ();

        this->rev_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->rev_parser_->_characters (s);

        if (!ctx.error_type ())
          this->rev_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->rev_parser_->post_LinkTypes ();

        this->rev ();
      }

      return true;
    }

    if (n == "shape" && ns.empty ())
    {
      if (this->shape_parser_)
      {
        this->shape_parser_->pre ();

        this->shape_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->shape_parser_->_characters (s);

        if (!ctx.error_type ())
          this->shape_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->shape_parser_->post_Shape ();

        this->shape ();
      }

      return true;
    }

    if (n == "coords" && ns.empty ())
    {
      if (this->coords_parser_)
      {
        this->coords_parser_->pre ();

        this->coords_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->coords_parser_->_characters (s);

        if (!ctx.error_type ())
          this->coords_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->coords_parser_->post_Coords ();

        this->coords ();
      }

      return true;
    }

    typedef ::xhtml::a_content_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for span_pskel.
  //
  bool span_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for bdo_pskel.
  //
  bool bdo_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->dir = true;
      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  void bdo_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.dir = false;
    typedef ::xhtml::Inline_pskel base;
    base::_pre_a_validate ();
  }

  void bdo_pskel::
  _post_a_validate ()
  {
    typedef ::xhtml::Inline_pskel base;
    base::_post_a_validate ();

    if (this->_context ().error_type ())
      return;

    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.dir)
    {
      this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
      return;
    }


    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for br_pskel.
  //
  bool br_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for em_pskel.
  //
  bool em_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for strong_pskel.
  //
  bool strong_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for dfn_pskel.
  //
  bool dfn_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for code_pskel.
  //
  bool code_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for samp_pskel.
  //
  bool samp_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for kbd_pskel.
  //
  bool kbd_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for var_pskel.
  //
  bool var_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for cite_pskel.
  //
  bool cite_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for abbr_pskel.
  //
  bool abbr_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for acronym_pskel.
  //
  bool acronym_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for q_pskel.
  //
  bool q_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "cite" && ns.empty ())
    {
      if (this->cite1_parser_)
      {
        this->cite1_parser_->pre ();

        this->cite1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->cite1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->cite1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->cite1_parser_->post_URI ();

        this->cite1 ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for sub_pskel.
  //
  bool sub_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for sup_pskel.
  //
  bool sup_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for tt_pskel.
  //
  bool tt_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for i_pskel.
  //
  bool i_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for b_pskel.
  //
  bool b_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for big_pskel.
  //
  bool big_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for small_pskel.
  //
  bool small_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for img_pskel.
  //
  bool img_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "src" && ns.empty ())
    {
      if (this->src_parser_)
      {
        this->src_parser_->pre ();

        this->src_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->src_parser_->_characters (s);

        if (!ctx.error_type ())
          this->src_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->src_parser_->post_URI ();

        this->src ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->src = true;
      return true;
    }

    if (n == "alt" && ns.empty ())
    {
      if (this->alt_parser_)
      {
        this->alt_parser_->pre ();

        this->alt_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->alt_parser_->_characters (s);

        if (!ctx.error_type ())
          this->alt_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->alt_parser_->post_Text ();

        this->alt ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->alt = true;
      return true;
    }

    if (n == "longdesc" && ns.empty ())
    {
      if (this->longdesc_parser_)
      {
        this->longdesc_parser_->pre ();

        this->longdesc_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->longdesc_parser_->_characters (s);

        if (!ctx.error_type ())
          this->longdesc_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->longdesc_parser_->post_URI ();

        this->longdesc ();
      }

      return true;
    }

    if (n == "height" && ns.empty ())
    {
      if (this->height_parser_)
      {
        this->height_parser_->pre ();

        this->height_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->height_parser_->_characters (s);

        if (!ctx.error_type ())
          this->height_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->height_parser_->post_Length ();

        this->height ();
      }

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
      {
        this->width_parser_->pre ();

        this->width_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->width_parser_->_characters (s);

        if (!ctx.error_type ())
          this->width_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->width_parser_->post_Length ();

        this->width ();
      }

      return true;
    }

    if (n == "usemap" && ns.empty ())
    {
      if (this->usemap_parser_)
      {
        this->usemap_parser_->pre ();

        this->usemap_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->usemap_parser_->_characters (s);

        if (!ctx.error_type ())
          this->usemap_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->usemap_parser_->post_URI ();

        this->usemap ();
      }

      return true;
    }

    if (n == "ismap" && ns.empty ())
    {
      if (this->ismap_parser_)
      {
        this->ismap_parser_->pre ();

        this->ismap_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->ismap_parser_->_characters (s);

        if (!ctx.error_type ())
          this->ismap_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->ismap_parser_->post_ismap ();

        this->ismap ();
      }

      return true;
    }

    return false;
  }

  void img_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.src = false;
    as.alt = false;
  }

  void img_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.src)
    {
      this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
      return;
    }

    if (!as.alt)
    {
      this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
      return;
    }


    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for map_pskel.
  //
  bool map_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->class__parser_->post_any_simple_type ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();

        this->name_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->name_parser_->_characters (s);

        if (!ctx.error_type ())
          this->name_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->name_parser_->post_nmtoken ();

          this->name (tmp);
        }
      }

      return true;
    }

    return false;
  }

  void map_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
  }

  void map_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
    {
      this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
      return;
    }


    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for area_pskel.
  //
  bool area_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "accesskey" && ns.empty ())
    {
      if (this->accesskey_parser_)
      {
        this->accesskey_parser_->pre ();

        this->accesskey_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->accesskey_parser_->_characters (s);

        if (!ctx.error_type ())
          this->accesskey_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->accesskey_parser_->post_Character ();

        this->accesskey ();
      }

      return true;
    }

    if (n == "tabindex" && ns.empty ())
    {
      if (this->tabindex_parser_)
      {
        this->tabindex_parser_->pre ();

        this->tabindex_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->tabindex_parser_->_characters (s);

        if (!ctx.error_type ())
          this->tabindex_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->tabindex_parser_->post_tabindexNumber ();

        this->tabindex ();
      }

      return true;
    }

    if (n == "shape" && ns.empty ())
    {
      if (this->shape_parser_)
      {
        this->shape_parser_->pre ();

        this->shape_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->shape_parser_->_characters (s);

        if (!ctx.error_type ())
          this->shape_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->shape_parser_->post_Shape ();

        this->shape ();
      }

      return true;
    }

    if (n == "coords" && ns.empty ())
    {
      if (this->coords_parser_)
      {
        this->coords_parser_->pre ();

        this->coords_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->coords_parser_->_characters (s);

        if (!ctx.error_type ())
          this->coords_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->coords_parser_->post_Coords ();

        this->coords ();
      }

      return true;
    }

    if (n == "href" && ns.empty ())
    {
      if (this->href_parser_)
      {
        this->href_parser_->pre ();

        this->href_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->href_parser_->_characters (s);

        if (!ctx.error_type ())
          this->href_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->href_parser_->post_URI ();

        this->href ();
      }

      return true;
    }

    if (n == "nohref" && ns.empty ())
    {
      if (this->nohref_parser_)
      {
        this->nohref_parser_->pre ();

        this->nohref_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->nohref_parser_->_characters (s);

        if (!ctx.error_type ())
          this->nohref_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->nohref_parser_->post_nohref ();

        this->nohref ();
      }

      return true;
    }

    if (n == "alt" && ns.empty ())
    {
      if (this->alt_parser_)
      {
        this->alt_parser_->pre ();

        this->alt_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->alt_parser_->_characters (s);

        if (!ctx.error_type ())
          this->alt_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->alt_parser_->post_Text ();

        this->alt ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->alt = true;
      return true;
    }

    return false;
  }

  void area_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.alt = false;
  }

  void area_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.alt)
    {
      this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
      return;
    }


    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for table_pskel.
  //
  bool table_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "summary" && ns.empty ())
    {
      if (this->summary_parser_)
      {
        this->summary_parser_->pre ();

        this->summary_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->summary_parser_->_characters (s);

        if (!ctx.error_type ())
          this->summary_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->summary_parser_->post_Text ();

        this->summary ();
      }

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
      {
        this->width_parser_->pre ();

        this->width_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->width_parser_->_characters (s);

        if (!ctx.error_type ())
          this->width_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->width_parser_->post_Length ();

        this->width ();
      }

      return true;
    }

    if (n == "border" && ns.empty ())
    {
      if (this->border_parser_)
      {
        this->border_parser_->pre ();

        this->border_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->border_parser_->_characters (s);

        if (!ctx.error_type ())
          this->border_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->border_parser_->post_Pixels ();

        this->border ();
      }

      return true;
    }

    if (n == "frame" && ns.empty ())
    {
      if (this->frame_parser_)
      {
        this->frame_parser_->pre ();

        this->frame_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->frame_parser_->_characters (s);

        if (!ctx.error_type ())
          this->frame_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->frame_parser_->post_TFrame ();

        this->frame ();
      }

      return true;
    }

    if (n == "rules" && ns.empty ())
    {
      if (this->rules_parser_)
      {
        this->rules_parser_->pre ();

        this->rules_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->rules_parser_->_characters (s);

        if (!ctx.error_type ())
          this->rules_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->rules_parser_->post_TRules ();

        this->rules ();
      }

      return true;
    }

    if (n == "cellspacing" && ns.empty ())
    {
      if (this->cellspacing_parser_)
      {
        this->cellspacing_parser_->pre ();

        this->cellspacing_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->cellspacing_parser_->_characters (s);

        if (!ctx.error_type ())
          this->cellspacing_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->cellspacing_parser_->post_Length ();

        this->cellspacing ();
      }

      return true;
    }

    if (n == "cellpadding" && ns.empty ())
    {
      if (this->cellpadding_parser_)
      {
        this->cellpadding_parser_->pre ();

        this->cellpadding_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->cellpadding_parser_->_characters (s);

        if (!ctx.error_type ())
          this->cellpadding_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->cellpadding_parser_->post_Length ();

        this->cellpadding ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for caption_pskel.
  //
  bool caption_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    typedef ::xhtml::Inline_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for thead_pskel.
  //
  bool thead_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for tfoot_pskel.
  //
  bool tfoot_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for tbody_pskel.
  //
  bool tbody_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for colgroup_pskel.
  //
  bool colgroup_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "span" && ns.empty ())
    {
      if (this->span_parser_)
      {
        this->span_parser_->pre ();

        this->span_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->span_parser_->_characters (s);

        if (!ctx.error_type ())
          this->span_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->span_parser_->post_Number ();

        this->span ();
      }

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
      {
        this->width_parser_->pre ();

        this->width_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->width_parser_->_characters (s);

        if (!ctx.error_type ())
          this->width_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->width_parser_->post_MultiLength ();

        this->width ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for col_pskel.
  //
  bool col_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "span" && ns.empty ())
    {
      if (this->span_parser_)
      {
        this->span_parser_->pre ();

        this->span_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->span_parser_->_characters (s);

        if (!ctx.error_type ())
          this->span_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->span_parser_->post_Number ();

        this->span ();
      }

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
      {
        this->width_parser_->pre ();

        this->width_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->width_parser_->_characters (s);

        if (!ctx.error_type ())
          this->width_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->width_parser_->post_MultiLength ();

        this->width ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for tr_pskel.
  //
  bool tr_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for th_pskel.
  //
  bool th_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "abbr" && ns.empty ())
    {
      if (this->abbr1_parser_)
      {
        this->abbr1_parser_->pre ();

        this->abbr1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->abbr1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->abbr1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->abbr1_parser_->post_Text ();

        this->abbr1 ();
      }

      return true;
    }

    if (n == "axis" && ns.empty ())
    {
      if (this->axis_parser_)
      {
        this->axis_parser_->pre ();

        this->axis_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->axis_parser_->_characters (s);

        if (!ctx.error_type ())
          this->axis_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->axis_parser_->post_any_simple_type ();

          this->axis (tmp);
        }
      }

      return true;
    }

    if (n == "headers" && ns.empty ())
    {
      if (this->headers_parser_)
      {
        this->headers_parser_->pre ();

        this->headers_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->headers_parser_->_characters (s);

        if (!ctx.error_type ())
          this->headers_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->headers_parser_->post_idrefs ();

          this->headers (tmp);
        }
      }

      return true;
    }

    if (n == "scope" && ns.empty ())
    {
      if (this->scope_parser_)
      {
        this->scope_parser_->pre ();

        this->scope_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->scope_parser_->_characters (s);

        if (!ctx.error_type ())
          this->scope_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->scope_parser_->post_Scope ();

        this->scope ();
      }

      return true;
    }

    if (n == "rowspan" && ns.empty ())
    {
      if (this->rowspan_parser_)
      {
        this->rowspan_parser_->pre ();

        this->rowspan_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->rowspan_parser_->_characters (s);

        if (!ctx.error_type ())
          this->rowspan_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->rowspan_parser_->post_Number ();

        this->rowspan ();
      }

      return true;
    }

    if (n == "colspan" && ns.empty ())
    {
      if (this->colspan_parser_)
      {
        this->colspan_parser_->pre ();

        this->colspan_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->colspan_parser_->_characters (s);

        if (!ctx.error_type ())
          this->colspan_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->colspan_parser_->post_Number ();

        this->colspan ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    typedef ::xhtml::Flow_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for td_pskel.
  //
  bool td_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->id_parser_->post_id ();

          this->id (tmp);
        }
      }

      return true;
    }

    if (n == "class" && ns.empty ())
    {
      if (this->class__parser_)
      {
        this->class__parser_->pre ();

        this->class__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->class__parser_->_characters (s);

        if (!ctx.error_type ())
          this->class__parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->class__parser_->post_nmtokens ();

          this->class_ (tmp);
        }
      }

      return true;
    }

    if (n == "style" && ns.empty ())
    {
      if (this->style_parser_)
      {
        this->style_parser_->pre ();

        this->style_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->style_parser_->_characters (s);

        if (!ctx.error_type ())
          this->style_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->style_parser_->post_StyleSheet ();

        this->style ();
      }

      return true;
    }

    if (n == "title" && ns.empty ())
    {
      if (this->title_parser_)
      {
        this->title_parser_->pre ();

        this->title_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->title_parser_->_characters (s);

        if (!ctx.error_type ())
          this->title_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->title_parser_->post_Text ();

        this->title ();
      }

      return true;
    }

    if (n == "lang" && ns.empty ())
    {
      if (this->lang_parser_)
      {
        this->lang_parser_->pre ();

        this->lang_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang_parser_->post_LanguageCode ();

        this->lang ();
      }

      return true;
    }

    if (n == "lang" &&
        ns == "http://www.w3.org/XML/1998/namespace")
    {
      if (this->lang1_parser_)
      {
        this->lang1_parser_->pre ();

        this->lang1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->lang1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->lang1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->lang1_parser_->post_lang ();

        this->lang1 ();
      }

      return true;
    }

    if (n == "dir" && ns.empty ())
    {
      if (this->dir_parser_)
      {
        this->dir_parser_->pre ();

        this->dir_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->dir_parser_->_characters (s);

        if (!ctx.error_type ())
          this->dir_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->dir_parser_->post_dir ();

        this->dir ();
      }

      return true;
    }

    if (n == "abbr" && ns.empty ())
    {
      if (this->abbr1_parser_)
      {
        this->abbr1_parser_->pre ();

        this->abbr1_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->abbr1_parser_->_characters (s);

        if (!ctx.error_type ())
          this->abbr1_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->abbr1_parser_->post_Text ();

        this->abbr1 ();
      }

      return true;
    }

    if (n == "axis" && ns.empty ())
    {
      if (this->axis_parser_)
      {
        this->axis_parser_->pre ();

        this->axis_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->axis_parser_->_characters (s);

        if (!ctx.error_type ())
          this->axis_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          const ::std::string& tmp = this->axis_parser_->post_any_simple_type ();

          this->axis (tmp);
        }
      }

      return true;
    }

    if (n == "headers" && ns.empty ())
    {
      if (this->headers_parser_)
      {
        this->headers_parser_->pre ();

        this->headers_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->headers_parser_->_characters (s);

        if (!ctx.error_type ())
          this->headers_parser_->_post_impl ();

        if (!ctx.error_type ())
        {
          ::xml_schema::string_sequence* tmp = this->headers_parser_->post_idrefs ();

          this->headers (tmp);
        }
      }

      return true;
    }

    if (n == "scope" && ns.empty ())
    {
      if (this->scope_parser_)
      {
        this->scope_parser_->pre ();

        this->scope_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->scope_parser_->_characters (s);

        if (!ctx.error_type ())
          this->scope_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->scope_parser_->post_Scope ();

        this->scope ();
      }

      return true;
    }

    if (n == "rowspan" && ns.empty ())
    {
      if (this->rowspan_parser_)
      {
        this->rowspan_parser_->pre ();

        this->rowspan_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->rowspan_parser_->_characters (s);

        if (!ctx.error_type ())
          this->rowspan_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->rowspan_parser_->post_Number ();

        this->rowspan ();
      }

      return true;
    }

    if (n == "colspan" && ns.empty ())
    {
      if (this->colspan_parser_)
      {
        this->colspan_parser_->pre ();

        this->colspan_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->colspan_parser_->_characters (s);

        if (!ctx.error_type ())
          this->colspan_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->colspan_parser_->post_Number ();

        this->colspan ();
      }

      return true;
    }

    if (n == "align" && ns.empty ())
    {
      if (this->align_parser_)
      {
        this->align_parser_->pre ();

        this->align_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->align_parser_->_characters (s);

        if (!ctx.error_type ())
          this->align_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->align_parser_->post_align ();

        this->align ();
      }

      return true;
    }

    if (n == "char" && ns.empty ())
    {
      if (this->char__parser_)
      {
        this->char__parser_->pre ();

        this->char__parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->char__parser_->_characters (s);

        if (!ctx.error_type ())
          this->char__parser_->_post_impl ();

        if (!ctx.error_type ())
          this->char__parser_->post_Character ();

        this->char_ ();
      }

      return true;
    }

    if (n == "charoff" && ns.empty ())
    {
      if (this->charoff_parser_)
      {
        this->charoff_parser_->pre ();

        this->charoff_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->charoff_parser_->_characters (s);

        if (!ctx.error_type ())
          this->charoff_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->charoff_parser_->post_Length ();

        this->charoff ();
      }

      return true;
    }

    if (n == "valign" && ns.empty ())
    {
      if (this->valign_parser_)
      {
        this->valign_parser_->pre ();

        this->valign_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->valign_parser_->_characters (s);

        if (!ctx.error_type ())
          this->valign_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->valign_parser_->post_valign ();

        this->valign ();
      }

      return true;
    }

    typedef ::xhtml::Flow_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace xhtml
{
  // Character validation functions for Inline_pskel.
  //
  bool Inline_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for Flow_pskel.
  //
  bool Flow_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for a_content_pskel.
  //
  bool a_content_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for pre_content_pskel.
  //
  bool pre_content_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for div_pskel.
  //
  bool div_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for p_pskel.
  //
  bool p_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for h1_pskel.
  //
  bool h1_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for h2_pskel.
  //
  bool h2_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for h3_pskel.
  //
  bool h3_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for h4_pskel.
  //
  bool h4_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for h5_pskel.
  //
  bool h5_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for h6_pskel.
  //
  bool h6_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for li_pskel.
  //
  bool li_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for dt_pskel.
  //
  bool dt_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for dd_pskel.
  //
  bool dd_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for address_pskel.
  //
  bool address_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for pre_pskel.
  //
  bool pre_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for a_pskel.
  //
  bool a_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for span_pskel.
  //
  bool span_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for bdo_pskel.
  //
  bool bdo_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for em_pskel.
  //
  bool em_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for strong_pskel.
  //
  bool strong_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for dfn_pskel.
  //
  bool dfn_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for code_pskel.
  //
  bool code_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for samp_pskel.
  //
  bool samp_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for kbd_pskel.
  //
  bool kbd_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for var_pskel.
  //
  bool var_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for cite_pskel.
  //
  bool cite_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for abbr_pskel.
  //
  bool abbr_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for acronym_pskel.
  //
  bool acronym_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for q_pskel.
  //
  bool q_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for sub_pskel.
  //
  bool sub_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for sup_pskel.
  //
  bool sup_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for tt_pskel.
  //
  bool tt_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for i_pskel.
  //
  bool i_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for b_pskel.
  //
  bool b_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for big_pskel.
  //
  bool big_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for small_pskel.
  //
  bool small_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for caption_pskel.
  //
  bool caption_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for th_pskel.
  //
  bool th_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }

  // Character validation functions for td_pskel.
  //
  bool td_pskel::
  _characters_impl (const ::xsde::cxx::ro_string& s)
  {
    this->_any_characters (s);
    return true;
  }
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


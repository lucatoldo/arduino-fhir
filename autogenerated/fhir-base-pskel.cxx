// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "fhir-base-pskel.hxx"

namespace fhir
{
  // date_primitive_base_pskel
  //

  date_primitive_base_pskel::
  date_primitive_base_pskel ()
  : date_primitive_base_impl_ (0)
  {
  }

  date_primitive_base_pskel::
  date_primitive_base_pskel (date_primitive_base_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::simple_content (impl, 0),
    date_primitive_base_impl_ (impl)
  {
  }

  // date_primitive_pskel
  //

  date_primitive_pskel::
  date_primitive_pskel (::fhir::date_primitive_base_pskel* tiein)
  : ::fhir::date_primitive_base_pskel (tiein, 0),
    date_primitive_impl_ (0)
  {
  }

  date_primitive_pskel::
  date_primitive_pskel (date_primitive_pskel* impl, void*)
  : ::fhir::date_primitive_base_pskel (impl, 0),
    date_primitive_impl_ (impl)
  {
  }

  // Element_pskel
  //

  void Element_pskel::
  id_parser (::fhir::string_primitive_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Element_pskel::
  extension_parser (::fhir::Extension_pskel& p)
  {
    this->extension_parser_ = &p;
  }

  void Element_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
  }

  Element_pskel::
  Element_pskel ()
  : Element_impl_ (0),
    id_parser_ (0),
    extension_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Element_pskel::
  Element_pskel (Element_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    Element_impl_ (impl),
    id_parser_ (0),
    extension_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // date_pskel
  //

  void date_pskel::
  value_parser (::fhir::date_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void date_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::date_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  date_pskel::
  date_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    date_impl_ (0),
    value_parser_ (0)
  {
  }

  date_pskel::
  date_pskel (date_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    date_impl_ (impl),
    value_parser_ (0)
  {
  }

  // dateTime_primitive_base_pskel
  //

  dateTime_primitive_base_pskel::
  dateTime_primitive_base_pskel ()
  : dateTime_primitive_base_impl_ (0)
  {
  }

  dateTime_primitive_base_pskel::
  dateTime_primitive_base_pskel (dateTime_primitive_base_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::simple_content (impl, 0),
    dateTime_primitive_base_impl_ (impl)
  {
  }

  // dateTime_primitive_pskel
  //

  dateTime_primitive_pskel::
  dateTime_primitive_pskel (::fhir::dateTime_primitive_base_pskel* tiein)
  : ::fhir::dateTime_primitive_base_pskel (tiein, 0),
    dateTime_primitive_impl_ (0)
  {
  }

  dateTime_primitive_pskel::
  dateTime_primitive_pskel (dateTime_primitive_pskel* impl, void*)
  : ::fhir::dateTime_primitive_base_pskel (impl, 0),
    dateTime_primitive_impl_ (impl)
  {
  }

  // dateTime_pskel
  //

  void dateTime_pskel::
  value_parser (::fhir::dateTime_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void dateTime_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::dateTime_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  dateTime_pskel::
  dateTime_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    dateTime_impl_ (0),
    value_parser_ (0)
  {
  }

  dateTime_pskel::
  dateTime_pskel (dateTime_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    dateTime_impl_ (impl),
    value_parser_ (0)
  {
  }

  // code_primitive_pskel
  //

  code_primitive_pskel::
  code_primitive_pskel (::xml_schema::token_pskel* tiein)
  : ::xml_schema::token_pskel (tiein, 0),
    code_primitive_impl_ (0)
  {
  }

  code_primitive_pskel::
  code_primitive_pskel (code_primitive_pskel* impl, void*)
  : ::xml_schema::token_pskel (impl, 0),
    code_primitive_impl_ (impl)
  {
  }

  // code_pskel
  //

  void code_pskel::
  value_parser (::fhir::code_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void code_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::code_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  code_pskel::
  code_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    code_impl_ (0),
    value_parser_ (0)
  {
  }

  code_pskel::
  code_pskel (code_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    code_impl_ (impl),
    value_parser_ (0)
  {
  }

  // string_primitive_pskel
  //

  string_primitive_pskel::
  string_primitive_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    string_primitive_impl_ (0)
  {
    this->_min_length_facet (1UL);
  }

  string_primitive_pskel::
  string_primitive_pskel (string_primitive_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    string_primitive_impl_ (impl)
  {
    this->_min_length_facet (1UL);
  }

  // string_pskel
  //

  void string_pskel::
  value_parser (::fhir::string_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void string_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  string_pskel::
  string_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    string_impl_ (0),
    value_parser_ (0)
  {
  }

  string_pskel::
  string_pskel (string_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    string_impl_ (impl),
    value_parser_ (0)
  {
  }

  // integer_primitive_pskel
  //

  integer_primitive_pskel::
  integer_primitive_pskel (::xml_schema::int_pskel* tiein)
  : ::xml_schema::int_pskel (tiein, 0),
    integer_primitive_impl_ (0)
  {
  }

  integer_primitive_pskel::
  integer_primitive_pskel (integer_primitive_pskel* impl, void*)
  : ::xml_schema::int_pskel (impl, 0),
    integer_primitive_impl_ (impl)
  {
  }

  // integer_pskel
  //

  void integer_pskel::
  value_parser (::fhir::integer_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void integer_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::integer_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  integer_pskel::
  integer_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    integer_impl_ (0),
    value_parser_ (0)
  {
  }

  integer_pskel::
  integer_pskel (integer_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    integer_impl_ (impl),
    value_parser_ (0)
  {
  }

  // oid_primitive_pskel
  //

  oid_primitive_pskel::
  oid_primitive_pskel (::xml_schema::uri_pskel* tiein)
  : ::xml_schema::uri_pskel (tiein, 0),
    oid_primitive_impl_ (0)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("urn:oid:[0-2](\\.(0|[1-9][0-9]*))+");
  }

  oid_primitive_pskel::
  oid_primitive_pskel (oid_primitive_pskel* impl, void*)
  : ::xml_schema::uri_pskel (impl, 0),
    oid_primitive_impl_ (impl)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("urn:oid:[0-2](\\.(0|[1-9][0-9]*))+");
  }

  // oid_pskel
  //

  void oid_pskel::
  value_parser (::fhir::oid_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void oid_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::oid_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  oid_pskel::
  oid_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    oid_impl_ (0),
    value_parser_ (0)
  {
  }

  oid_pskel::
  oid_pskel (oid_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    oid_impl_ (impl),
    value_parser_ (0)
  {
  }

  // canonical_primitive_pskel
  //

  canonical_primitive_pskel::
  canonical_primitive_pskel (::xml_schema::uri_pskel* tiein)
  : ::xml_schema::uri_pskel (tiein, 0),
    canonical_primitive_impl_ (0)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("\\S*");
  }

  canonical_primitive_pskel::
  canonical_primitive_pskel (canonical_primitive_pskel* impl, void*)
  : ::xml_schema::uri_pskel (impl, 0),
    canonical_primitive_impl_ (impl)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("\\S*");
  }

  // canonical_pskel
  //

  void canonical_pskel::
  value_parser (::fhir::canonical_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void canonical_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::canonical_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  canonical_pskel::
  canonical_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    canonical_impl_ (0),
    value_parser_ (0)
  {
  }

  canonical_pskel::
  canonical_pskel (canonical_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    canonical_impl_ (impl),
    value_parser_ (0)
  {
  }

  // uri_primitive_pskel
  //

  uri_primitive_pskel::
  uri_primitive_pskel (::xml_schema::uri_pskel* tiein)
  : ::xml_schema::uri_pskel (tiein, 0),
    uri_primitive_impl_ (0)
  {
    this->_pattern_facet ("\\S*");
  }

  uri_primitive_pskel::
  uri_primitive_pskel (uri_primitive_pskel* impl, void*)
  : ::xml_schema::uri_pskel (impl, 0),
    uri_primitive_impl_ (impl)
  {
    this->_pattern_facet ("\\S*");
  }

  // uri_pskel
  //

  void uri_pskel::
  value_parser (::fhir::uri_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void uri_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::uri_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  uri_pskel::
  uri_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    uri_impl_ (0),
    value_parser_ (0)
  {
  }

  uri_pskel::
  uri_pskel (uri_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    uri_impl_ (impl),
    value_parser_ (0)
  {
  }

  // uuid_primitive_pskel
  //

  uuid_primitive_pskel::
  uuid_primitive_pskel (::xml_schema::uri_pskel* tiein)
  : ::xml_schema::uri_pskel (tiein, 0),
    uuid_primitive_impl_ (0)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");
  }

  uuid_primitive_pskel::
  uuid_primitive_pskel (uuid_primitive_pskel* impl, void*)
  : ::xml_schema::uri_pskel (impl, 0),
    uuid_primitive_impl_ (impl)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");
  }

  // uuid_pskel
  //

  void uuid_pskel::
  value_parser (::fhir::uuid_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void uuid_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::uuid_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  uuid_pskel::
  uuid_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    uuid_impl_ (0),
    value_parser_ (0)
  {
  }

  uuid_pskel::
  uuid_pskel (uuid_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    uuid_impl_ (impl),
    value_parser_ (0)
  {
  }

  // url_primitive_pskel
  //

  url_primitive_pskel::
  url_primitive_pskel (::xml_schema::uri_pskel* tiein)
  : ::xml_schema::uri_pskel (tiein, 0),
    url_primitive_impl_ (0)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("\\S*");
  }

  url_primitive_pskel::
  url_primitive_pskel (url_primitive_pskel* impl, void*)
  : ::xml_schema::uri_pskel (impl, 0),
    url_primitive_impl_ (impl)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("\\S*");
  }

  // url_pskel
  //

  void url_pskel::
  value_parser (::fhir::url_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void url_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::url_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  url_pskel::
  url_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    url_impl_ (0),
    value_parser_ (0)
  {
  }

  url_pskel::
  url_pskel (url_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    url_impl_ (impl),
    value_parser_ (0)
  {
  }

  // instant_primitive_pskel
  //

  instant_primitive_pskel::
  instant_primitive_pskel (::xml_schema::date_time_pskel* tiein)
  : ::xml_schema::date_time_pskel (tiein, 0),
    instant_primitive_impl_ (0)
  {
  }

  instant_primitive_pskel::
  instant_primitive_pskel (instant_primitive_pskel* impl, void*)
  : ::xml_schema::date_time_pskel (impl, 0),
    instant_primitive_impl_ (impl)
  {
  }

  // instant_pskel
  //

  void instant_pskel::
  value_parser (::fhir::instant_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void instant_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::instant_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  instant_pskel::
  instant_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    instant_impl_ (0),
    value_parser_ (0)
  {
  }

  instant_pskel::
  instant_pskel (instant_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    instant_impl_ (impl),
    value_parser_ (0)
  {
  }

  // boolean_primitive_pskel
  //

  boolean_primitive_pskel::
  boolean_primitive_pskel (::xml_schema::boolean_pskel* tiein)
  : ::xml_schema::boolean_pskel (tiein, 0),
    boolean_primitive_impl_ (0)
  {
  }

  boolean_primitive_pskel::
  boolean_primitive_pskel (boolean_primitive_pskel* impl, void*)
  : ::xml_schema::boolean_pskel (impl, 0),
    boolean_primitive_impl_ (impl)
  {
  }

  // boolean_pskel
  //

  void boolean_pskel::
  value_parser (::fhir::boolean_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void boolean_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::boolean_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  boolean_pskel::
  boolean_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    boolean_impl_ (0),
    value_parser_ (0)
  {
  }

  boolean_pskel::
  boolean_pskel (boolean_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    boolean_impl_ (impl),
    value_parser_ (0)
  {
  }

  // base64Binary_primitive_pskel
  //

  base64Binary_primitive_pskel::
  base64Binary_primitive_pskel (::xml_schema::base64_binary_pskel* tiein)
  : ::xml_schema::base64_binary_pskel (tiein, 0),
    base64Binary_primitive_impl_ (0)
  {
  }

  base64Binary_primitive_pskel::
  base64Binary_primitive_pskel (base64Binary_primitive_pskel* impl, void*)
  : ::xml_schema::base64_binary_pskel (impl, 0),
    base64Binary_primitive_impl_ (impl)
  {
  }

  // base64Binary_pskel
  //

  void base64Binary_pskel::
  value_parser (::fhir::base64Binary_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void base64Binary_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::base64Binary_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  base64Binary_pskel::
  base64Binary_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    base64Binary_impl_ (0),
    value_parser_ (0)
  {
  }

  base64Binary_pskel::
  base64Binary_pskel (base64Binary_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    base64Binary_impl_ (impl),
    value_parser_ (0)
  {
  }

  // unsignedInt_primitive_pskel
  //

  unsignedInt_primitive_pskel::
  unsignedInt_primitive_pskel (::xml_schema::non_negative_integer_pskel* tiein)
  : ::xml_schema::non_negative_integer_pskel (tiein, 0),
    unsignedInt_primitive_impl_ (0)
  {
  }

  unsignedInt_primitive_pskel::
  unsignedInt_primitive_pskel (unsignedInt_primitive_pskel* impl, void*)
  : ::xml_schema::non_negative_integer_pskel (impl, 0),
    unsignedInt_primitive_impl_ (impl)
  {
  }

  // unsignedInt_pskel
  //

  void unsignedInt_pskel::
  value_parser (::fhir::unsignedInt_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void unsignedInt_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::unsignedInt_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  unsignedInt_pskel::
  unsignedInt_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    unsignedInt_impl_ (0),
    value_parser_ (0)
  {
  }

  unsignedInt_pskel::
  unsignedInt_pskel (unsignedInt_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    unsignedInt_impl_ (impl),
    value_parser_ (0)
  {
  }

  // markdown_primitive_pskel
  //

  markdown_primitive_pskel::
  markdown_primitive_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    markdown_primitive_impl_ (0)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("[ \\r\\n\\t\\S]+");
  }

  markdown_primitive_pskel::
  markdown_primitive_pskel (markdown_primitive_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    markdown_primitive_impl_ (impl)
  {
    this->_min_length_facet (1UL);
    this->_pattern_facet ("[ \\r\\n\\t\\S]+");
  }

  // markdown_pskel
  //

  void markdown_pskel::
  value_parser (::fhir::markdown_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void markdown_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::markdown_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  markdown_pskel::
  markdown_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    markdown_impl_ (0),
    value_parser_ (0)
  {
  }

  markdown_pskel::
  markdown_pskel (markdown_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    markdown_impl_ (impl),
    value_parser_ (0)
  {
  }

  // time_primitive_pskel
  //

  time_primitive_pskel::
  time_primitive_pskel (::xml_schema::time_pskel* tiein)
  : ::xml_schema::time_pskel (tiein, 0),
    time_primitive_impl_ (0)
  {
  }

  time_primitive_pskel::
  time_primitive_pskel (time_primitive_pskel* impl, void*)
  : ::xml_schema::time_pskel (impl, 0),
    time_primitive_impl_ (impl)
  {
  }

  // time_pskel
  //

  void time_pskel::
  value_parser (::fhir::time_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void time_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::time_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  time_pskel::
  time_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    time_impl_ (0),
    value_parser_ (0)
  {
  }

  time_pskel::
  time_pskel (time_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    time_impl_ (impl),
    value_parser_ (0)
  {
  }

  // id_primitive_pskel
  //

  id_primitive_pskel::
  id_primitive_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    id_primitive_impl_ (0)
  {
    this->_max_length_facet (64UL);
    this->_min_length_facet (1UL);
    this->_pattern_facet ("[A-Za-z0-9\\-\\.]{1,64}");
  }

  id_primitive_pskel::
  id_primitive_pskel (id_primitive_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    id_primitive_impl_ (impl)
  {
    this->_max_length_facet (64UL);
    this->_min_length_facet (1UL);
    this->_pattern_facet ("[A-Za-z0-9\\-\\.]{1,64}");
  }

  // id_pskel
  //

  void id_pskel::
  value_parser (::fhir::id_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void id_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::id_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  id_pskel::
  id_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    id_impl_ (0),
    value_parser_ (0)
  {
  }

  id_pskel::
  id_pskel (id_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    id_impl_ (impl),
    value_parser_ (0)
  {
  }

  // positiveInt_primitive_pskel
  //

  positiveInt_primitive_pskel::
  positiveInt_primitive_pskel (::xml_schema::positive_integer_pskel* tiein)
  : ::xml_schema::positive_integer_pskel (tiein, 0),
    positiveInt_primitive_impl_ (0)
  {
  }

  positiveInt_primitive_pskel::
  positiveInt_primitive_pskel (positiveInt_primitive_pskel* impl, void*)
  : ::xml_schema::positive_integer_pskel (impl, 0),
    positiveInt_primitive_impl_ (impl)
  {
  }

  // positiveInt_pskel
  //

  void positiveInt_pskel::
  value_parser (::fhir::positiveInt_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void positiveInt_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::positiveInt_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  positiveInt_pskel::
  positiveInt_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    positiveInt_impl_ (0),
    value_parser_ (0)
  {
  }

  positiveInt_pskel::
  positiveInt_pskel (positiveInt_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    positiveInt_impl_ (impl),
    value_parser_ (0)
  {
  }

  // decimal_primitive_pskel
  //

  decimal_primitive_pskel::
  decimal_primitive_pskel ()
  : decimal_primitive_impl_ (0)
  {
  }

  decimal_primitive_pskel::
  decimal_primitive_pskel (decimal_primitive_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::simple_content (impl, 0),
    decimal_primitive_impl_ (impl)
  {
  }

  // decimal_pskel
  //

  void decimal_pskel::
  value_parser (::fhir::decimal_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void decimal_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::decimal_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  decimal_pskel::
  decimal_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    decimal_impl_ (0),
    value_parser_ (0)
  {
  }

  decimal_pskel::
  decimal_pskel (decimal_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    decimal_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ResourceContainer_pskel
  //

  void ResourceContainer_pskel::
  Account_parser (::fhir::Account_pskel& p)
  {
    this->Account_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ActivityDefinition_parser (::fhir::ActivityDefinition_pskel& p)
  {
    this->ActivityDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  AdverseEvent_parser (::fhir::AdverseEvent_pskel& p)
  {
    this->AdverseEvent_parser_ = &p;
  }

  void ResourceContainer_pskel::
  AllergyIntolerance_parser (::fhir::AllergyIntolerance_pskel& p)
  {
    this->AllergyIntolerance_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Appointment_parser (::fhir::Appointment_pskel& p)
  {
    this->Appointment_parser_ = &p;
  }

  void ResourceContainer_pskel::
  AppointmentResponse_parser (::fhir::AppointmentResponse_pskel& p)
  {
    this->AppointmentResponse_parser_ = &p;
  }

  void ResourceContainer_pskel::
  AuditEvent_parser (::fhir::AuditEvent_pskel& p)
  {
    this->AuditEvent_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Basic_parser (::fhir::Basic_pskel& p)
  {
    this->Basic_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Binary_parser (::fhir::Binary_pskel& p)
  {
    this->Binary_parser_ = &p;
  }

  void ResourceContainer_pskel::
  BiologicallyDerivedProduct_parser (::fhir::BiologicallyDerivedProduct_pskel& p)
  {
    this->BiologicallyDerivedProduct_parser_ = &p;
  }

  void ResourceContainer_pskel::
  BodyStructure_parser (::fhir::BodyStructure_pskel& p)
  {
    this->BodyStructure_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Bundle_parser (::fhir::Bundle_pskel& p)
  {
    this->Bundle_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CapabilityStatement_parser (::fhir::CapabilityStatement_pskel& p)
  {
    this->CapabilityStatement_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CarePlan_parser (::fhir::CarePlan_pskel& p)
  {
    this->CarePlan_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CareTeam_parser (::fhir::CareTeam_pskel& p)
  {
    this->CareTeam_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CatalogEntry_parser (::fhir::CatalogEntry_pskel& p)
  {
    this->CatalogEntry_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ChargeItem_parser (::fhir::ChargeItem_pskel& p)
  {
    this->ChargeItem_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ChargeItemDefinition_parser (::fhir::ChargeItemDefinition_pskel& p)
  {
    this->ChargeItemDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Claim_parser (::fhir::Claim_pskel& p)
  {
    this->Claim_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ClaimResponse_parser (::fhir::ClaimResponse_pskel& p)
  {
    this->ClaimResponse_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ClinicalImpression_parser (::fhir::ClinicalImpression_pskel& p)
  {
    this->ClinicalImpression_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CodeSystem_parser (::fhir::CodeSystem_pskel& p)
  {
    this->CodeSystem_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Communication_parser (::fhir::Communication_pskel& p)
  {
    this->Communication_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CommunicationRequest_parser (::fhir::CommunicationRequest_pskel& p)
  {
    this->CommunicationRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CompartmentDefinition_parser (::fhir::CompartmentDefinition_pskel& p)
  {
    this->CompartmentDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Composition_parser (::fhir::Composition_pskel& p)
  {
    this->Composition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ConceptMap_parser (::fhir::ConceptMap_pskel& p)
  {
    this->ConceptMap_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Condition_parser (::fhir::Condition_pskel& p)
  {
    this->Condition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Consent_parser (::fhir::Consent_pskel& p)
  {
    this->Consent_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Contract_parser (::fhir::Contract_pskel& p)
  {
    this->Contract_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Coverage_parser (::fhir::Coverage_pskel& p)
  {
    this->Coverage_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CoverageEligibilityRequest_parser (::fhir::CoverageEligibilityRequest_pskel& p)
  {
    this->CoverageEligibilityRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  CoverageEligibilityResponse_parser (::fhir::CoverageEligibilityResponse_pskel& p)
  {
    this->CoverageEligibilityResponse_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DetectedIssue_parser (::fhir::DetectedIssue_pskel& p)
  {
    this->DetectedIssue_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Device_parser (::fhir::Device_pskel& p)
  {
    this->Device_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DeviceDefinition_parser (::fhir::DeviceDefinition_pskel& p)
  {
    this->DeviceDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DeviceMetric_parser (::fhir::DeviceMetric_pskel& p)
  {
    this->DeviceMetric_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DeviceRequest_parser (::fhir::DeviceRequest_pskel& p)
  {
    this->DeviceRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DeviceUseStatement_parser (::fhir::DeviceUseStatement_pskel& p)
  {
    this->DeviceUseStatement_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DiagnosticReport_parser (::fhir::DiagnosticReport_pskel& p)
  {
    this->DiagnosticReport_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DocumentManifest_parser (::fhir::DocumentManifest_pskel& p)
  {
    this->DocumentManifest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  DocumentReference_parser (::fhir::DocumentReference_pskel& p)
  {
    this->DocumentReference_parser_ = &p;
  }

  void ResourceContainer_pskel::
  EffectEvidenceSynthesis_parser (::fhir::EffectEvidenceSynthesis_pskel& p)
  {
    this->EffectEvidenceSynthesis_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Encounter_parser (::fhir::Encounter_pskel& p)
  {
    this->Encounter_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Endpoint_parser (::fhir::Endpoint_pskel& p)
  {
    this->Endpoint_parser_ = &p;
  }

  void ResourceContainer_pskel::
  EnrollmentRequest_parser (::fhir::EnrollmentRequest_pskel& p)
  {
    this->EnrollmentRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  EnrollmentResponse_parser (::fhir::EnrollmentResponse_pskel& p)
  {
    this->EnrollmentResponse_parser_ = &p;
  }

  void ResourceContainer_pskel::
  EpisodeOfCare_parser (::fhir::EpisodeOfCare_pskel& p)
  {
    this->EpisodeOfCare_parser_ = &p;
  }

  void ResourceContainer_pskel::
  EventDefinition_parser (::fhir::EventDefinition_pskel& p)
  {
    this->EventDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Evidence_parser (::fhir::Evidence_pskel& p)
  {
    this->Evidence_parser_ = &p;
  }

  void ResourceContainer_pskel::
  EvidenceVariable_parser (::fhir::EvidenceVariable_pskel& p)
  {
    this->EvidenceVariable_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ExampleScenario_parser (::fhir::ExampleScenario_pskel& p)
  {
    this->ExampleScenario_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ExplanationOfBenefit_parser (::fhir::ExplanationOfBenefit_pskel& p)
  {
    this->ExplanationOfBenefit_parser_ = &p;
  }

  void ResourceContainer_pskel::
  FamilyMemberHistory_parser (::fhir::FamilyMemberHistory_pskel& p)
  {
    this->FamilyMemberHistory_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Flag_parser (::fhir::Flag_pskel& p)
  {
    this->Flag_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Goal_parser (::fhir::Goal_pskel& p)
  {
    this->Goal_parser_ = &p;
  }

  void ResourceContainer_pskel::
  GraphDefinition_parser (::fhir::GraphDefinition_pskel& p)
  {
    this->GraphDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Group_parser (::fhir::Group_pskel& p)
  {
    this->Group_parser_ = &p;
  }

  void ResourceContainer_pskel::
  GuidanceResponse_parser (::fhir::GuidanceResponse_pskel& p)
  {
    this->GuidanceResponse_parser_ = &p;
  }

  void ResourceContainer_pskel::
  HealthcareService_parser (::fhir::HealthcareService_pskel& p)
  {
    this->HealthcareService_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ImagingStudy_parser (::fhir::ImagingStudy_pskel& p)
  {
    this->ImagingStudy_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Immunization_parser (::fhir::Immunization_pskel& p)
  {
    this->Immunization_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ImmunizationEvaluation_parser (::fhir::ImmunizationEvaluation_pskel& p)
  {
    this->ImmunizationEvaluation_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ImmunizationRecommendation_parser (::fhir::ImmunizationRecommendation_pskel& p)
  {
    this->ImmunizationRecommendation_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ImplementationGuide_parser (::fhir::ImplementationGuide_pskel& p)
  {
    this->ImplementationGuide_parser_ = &p;
  }

  void ResourceContainer_pskel::
  InsurancePlan_parser (::fhir::InsurancePlan_pskel& p)
  {
    this->InsurancePlan_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Invoice_parser (::fhir::Invoice_pskel& p)
  {
    this->Invoice_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Library_parser (::fhir::Library_pskel& p)
  {
    this->Library_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Linkage_parser (::fhir::Linkage_pskel& p)
  {
    this->Linkage_parser_ = &p;
  }

  void ResourceContainer_pskel::
  List_parser (::fhir::List_pskel& p)
  {
    this->List_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Location_parser (::fhir::Location_pskel& p)
  {
    this->Location_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Measure_parser (::fhir::Measure_pskel& p)
  {
    this->Measure_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MeasureReport_parser (::fhir::MeasureReport_pskel& p)
  {
    this->MeasureReport_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Media_parser (::fhir::Media_pskel& p)
  {
    this->Media_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Medication_parser (::fhir::Medication_pskel& p)
  {
    this->Medication_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicationAdministration_parser (::fhir::MedicationAdministration_pskel& p)
  {
    this->MedicationAdministration_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicationDispense_parser (::fhir::MedicationDispense_pskel& p)
  {
    this->MedicationDispense_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicationKnowledge_parser (::fhir::MedicationKnowledge_pskel& p)
  {
    this->MedicationKnowledge_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicationRequest_parser (::fhir::MedicationRequest_pskel& p)
  {
    this->MedicationRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicationStatement_parser (::fhir::MedicationStatement_pskel& p)
  {
    this->MedicationStatement_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProduct_parser (::fhir::MedicinalProduct_pskel& p)
  {
    this->MedicinalProduct_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductAuthorization_parser (::fhir::MedicinalProductAuthorization_pskel& p)
  {
    this->MedicinalProductAuthorization_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductContraindication_parser (::fhir::MedicinalProductContraindication_pskel& p)
  {
    this->MedicinalProductContraindication_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductIndication_parser (::fhir::MedicinalProductIndication_pskel& p)
  {
    this->MedicinalProductIndication_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductIngredient_parser (::fhir::MedicinalProductIngredient_pskel& p)
  {
    this->MedicinalProductIngredient_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductInteraction_parser (::fhir::MedicinalProductInteraction_pskel& p)
  {
    this->MedicinalProductInteraction_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductManufactured_parser (::fhir::MedicinalProductManufactured_pskel& p)
  {
    this->MedicinalProductManufactured_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductPackaged_parser (::fhir::MedicinalProductPackaged_pskel& p)
  {
    this->MedicinalProductPackaged_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductPharmaceutical_parser (::fhir::MedicinalProductPharmaceutical_pskel& p)
  {
    this->MedicinalProductPharmaceutical_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MedicinalProductUndesirableEffect_parser (::fhir::MedicinalProductUndesirableEffect_pskel& p)
  {
    this->MedicinalProductUndesirableEffect_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MessageDefinition_parser (::fhir::MessageDefinition_pskel& p)
  {
    this->MessageDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MessageHeader_parser (::fhir::MessageHeader_pskel& p)
  {
    this->MessageHeader_parser_ = &p;
  }

  void ResourceContainer_pskel::
  MolecularSequence_parser (::fhir::MolecularSequence_pskel& p)
  {
    this->MolecularSequence_parser_ = &p;
  }

  void ResourceContainer_pskel::
  NamingSystem_parser (::fhir::NamingSystem_pskel& p)
  {
    this->NamingSystem_parser_ = &p;
  }

  void ResourceContainer_pskel::
  NutritionOrder_parser (::fhir::NutritionOrder_pskel& p)
  {
    this->NutritionOrder_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Observation_parser (::fhir::Observation_pskel& p)
  {
    this->Observation_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ObservationDefinition_parser (::fhir::ObservationDefinition_pskel& p)
  {
    this->ObservationDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  OperationDefinition_parser (::fhir::OperationDefinition_pskel& p)
  {
    this->OperationDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  OperationOutcome_parser (::fhir::OperationOutcome_pskel& p)
  {
    this->OperationOutcome_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Organization_parser (::fhir::Organization_pskel& p)
  {
    this->Organization_parser_ = &p;
  }

  void ResourceContainer_pskel::
  OrganizationAffiliation_parser (::fhir::OrganizationAffiliation_pskel& p)
  {
    this->OrganizationAffiliation_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Patient_parser (::fhir::Patient_pskel& p)
  {
    this->Patient_parser_ = &p;
  }

  void ResourceContainer_pskel::
  PaymentNotice_parser (::fhir::PaymentNotice_pskel& p)
  {
    this->PaymentNotice_parser_ = &p;
  }

  void ResourceContainer_pskel::
  PaymentReconciliation_parser (::fhir::PaymentReconciliation_pskel& p)
  {
    this->PaymentReconciliation_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Person_parser (::fhir::Person_pskel& p)
  {
    this->Person_parser_ = &p;
  }

  void ResourceContainer_pskel::
  PlanDefinition_parser (::fhir::PlanDefinition_pskel& p)
  {
    this->PlanDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Practitioner_parser (::fhir::Practitioner_pskel& p)
  {
    this->Practitioner_parser_ = &p;
  }

  void ResourceContainer_pskel::
  PractitionerRole_parser (::fhir::PractitionerRole_pskel& p)
  {
    this->PractitionerRole_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Procedure_parser (::fhir::Procedure_pskel& p)
  {
    this->Procedure_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Provenance_parser (::fhir::Provenance_pskel& p)
  {
    this->Provenance_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Questionnaire_parser (::fhir::Questionnaire_pskel& p)
  {
    this->Questionnaire_parser_ = &p;
  }

  void ResourceContainer_pskel::
  QuestionnaireResponse_parser (::fhir::QuestionnaireResponse_pskel& p)
  {
    this->QuestionnaireResponse_parser_ = &p;
  }

  void ResourceContainer_pskel::
  RelatedPerson_parser (::fhir::RelatedPerson_pskel& p)
  {
    this->RelatedPerson_parser_ = &p;
  }

  void ResourceContainer_pskel::
  RequestGroup_parser (::fhir::RequestGroup_pskel& p)
  {
    this->RequestGroup_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ResearchDefinition_parser (::fhir::ResearchDefinition_pskel& p)
  {
    this->ResearchDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ResearchElementDefinition_parser (::fhir::ResearchElementDefinition_pskel& p)
  {
    this->ResearchElementDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ResearchStudy_parser (::fhir::ResearchStudy_pskel& p)
  {
    this->ResearchStudy_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ResearchSubject_parser (::fhir::ResearchSubject_pskel& p)
  {
    this->ResearchSubject_parser_ = &p;
  }

  void ResourceContainer_pskel::
  RiskAssessment_parser (::fhir::RiskAssessment_pskel& p)
  {
    this->RiskAssessment_parser_ = &p;
  }

  void ResourceContainer_pskel::
  RiskEvidenceSynthesis_parser (::fhir::RiskEvidenceSynthesis_pskel& p)
  {
    this->RiskEvidenceSynthesis_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Schedule_parser (::fhir::Schedule_pskel& p)
  {
    this->Schedule_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SearchParameter_parser (::fhir::SearchParameter_pskel& p)
  {
    this->SearchParameter_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ServiceRequest_parser (::fhir::ServiceRequest_pskel& p)
  {
    this->ServiceRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Slot_parser (::fhir::Slot_pskel& p)
  {
    this->Slot_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Specimen_parser (::fhir::Specimen_pskel& p)
  {
    this->Specimen_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SpecimenDefinition_parser (::fhir::SpecimenDefinition_pskel& p)
  {
    this->SpecimenDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  StructureDefinition_parser (::fhir::StructureDefinition_pskel& p)
  {
    this->StructureDefinition_parser_ = &p;
  }

  void ResourceContainer_pskel::
  StructureMap_parser (::fhir::StructureMap_pskel& p)
  {
    this->StructureMap_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Subscription_parser (::fhir::Subscription_pskel& p)
  {
    this->Subscription_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Substance_parser (::fhir::Substance_pskel& p)
  {
    this->Substance_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SubstanceNucleicAcid_parser (::fhir::SubstanceNucleicAcid_pskel& p)
  {
    this->SubstanceNucleicAcid_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SubstancePolymer_parser (::fhir::SubstancePolymer_pskel& p)
  {
    this->SubstancePolymer_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SubstanceProtein_parser (::fhir::SubstanceProtein_pskel& p)
  {
    this->SubstanceProtein_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SubstanceReferenceInformation_parser (::fhir::SubstanceReferenceInformation_pskel& p)
  {
    this->SubstanceReferenceInformation_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SubstanceSourceMaterial_parser (::fhir::SubstanceSourceMaterial_pskel& p)
  {
    this->SubstanceSourceMaterial_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SubstanceSpecification_parser (::fhir::SubstanceSpecification_pskel& p)
  {
    this->SubstanceSpecification_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SupplyDelivery_parser (::fhir::SupplyDelivery_pskel& p)
  {
    this->SupplyDelivery_parser_ = &p;
  }

  void ResourceContainer_pskel::
  SupplyRequest_parser (::fhir::SupplyRequest_pskel& p)
  {
    this->SupplyRequest_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Task_parser (::fhir::Task_pskel& p)
  {
    this->Task_parser_ = &p;
  }

  void ResourceContainer_pskel::
  TerminologyCapabilities_parser (::fhir::TerminologyCapabilities_pskel& p)
  {
    this->TerminologyCapabilities_parser_ = &p;
  }

  void ResourceContainer_pskel::
  TestReport_parser (::fhir::TestReport_pskel& p)
  {
    this->TestReport_parser_ = &p;
  }

  void ResourceContainer_pskel::
  TestScript_parser (::fhir::TestScript_pskel& p)
  {
    this->TestScript_parser_ = &p;
  }

  void ResourceContainer_pskel::
  ValueSet_parser (::fhir::ValueSet_pskel& p)
  {
    this->ValueSet_parser_ = &p;
  }

  void ResourceContainer_pskel::
  VerificationResult_parser (::fhir::VerificationResult_pskel& p)
  {
    this->VerificationResult_parser_ = &p;
  }

  void ResourceContainer_pskel::
  VisionPrescription_parser (::fhir::VisionPrescription_pskel& p)
  {
    this->VisionPrescription_parser_ = &p;
  }

  void ResourceContainer_pskel::
  Parameters_parser (::fhir::Parameters_pskel& p)
  {
    this->Parameters_parser_ = &p;
  }

  void ResourceContainer_pskel::
  parsers (::fhir::Account_pskel& Account,
           ::fhir::ActivityDefinition_pskel& ActivityDefinition,
           ::fhir::AdverseEvent_pskel& AdverseEvent,
           ::fhir::AllergyIntolerance_pskel& AllergyIntolerance,
           ::fhir::Appointment_pskel& Appointment,
           ::fhir::AppointmentResponse_pskel& AppointmentResponse,
           ::fhir::AuditEvent_pskel& AuditEvent,
           ::fhir::Basic_pskel& Basic,
           ::fhir::Binary_pskel& Binary,
           ::fhir::BiologicallyDerivedProduct_pskel& BiologicallyDerivedProduct,
           ::fhir::BodyStructure_pskel& BodyStructure,
           ::fhir::Bundle_pskel& Bundle,
           ::fhir::CapabilityStatement_pskel& CapabilityStatement,
           ::fhir::CarePlan_pskel& CarePlan,
           ::fhir::CareTeam_pskel& CareTeam,
           ::fhir::CatalogEntry_pskel& CatalogEntry,
           ::fhir::ChargeItem_pskel& ChargeItem,
           ::fhir::ChargeItemDefinition_pskel& ChargeItemDefinition,
           ::fhir::Claim_pskel& Claim,
           ::fhir::ClaimResponse_pskel& ClaimResponse,
           ::fhir::ClinicalImpression_pskel& ClinicalImpression,
           ::fhir::CodeSystem_pskel& CodeSystem,
           ::fhir::Communication_pskel& Communication,
           ::fhir::CommunicationRequest_pskel& CommunicationRequest,
           ::fhir::CompartmentDefinition_pskel& CompartmentDefinition,
           ::fhir::Composition_pskel& Composition,
           ::fhir::ConceptMap_pskel& ConceptMap,
           ::fhir::Condition_pskel& Condition,
           ::fhir::Consent_pskel& Consent,
           ::fhir::Contract_pskel& Contract,
           ::fhir::Coverage_pskel& Coverage,
           ::fhir::CoverageEligibilityRequest_pskel& CoverageEligibilityRequest,
           ::fhir::CoverageEligibilityResponse_pskel& CoverageEligibilityResponse,
           ::fhir::DetectedIssue_pskel& DetectedIssue,
           ::fhir::Device_pskel& Device,
           ::fhir::DeviceDefinition_pskel& DeviceDefinition,
           ::fhir::DeviceMetric_pskel& DeviceMetric,
           ::fhir::DeviceRequest_pskel& DeviceRequest,
           ::fhir::DeviceUseStatement_pskel& DeviceUseStatement,
           ::fhir::DiagnosticReport_pskel& DiagnosticReport,
           ::fhir::DocumentManifest_pskel& DocumentManifest,
           ::fhir::DocumentReference_pskel& DocumentReference,
           ::fhir::EffectEvidenceSynthesis_pskel& EffectEvidenceSynthesis,
           ::fhir::Encounter_pskel& Encounter,
           ::fhir::Endpoint_pskel& Endpoint,
           ::fhir::EnrollmentRequest_pskel& EnrollmentRequest,
           ::fhir::EnrollmentResponse_pskel& EnrollmentResponse,
           ::fhir::EpisodeOfCare_pskel& EpisodeOfCare,
           ::fhir::EventDefinition_pskel& EventDefinition,
           ::fhir::Evidence_pskel& Evidence,
           ::fhir::EvidenceVariable_pskel& EvidenceVariable,
           ::fhir::ExampleScenario_pskel& ExampleScenario,
           ::fhir::ExplanationOfBenefit_pskel& ExplanationOfBenefit,
           ::fhir::FamilyMemberHistory_pskel& FamilyMemberHistory,
           ::fhir::Flag_pskel& Flag,
           ::fhir::Goal_pskel& Goal,
           ::fhir::GraphDefinition_pskel& GraphDefinition,
           ::fhir::Group_pskel& Group,
           ::fhir::GuidanceResponse_pskel& GuidanceResponse,
           ::fhir::HealthcareService_pskel& HealthcareService,
           ::fhir::ImagingStudy_pskel& ImagingStudy,
           ::fhir::Immunization_pskel& Immunization,
           ::fhir::ImmunizationEvaluation_pskel& ImmunizationEvaluation,
           ::fhir::ImmunizationRecommendation_pskel& ImmunizationRecommendation,
           ::fhir::ImplementationGuide_pskel& ImplementationGuide,
           ::fhir::InsurancePlan_pskel& InsurancePlan,
           ::fhir::Invoice_pskel& Invoice,
           ::fhir::Library_pskel& Library,
           ::fhir::Linkage_pskel& Linkage,
           ::fhir::List_pskel& List,
           ::fhir::Location_pskel& Location,
           ::fhir::Measure_pskel& Measure,
           ::fhir::MeasureReport_pskel& MeasureReport,
           ::fhir::Media_pskel& Media,
           ::fhir::Medication_pskel& Medication,
           ::fhir::MedicationAdministration_pskel& MedicationAdministration,
           ::fhir::MedicationDispense_pskel& MedicationDispense,
           ::fhir::MedicationKnowledge_pskel& MedicationKnowledge,
           ::fhir::MedicationRequest_pskel& MedicationRequest,
           ::fhir::MedicationStatement_pskel& MedicationStatement,
           ::fhir::MedicinalProduct_pskel& MedicinalProduct,
           ::fhir::MedicinalProductAuthorization_pskel& MedicinalProductAuthorization,
           ::fhir::MedicinalProductContraindication_pskel& MedicinalProductContraindication,
           ::fhir::MedicinalProductIndication_pskel& MedicinalProductIndication,
           ::fhir::MedicinalProductIngredient_pskel& MedicinalProductIngredient,
           ::fhir::MedicinalProductInteraction_pskel& MedicinalProductInteraction,
           ::fhir::MedicinalProductManufactured_pskel& MedicinalProductManufactured,
           ::fhir::MedicinalProductPackaged_pskel& MedicinalProductPackaged,
           ::fhir::MedicinalProductPharmaceutical_pskel& MedicinalProductPharmaceutical,
           ::fhir::MedicinalProductUndesirableEffect_pskel& MedicinalProductUndesirableEffect,
           ::fhir::MessageDefinition_pskel& MessageDefinition,
           ::fhir::MessageHeader_pskel& MessageHeader,
           ::fhir::MolecularSequence_pskel& MolecularSequence,
           ::fhir::NamingSystem_pskel& NamingSystem,
           ::fhir::NutritionOrder_pskel& NutritionOrder,
           ::fhir::Observation_pskel& Observation,
           ::fhir::ObservationDefinition_pskel& ObservationDefinition,
           ::fhir::OperationDefinition_pskel& OperationDefinition,
           ::fhir::OperationOutcome_pskel& OperationOutcome,
           ::fhir::Organization_pskel& Organization,
           ::fhir::OrganizationAffiliation_pskel& OrganizationAffiliation,
           ::fhir::Patient_pskel& Patient,
           ::fhir::PaymentNotice_pskel& PaymentNotice,
           ::fhir::PaymentReconciliation_pskel& PaymentReconciliation,
           ::fhir::Person_pskel& Person,
           ::fhir::PlanDefinition_pskel& PlanDefinition,
           ::fhir::Practitioner_pskel& Practitioner,
           ::fhir::PractitionerRole_pskel& PractitionerRole,
           ::fhir::Procedure_pskel& Procedure,
           ::fhir::Provenance_pskel& Provenance,
           ::fhir::Questionnaire_pskel& Questionnaire,
           ::fhir::QuestionnaireResponse_pskel& QuestionnaireResponse,
           ::fhir::RelatedPerson_pskel& RelatedPerson,
           ::fhir::RequestGroup_pskel& RequestGroup,
           ::fhir::ResearchDefinition_pskel& ResearchDefinition,
           ::fhir::ResearchElementDefinition_pskel& ResearchElementDefinition,
           ::fhir::ResearchStudy_pskel& ResearchStudy,
           ::fhir::ResearchSubject_pskel& ResearchSubject,
           ::fhir::RiskAssessment_pskel& RiskAssessment,
           ::fhir::RiskEvidenceSynthesis_pskel& RiskEvidenceSynthesis,
           ::fhir::Schedule_pskel& Schedule,
           ::fhir::SearchParameter_pskel& SearchParameter,
           ::fhir::ServiceRequest_pskel& ServiceRequest,
           ::fhir::Slot_pskel& Slot,
           ::fhir::Specimen_pskel& Specimen,
           ::fhir::SpecimenDefinition_pskel& SpecimenDefinition,
           ::fhir::StructureDefinition_pskel& StructureDefinition,
           ::fhir::StructureMap_pskel& StructureMap,
           ::fhir::Subscription_pskel& Subscription,
           ::fhir::Substance_pskel& Substance,
           ::fhir::SubstanceNucleicAcid_pskel& SubstanceNucleicAcid,
           ::fhir::SubstancePolymer_pskel& SubstancePolymer,
           ::fhir::SubstanceProtein_pskel& SubstanceProtein,
           ::fhir::SubstanceReferenceInformation_pskel& SubstanceReferenceInformation,
           ::fhir::SubstanceSourceMaterial_pskel& SubstanceSourceMaterial,
           ::fhir::SubstanceSpecification_pskel& SubstanceSpecification,
           ::fhir::SupplyDelivery_pskel& SupplyDelivery,
           ::fhir::SupplyRequest_pskel& SupplyRequest,
           ::fhir::Task_pskel& Task,
           ::fhir::TerminologyCapabilities_pskel& TerminologyCapabilities,
           ::fhir::TestReport_pskel& TestReport,
           ::fhir::TestScript_pskel& TestScript,
           ::fhir::ValueSet_pskel& ValueSet,
           ::fhir::VerificationResult_pskel& VerificationResult,
           ::fhir::VisionPrescription_pskel& VisionPrescription,
           ::fhir::Parameters_pskel& Parameters)
  {
    this->Account_parser_ = &Account;
    this->ActivityDefinition_parser_ = &ActivityDefinition;
    this->AdverseEvent_parser_ = &AdverseEvent;
    this->AllergyIntolerance_parser_ = &AllergyIntolerance;
    this->Appointment_parser_ = &Appointment;
    this->AppointmentResponse_parser_ = &AppointmentResponse;
    this->AuditEvent_parser_ = &AuditEvent;
    this->Basic_parser_ = &Basic;
    this->Binary_parser_ = &Binary;
    this->BiologicallyDerivedProduct_parser_ = &BiologicallyDerivedProduct;
    this->BodyStructure_parser_ = &BodyStructure;
    this->Bundle_parser_ = &Bundle;
    this->CapabilityStatement_parser_ = &CapabilityStatement;
    this->CarePlan_parser_ = &CarePlan;
    this->CareTeam_parser_ = &CareTeam;
    this->CatalogEntry_parser_ = &CatalogEntry;
    this->ChargeItem_parser_ = &ChargeItem;
    this->ChargeItemDefinition_parser_ = &ChargeItemDefinition;
    this->Claim_parser_ = &Claim;
    this->ClaimResponse_parser_ = &ClaimResponse;
    this->ClinicalImpression_parser_ = &ClinicalImpression;
    this->CodeSystem_parser_ = &CodeSystem;
    this->Communication_parser_ = &Communication;
    this->CommunicationRequest_parser_ = &CommunicationRequest;
    this->CompartmentDefinition_parser_ = &CompartmentDefinition;
    this->Composition_parser_ = &Composition;
    this->ConceptMap_parser_ = &ConceptMap;
    this->Condition_parser_ = &Condition;
    this->Consent_parser_ = &Consent;
    this->Contract_parser_ = &Contract;
    this->Coverage_parser_ = &Coverage;
    this->CoverageEligibilityRequest_parser_ = &CoverageEligibilityRequest;
    this->CoverageEligibilityResponse_parser_ = &CoverageEligibilityResponse;
    this->DetectedIssue_parser_ = &DetectedIssue;
    this->Device_parser_ = &Device;
    this->DeviceDefinition_parser_ = &DeviceDefinition;
    this->DeviceMetric_parser_ = &DeviceMetric;
    this->DeviceRequest_parser_ = &DeviceRequest;
    this->DeviceUseStatement_parser_ = &DeviceUseStatement;
    this->DiagnosticReport_parser_ = &DiagnosticReport;
    this->DocumentManifest_parser_ = &DocumentManifest;
    this->DocumentReference_parser_ = &DocumentReference;
    this->EffectEvidenceSynthesis_parser_ = &EffectEvidenceSynthesis;
    this->Encounter_parser_ = &Encounter;
    this->Endpoint_parser_ = &Endpoint;
    this->EnrollmentRequest_parser_ = &EnrollmentRequest;
    this->EnrollmentResponse_parser_ = &EnrollmentResponse;
    this->EpisodeOfCare_parser_ = &EpisodeOfCare;
    this->EventDefinition_parser_ = &EventDefinition;
    this->Evidence_parser_ = &Evidence;
    this->EvidenceVariable_parser_ = &EvidenceVariable;
    this->ExampleScenario_parser_ = &ExampleScenario;
    this->ExplanationOfBenefit_parser_ = &ExplanationOfBenefit;
    this->FamilyMemberHistory_parser_ = &FamilyMemberHistory;
    this->Flag_parser_ = &Flag;
    this->Goal_parser_ = &Goal;
    this->GraphDefinition_parser_ = &GraphDefinition;
    this->Group_parser_ = &Group;
    this->GuidanceResponse_parser_ = &GuidanceResponse;
    this->HealthcareService_parser_ = &HealthcareService;
    this->ImagingStudy_parser_ = &ImagingStudy;
    this->Immunization_parser_ = &Immunization;
    this->ImmunizationEvaluation_parser_ = &ImmunizationEvaluation;
    this->ImmunizationRecommendation_parser_ = &ImmunizationRecommendation;
    this->ImplementationGuide_parser_ = &ImplementationGuide;
    this->InsurancePlan_parser_ = &InsurancePlan;
    this->Invoice_parser_ = &Invoice;
    this->Library_parser_ = &Library;
    this->Linkage_parser_ = &Linkage;
    this->List_parser_ = &List;
    this->Location_parser_ = &Location;
    this->Measure_parser_ = &Measure;
    this->MeasureReport_parser_ = &MeasureReport;
    this->Media_parser_ = &Media;
    this->Medication_parser_ = &Medication;
    this->MedicationAdministration_parser_ = &MedicationAdministration;
    this->MedicationDispense_parser_ = &MedicationDispense;
    this->MedicationKnowledge_parser_ = &MedicationKnowledge;
    this->MedicationRequest_parser_ = &MedicationRequest;
    this->MedicationStatement_parser_ = &MedicationStatement;
    this->MedicinalProduct_parser_ = &MedicinalProduct;
    this->MedicinalProductAuthorization_parser_ = &MedicinalProductAuthorization;
    this->MedicinalProductContraindication_parser_ = &MedicinalProductContraindication;
    this->MedicinalProductIndication_parser_ = &MedicinalProductIndication;
    this->MedicinalProductIngredient_parser_ = &MedicinalProductIngredient;
    this->MedicinalProductInteraction_parser_ = &MedicinalProductInteraction;
    this->MedicinalProductManufactured_parser_ = &MedicinalProductManufactured;
    this->MedicinalProductPackaged_parser_ = &MedicinalProductPackaged;
    this->MedicinalProductPharmaceutical_parser_ = &MedicinalProductPharmaceutical;
    this->MedicinalProductUndesirableEffect_parser_ = &MedicinalProductUndesirableEffect;
    this->MessageDefinition_parser_ = &MessageDefinition;
    this->MessageHeader_parser_ = &MessageHeader;
    this->MolecularSequence_parser_ = &MolecularSequence;
    this->NamingSystem_parser_ = &NamingSystem;
    this->NutritionOrder_parser_ = &NutritionOrder;
    this->Observation_parser_ = &Observation;
    this->ObservationDefinition_parser_ = &ObservationDefinition;
    this->OperationDefinition_parser_ = &OperationDefinition;
    this->OperationOutcome_parser_ = &OperationOutcome;
    this->Organization_parser_ = &Organization;
    this->OrganizationAffiliation_parser_ = &OrganizationAffiliation;
    this->Patient_parser_ = &Patient;
    this->PaymentNotice_parser_ = &PaymentNotice;
    this->PaymentReconciliation_parser_ = &PaymentReconciliation;
    this->Person_parser_ = &Person;
    this->PlanDefinition_parser_ = &PlanDefinition;
    this->Practitioner_parser_ = &Practitioner;
    this->PractitionerRole_parser_ = &PractitionerRole;
    this->Procedure_parser_ = &Procedure;
    this->Provenance_parser_ = &Provenance;
    this->Questionnaire_parser_ = &Questionnaire;
    this->QuestionnaireResponse_parser_ = &QuestionnaireResponse;
    this->RelatedPerson_parser_ = &RelatedPerson;
    this->RequestGroup_parser_ = &RequestGroup;
    this->ResearchDefinition_parser_ = &ResearchDefinition;
    this->ResearchElementDefinition_parser_ = &ResearchElementDefinition;
    this->ResearchStudy_parser_ = &ResearchStudy;
    this->ResearchSubject_parser_ = &ResearchSubject;
    this->RiskAssessment_parser_ = &RiskAssessment;
    this->RiskEvidenceSynthesis_parser_ = &RiskEvidenceSynthesis;
    this->Schedule_parser_ = &Schedule;
    this->SearchParameter_parser_ = &SearchParameter;
    this->ServiceRequest_parser_ = &ServiceRequest;
    this->Slot_parser_ = &Slot;
    this->Specimen_parser_ = &Specimen;
    this->SpecimenDefinition_parser_ = &SpecimenDefinition;
    this->StructureDefinition_parser_ = &StructureDefinition;
    this->StructureMap_parser_ = &StructureMap;
    this->Subscription_parser_ = &Subscription;
    this->Substance_parser_ = &Substance;
    this->SubstanceNucleicAcid_parser_ = &SubstanceNucleicAcid;
    this->SubstancePolymer_parser_ = &SubstancePolymer;
    this->SubstanceProtein_parser_ = &SubstanceProtein;
    this->SubstanceReferenceInformation_parser_ = &SubstanceReferenceInformation;
    this->SubstanceSourceMaterial_parser_ = &SubstanceSourceMaterial;
    this->SubstanceSpecification_parser_ = &SubstanceSpecification;
    this->SupplyDelivery_parser_ = &SupplyDelivery;
    this->SupplyRequest_parser_ = &SupplyRequest;
    this->Task_parser_ = &Task;
    this->TerminologyCapabilities_parser_ = &TerminologyCapabilities;
    this->TestReport_parser_ = &TestReport;
    this->TestScript_parser_ = &TestScript;
    this->ValueSet_parser_ = &ValueSet;
    this->VerificationResult_parser_ = &VerificationResult;
    this->VisionPrescription_parser_ = &VisionPrescription;
    this->Parameters_parser_ = &Parameters;
  }

  ResourceContainer_pskel::
  ResourceContainer_pskel ()
  : ResourceContainer_impl_ (0),
    Account_parser_ (0),
    ActivityDefinition_parser_ (0),
    AdverseEvent_parser_ (0),
    AllergyIntolerance_parser_ (0),
    Appointment_parser_ (0),
    AppointmentResponse_parser_ (0),
    AuditEvent_parser_ (0),
    Basic_parser_ (0),
    Binary_parser_ (0),
    BiologicallyDerivedProduct_parser_ (0),
    BodyStructure_parser_ (0),
    Bundle_parser_ (0),
    CapabilityStatement_parser_ (0),
    CarePlan_parser_ (0),
    CareTeam_parser_ (0),
    CatalogEntry_parser_ (0),
    ChargeItem_parser_ (0),
    ChargeItemDefinition_parser_ (0),
    Claim_parser_ (0),
    ClaimResponse_parser_ (0),
    ClinicalImpression_parser_ (0),
    CodeSystem_parser_ (0),
    Communication_parser_ (0),
    CommunicationRequest_parser_ (0),
    CompartmentDefinition_parser_ (0),
    Composition_parser_ (0),
    ConceptMap_parser_ (0),
    Condition_parser_ (0),
    Consent_parser_ (0),
    Contract_parser_ (0),
    Coverage_parser_ (0),
    CoverageEligibilityRequest_parser_ (0),
    CoverageEligibilityResponse_parser_ (0),
    DetectedIssue_parser_ (0),
    Device_parser_ (0),
    DeviceDefinition_parser_ (0),
    DeviceMetric_parser_ (0),
    DeviceRequest_parser_ (0),
    DeviceUseStatement_parser_ (0),
    DiagnosticReport_parser_ (0),
    DocumentManifest_parser_ (0),
    DocumentReference_parser_ (0),
    EffectEvidenceSynthesis_parser_ (0),
    Encounter_parser_ (0),
    Endpoint_parser_ (0),
    EnrollmentRequest_parser_ (0),
    EnrollmentResponse_parser_ (0),
    EpisodeOfCare_parser_ (0),
    EventDefinition_parser_ (0),
    Evidence_parser_ (0),
    EvidenceVariable_parser_ (0),
    ExampleScenario_parser_ (0),
    ExplanationOfBenefit_parser_ (0),
    FamilyMemberHistory_parser_ (0),
    Flag_parser_ (0),
    Goal_parser_ (0),
    GraphDefinition_parser_ (0),
    Group_parser_ (0),
    GuidanceResponse_parser_ (0),
    HealthcareService_parser_ (0),
    ImagingStudy_parser_ (0),
    Immunization_parser_ (0),
    ImmunizationEvaluation_parser_ (0),
    ImmunizationRecommendation_parser_ (0),
    ImplementationGuide_parser_ (0),
    InsurancePlan_parser_ (0),
    Invoice_parser_ (0),
    Library_parser_ (0),
    Linkage_parser_ (0),
    List_parser_ (0),
    Location_parser_ (0),
    Measure_parser_ (0),
    MeasureReport_parser_ (0),
    Media_parser_ (0),
    Medication_parser_ (0),
    MedicationAdministration_parser_ (0),
    MedicationDispense_parser_ (0),
    MedicationKnowledge_parser_ (0),
    MedicationRequest_parser_ (0),
    MedicationStatement_parser_ (0),
    MedicinalProduct_parser_ (0),
    MedicinalProductAuthorization_parser_ (0),
    MedicinalProductContraindication_parser_ (0),
    MedicinalProductIndication_parser_ (0),
    MedicinalProductIngredient_parser_ (0),
    MedicinalProductInteraction_parser_ (0),
    MedicinalProductManufactured_parser_ (0),
    MedicinalProductPackaged_parser_ (0),
    MedicinalProductPharmaceutical_parser_ (0),
    MedicinalProductUndesirableEffect_parser_ (0),
    MessageDefinition_parser_ (0),
    MessageHeader_parser_ (0),
    MolecularSequence_parser_ (0),
    NamingSystem_parser_ (0),
    NutritionOrder_parser_ (0),
    Observation_parser_ (0),
    ObservationDefinition_parser_ (0),
    OperationDefinition_parser_ (0),
    OperationOutcome_parser_ (0),
    Organization_parser_ (0),
    OrganizationAffiliation_parser_ (0),
    Patient_parser_ (0),
    PaymentNotice_parser_ (0),
    PaymentReconciliation_parser_ (0),
    Person_parser_ (0),
    PlanDefinition_parser_ (0),
    Practitioner_parser_ (0),
    PractitionerRole_parser_ (0),
    Procedure_parser_ (0),
    Provenance_parser_ (0),
    Questionnaire_parser_ (0),
    QuestionnaireResponse_parser_ (0),
    RelatedPerson_parser_ (0),
    RequestGroup_parser_ (0),
    ResearchDefinition_parser_ (0),
    ResearchElementDefinition_parser_ (0),
    ResearchStudy_parser_ (0),
    ResearchSubject_parser_ (0),
    RiskAssessment_parser_ (0),
    RiskEvidenceSynthesis_parser_ (0),
    Schedule_parser_ (0),
    SearchParameter_parser_ (0),
    ServiceRequest_parser_ (0),
    Slot_parser_ (0),
    Specimen_parser_ (0),
    SpecimenDefinition_parser_ (0),
    StructureDefinition_parser_ (0),
    StructureMap_parser_ (0),
    Subscription_parser_ (0),
    Substance_parser_ (0),
    SubstanceNucleicAcid_parser_ (0),
    SubstancePolymer_parser_ (0),
    SubstanceProtein_parser_ (0),
    SubstanceReferenceInformation_parser_ (0),
    SubstanceSourceMaterial_parser_ (0),
    SubstanceSpecification_parser_ (0),
    SupplyDelivery_parser_ (0),
    SupplyRequest_parser_ (0),
    Task_parser_ (0),
    TerminologyCapabilities_parser_ (0),
    TestReport_parser_ (0),
    TestScript_parser_ (0),
    ValueSet_parser_ (0),
    VerificationResult_parser_ (0),
    VisionPrescription_parser_ (0),
    Parameters_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ResourceContainer_pskel::
  ResourceContainer_pskel (ResourceContainer_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    ResourceContainer_impl_ (impl),
    Account_parser_ (0),
    ActivityDefinition_parser_ (0),
    AdverseEvent_parser_ (0),
    AllergyIntolerance_parser_ (0),
    Appointment_parser_ (0),
    AppointmentResponse_parser_ (0),
    AuditEvent_parser_ (0),
    Basic_parser_ (0),
    Binary_parser_ (0),
    BiologicallyDerivedProduct_parser_ (0),
    BodyStructure_parser_ (0),
    Bundle_parser_ (0),
    CapabilityStatement_parser_ (0),
    CarePlan_parser_ (0),
    CareTeam_parser_ (0),
    CatalogEntry_parser_ (0),
    ChargeItem_parser_ (0),
    ChargeItemDefinition_parser_ (0),
    Claim_parser_ (0),
    ClaimResponse_parser_ (0),
    ClinicalImpression_parser_ (0),
    CodeSystem_parser_ (0),
    Communication_parser_ (0),
    CommunicationRequest_parser_ (0),
    CompartmentDefinition_parser_ (0),
    Composition_parser_ (0),
    ConceptMap_parser_ (0),
    Condition_parser_ (0),
    Consent_parser_ (0),
    Contract_parser_ (0),
    Coverage_parser_ (0),
    CoverageEligibilityRequest_parser_ (0),
    CoverageEligibilityResponse_parser_ (0),
    DetectedIssue_parser_ (0),
    Device_parser_ (0),
    DeviceDefinition_parser_ (0),
    DeviceMetric_parser_ (0),
    DeviceRequest_parser_ (0),
    DeviceUseStatement_parser_ (0),
    DiagnosticReport_parser_ (0),
    DocumentManifest_parser_ (0),
    DocumentReference_parser_ (0),
    EffectEvidenceSynthesis_parser_ (0),
    Encounter_parser_ (0),
    Endpoint_parser_ (0),
    EnrollmentRequest_parser_ (0),
    EnrollmentResponse_parser_ (0),
    EpisodeOfCare_parser_ (0),
    EventDefinition_parser_ (0),
    Evidence_parser_ (0),
    EvidenceVariable_parser_ (0),
    ExampleScenario_parser_ (0),
    ExplanationOfBenefit_parser_ (0),
    FamilyMemberHistory_parser_ (0),
    Flag_parser_ (0),
    Goal_parser_ (0),
    GraphDefinition_parser_ (0),
    Group_parser_ (0),
    GuidanceResponse_parser_ (0),
    HealthcareService_parser_ (0),
    ImagingStudy_parser_ (0),
    Immunization_parser_ (0),
    ImmunizationEvaluation_parser_ (0),
    ImmunizationRecommendation_parser_ (0),
    ImplementationGuide_parser_ (0),
    InsurancePlan_parser_ (0),
    Invoice_parser_ (0),
    Library_parser_ (0),
    Linkage_parser_ (0),
    List_parser_ (0),
    Location_parser_ (0),
    Measure_parser_ (0),
    MeasureReport_parser_ (0),
    Media_parser_ (0),
    Medication_parser_ (0),
    MedicationAdministration_parser_ (0),
    MedicationDispense_parser_ (0),
    MedicationKnowledge_parser_ (0),
    MedicationRequest_parser_ (0),
    MedicationStatement_parser_ (0),
    MedicinalProduct_parser_ (0),
    MedicinalProductAuthorization_parser_ (0),
    MedicinalProductContraindication_parser_ (0),
    MedicinalProductIndication_parser_ (0),
    MedicinalProductIngredient_parser_ (0),
    MedicinalProductInteraction_parser_ (0),
    MedicinalProductManufactured_parser_ (0),
    MedicinalProductPackaged_parser_ (0),
    MedicinalProductPharmaceutical_parser_ (0),
    MedicinalProductUndesirableEffect_parser_ (0),
    MessageDefinition_parser_ (0),
    MessageHeader_parser_ (0),
    MolecularSequence_parser_ (0),
    NamingSystem_parser_ (0),
    NutritionOrder_parser_ (0),
    Observation_parser_ (0),
    ObservationDefinition_parser_ (0),
    OperationDefinition_parser_ (0),
    OperationOutcome_parser_ (0),
    Organization_parser_ (0),
    OrganizationAffiliation_parser_ (0),
    Patient_parser_ (0),
    PaymentNotice_parser_ (0),
    PaymentReconciliation_parser_ (0),
    Person_parser_ (0),
    PlanDefinition_parser_ (0),
    Practitioner_parser_ (0),
    PractitionerRole_parser_ (0),
    Procedure_parser_ (0),
    Provenance_parser_ (0),
    Questionnaire_parser_ (0),
    QuestionnaireResponse_parser_ (0),
    RelatedPerson_parser_ (0),
    RequestGroup_parser_ (0),
    ResearchDefinition_parser_ (0),
    ResearchElementDefinition_parser_ (0),
    ResearchStudy_parser_ (0),
    ResearchSubject_parser_ (0),
    RiskAssessment_parser_ (0),
    RiskEvidenceSynthesis_parser_ (0),
    Schedule_parser_ (0),
    SearchParameter_parser_ (0),
    ServiceRequest_parser_ (0),
    Slot_parser_ (0),
    Specimen_parser_ (0),
    SpecimenDefinition_parser_ (0),
    StructureDefinition_parser_ (0),
    StructureMap_parser_ (0),
    Subscription_parser_ (0),
    Substance_parser_ (0),
    SubstanceNucleicAcid_parser_ (0),
    SubstancePolymer_parser_ (0),
    SubstanceProtein_parser_ (0),
    SubstanceReferenceInformation_parser_ (0),
    SubstanceSourceMaterial_parser_ (0),
    SubstanceSpecification_parser_ (0),
    SupplyDelivery_parser_ (0),
    SupplyRequest_parser_ (0),
    Task_parser_ (0),
    TerminologyCapabilities_parser_ (0),
    TestReport_parser_ (0),
    TestScript_parser_ (0),
    ValueSet_parser_ (0),
    VerificationResult_parser_ (0),
    VisionPrescription_parser_ (0),
    Parameters_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Extension_pskel
  //

  void Extension_pskel::
  url_parser (::fhir::uri_primitive_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void Extension_pskel::
  valueBase64Binary_parser (::fhir::base64Binary_pskel& p)
  {
    this->valueBase64Binary_parser_ = &p;
  }

  void Extension_pskel::
  valueBoolean_parser (::fhir::boolean_pskel& p)
  {
    this->valueBoolean_parser_ = &p;
  }

  void Extension_pskel::
  valueCanonical_parser (::fhir::canonical_pskel& p)
  {
    this->valueCanonical_parser_ = &p;
  }

  void Extension_pskel::
  valueCode_parser (::fhir::code_pskel& p)
  {
    this->valueCode_parser_ = &p;
  }

  void Extension_pskel::
  valueDate_parser (::fhir::date_pskel& p)
  {
    this->valueDate_parser_ = &p;
  }

  void Extension_pskel::
  valueDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->valueDateTime_parser_ = &p;
  }

  void Extension_pskel::
  valueDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->valueDecimal_parser_ = &p;
  }

  void Extension_pskel::
  valueId_parser (::fhir::id_pskel& p)
  {
    this->valueId_parser_ = &p;
  }

  void Extension_pskel::
  valueInstant_parser (::fhir::instant_pskel& p)
  {
    this->valueInstant_parser_ = &p;
  }

  void Extension_pskel::
  valueInteger_parser (::fhir::integer_pskel& p)
  {
    this->valueInteger_parser_ = &p;
  }

  void Extension_pskel::
  valueMarkdown_parser (::fhir::markdown_pskel& p)
  {
    this->valueMarkdown_parser_ = &p;
  }

  void Extension_pskel::
  valueOid_parser (::fhir::oid_pskel& p)
  {
    this->valueOid_parser_ = &p;
  }

  void Extension_pskel::
  valuePositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->valuePositiveInt_parser_ = &p;
  }

  void Extension_pskel::
  valueString_parser (::fhir::string_pskel& p)
  {
    this->valueString_parser_ = &p;
  }

  void Extension_pskel::
  valueTime_parser (::fhir::time_pskel& p)
  {
    this->valueTime_parser_ = &p;
  }

  void Extension_pskel::
  valueUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->valueUnsignedInt_parser_ = &p;
  }

  void Extension_pskel::
  valueUri_parser (::fhir::uri_pskel& p)
  {
    this->valueUri_parser_ = &p;
  }

  void Extension_pskel::
  valueUrl_parser (::fhir::url_pskel& p)
  {
    this->valueUrl_parser_ = &p;
  }

  void Extension_pskel::
  valueUuid_parser (::fhir::uuid_pskel& p)
  {
    this->valueUuid_parser_ = &p;
  }

  void Extension_pskel::
  valueAddress_parser (::fhir::Address_pskel& p)
  {
    this->valueAddress_parser_ = &p;
  }

  void Extension_pskel::
  valueAge_parser (::fhir::Age_pskel& p)
  {
    this->valueAge_parser_ = &p;
  }

  void Extension_pskel::
  valueAnnotation_parser (::fhir::Annotation_pskel& p)
  {
    this->valueAnnotation_parser_ = &p;
  }

  void Extension_pskel::
  valueAttachment_parser (::fhir::Attachment_pskel& p)
  {
    this->valueAttachment_parser_ = &p;
  }

  void Extension_pskel::
  valueCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->valueCodeableConcept_parser_ = &p;
  }

  void Extension_pskel::
  valueCoding_parser (::fhir::Coding_pskel& p)
  {
    this->valueCoding_parser_ = &p;
  }

  void Extension_pskel::
  valueContactPoint_parser (::fhir::ContactPoint_pskel& p)
  {
    this->valueContactPoint_parser_ = &p;
  }

  void Extension_pskel::
  valueCount_parser (::fhir::Count_pskel& p)
  {
    this->valueCount_parser_ = &p;
  }

  void Extension_pskel::
  valueDistance_parser (::fhir::Distance_pskel& p)
  {
    this->valueDistance_parser_ = &p;
  }

  void Extension_pskel::
  valueDuration_parser (::fhir::Duration_pskel& p)
  {
    this->valueDuration_parser_ = &p;
  }

  void Extension_pskel::
  valueHumanName_parser (::fhir::HumanName_pskel& p)
  {
    this->valueHumanName_parser_ = &p;
  }

  void Extension_pskel::
  valueIdentifier_parser (::fhir::Identifier_pskel& p)
  {
    this->valueIdentifier_parser_ = &p;
  }

  void Extension_pskel::
  valueMoney_parser (::fhir::Money_pskel& p)
  {
    this->valueMoney_parser_ = &p;
  }

  void Extension_pskel::
  valuePeriod_parser (::fhir::Period_pskel& p)
  {
    this->valuePeriod_parser_ = &p;
  }

  void Extension_pskel::
  valueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->valueQuantity_parser_ = &p;
  }

  void Extension_pskel::
  valueRange_parser (::fhir::Range_pskel& p)
  {
    this->valueRange_parser_ = &p;
  }

  void Extension_pskel::
  valueRatio_parser (::fhir::Ratio_pskel& p)
  {
    this->valueRatio_parser_ = &p;
  }

  void Extension_pskel::
  valueReference_parser (::fhir::Reference_pskel& p)
  {
    this->valueReference_parser_ = &p;
  }

  void Extension_pskel::
  valueSampledData_parser (::fhir::SampledData_pskel& p)
  {
    this->valueSampledData_parser_ = &p;
  }

  void Extension_pskel::
  valueSignature_parser (::fhir::Signature_pskel& p)
  {
    this->valueSignature_parser_ = &p;
  }

  void Extension_pskel::
  valueTiming_parser (::fhir::Timing_pskel& p)
  {
    this->valueTiming_parser_ = &p;
  }

  void Extension_pskel::
  valueContactDetail_parser (::fhir::ContactDetail_pskel& p)
  {
    this->valueContactDetail_parser_ = &p;
  }

  void Extension_pskel::
  valueContributor_parser (::fhir::Contributor_pskel& p)
  {
    this->valueContributor_parser_ = &p;
  }

  void Extension_pskel::
  valueDataRequirement_parser (::fhir::DataRequirement_pskel& p)
  {
    this->valueDataRequirement_parser_ = &p;
  }

  void Extension_pskel::
  valueExpression_parser (::fhir::Expression_pskel& p)
  {
    this->valueExpression_parser_ = &p;
  }

  void Extension_pskel::
  valueParameterDefinition_parser (::fhir::ParameterDefinition_pskel& p)
  {
    this->valueParameterDefinition_parser_ = &p;
  }

  void Extension_pskel::
  valueRelatedArtifact_parser (::fhir::RelatedArtifact_pskel& p)
  {
    this->valueRelatedArtifact_parser_ = &p;
  }

  void Extension_pskel::
  valueTriggerDefinition_parser (::fhir::TriggerDefinition_pskel& p)
  {
    this->valueTriggerDefinition_parser_ = &p;
  }

  void Extension_pskel::
  valueUsageContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->valueUsageContext_parser_ = &p;
  }

  void Extension_pskel::
  valueDosage_parser (::fhir::Dosage_pskel& p)
  {
    this->valueDosage_parser_ = &p;
  }

  void Extension_pskel::
  valueMeta_parser (::fhir::Meta_pskel& p)
  {
    this->valueMeta_parser_ = &p;
  }

  void Extension_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::uri_primitive_pskel& url,
           ::fhir::base64Binary_pskel& valueBase64Binary,
           ::fhir::boolean_pskel& valueBoolean,
           ::fhir::canonical_pskel& valueCanonical,
           ::fhir::code_pskel& valueCode,
           ::fhir::date_pskel& valueDate,
           ::fhir::dateTime_pskel& valueDateTime,
           ::fhir::decimal_pskel& valueDecimal,
           ::fhir::id_pskel& valueId,
           ::fhir::instant_pskel& valueInstant,
           ::fhir::integer_pskel& valueInteger,
           ::fhir::markdown_pskel& valueMarkdown,
           ::fhir::oid_pskel& valueOid,
           ::fhir::positiveInt_pskel& valuePositiveInt,
           ::fhir::string_pskel& valueString,
           ::fhir::time_pskel& valueTime,
           ::fhir::unsignedInt_pskel& valueUnsignedInt,
           ::fhir::uri_pskel& valueUri,
           ::fhir::url_pskel& valueUrl,
           ::fhir::uuid_pskel& valueUuid,
           ::fhir::Address_pskel& valueAddress,
           ::fhir::Age_pskel& valueAge,
           ::fhir::Annotation_pskel& valueAnnotation,
           ::fhir::Attachment_pskel& valueAttachment,
           ::fhir::CodeableConcept_pskel& valueCodeableConcept,
           ::fhir::Coding_pskel& valueCoding,
           ::fhir::ContactPoint_pskel& valueContactPoint,
           ::fhir::Count_pskel& valueCount,
           ::fhir::Distance_pskel& valueDistance,
           ::fhir::Duration_pskel& valueDuration,
           ::fhir::HumanName_pskel& valueHumanName,
           ::fhir::Identifier_pskel& valueIdentifier,
           ::fhir::Money_pskel& valueMoney,
           ::fhir::Period_pskel& valuePeriod,
           ::fhir::Quantity_pskel& valueQuantity,
           ::fhir::Range_pskel& valueRange,
           ::fhir::Ratio_pskel& valueRatio,
           ::fhir::Reference_pskel& valueReference,
           ::fhir::SampledData_pskel& valueSampledData,
           ::fhir::Signature_pskel& valueSignature,
           ::fhir::Timing_pskel& valueTiming,
           ::fhir::ContactDetail_pskel& valueContactDetail,
           ::fhir::Contributor_pskel& valueContributor,
           ::fhir::DataRequirement_pskel& valueDataRequirement,
           ::fhir::Expression_pskel& valueExpression,
           ::fhir::ParameterDefinition_pskel& valueParameterDefinition,
           ::fhir::RelatedArtifact_pskel& valueRelatedArtifact,
           ::fhir::TriggerDefinition_pskel& valueTriggerDefinition,
           ::fhir::UsageContext_pskel& valueUsageContext,
           ::fhir::Dosage_pskel& valueDosage,
           ::fhir::Meta_pskel& valueMeta)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->url_parser_ = &url;
    this->valueBase64Binary_parser_ = &valueBase64Binary;
    this->valueBoolean_parser_ = &valueBoolean;
    this->valueCanonical_parser_ = &valueCanonical;
    this->valueCode_parser_ = &valueCode;
    this->valueDate_parser_ = &valueDate;
    this->valueDateTime_parser_ = &valueDateTime;
    this->valueDecimal_parser_ = &valueDecimal;
    this->valueId_parser_ = &valueId;
    this->valueInstant_parser_ = &valueInstant;
    this->valueInteger_parser_ = &valueInteger;
    this->valueMarkdown_parser_ = &valueMarkdown;
    this->valueOid_parser_ = &valueOid;
    this->valuePositiveInt_parser_ = &valuePositiveInt;
    this->valueString_parser_ = &valueString;
    this->valueTime_parser_ = &valueTime;
    this->valueUnsignedInt_parser_ = &valueUnsignedInt;
    this->valueUri_parser_ = &valueUri;
    this->valueUrl_parser_ = &valueUrl;
    this->valueUuid_parser_ = &valueUuid;
    this->valueAddress_parser_ = &valueAddress;
    this->valueAge_parser_ = &valueAge;
    this->valueAnnotation_parser_ = &valueAnnotation;
    this->valueAttachment_parser_ = &valueAttachment;
    this->valueCodeableConcept_parser_ = &valueCodeableConcept;
    this->valueCoding_parser_ = &valueCoding;
    this->valueContactPoint_parser_ = &valueContactPoint;
    this->valueCount_parser_ = &valueCount;
    this->valueDistance_parser_ = &valueDistance;
    this->valueDuration_parser_ = &valueDuration;
    this->valueHumanName_parser_ = &valueHumanName;
    this->valueIdentifier_parser_ = &valueIdentifier;
    this->valueMoney_parser_ = &valueMoney;
    this->valuePeriod_parser_ = &valuePeriod;
    this->valueQuantity_parser_ = &valueQuantity;
    this->valueRange_parser_ = &valueRange;
    this->valueRatio_parser_ = &valueRatio;
    this->valueReference_parser_ = &valueReference;
    this->valueSampledData_parser_ = &valueSampledData;
    this->valueSignature_parser_ = &valueSignature;
    this->valueTiming_parser_ = &valueTiming;
    this->valueContactDetail_parser_ = &valueContactDetail;
    this->valueContributor_parser_ = &valueContributor;
    this->valueDataRequirement_parser_ = &valueDataRequirement;
    this->valueExpression_parser_ = &valueExpression;
    this->valueParameterDefinition_parser_ = &valueParameterDefinition;
    this->valueRelatedArtifact_parser_ = &valueRelatedArtifact;
    this->valueTriggerDefinition_parser_ = &valueTriggerDefinition;
    this->valueUsageContext_parser_ = &valueUsageContext;
    this->valueDosage_parser_ = &valueDosage;
    this->valueMeta_parser_ = &valueMeta;
  }

  Extension_pskel::
  Extension_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Extension_impl_ (0),
    url_parser_ (0),
    valueBase64Binary_parser_ (0),
    valueBoolean_parser_ (0),
    valueCanonical_parser_ (0),
    valueCode_parser_ (0),
    valueDate_parser_ (0),
    valueDateTime_parser_ (0),
    valueDecimal_parser_ (0),
    valueId_parser_ (0),
    valueInstant_parser_ (0),
    valueInteger_parser_ (0),
    valueMarkdown_parser_ (0),
    valueOid_parser_ (0),
    valuePositiveInt_parser_ (0),
    valueString_parser_ (0),
    valueTime_parser_ (0),
    valueUnsignedInt_parser_ (0),
    valueUri_parser_ (0),
    valueUrl_parser_ (0),
    valueUuid_parser_ (0),
    valueAddress_parser_ (0),
    valueAge_parser_ (0),
    valueAnnotation_parser_ (0),
    valueAttachment_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueCoding_parser_ (0),
    valueContactPoint_parser_ (0),
    valueCount_parser_ (0),
    valueDistance_parser_ (0),
    valueDuration_parser_ (0),
    valueHumanName_parser_ (0),
    valueIdentifier_parser_ (0),
    valueMoney_parser_ (0),
    valuePeriod_parser_ (0),
    valueQuantity_parser_ (0),
    valueRange_parser_ (0),
    valueRatio_parser_ (0),
    valueReference_parser_ (0),
    valueSampledData_parser_ (0),
    valueSignature_parser_ (0),
    valueTiming_parser_ (0),
    valueContactDetail_parser_ (0),
    valueContributor_parser_ (0),
    valueDataRequirement_parser_ (0),
    valueExpression_parser_ (0),
    valueParameterDefinition_parser_ (0),
    valueRelatedArtifact_parser_ (0),
    valueTriggerDefinition_parser_ (0),
    valueUsageContext_parser_ (0),
    valueDosage_parser_ (0),
    valueMeta_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  Extension_pskel::
  Extension_pskel (Extension_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Extension_impl_ (impl),
    url_parser_ (0),
    valueBase64Binary_parser_ (0),
    valueBoolean_parser_ (0),
    valueCanonical_parser_ (0),
    valueCode_parser_ (0),
    valueDate_parser_ (0),
    valueDateTime_parser_ (0),
    valueDecimal_parser_ (0),
    valueId_parser_ (0),
    valueInstant_parser_ (0),
    valueInteger_parser_ (0),
    valueMarkdown_parser_ (0),
    valueOid_parser_ (0),
    valuePositiveInt_parser_ (0),
    valueString_parser_ (0),
    valueTime_parser_ (0),
    valueUnsignedInt_parser_ (0),
    valueUri_parser_ (0),
    valueUrl_parser_ (0),
    valueUuid_parser_ (0),
    valueAddress_parser_ (0),
    valueAge_parser_ (0),
    valueAnnotation_parser_ (0),
    valueAttachment_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueCoding_parser_ (0),
    valueContactPoint_parser_ (0),
    valueCount_parser_ (0),
    valueDistance_parser_ (0),
    valueDuration_parser_ (0),
    valueHumanName_parser_ (0),
    valueIdentifier_parser_ (0),
    valueMoney_parser_ (0),
    valuePeriod_parser_ (0),
    valueQuantity_parser_ (0),
    valueRange_parser_ (0),
    valueRatio_parser_ (0),
    valueReference_parser_ (0),
    valueSampledData_parser_ (0),
    valueSignature_parser_ (0),
    valueTiming_parser_ (0),
    valueContactDetail_parser_ (0),
    valueContributor_parser_ (0),
    valueDataRequirement_parser_ (0),
    valueExpression_parser_ (0),
    valueParameterDefinition_parser_ (0),
    valueRelatedArtifact_parser_ (0),
    valueTriggerDefinition_parser_ (0),
    valueUsageContext_parser_ (0),
    valueDosage_parser_ (0),
    valueMeta_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // BackboneElement_pskel
  //

  void BackboneElement_pskel::
  modifierExtension_parser (::fhir::Extension_pskel& p)
  {
    this->modifierExtension_parser_ = &p;
  }

  void BackboneElement_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
  }

  BackboneElement_pskel::
  BackboneElement_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    BackboneElement_impl_ (0),
    modifierExtension_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  BackboneElement_pskel::
  BackboneElement_pskel (BackboneElement_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    BackboneElement_impl_ (impl),
    modifierExtension_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Narrative_pskel
  //

  void Narrative_pskel::
  status_parser (::fhir::NarrativeStatus_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void Narrative_pskel::
  div_parser (::xhtml::div_pskel& p)
  {
    this->div_parser_ = &p;
  }

  void Narrative_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::NarrativeStatus_pskel& status,
           ::xhtml::div_pskel& div)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->status_parser_ = &status;
    this->div_parser_ = &div;
  }

  Narrative_pskel::
  Narrative_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Narrative_impl_ (0),
    status_parser_ (0),
    div_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Narrative_pskel::
  Narrative_pskel (Narrative_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Narrative_impl_ (impl),
    status_parser_ (0),
    div_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // NarrativeStatus_list_pskel
  //

  NarrativeStatus_list_pskel::
  NarrativeStatus_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    NarrativeStatus_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_NarrativeStatus_list_pskel_enums_, 4UL);
  }

  NarrativeStatus_list_pskel::
  NarrativeStatus_list_pskel (NarrativeStatus_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    NarrativeStatus_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_NarrativeStatus_list_pskel_enums_, 4UL);
  }

  // NarrativeStatus_pskel
  //

  void NarrativeStatus_pskel::
  value_parser (::fhir::NarrativeStatus_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void NarrativeStatus_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::NarrativeStatus_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  NarrativeStatus_pskel::
  NarrativeStatus_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    NarrativeStatus_impl_ (0),
    value_parser_ (0)
  {
  }

  NarrativeStatus_pskel::
  NarrativeStatus_pskel (NarrativeStatus_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    NarrativeStatus_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Meta_pskel
  //

  void Meta_pskel::
  versionId_parser (::fhir::id_pskel& p)
  {
    this->versionId_parser_ = &p;
  }

  void Meta_pskel::
  lastUpdated_parser (::fhir::instant_pskel& p)
  {
    this->lastUpdated_parser_ = &p;
  }

  void Meta_pskel::
  source_parser (::fhir::uri_pskel& p)
  {
    this->source_parser_ = &p;
  }

  void Meta_pskel::
  profile_parser (::fhir::canonical_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void Meta_pskel::
  security_parser (::fhir::Coding_pskel& p)
  {
    this->security_parser_ = &p;
  }

  void Meta_pskel::
  tag_parser (::fhir::Coding_pskel& p)
  {
    this->tag_parser_ = &p;
  }

  void Meta_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::id_pskel& versionId,
           ::fhir::instant_pskel& lastUpdated,
           ::fhir::uri_pskel& source,
           ::fhir::canonical_pskel& profile,
           ::fhir::Coding_pskel& security,
           ::fhir::Coding_pskel& tag)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->versionId_parser_ = &versionId;
    this->lastUpdated_parser_ = &lastUpdated;
    this->source_parser_ = &source;
    this->profile_parser_ = &profile;
    this->security_parser_ = &security;
    this->tag_parser_ = &tag;
  }

  Meta_pskel::
  Meta_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Meta_impl_ (0),
    versionId_parser_ (0),
    lastUpdated_parser_ (0),
    source_parser_ (0),
    profile_parser_ (0),
    security_parser_ (0),
    tag_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Meta_pskel::
  Meta_pskel (Meta_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Meta_impl_ (impl),
    versionId_parser_ (0),
    lastUpdated_parser_ (0),
    source_parser_ (0),
    profile_parser_ (0),
    security_parser_ (0),
    tag_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Address_pskel
  //

  void Address_pskel::
  use_parser (::fhir::AddressUse_pskel& p)
  {
    this->use_parser_ = &p;
  }

  void Address_pskel::
  type_parser (::fhir::AddressType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Address_pskel::
  text_parser (::fhir::string_pskel& p)
  {
    this->text_parser_ = &p;
  }

  void Address_pskel::
  line_parser (::fhir::string_pskel& p)
  {
    this->line_parser_ = &p;
  }

  void Address_pskel::
  city_parser (::fhir::string_pskel& p)
  {
    this->city_parser_ = &p;
  }

  void Address_pskel::
  district_parser (::fhir::string_pskel& p)
  {
    this->district_parser_ = &p;
  }

  void Address_pskel::
  state_parser (::fhir::string_pskel& p)
  {
    this->state_parser_ = &p;
  }

  void Address_pskel::
  postalCode_parser (::fhir::string_pskel& p)
  {
    this->postalCode_parser_ = &p;
  }

  void Address_pskel::
  country_parser (::fhir::string_pskel& p)
  {
    this->country_parser_ = &p;
  }

  void Address_pskel::
  period_parser (::fhir::Period_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void Address_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AddressUse_pskel& use,
           ::fhir::AddressType_pskel& type,
           ::fhir::string_pskel& text,
           ::fhir::string_pskel& line,
           ::fhir::string_pskel& city,
           ::fhir::string_pskel& district,
           ::fhir::string_pskel& state,
           ::fhir::string_pskel& postalCode,
           ::fhir::string_pskel& country,
           ::fhir::Period_pskel& period)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->use_parser_ = &use;
    this->type_parser_ = &type;
    this->text_parser_ = &text;
    this->line_parser_ = &line;
    this->city_parser_ = &city;
    this->district_parser_ = &district;
    this->state_parser_ = &state;
    this->postalCode_parser_ = &postalCode;
    this->country_parser_ = &country;
    this->period_parser_ = &period;
  }

  Address_pskel::
  Address_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Address_impl_ (0),
    use_parser_ (0),
    type_parser_ (0),
    text_parser_ (0),
    line_parser_ (0),
    city_parser_ (0),
    district_parser_ (0),
    state_parser_ (0),
    postalCode_parser_ (0),
    country_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Address_pskel::
  Address_pskel (Address_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Address_impl_ (impl),
    use_parser_ (0),
    type_parser_ (0),
    text_parser_ (0),
    line_parser_ (0),
    city_parser_ (0),
    district_parser_ (0),
    state_parser_ (0),
    postalCode_parser_ (0),
    country_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // AddressUse_list_pskel
  //

  AddressUse_list_pskel::
  AddressUse_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AddressUse_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AddressUse_list_pskel_enums_, 5UL);
  }

  AddressUse_list_pskel::
  AddressUse_list_pskel (AddressUse_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AddressUse_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AddressUse_list_pskel_enums_, 5UL);
  }

  // AddressUse_pskel
  //

  void AddressUse_pskel::
  value_parser (::fhir::AddressUse_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AddressUse_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AddressUse_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AddressUse_pskel::
  AddressUse_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AddressUse_impl_ (0),
    value_parser_ (0)
  {
  }

  AddressUse_pskel::
  AddressUse_pskel (AddressUse_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AddressUse_impl_ (impl),
    value_parser_ (0)
  {
  }

  // AddressType_list_pskel
  //

  AddressType_list_pskel::
  AddressType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AddressType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AddressType_list_pskel_enums_, 3UL);
  }

  AddressType_list_pskel::
  AddressType_list_pskel (AddressType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AddressType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AddressType_list_pskel_enums_, 3UL);
  }

  // AddressType_pskel
  //

  void AddressType_pskel::
  value_parser (::fhir::AddressType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AddressType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AddressType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AddressType_pskel::
  AddressType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AddressType_impl_ (0),
    value_parser_ (0)
  {
  }

  AddressType_pskel::
  AddressType_pskel (AddressType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AddressType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Contributor_pskel
  //

  void Contributor_pskel::
  type_parser (::fhir::ContributorType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Contributor_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Contributor_pskel::
  contact_parser (::fhir::ContactDetail_pskel& p)
  {
    this->contact_parser_ = &p;
  }

  void Contributor_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ContributorType_pskel& type,
           ::fhir::string_pskel& name,
           ::fhir::ContactDetail_pskel& contact)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->type_parser_ = &type;
    this->name_parser_ = &name;
    this->contact_parser_ = &contact;
  }

  Contributor_pskel::
  Contributor_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Contributor_impl_ (0),
    type_parser_ (0),
    name_parser_ (0),
    contact_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Contributor_pskel::
  Contributor_pskel (Contributor_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Contributor_impl_ (impl),
    type_parser_ (0),
    name_parser_ (0),
    contact_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ContributorType_list_pskel
  //

  ContributorType_list_pskel::
  ContributorType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ContributorType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ContributorType_list_pskel_enums_, 4UL);
  }

  ContributorType_list_pskel::
  ContributorType_list_pskel (ContributorType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ContributorType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ContributorType_list_pskel_enums_, 4UL);
  }

  // ContributorType_pskel
  //

  void ContributorType_pskel::
  value_parser (::fhir::ContributorType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ContributorType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ContributorType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ContributorType_pskel::
  ContributorType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ContributorType_impl_ (0),
    value_parser_ (0)
  {
  }

  ContributorType_pskel::
  ContributorType_pskel (ContributorType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ContributorType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Attachment_pskel
  //

  void Attachment_pskel::
  contentType_parser (::fhir::code_pskel& p)
  {
    this->contentType_parser_ = &p;
  }

  void Attachment_pskel::
  language_parser (::fhir::code_pskel& p)
  {
    this->language_parser_ = &p;
  }

  void Attachment_pskel::
  data_parser (::fhir::base64Binary_pskel& p)
  {
    this->data_parser_ = &p;
  }

  void Attachment_pskel::
  url_parser (::fhir::url_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void Attachment_pskel::
  size_parser (::fhir::unsignedInt_pskel& p)
  {
    this->size_parser_ = &p;
  }

  void Attachment_pskel::
  hash_parser (::fhir::base64Binary_pskel& p)
  {
    this->hash_parser_ = &p;
  }

  void Attachment_pskel::
  title_parser (::fhir::string_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void Attachment_pskel::
  creation_parser (::fhir::dateTime_pskel& p)
  {
    this->creation_parser_ = &p;
  }

  void Attachment_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::code_pskel& contentType,
           ::fhir::code_pskel& language,
           ::fhir::base64Binary_pskel& data,
           ::fhir::url_pskel& url,
           ::fhir::unsignedInt_pskel& size,
           ::fhir::base64Binary_pskel& hash,
           ::fhir::string_pskel& title,
           ::fhir::dateTime_pskel& creation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->contentType_parser_ = &contentType;
    this->language_parser_ = &language;
    this->data_parser_ = &data;
    this->url_parser_ = &url;
    this->size_parser_ = &size;
    this->hash_parser_ = &hash;
    this->title_parser_ = &title;
    this->creation_parser_ = &creation;
  }

  Attachment_pskel::
  Attachment_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Attachment_impl_ (0),
    contentType_parser_ (0),
    language_parser_ (0),
    data_parser_ (0),
    url_parser_ (0),
    size_parser_ (0),
    hash_parser_ (0),
    title_parser_ (0),
    creation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Attachment_pskel::
  Attachment_pskel (Attachment_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Attachment_impl_ (impl),
    contentType_parser_ (0),
    language_parser_ (0),
    data_parser_ (0),
    url_parser_ (0),
    size_parser_ (0),
    hash_parser_ (0),
    title_parser_ (0),
    creation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Quantity_pskel
  //

  void Quantity_pskel::
  value_parser (::fhir::decimal_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void Quantity_pskel::
  comparator_parser (::fhir::QuantityComparator_pskel& p)
  {
    this->comparator_parser_ = &p;
  }

  void Quantity_pskel::
  unit_parser (::fhir::string_pskel& p)
  {
    this->unit_parser_ = &p;
  }

  void Quantity_pskel::
  system_parser (::fhir::uri_pskel& p)
  {
    this->system_parser_ = &p;
  }

  void Quantity_pskel::
  code_parser (::fhir::code_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void Quantity_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::decimal_pskel& value,
           ::fhir::QuantityComparator_pskel& comparator,
           ::fhir::string_pskel& unit,
           ::fhir::uri_pskel& system,
           ::fhir::code_pskel& code)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
    this->comparator_parser_ = &comparator;
    this->unit_parser_ = &unit;
    this->system_parser_ = &system;
    this->code_parser_ = &code;
  }

  Quantity_pskel::
  Quantity_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Quantity_impl_ (0),
    value_parser_ (0),
    comparator_parser_ (0),
    unit_parser_ (0),
    system_parser_ (0),
    code_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Quantity_pskel::
  Quantity_pskel (Quantity_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Quantity_impl_ (impl),
    value_parser_ (0),
    comparator_parser_ (0),
    unit_parser_ (0),
    system_parser_ (0),
    code_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Count_pskel
  //

  Count_pskel::
  Count_pskel (::fhir::Quantity_pskel* tiein)
  : ::fhir::Quantity_pskel (tiein, 0),
    Count_impl_ (0)
  {
  }

  Count_pskel::
  Count_pskel (Count_pskel* impl, void*)
  : ::fhir::Quantity_pskel (impl, 0),
    Count_impl_ (impl)
  {
  }

  // DataRequirement_pskel
  //

  void DataRequirement_pskel::
  type_parser (::fhir::code_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void DataRequirement_pskel::
  profile_parser (::fhir::canonical_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void DataRequirement_pskel::
  subjectCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->subjectCodeableConcept_parser_ = &p;
  }

  void DataRequirement_pskel::
  subjectReference_parser (::fhir::Reference_pskel& p)
  {
    this->subjectReference_parser_ = &p;
  }

  void DataRequirement_pskel::
  mustSupport_parser (::fhir::string_pskel& p)
  {
    this->mustSupport_parser_ = &p;
  }

  void DataRequirement_pskel::
  codeFilter_parser (::fhir::DataRequirement_CodeFilter_pskel& p)
  {
    this->codeFilter_parser_ = &p;
  }

  void DataRequirement_pskel::
  dateFilter_parser (::fhir::DataRequirement_DateFilter_pskel& p)
  {
    this->dateFilter_parser_ = &p;
  }

  void DataRequirement_pskel::
  limit_parser (::fhir::positiveInt_pskel& p)
  {
    this->limit_parser_ = &p;
  }

  void DataRequirement_pskel::
  sort_parser (::fhir::DataRequirement_Sort_pskel& p)
  {
    this->sort_parser_ = &p;
  }

  void DataRequirement_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::code_pskel& type,
           ::fhir::canonical_pskel& profile,
           ::fhir::CodeableConcept_pskel& subjectCodeableConcept,
           ::fhir::Reference_pskel& subjectReference,
           ::fhir::string_pskel& mustSupport,
           ::fhir::DataRequirement_CodeFilter_pskel& codeFilter,
           ::fhir::DataRequirement_DateFilter_pskel& dateFilter,
           ::fhir::positiveInt_pskel& limit,
           ::fhir::DataRequirement_Sort_pskel& sort)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->type_parser_ = &type;
    this->profile_parser_ = &profile;
    this->subjectCodeableConcept_parser_ = &subjectCodeableConcept;
    this->subjectReference_parser_ = &subjectReference;
    this->mustSupport_parser_ = &mustSupport;
    this->codeFilter_parser_ = &codeFilter;
    this->dateFilter_parser_ = &dateFilter;
    this->limit_parser_ = &limit;
    this->sort_parser_ = &sort;
  }

  DataRequirement_pskel::
  DataRequirement_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DataRequirement_impl_ (0),
    type_parser_ (0),
    profile_parser_ (0),
    subjectCodeableConcept_parser_ (0),
    subjectReference_parser_ (0),
    mustSupport_parser_ (0),
    codeFilter_parser_ (0),
    dateFilter_parser_ (0),
    limit_parser_ (0),
    sort_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  DataRequirement_pskel::
  DataRequirement_pskel (DataRequirement_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DataRequirement_impl_ (impl),
    type_parser_ (0),
    profile_parser_ (0),
    subjectCodeableConcept_parser_ (0),
    subjectReference_parser_ (0),
    mustSupport_parser_ (0),
    codeFilter_parser_ (0),
    dateFilter_parser_ (0),
    limit_parser_ (0),
    sort_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // DataRequirement_CodeFilter_pskel
  //

  void DataRequirement_CodeFilter_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void DataRequirement_CodeFilter_pskel::
  searchParam_parser (::fhir::string_pskel& p)
  {
    this->searchParam_parser_ = &p;
  }

  void DataRequirement_CodeFilter_pskel::
  valueSet_parser (::fhir::canonical_pskel& p)
  {
    this->valueSet_parser_ = &p;
  }

  void DataRequirement_CodeFilter_pskel::
  code_parser (::fhir::Coding_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void DataRequirement_CodeFilter_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_pskel& path,
           ::fhir::string_pskel& searchParam,
           ::fhir::canonical_pskel& valueSet,
           ::fhir::Coding_pskel& code)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->path_parser_ = &path;
    this->searchParam_parser_ = &searchParam;
    this->valueSet_parser_ = &valueSet;
    this->code_parser_ = &code;
  }

  DataRequirement_CodeFilter_pskel::
  DataRequirement_CodeFilter_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DataRequirement_CodeFilter_impl_ (0),
    path_parser_ (0),
    searchParam_parser_ (0),
    valueSet_parser_ (0),
    code_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  DataRequirement_CodeFilter_pskel::
  DataRequirement_CodeFilter_pskel (DataRequirement_CodeFilter_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DataRequirement_CodeFilter_impl_ (impl),
    path_parser_ (0),
    searchParam_parser_ (0),
    valueSet_parser_ (0),
    code_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // DataRequirement_DateFilter_pskel
  //

  void DataRequirement_DateFilter_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void DataRequirement_DateFilter_pskel::
  searchParam_parser (::fhir::string_pskel& p)
  {
    this->searchParam_parser_ = &p;
  }

  void DataRequirement_DateFilter_pskel::
  valueDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->valueDateTime_parser_ = &p;
  }

  void DataRequirement_DateFilter_pskel::
  valuePeriod_parser (::fhir::Period_pskel& p)
  {
    this->valuePeriod_parser_ = &p;
  }

  void DataRequirement_DateFilter_pskel::
  valueDuration_parser (::fhir::Duration_pskel& p)
  {
    this->valueDuration_parser_ = &p;
  }

  void DataRequirement_DateFilter_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_pskel& path,
           ::fhir::string_pskel& searchParam,
           ::fhir::dateTime_pskel& valueDateTime,
           ::fhir::Period_pskel& valuePeriod,
           ::fhir::Duration_pskel& valueDuration)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->path_parser_ = &path;
    this->searchParam_parser_ = &searchParam;
    this->valueDateTime_parser_ = &valueDateTime;
    this->valuePeriod_parser_ = &valuePeriod;
    this->valueDuration_parser_ = &valueDuration;
  }

  DataRequirement_DateFilter_pskel::
  DataRequirement_DateFilter_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DataRequirement_DateFilter_impl_ (0),
    path_parser_ (0),
    searchParam_parser_ (0),
    valueDateTime_parser_ (0),
    valuePeriod_parser_ (0),
    valueDuration_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  DataRequirement_DateFilter_pskel::
  DataRequirement_DateFilter_pskel (DataRequirement_DateFilter_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DataRequirement_DateFilter_impl_ (impl),
    path_parser_ (0),
    searchParam_parser_ (0),
    valueDateTime_parser_ (0),
    valuePeriod_parser_ (0),
    valueDuration_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // DataRequirement_Sort_pskel
  //

  void DataRequirement_Sort_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void DataRequirement_Sort_pskel::
  direction_parser (::fhir::SortDirection_pskel& p)
  {
    this->direction_parser_ = &p;
  }

  void DataRequirement_Sort_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_pskel& path,
           ::fhir::SortDirection_pskel& direction)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->path_parser_ = &path;
    this->direction_parser_ = &direction;
  }

  DataRequirement_Sort_pskel::
  DataRequirement_Sort_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DataRequirement_Sort_impl_ (0),
    path_parser_ (0),
    direction_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  DataRequirement_Sort_pskel::
  DataRequirement_Sort_pskel (DataRequirement_Sort_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DataRequirement_Sort_impl_ (impl),
    path_parser_ (0),
    direction_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SortDirection_list_pskel
  //

  SortDirection_list_pskel::
  SortDirection_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    SortDirection_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_SortDirection_list_pskel_enums_, 2UL);
  }

  SortDirection_list_pskel::
  SortDirection_list_pskel (SortDirection_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    SortDirection_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_SortDirection_list_pskel_enums_, 2UL);
  }

  // SortDirection_pskel
  //

  void SortDirection_pskel::
  value_parser (::fhir::SortDirection_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void SortDirection_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::SortDirection_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  SortDirection_pskel::
  SortDirection_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SortDirection_impl_ (0),
    value_parser_ (0)
  {
  }

  SortDirection_pskel::
  SortDirection_pskel (SortDirection_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SortDirection_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Dosage_pskel
  //

  void Dosage_pskel::
  sequence_parser (::fhir::integer_pskel& p)
  {
    this->sequence_parser_ = &p;
  }

  void Dosage_pskel::
  text_parser (::fhir::string_pskel& p)
  {
    this->text_parser_ = &p;
  }

  void Dosage_pskel::
  additionalInstruction_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->additionalInstruction_parser_ = &p;
  }

  void Dosage_pskel::
  patientInstruction_parser (::fhir::string_pskel& p)
  {
    this->patientInstruction_parser_ = &p;
  }

  void Dosage_pskel::
  timing_parser (::fhir::Timing_pskel& p)
  {
    this->timing_parser_ = &p;
  }

  void Dosage_pskel::
  asNeededBoolean_parser (::fhir::boolean_pskel& p)
  {
    this->asNeededBoolean_parser_ = &p;
  }

  void Dosage_pskel::
  asNeededCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->asNeededCodeableConcept_parser_ = &p;
  }

  void Dosage_pskel::
  site_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->site_parser_ = &p;
  }

  void Dosage_pskel::
  route_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->route_parser_ = &p;
  }

  void Dosage_pskel::
  method_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->method_parser_ = &p;
  }

  void Dosage_pskel::
  doseAndRate_parser (::fhir::Dosage_DoseAndRate_pskel& p)
  {
    this->doseAndRate_parser_ = &p;
  }

  void Dosage_pskel::
  maxDosePerPeriod_parser (::fhir::Ratio_pskel& p)
  {
    this->maxDosePerPeriod_parser_ = &p;
  }

  void Dosage_pskel::
  maxDosePerAdministration_parser (::fhir::Quantity_pskel& p)
  {
    this->maxDosePerAdministration_parser_ = &p;
  }

  void Dosage_pskel::
  maxDosePerLifetime_parser (::fhir::Quantity_pskel& p)
  {
    this->maxDosePerLifetime_parser_ = &p;
  }

  void Dosage_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& sequence,
           ::fhir::string_pskel& text,
           ::fhir::CodeableConcept_pskel& additionalInstruction,
           ::fhir::string_pskel& patientInstruction,
           ::fhir::Timing_pskel& timing,
           ::fhir::boolean_pskel& asNeededBoolean,
           ::fhir::CodeableConcept_pskel& asNeededCodeableConcept,
           ::fhir::CodeableConcept_pskel& site,
           ::fhir::CodeableConcept_pskel& route,
           ::fhir::CodeableConcept_pskel& method,
           ::fhir::Dosage_DoseAndRate_pskel& doseAndRate,
           ::fhir::Ratio_pskel& maxDosePerPeriod,
           ::fhir::Quantity_pskel& maxDosePerAdministration,
           ::fhir::Quantity_pskel& maxDosePerLifetime)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->sequence_parser_ = &sequence;
    this->text_parser_ = &text;
    this->additionalInstruction_parser_ = &additionalInstruction;
    this->patientInstruction_parser_ = &patientInstruction;
    this->timing_parser_ = &timing;
    this->asNeededBoolean_parser_ = &asNeededBoolean;
    this->asNeededCodeableConcept_parser_ = &asNeededCodeableConcept;
    this->site_parser_ = &site;
    this->route_parser_ = &route;
    this->method_parser_ = &method;
    this->doseAndRate_parser_ = &doseAndRate;
    this->maxDosePerPeriod_parser_ = &maxDosePerPeriod;
    this->maxDosePerAdministration_parser_ = &maxDosePerAdministration;
    this->maxDosePerLifetime_parser_ = &maxDosePerLifetime;
  }

  Dosage_pskel::
  Dosage_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    Dosage_impl_ (0),
    sequence_parser_ (0),
    text_parser_ (0),
    additionalInstruction_parser_ (0),
    patientInstruction_parser_ (0),
    timing_parser_ (0),
    asNeededBoolean_parser_ (0),
    asNeededCodeableConcept_parser_ (0),
    site_parser_ (0),
    route_parser_ (0),
    method_parser_ (0),
    doseAndRate_parser_ (0),
    maxDosePerPeriod_parser_ (0),
    maxDosePerAdministration_parser_ (0),
    maxDosePerLifetime_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Dosage_pskel::
  Dosage_pskel (Dosage_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    Dosage_impl_ (impl),
    sequence_parser_ (0),
    text_parser_ (0),
    additionalInstruction_parser_ (0),
    patientInstruction_parser_ (0),
    timing_parser_ (0),
    asNeededBoolean_parser_ (0),
    asNeededCodeableConcept_parser_ (0),
    site_parser_ (0),
    route_parser_ (0),
    method_parser_ (0),
    doseAndRate_parser_ (0),
    maxDosePerPeriod_parser_ (0),
    maxDosePerAdministration_parser_ (0),
    maxDosePerLifetime_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Dosage_DoseAndRate_pskel
  //

  void Dosage_DoseAndRate_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Dosage_DoseAndRate_pskel::
  doseRange_parser (::fhir::Range_pskel& p)
  {
    this->doseRange_parser_ = &p;
  }

  void Dosage_DoseAndRate_pskel::
  doseQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->doseQuantity_parser_ = &p;
  }

  void Dosage_DoseAndRate_pskel::
  rateRatio_parser (::fhir::Ratio_pskel& p)
  {
    this->rateRatio_parser_ = &p;
  }

  void Dosage_DoseAndRate_pskel::
  rateRange_parser (::fhir::Range_pskel& p)
  {
    this->rateRange_parser_ = &p;
  }

  void Dosage_DoseAndRate_pskel::
  rateQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->rateQuantity_parser_ = &p;
  }

  void Dosage_DoseAndRate_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Range_pskel& doseRange,
           ::fhir::Quantity_pskel& doseQuantity,
           ::fhir::Ratio_pskel& rateRatio,
           ::fhir::Range_pskel& rateRange,
           ::fhir::Quantity_pskel& rateQuantity)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->doseRange_parser_ = &doseRange;
    this->doseQuantity_parser_ = &doseQuantity;
    this->rateRatio_parser_ = &rateRatio;
    this->rateRange_parser_ = &rateRange;
    this->rateQuantity_parser_ = &rateQuantity;
  }

  Dosage_DoseAndRate_pskel::
  Dosage_DoseAndRate_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    Dosage_DoseAndRate_impl_ (0),
    type_parser_ (0),
    doseRange_parser_ (0),
    doseQuantity_parser_ (0),
    rateRatio_parser_ (0),
    rateRange_parser_ (0),
    rateQuantity_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Dosage_DoseAndRate_pskel::
  Dosage_DoseAndRate_pskel (Dosage_DoseAndRate_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    Dosage_DoseAndRate_impl_ (impl),
    type_parser_ (0),
    doseRange_parser_ (0),
    doseQuantity_parser_ (0),
    rateRatio_parser_ (0),
    rateRange_parser_ (0),
    rateQuantity_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Money_pskel
  //

  void Money_pskel::
  value_parser (::fhir::decimal_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void Money_pskel::
  currency_parser (::fhir::code_pskel& p)
  {
    this->currency_parser_ = &p;
  }

  void Money_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::decimal_pskel& value,
           ::fhir::code_pskel& currency)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
    this->currency_parser_ = &currency;
  }

  Money_pskel::
  Money_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Money_impl_ (0),
    value_parser_ (0),
    currency_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Money_pskel::
  Money_pskel (Money_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Money_impl_ (impl),
    value_parser_ (0),
    currency_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // HumanName_pskel
  //

  void HumanName_pskel::
  use_parser (::fhir::NameUse_pskel& p)
  {
    this->use_parser_ = &p;
  }

  void HumanName_pskel::
  text_parser (::fhir::string_pskel& p)
  {
    this->text_parser_ = &p;
  }

  void HumanName_pskel::
  family_parser (::fhir::string_pskel& p)
  {
    this->family_parser_ = &p;
  }

  void HumanName_pskel::
  given_parser (::fhir::string_pskel& p)
  {
    this->given_parser_ = &p;
  }

  void HumanName_pskel::
  prefix_parser (::fhir::string_pskel& p)
  {
    this->prefix_parser_ = &p;
  }

  void HumanName_pskel::
  suffix_parser (::fhir::string_pskel& p)
  {
    this->suffix_parser_ = &p;
  }

  void HumanName_pskel::
  period_parser (::fhir::Period_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void HumanName_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::NameUse_pskel& use,
           ::fhir::string_pskel& text,
           ::fhir::string_pskel& family,
           ::fhir::string_pskel& given,
           ::fhir::string_pskel& prefix,
           ::fhir::string_pskel& suffix,
           ::fhir::Period_pskel& period)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->use_parser_ = &use;
    this->text_parser_ = &text;
    this->family_parser_ = &family;
    this->given_parser_ = &given;
    this->prefix_parser_ = &prefix;
    this->suffix_parser_ = &suffix;
    this->period_parser_ = &period;
  }

  HumanName_pskel::
  HumanName_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    HumanName_impl_ (0),
    use_parser_ (0),
    text_parser_ (0),
    family_parser_ (0),
    given_parser_ (0),
    prefix_parser_ (0),
    suffix_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  HumanName_pskel::
  HumanName_pskel (HumanName_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    HumanName_impl_ (impl),
    use_parser_ (0),
    text_parser_ (0),
    family_parser_ (0),
    given_parser_ (0),
    prefix_parser_ (0),
    suffix_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // NameUse_list_pskel
  //

  NameUse_list_pskel::
  NameUse_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    NameUse_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_NameUse_list_pskel_enums_, 7UL);
  }

  NameUse_list_pskel::
  NameUse_list_pskel (NameUse_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    NameUse_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_NameUse_list_pskel_enums_, 7UL);
  }

  // NameUse_pskel
  //

  void NameUse_pskel::
  value_parser (::fhir::NameUse_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void NameUse_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::NameUse_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  NameUse_pskel::
  NameUse_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    NameUse_impl_ (0),
    value_parser_ (0)
  {
  }

  NameUse_pskel::
  NameUse_pskel (NameUse_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    NameUse_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ContactPoint_pskel
  //

  void ContactPoint_pskel::
  system_parser (::fhir::ContactPointSystem_pskel& p)
  {
    this->system_parser_ = &p;
  }

  void ContactPoint_pskel::
  value_parser (::fhir::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ContactPoint_pskel::
  use_parser (::fhir::ContactPointUse_pskel& p)
  {
    this->use_parser_ = &p;
  }

  void ContactPoint_pskel::
  rank_parser (::fhir::positiveInt_pskel& p)
  {
    this->rank_parser_ = &p;
  }

  void ContactPoint_pskel::
  period_parser (::fhir::Period_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void ContactPoint_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ContactPointSystem_pskel& system,
           ::fhir::string_pskel& value,
           ::fhir::ContactPointUse_pskel& use,
           ::fhir::positiveInt_pskel& rank,
           ::fhir::Period_pskel& period)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->system_parser_ = &system;
    this->value_parser_ = &value;
    this->use_parser_ = &use;
    this->rank_parser_ = &rank;
    this->period_parser_ = &period;
  }

  ContactPoint_pskel::
  ContactPoint_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ContactPoint_impl_ (0),
    system_parser_ (0),
    value_parser_ (0),
    use_parser_ (0),
    rank_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ContactPoint_pskel::
  ContactPoint_pskel (ContactPoint_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ContactPoint_impl_ (impl),
    system_parser_ (0),
    value_parser_ (0),
    use_parser_ (0),
    rank_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ContactPointSystem_list_pskel
  //

  ContactPointSystem_list_pskel::
  ContactPointSystem_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ContactPointSystem_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ContactPointSystem_list_pskel_enums_, 7UL);
  }

  ContactPointSystem_list_pskel::
  ContactPointSystem_list_pskel (ContactPointSystem_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ContactPointSystem_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ContactPointSystem_list_pskel_enums_, 7UL);
  }

  // ContactPointSystem_pskel
  //

  void ContactPointSystem_pskel::
  value_parser (::fhir::ContactPointSystem_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ContactPointSystem_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ContactPointSystem_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ContactPointSystem_pskel::
  ContactPointSystem_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ContactPointSystem_impl_ (0),
    value_parser_ (0)
  {
  }

  ContactPointSystem_pskel::
  ContactPointSystem_pskel (ContactPointSystem_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ContactPointSystem_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ContactPointUse_list_pskel
  //

  ContactPointUse_list_pskel::
  ContactPointUse_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ContactPointUse_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ContactPointUse_list_pskel_enums_, 5UL);
  }

  ContactPointUse_list_pskel::
  ContactPointUse_list_pskel (ContactPointUse_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ContactPointUse_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ContactPointUse_list_pskel_enums_, 5UL);
  }

  // ContactPointUse_pskel
  //

  void ContactPointUse_pskel::
  value_parser (::fhir::ContactPointUse_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ContactPointUse_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ContactPointUse_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ContactPointUse_pskel::
  ContactPointUse_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ContactPointUse_impl_ (0),
    value_parser_ (0)
  {
  }

  ContactPointUse_pskel::
  ContactPointUse_pskel (ContactPointUse_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ContactPointUse_impl_ (impl),
    value_parser_ (0)
  {
  }

  // MarketingStatus_pskel
  //

  void MarketingStatus_pskel::
  country_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->country_parser_ = &p;
  }

  void MarketingStatus_pskel::
  jurisdiction_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->jurisdiction_parser_ = &p;
  }

  void MarketingStatus_pskel::
  status_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void MarketingStatus_pskel::
  dateRange_parser (::fhir::Period_pskel& p)
  {
    this->dateRange_parser_ = &p;
  }

  void MarketingStatus_pskel::
  restoreDate_parser (::fhir::dateTime_pskel& p)
  {
    this->restoreDate_parser_ = &p;
  }

  void MarketingStatus_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& country,
           ::fhir::CodeableConcept_pskel& jurisdiction,
           ::fhir::CodeableConcept_pskel& status,
           ::fhir::Period_pskel& dateRange,
           ::fhir::dateTime_pskel& restoreDate)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->country_parser_ = &country;
    this->jurisdiction_parser_ = &jurisdiction;
    this->status_parser_ = &status;
    this->dateRange_parser_ = &dateRange;
    this->restoreDate_parser_ = &restoreDate;
  }

  MarketingStatus_pskel::
  MarketingStatus_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MarketingStatus_impl_ (0),
    country_parser_ (0),
    jurisdiction_parser_ (0),
    status_parser_ (0),
    dateRange_parser_ (0),
    restoreDate_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MarketingStatus_pskel::
  MarketingStatus_pskel (MarketingStatus_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MarketingStatus_impl_ (impl),
    country_parser_ (0),
    jurisdiction_parser_ (0),
    status_parser_ (0),
    dateRange_parser_ (0),
    restoreDate_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Identifier_pskel
  //

  void Identifier_pskel::
  use_parser (::fhir::IdentifierUse_pskel& p)
  {
    this->use_parser_ = &p;
  }

  void Identifier_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Identifier_pskel::
  system_parser (::fhir::uri_pskel& p)
  {
    this->system_parser_ = &p;
  }

  void Identifier_pskel::
  value_parser (::fhir::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void Identifier_pskel::
  period_parser (::fhir::Period_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void Identifier_pskel::
  assigner_parser (::fhir::Reference_pskel& p)
  {
    this->assigner_parser_ = &p;
  }

  void Identifier_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::IdentifierUse_pskel& use,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::uri_pskel& system,
           ::fhir::string_pskel& value,
           ::fhir::Period_pskel& period,
           ::fhir::Reference_pskel& assigner)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->use_parser_ = &use;
    this->type_parser_ = &type;
    this->system_parser_ = &system;
    this->value_parser_ = &value;
    this->period_parser_ = &period;
    this->assigner_parser_ = &assigner;
  }

  Identifier_pskel::
  Identifier_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Identifier_impl_ (0),
    use_parser_ (0),
    type_parser_ (0),
    system_parser_ (0),
    value_parser_ (0),
    period_parser_ (0),
    assigner_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Identifier_pskel::
  Identifier_pskel (Identifier_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Identifier_impl_ (impl),
    use_parser_ (0),
    type_parser_ (0),
    system_parser_ (0),
    value_parser_ (0),
    period_parser_ (0),
    assigner_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // IdentifierUse_list_pskel
  //

  IdentifierUse_list_pskel::
  IdentifierUse_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    IdentifierUse_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_IdentifierUse_list_pskel_enums_, 5UL);
  }

  IdentifierUse_list_pskel::
  IdentifierUse_list_pskel (IdentifierUse_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    IdentifierUse_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_IdentifierUse_list_pskel_enums_, 5UL);
  }

  // IdentifierUse_pskel
  //

  void IdentifierUse_pskel::
  value_parser (::fhir::IdentifierUse_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void IdentifierUse_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::IdentifierUse_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  IdentifierUse_pskel::
  IdentifierUse_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    IdentifierUse_impl_ (0),
    value_parser_ (0)
  {
  }

  IdentifierUse_pskel::
  IdentifierUse_pskel (IdentifierUse_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    IdentifierUse_impl_ (impl),
    value_parser_ (0)
  {
  }

  // SubstanceAmount_pskel
  //

  void SubstanceAmount_pskel::
  amountQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->amountQuantity_parser_ = &p;
  }

  void SubstanceAmount_pskel::
  amountRange_parser (::fhir::Range_pskel& p)
  {
    this->amountRange_parser_ = &p;
  }

  void SubstanceAmount_pskel::
  amountString_parser (::fhir::string_pskel& p)
  {
    this->amountString_parser_ = &p;
  }

  void SubstanceAmount_pskel::
  amountType_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->amountType_parser_ = &p;
  }

  void SubstanceAmount_pskel::
  amountText_parser (::fhir::string_pskel& p)
  {
    this->amountText_parser_ = &p;
  }

  void SubstanceAmount_pskel::
  referenceRange_parser (::fhir::SubstanceAmount_ReferenceRange_pskel& p)
  {
    this->referenceRange_parser_ = &p;
  }

  void SubstanceAmount_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Quantity_pskel& amountQuantity,
           ::fhir::Range_pskel& amountRange,
           ::fhir::string_pskel& amountString,
           ::fhir::CodeableConcept_pskel& amountType,
           ::fhir::string_pskel& amountText,
           ::fhir::SubstanceAmount_ReferenceRange_pskel& referenceRange)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->amountQuantity_parser_ = &amountQuantity;
    this->amountRange_parser_ = &amountRange;
    this->amountString_parser_ = &amountString;
    this->amountType_parser_ = &amountType;
    this->amountText_parser_ = &amountText;
    this->referenceRange_parser_ = &referenceRange;
  }

  SubstanceAmount_pskel::
  SubstanceAmount_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    SubstanceAmount_impl_ (0),
    amountQuantity_parser_ (0),
    amountRange_parser_ (0),
    amountString_parser_ (0),
    amountType_parser_ (0),
    amountText_parser_ (0),
    referenceRange_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SubstanceAmount_pskel::
  SubstanceAmount_pskel (SubstanceAmount_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    SubstanceAmount_impl_ (impl),
    amountQuantity_parser_ (0),
    amountRange_parser_ (0),
    amountString_parser_ (0),
    amountType_parser_ (0),
    amountText_parser_ (0),
    referenceRange_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SubstanceAmount_ReferenceRange_pskel
  //

  void SubstanceAmount_ReferenceRange_pskel::
  lowLimit_parser (::fhir::Quantity_pskel& p)
  {
    this->lowLimit_parser_ = &p;
  }

  void SubstanceAmount_ReferenceRange_pskel::
  highLimit_parser (::fhir::Quantity_pskel& p)
  {
    this->highLimit_parser_ = &p;
  }

  void SubstanceAmount_ReferenceRange_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Quantity_pskel& lowLimit,
           ::fhir::Quantity_pskel& highLimit)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->lowLimit_parser_ = &lowLimit;
    this->highLimit_parser_ = &highLimit;
  }

  SubstanceAmount_ReferenceRange_pskel::
  SubstanceAmount_ReferenceRange_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    SubstanceAmount_ReferenceRange_impl_ (0),
    lowLimit_parser_ (0),
    highLimit_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SubstanceAmount_ReferenceRange_pskel::
  SubstanceAmount_ReferenceRange_pskel (SubstanceAmount_ReferenceRange_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    SubstanceAmount_ReferenceRange_impl_ (impl),
    lowLimit_parser_ (0),
    highLimit_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Coding_pskel
  //

  void Coding_pskel::
  system_parser (::fhir::uri_pskel& p)
  {
    this->system_parser_ = &p;
  }

  void Coding_pskel::
  version_parser (::fhir::string_pskel& p)
  {
    this->version_parser_ = &p;
  }

  void Coding_pskel::
  code_parser (::fhir::code_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void Coding_pskel::
  display_parser (::fhir::string_pskel& p)
  {
    this->display_parser_ = &p;
  }

  void Coding_pskel::
  userSelected_parser (::fhir::boolean_pskel& p)
  {
    this->userSelected_parser_ = &p;
  }

  void Coding_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::uri_pskel& system,
           ::fhir::string_pskel& version,
           ::fhir::code_pskel& code,
           ::fhir::string_pskel& display,
           ::fhir::boolean_pskel& userSelected)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->system_parser_ = &system;
    this->version_parser_ = &version;
    this->code_parser_ = &code;
    this->display_parser_ = &display;
    this->userSelected_parser_ = &userSelected;
  }

  Coding_pskel::
  Coding_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Coding_impl_ (0),
    system_parser_ (0),
    version_parser_ (0),
    code_parser_ (0),
    display_parser_ (0),
    userSelected_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Coding_pskel::
  Coding_pskel (Coding_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Coding_impl_ (impl),
    system_parser_ (0),
    version_parser_ (0),
    code_parser_ (0),
    display_parser_ (0),
    userSelected_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SampledData_pskel
  //

  void SampledData_pskel::
  origin_parser (::fhir::Quantity_pskel& p)
  {
    this->origin_parser_ = &p;
  }

  void SampledData_pskel::
  period_parser (::fhir::decimal_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void SampledData_pskel::
  factor_parser (::fhir::decimal_pskel& p)
  {
    this->factor_parser_ = &p;
  }

  void SampledData_pskel::
  lowerLimit_parser (::fhir::decimal_pskel& p)
  {
    this->lowerLimit_parser_ = &p;
  }

  void SampledData_pskel::
  upperLimit_parser (::fhir::decimal_pskel& p)
  {
    this->upperLimit_parser_ = &p;
  }

  void SampledData_pskel::
  dimensions_parser (::fhir::positiveInt_pskel& p)
  {
    this->dimensions_parser_ = &p;
  }

  void SampledData_pskel::
  data_parser (::fhir::SampledDataDataType_pskel& p)
  {
    this->data_parser_ = &p;
  }

  void SampledData_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Quantity_pskel& origin,
           ::fhir::decimal_pskel& period,
           ::fhir::decimal_pskel& factor,
           ::fhir::decimal_pskel& lowerLimit,
           ::fhir::decimal_pskel& upperLimit,
           ::fhir::positiveInt_pskel& dimensions,
           ::fhir::SampledDataDataType_pskel& data)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->origin_parser_ = &origin;
    this->period_parser_ = &period;
    this->factor_parser_ = &factor;
    this->lowerLimit_parser_ = &lowerLimit;
    this->upperLimit_parser_ = &upperLimit;
    this->dimensions_parser_ = &dimensions;
    this->data_parser_ = &data;
  }

  SampledData_pskel::
  SampledData_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SampledData_impl_ (0),
    origin_parser_ (0),
    period_parser_ (0),
    factor_parser_ (0),
    lowerLimit_parser_ (0),
    upperLimit_parser_ (0),
    dimensions_parser_ (0),
    data_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  SampledData_pskel::
  SampledData_pskel (SampledData_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SampledData_impl_ (impl),
    origin_parser_ (0),
    period_parser_ (0),
    factor_parser_ (0),
    lowerLimit_parser_ (0),
    upperLimit_parser_ (0),
    dimensions_parser_ (0),
    data_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // SampledDataDataType_primitive_pskel
  //

  SampledDataDataType_primitive_pskel::
  SampledDataDataType_primitive_pskel (::xml_schema::string_pskel* tiein)
  : ::xml_schema::string_pskel (tiein, 0),
    SampledDataDataType_primitive_impl_ (0)
  {
    this->_pattern_facet ("((-{0,1}\\d*\\.{0,1}\\d+)|[EUL])( ((-{0,1}\\d*\\.{0,1}\\d+)|[EUL]))*");
  }

  SampledDataDataType_primitive_pskel::
  SampledDataDataType_primitive_pskel (SampledDataDataType_primitive_pskel* impl, void*)
  : ::xml_schema::string_pskel (impl, 0),
    SampledDataDataType_primitive_impl_ (impl)
  {
    this->_pattern_facet ("((-{0,1}\\d*\\.{0,1}\\d+)|[EUL])( ((-{0,1}\\d*\\.{0,1}\\d+)|[EUL]))*");
  }

  // SampledDataDataType_pskel
  //

  void SampledDataDataType_pskel::
  value_parser (::fhir::SampledDataDataType_primitive_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void SampledDataDataType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::SampledDataDataType_primitive_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  SampledDataDataType_pskel::
  SampledDataDataType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SampledDataDataType_impl_ (0),
    value_parser_ (0)
  {
  }

  SampledDataDataType_pskel::
  SampledDataDataType_pskel (SampledDataDataType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SampledDataDataType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Population_pskel
  //

  void Population_pskel::
  ageRange_parser (::fhir::Range_pskel& p)
  {
    this->ageRange_parser_ = &p;
  }

  void Population_pskel::
  ageCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->ageCodeableConcept_parser_ = &p;
  }

  void Population_pskel::
  gender_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->gender_parser_ = &p;
  }

  void Population_pskel::
  race_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->race_parser_ = &p;
  }

  void Population_pskel::
  physiologicalCondition_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->physiologicalCondition_parser_ = &p;
  }

  void Population_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Range_pskel& ageRange,
           ::fhir::CodeableConcept_pskel& ageCodeableConcept,
           ::fhir::CodeableConcept_pskel& gender,
           ::fhir::CodeableConcept_pskel& race,
           ::fhir::CodeableConcept_pskel& physiologicalCondition)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->ageRange_parser_ = &ageRange;
    this->ageCodeableConcept_parser_ = &ageCodeableConcept;
    this->gender_parser_ = &gender;
    this->race_parser_ = &race;
    this->physiologicalCondition_parser_ = &physiologicalCondition;
  }

  Population_pskel::
  Population_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    Population_impl_ (0),
    ageRange_parser_ (0),
    ageCodeableConcept_parser_ (0),
    gender_parser_ (0),
    race_parser_ (0),
    physiologicalCondition_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Population_pskel::
  Population_pskel (Population_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    Population_impl_ (impl),
    ageRange_parser_ (0),
    ageCodeableConcept_parser_ (0),
    gender_parser_ (0),
    race_parser_ (0),
    physiologicalCondition_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Ratio_pskel
  //

  void Ratio_pskel::
  numerator_parser (::fhir::Quantity_pskel& p)
  {
    this->numerator_parser_ = &p;
  }

  void Ratio_pskel::
  denominator_parser (::fhir::Quantity_pskel& p)
  {
    this->denominator_parser_ = &p;
  }

  void Ratio_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Quantity_pskel& numerator,
           ::fhir::Quantity_pskel& denominator)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->numerator_parser_ = &numerator;
    this->denominator_parser_ = &denominator;
  }

  Ratio_pskel::
  Ratio_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Ratio_impl_ (0),
    numerator_parser_ (0),
    denominator_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Ratio_pskel::
  Ratio_pskel (Ratio_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Ratio_impl_ (impl),
    numerator_parser_ (0),
    denominator_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Distance_pskel
  //

  Distance_pskel::
  Distance_pskel (::fhir::Quantity_pskel* tiein)
  : ::fhir::Quantity_pskel (tiein, 0),
    Distance_impl_ (0)
  {
  }

  Distance_pskel::
  Distance_pskel (Distance_pskel* impl, void*)
  : ::fhir::Quantity_pskel (impl, 0),
    Distance_impl_ (impl)
  {
  }

  // Age_pskel
  //

  Age_pskel::
  Age_pskel (::fhir::Quantity_pskel* tiein)
  : ::fhir::Quantity_pskel (tiein, 0),
    Age_impl_ (0)
  {
  }

  Age_pskel::
  Age_pskel (Age_pskel* impl, void*)
  : ::fhir::Quantity_pskel (impl, 0),
    Age_impl_ (impl)
  {
  }

  // Reference_pskel
  //

  void Reference_pskel::
  reference_parser (::fhir::string_pskel& p)
  {
    this->reference_parser_ = &p;
  }

  void Reference_pskel::
  type_parser (::fhir::uri_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Reference_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void Reference_pskel::
  display_parser (::fhir::string_pskel& p)
  {
    this->display_parser_ = &p;
  }

  void Reference_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_pskel& reference,
           ::fhir::uri_pskel& type,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::string_pskel& display)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->reference_parser_ = &reference;
    this->type_parser_ = &type;
    this->identifier_parser_ = &identifier;
    this->display_parser_ = &display;
  }

  Reference_pskel::
  Reference_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Reference_impl_ (0),
    reference_parser_ (0),
    type_parser_ (0),
    identifier_parser_ (0),
    display_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Reference_pskel::
  Reference_pskel (Reference_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Reference_impl_ (impl),
    reference_parser_ (0),
    type_parser_ (0),
    identifier_parser_ (0),
    display_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TriggerDefinition_pskel
  //

  void TriggerDefinition_pskel::
  type_parser (::fhir::TriggerType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  timingTiming_parser (::fhir::Timing_pskel& p)
  {
    this->timingTiming_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  timingReference_parser (::fhir::Reference_pskel& p)
  {
    this->timingReference_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  timingDate_parser (::fhir::date_pskel& p)
  {
    this->timingDate_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  timingDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->timingDateTime_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  data_parser (::fhir::DataRequirement_pskel& p)
  {
    this->data_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  condition_parser (::fhir::Expression_pskel& p)
  {
    this->condition_parser_ = &p;
  }

  void TriggerDefinition_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::TriggerType_pskel& type,
           ::fhir::string_pskel& name,
           ::fhir::Timing_pskel& timingTiming,
           ::fhir::Reference_pskel& timingReference,
           ::fhir::date_pskel& timingDate,
           ::fhir::dateTime_pskel& timingDateTime,
           ::fhir::DataRequirement_pskel& data,
           ::fhir::Expression_pskel& condition)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->type_parser_ = &type;
    this->name_parser_ = &name;
    this->timingTiming_parser_ = &timingTiming;
    this->timingReference_parser_ = &timingReference;
    this->timingDate_parser_ = &timingDate;
    this->timingDateTime_parser_ = &timingDateTime;
    this->data_parser_ = &data;
    this->condition_parser_ = &condition;
  }

  TriggerDefinition_pskel::
  TriggerDefinition_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    TriggerDefinition_impl_ (0),
    type_parser_ (0),
    name_parser_ (0),
    timingTiming_parser_ (0),
    timingReference_parser_ (0),
    timingDate_parser_ (0),
    timingDateTime_parser_ (0),
    data_parser_ (0),
    condition_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  TriggerDefinition_pskel::
  TriggerDefinition_pskel (TriggerDefinition_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    TriggerDefinition_impl_ (impl),
    type_parser_ (0),
    name_parser_ (0),
    timingTiming_parser_ (0),
    timingReference_parser_ (0),
    timingDate_parser_ (0),
    timingDateTime_parser_ (0),
    data_parser_ (0),
    condition_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // TriggerType_list_pskel
  //

  TriggerType_list_pskel::
  TriggerType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    TriggerType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_TriggerType_list_pskel_enums_, 8UL);
  }

  TriggerType_list_pskel::
  TriggerType_list_pskel (TriggerType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    TriggerType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_TriggerType_list_pskel_enums_, 8UL);
  }

  // TriggerType_pskel
  //

  void TriggerType_pskel::
  value_parser (::fhir::TriggerType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void TriggerType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::TriggerType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  TriggerType_pskel::
  TriggerType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    TriggerType_impl_ (0),
    value_parser_ (0)
  {
  }

  TriggerType_pskel::
  TriggerType_pskel (TriggerType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    TriggerType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // QuantityComparator_list_pskel
  //

  QuantityComparator_list_pskel::
  QuantityComparator_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    QuantityComparator_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_QuantityComparator_list_pskel_enums_, 4UL);
  }

  QuantityComparator_list_pskel::
  QuantityComparator_list_pskel (QuantityComparator_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    QuantityComparator_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_QuantityComparator_list_pskel_enums_, 4UL);
  }

  // QuantityComparator_pskel
  //

  void QuantityComparator_pskel::
  value_parser (::fhir::QuantityComparator_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void QuantityComparator_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::QuantityComparator_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  QuantityComparator_pskel::
  QuantityComparator_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    QuantityComparator_impl_ (0),
    value_parser_ (0)
  {
  }

  QuantityComparator_pskel::
  QuantityComparator_pskel (QuantityComparator_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    QuantityComparator_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Period_pskel
  //

  void Period_pskel::
  start_parser (::fhir::dateTime_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void Period_pskel::
  end_parser (::fhir::dateTime_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void Period_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::dateTime_pskel& start,
           ::fhir::dateTime_pskel& end)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  Period_pskel::
  Period_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Period_impl_ (0),
    start_parser_ (0),
    end_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Period_pskel::
  Period_pskel (Period_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Period_impl_ (impl),
    start_parser_ (0),
    end_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Duration_pskel
  //

  Duration_pskel::
  Duration_pskel (::fhir::Quantity_pskel* tiein)
  : ::fhir::Quantity_pskel (tiein, 0),
    Duration_impl_ (0)
  {
  }

  Duration_pskel::
  Duration_pskel (Duration_pskel* impl, void*)
  : ::fhir::Quantity_pskel (impl, 0),
    Duration_impl_ (impl)
  {
  }

  // Range_pskel
  //

  void Range_pskel::
  low_parser (::fhir::Quantity_pskel& p)
  {
    this->low_parser_ = &p;
  }

  void Range_pskel::
  high_parser (::fhir::Quantity_pskel& p)
  {
    this->high_parser_ = &p;
  }

  void Range_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Quantity_pskel& low,
           ::fhir::Quantity_pskel& high)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->low_parser_ = &low;
    this->high_parser_ = &high;
  }

  Range_pskel::
  Range_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Range_impl_ (0),
    low_parser_ (0),
    high_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Range_pskel::
  Range_pskel (Range_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Range_impl_ (impl),
    low_parser_ (0),
    high_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // RelatedArtifact_pskel
  //

  void RelatedArtifact_pskel::
  type_parser (::fhir::RelatedArtifactType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  label_parser (::fhir::string_pskel& p)
  {
    this->label_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  display_parser (::fhir::string_pskel& p)
  {
    this->display_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  citation_parser (::fhir::markdown_pskel& p)
  {
    this->citation_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  url_parser (::fhir::url_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  document_parser (::fhir::Attachment_pskel& p)
  {
    this->document_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  resource_parser (::fhir::canonical_pskel& p)
  {
    this->resource_parser_ = &p;
  }

  void RelatedArtifact_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::RelatedArtifactType_pskel& type,
           ::fhir::string_pskel& label,
           ::fhir::string_pskel& display,
           ::fhir::markdown_pskel& citation,
           ::fhir::url_pskel& url,
           ::fhir::Attachment_pskel& document,
           ::fhir::canonical_pskel& resource)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->type_parser_ = &type;
    this->label_parser_ = &label;
    this->display_parser_ = &display;
    this->citation_parser_ = &citation;
    this->url_parser_ = &url;
    this->document_parser_ = &document;
    this->resource_parser_ = &resource;
  }

  RelatedArtifact_pskel::
  RelatedArtifact_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    RelatedArtifact_impl_ (0),
    type_parser_ (0),
    label_parser_ (0),
    display_parser_ (0),
    citation_parser_ (0),
    url_parser_ (0),
    document_parser_ (0),
    resource_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  RelatedArtifact_pskel::
  RelatedArtifact_pskel (RelatedArtifact_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    RelatedArtifact_impl_ (impl),
    type_parser_ (0),
    label_parser_ (0),
    display_parser_ (0),
    citation_parser_ (0),
    url_parser_ (0),
    document_parser_ (0),
    resource_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // RelatedArtifactType_list_pskel
  //

  RelatedArtifactType_list_pskel::
  RelatedArtifactType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    RelatedArtifactType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_RelatedArtifactType_list_pskel_enums_, 8UL);
  }

  RelatedArtifactType_list_pskel::
  RelatedArtifactType_list_pskel (RelatedArtifactType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    RelatedArtifactType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_RelatedArtifactType_list_pskel_enums_, 8UL);
  }

  // RelatedArtifactType_pskel
  //

  void RelatedArtifactType_pskel::
  value_parser (::fhir::RelatedArtifactType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void RelatedArtifactType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::RelatedArtifactType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  RelatedArtifactType_pskel::
  RelatedArtifactType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    RelatedArtifactType_impl_ (0),
    value_parser_ (0)
  {
  }

  RelatedArtifactType_pskel::
  RelatedArtifactType_pskel (RelatedArtifactType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    RelatedArtifactType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Annotation_pskel
  //

  void Annotation_pskel::
  authorReference_parser (::fhir::Reference_pskel& p)
  {
    this->authorReference_parser_ = &p;
  }

  void Annotation_pskel::
  authorString_parser (::fhir::string_pskel& p)
  {
    this->authorString_parser_ = &p;
  }

  void Annotation_pskel::
  time_parser (::fhir::dateTime_pskel& p)
  {
    this->time_parser_ = &p;
  }

  void Annotation_pskel::
  text_parser (::fhir::markdown_pskel& p)
  {
    this->text_parser_ = &p;
  }

  void Annotation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Reference_pskel& authorReference,
           ::fhir::string_pskel& authorString,
           ::fhir::dateTime_pskel& time,
           ::fhir::markdown_pskel& text)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->authorReference_parser_ = &authorReference;
    this->authorString_parser_ = &authorString;
    this->time_parser_ = &time;
    this->text_parser_ = &text;
  }

  Annotation_pskel::
  Annotation_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Annotation_impl_ (0),
    authorReference_parser_ (0),
    authorString_parser_ (0),
    time_parser_ (0),
    text_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Annotation_pskel::
  Annotation_pskel (Annotation_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Annotation_impl_ (impl),
    authorReference_parser_ (0),
    authorString_parser_ (0),
    time_parser_ (0),
    text_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ProductShelfLife_pskel
  //

  void ProductShelfLife_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void ProductShelfLife_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void ProductShelfLife_pskel::
  period_parser (::fhir::Quantity_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void ProductShelfLife_pskel::
  specialPrecautionsForStorage_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->specialPrecautionsForStorage_parser_ = &p;
  }

  void ProductShelfLife_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Quantity_pskel& period,
           ::fhir::CodeableConcept_pskel& specialPrecautionsForStorage)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->identifier_parser_ = &identifier;
    this->type_parser_ = &type;
    this->period_parser_ = &period;
    this->specialPrecautionsForStorage_parser_ = &specialPrecautionsForStorage;
  }

  ProductShelfLife_pskel::
  ProductShelfLife_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ProductShelfLife_impl_ (0),
    identifier_parser_ (0),
    type_parser_ (0),
    period_parser_ (0),
    specialPrecautionsForStorage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ProductShelfLife_pskel::
  ProductShelfLife_pskel (ProductShelfLife_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ProductShelfLife_impl_ (impl),
    identifier_parser_ (0),
    type_parser_ (0),
    period_parser_ (0),
    specialPrecautionsForStorage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ContactDetail_pskel
  //

  void ContactDetail_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void ContactDetail_pskel::
  telecom_parser (::fhir::ContactPoint_pskel& p)
  {
    this->telecom_parser_ = &p;
  }

  void ContactDetail_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_pskel& name,
           ::fhir::ContactPoint_pskel& telecom)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->name_parser_ = &name;
    this->telecom_parser_ = &telecom;
  }

  ContactDetail_pskel::
  ContactDetail_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ContactDetail_impl_ (0),
    name_parser_ (0),
    telecom_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ContactDetail_pskel::
  ContactDetail_pskel (ContactDetail_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ContactDetail_impl_ (impl),
    name_parser_ (0),
    telecom_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // UsageContext_pskel
  //

  void UsageContext_pskel::
  code_parser (::fhir::Coding_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void UsageContext_pskel::
  valueCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->valueCodeableConcept_parser_ = &p;
  }

  void UsageContext_pskel::
  valueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->valueQuantity_parser_ = &p;
  }

  void UsageContext_pskel::
  valueRange_parser (::fhir::Range_pskel& p)
  {
    this->valueRange_parser_ = &p;
  }

  void UsageContext_pskel::
  valueReference_parser (::fhir::Reference_pskel& p)
  {
    this->valueReference_parser_ = &p;
  }

  void UsageContext_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Coding_pskel& code,
           ::fhir::CodeableConcept_pskel& valueCodeableConcept,
           ::fhir::Quantity_pskel& valueQuantity,
           ::fhir::Range_pskel& valueRange,
           ::fhir::Reference_pskel& valueReference)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->code_parser_ = &code;
    this->valueCodeableConcept_parser_ = &valueCodeableConcept;
    this->valueQuantity_parser_ = &valueQuantity;
    this->valueRange_parser_ = &valueRange;
    this->valueReference_parser_ = &valueReference;
  }

  UsageContext_pskel::
  UsageContext_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    UsageContext_impl_ (0),
    code_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueQuantity_parser_ (0),
    valueRange_parser_ (0),
    valueReference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  UsageContext_pskel::
  UsageContext_pskel (UsageContext_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    UsageContext_impl_ (impl),
    code_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueQuantity_parser_ (0),
    valueRange_parser_ (0),
    valueReference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Expression_pskel
  //

  void Expression_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void Expression_pskel::
  name_parser (::fhir::id_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Expression_pskel::
  language_parser (::fhir::ExpressionLanguage_pskel& p)
  {
    this->language_parser_ = &p;
  }

  void Expression_pskel::
  expression_parser (::fhir::string_pskel& p)
  {
    this->expression_parser_ = &p;
  }

  void Expression_pskel::
  reference_parser (::fhir::uri_pskel& p)
  {
    this->reference_parser_ = &p;
  }

  void Expression_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::string_pskel& description,
           ::fhir::id_pskel& name,
           ::fhir::ExpressionLanguage_pskel& language,
           ::fhir::string_pskel& expression,
           ::fhir::uri_pskel& reference)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->description_parser_ = &description;
    this->name_parser_ = &name;
    this->language_parser_ = &language;
    this->expression_parser_ = &expression;
    this->reference_parser_ = &reference;
  }

  Expression_pskel::
  Expression_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Expression_impl_ (0),
    description_parser_ (0),
    name_parser_ (0),
    language_parser_ (0),
    expression_parser_ (0),
    reference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Expression_pskel::
  Expression_pskel (Expression_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Expression_impl_ (impl),
    description_parser_ (0),
    name_parser_ (0),
    language_parser_ (0),
    expression_parser_ (0),
    reference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ExpressionLanguage_list_pskel
  //

  ExpressionLanguage_list_pskel::
  ExpressionLanguage_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ExpressionLanguage_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ExpressionLanguage_list_pskel_enums_, 3UL);
  }

  ExpressionLanguage_list_pskel::
  ExpressionLanguage_list_pskel (ExpressionLanguage_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ExpressionLanguage_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ExpressionLanguage_list_pskel_enums_, 3UL);
  }

  // ExpressionLanguage_pskel
  //

  void ExpressionLanguage_pskel::
  value_parser (::fhir::ExpressionLanguage_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ExpressionLanguage_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ExpressionLanguage_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ExpressionLanguage_pskel::
  ExpressionLanguage_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ExpressionLanguage_impl_ (0),
    value_parser_ (0)
  {
  }

  ExpressionLanguage_pskel::
  ExpressionLanguage_pskel (ExpressionLanguage_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ExpressionLanguage_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Signature_pskel
  //

  void Signature_pskel::
  type_parser (::fhir::Coding_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void Signature_pskel::
  when_parser (::fhir::instant_pskel& p)
  {
    this->when_parser_ = &p;
  }

  void Signature_pskel::
  who_parser (::fhir::Reference_pskel& p)
  {
    this->who_parser_ = &p;
  }

  void Signature_pskel::
  onBehalfOf_parser (::fhir::Reference_pskel& p)
  {
    this->onBehalfOf_parser_ = &p;
  }

  void Signature_pskel::
  targetFormat_parser (::fhir::code_pskel& p)
  {
    this->targetFormat_parser_ = &p;
  }

  void Signature_pskel::
  sigFormat_parser (::fhir::code_pskel& p)
  {
    this->sigFormat_parser_ = &p;
  }

  void Signature_pskel::
  data_parser (::fhir::base64Binary_pskel& p)
  {
    this->data_parser_ = &p;
  }

  void Signature_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Coding_pskel& type,
           ::fhir::instant_pskel& when,
           ::fhir::Reference_pskel& who,
           ::fhir::Reference_pskel& onBehalfOf,
           ::fhir::code_pskel& targetFormat,
           ::fhir::code_pskel& sigFormat,
           ::fhir::base64Binary_pskel& data)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->type_parser_ = &type;
    this->when_parser_ = &when;
    this->who_parser_ = &who;
    this->onBehalfOf_parser_ = &onBehalfOf;
    this->targetFormat_parser_ = &targetFormat;
    this->sigFormat_parser_ = &sigFormat;
    this->data_parser_ = &data;
  }

  Signature_pskel::
  Signature_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    Signature_impl_ (0),
    type_parser_ (0),
    when_parser_ (0),
    who_parser_ (0),
    onBehalfOf_parser_ (0),
    targetFormat_parser_ (0),
    sigFormat_parser_ (0),
    data_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Signature_pskel::
  Signature_pskel (Signature_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    Signature_impl_ (impl),
    type_parser_ (0),
    when_parser_ (0),
    who_parser_ (0),
    onBehalfOf_parser_ (0),
    targetFormat_parser_ (0),
    sigFormat_parser_ (0),
    data_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Timing_pskel
  //

  void Timing_pskel::
  event_parser (::fhir::dateTime_pskel& p)
  {
    this->event_parser_ = &p;
  }

  void Timing_pskel::
  repeat_parser (::fhir::Timing_Repeat_pskel& p)
  {
    this->repeat_parser_ = &p;
  }

  void Timing_pskel::
  code_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void Timing_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::dateTime_pskel& event,
           ::fhir::Timing_Repeat_pskel& repeat,
           ::fhir::CodeableConcept_pskel& code)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->event_parser_ = &event;
    this->repeat_parser_ = &repeat;
    this->code_parser_ = &code;
  }

  Timing_pskel::
  Timing_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    Timing_impl_ (0),
    event_parser_ (0),
    repeat_parser_ (0),
    code_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Timing_pskel::
  Timing_pskel (Timing_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    Timing_impl_ (impl),
    event_parser_ (0),
    repeat_parser_ (0),
    code_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // Timing_Repeat_pskel
  //

  void Timing_Repeat_pskel::
  boundsDuration_parser (::fhir::Duration_pskel& p)
  {
    this->boundsDuration_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  boundsRange_parser (::fhir::Range_pskel& p)
  {
    this->boundsRange_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  boundsPeriod_parser (::fhir::Period_pskel& p)
  {
    this->boundsPeriod_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  count_parser (::fhir::positiveInt_pskel& p)
  {
    this->count_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  countMax_parser (::fhir::positiveInt_pskel& p)
  {
    this->countMax_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  duration_parser (::fhir::decimal_pskel& p)
  {
    this->duration_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  durationMax_parser (::fhir::decimal_pskel& p)
  {
    this->durationMax_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  durationUnit_parser (::fhir::UnitsOfTime_pskel& p)
  {
    this->durationUnit_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  frequency_parser (::fhir::positiveInt_pskel& p)
  {
    this->frequency_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  frequencyMax_parser (::fhir::positiveInt_pskel& p)
  {
    this->frequencyMax_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  period_parser (::fhir::decimal_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  periodMax_parser (::fhir::decimal_pskel& p)
  {
    this->periodMax_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  periodUnit_parser (::fhir::UnitsOfTime_pskel& p)
  {
    this->periodUnit_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  dayOfWeek_parser (::fhir::code_pskel& p)
  {
    this->dayOfWeek_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  timeOfDay_parser (::fhir::time_pskel& p)
  {
    this->timeOfDay_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  when_parser (::fhir::EventTiming_pskel& p)
  {
    this->when_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  offset_parser (::fhir::unsignedInt_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void Timing_Repeat_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Duration_pskel& boundsDuration,
           ::fhir::Range_pskel& boundsRange,
           ::fhir::Period_pskel& boundsPeriod,
           ::fhir::positiveInt_pskel& count,
           ::fhir::positiveInt_pskel& countMax,
           ::fhir::decimal_pskel& duration,
           ::fhir::decimal_pskel& durationMax,
           ::fhir::UnitsOfTime_pskel& durationUnit,
           ::fhir::positiveInt_pskel& frequency,
           ::fhir::positiveInt_pskel& frequencyMax,
           ::fhir::decimal_pskel& period,
           ::fhir::decimal_pskel& periodMax,
           ::fhir::UnitsOfTime_pskel& periodUnit,
           ::fhir::code_pskel& dayOfWeek,
           ::fhir::time_pskel& timeOfDay,
           ::fhir::EventTiming_pskel& when,
           ::fhir::unsignedInt_pskel& offset)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->boundsDuration_parser_ = &boundsDuration;
    this->boundsRange_parser_ = &boundsRange;
    this->boundsPeriod_parser_ = &boundsPeriod;
    this->count_parser_ = &count;
    this->countMax_parser_ = &countMax;
    this->duration_parser_ = &duration;
    this->durationMax_parser_ = &durationMax;
    this->durationUnit_parser_ = &durationUnit;
    this->frequency_parser_ = &frequency;
    this->frequencyMax_parser_ = &frequencyMax;
    this->period_parser_ = &period;
    this->periodMax_parser_ = &periodMax;
    this->periodUnit_parser_ = &periodUnit;
    this->dayOfWeek_parser_ = &dayOfWeek;
    this->timeOfDay_parser_ = &timeOfDay;
    this->when_parser_ = &when;
    this->offset_parser_ = &offset;
  }

  Timing_Repeat_pskel::
  Timing_Repeat_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    Timing_Repeat_impl_ (0),
    boundsDuration_parser_ (0),
    boundsRange_parser_ (0),
    boundsPeriod_parser_ (0),
    count_parser_ (0),
    countMax_parser_ (0),
    duration_parser_ (0),
    durationMax_parser_ (0),
    durationUnit_parser_ (0),
    frequency_parser_ (0),
    frequencyMax_parser_ (0),
    period_parser_ (0),
    periodMax_parser_ (0),
    periodUnit_parser_ (0),
    dayOfWeek_parser_ (0),
    timeOfDay_parser_ (0),
    when_parser_ (0),
    offset_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Timing_Repeat_pskel::
  Timing_Repeat_pskel (Timing_Repeat_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    Timing_Repeat_impl_ (impl),
    boundsDuration_parser_ (0),
    boundsRange_parser_ (0),
    boundsPeriod_parser_ (0),
    count_parser_ (0),
    countMax_parser_ (0),
    duration_parser_ (0),
    durationMax_parser_ (0),
    durationUnit_parser_ (0),
    frequency_parser_ (0),
    frequencyMax_parser_ (0),
    period_parser_ (0),
    periodMax_parser_ (0),
    periodUnit_parser_ (0),
    dayOfWeek_parser_ (0),
    timeOfDay_parser_ (0),
    when_parser_ (0),
    offset_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // UnitsOfTime_list_pskel
  //

  UnitsOfTime_list_pskel::
  UnitsOfTime_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    UnitsOfTime_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_UnitsOfTime_list_pskel_enums_, 7UL);
  }

  UnitsOfTime_list_pskel::
  UnitsOfTime_list_pskel (UnitsOfTime_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    UnitsOfTime_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_UnitsOfTime_list_pskel_enums_, 7UL);
  }

  // UnitsOfTime_pskel
  //

  void UnitsOfTime_pskel::
  value_parser (::fhir::UnitsOfTime_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void UnitsOfTime_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::UnitsOfTime_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  UnitsOfTime_pskel::
  UnitsOfTime_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    UnitsOfTime_impl_ (0),
    value_parser_ (0)
  {
  }

  UnitsOfTime_pskel::
  UnitsOfTime_pskel (UnitsOfTime_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    UnitsOfTime_impl_ (impl),
    value_parser_ (0)
  {
  }

  // EventTiming_list_pskel
  //

  EventTiming_list_pskel::
  EventTiming_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    EventTiming_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_EventTiming_list_pskel_enums_, 26UL);
  }

  EventTiming_list_pskel::
  EventTiming_list_pskel (EventTiming_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    EventTiming_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_EventTiming_list_pskel_enums_, 26UL);
  }

  // EventTiming_pskel
  //

  void EventTiming_pskel::
  value_parser (::fhir::EventTiming_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void EventTiming_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::EventTiming_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  EventTiming_pskel::
  EventTiming_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    EventTiming_impl_ (0),
    value_parser_ (0)
  {
  }

  EventTiming_pskel::
  EventTiming_pskel (EventTiming_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    EventTiming_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ProdCharacteristic_pskel
  //

  void ProdCharacteristic_pskel::
  height_parser (::fhir::Quantity_pskel& p)
  {
    this->height_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  width_parser (::fhir::Quantity_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  depth_parser (::fhir::Quantity_pskel& p)
  {
    this->depth_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  weight_parser (::fhir::Quantity_pskel& p)
  {
    this->weight_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  nominalVolume_parser (::fhir::Quantity_pskel& p)
  {
    this->nominalVolume_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  externalDiameter_parser (::fhir::Quantity_pskel& p)
  {
    this->externalDiameter_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  shape_parser (::fhir::string_pskel& p)
  {
    this->shape_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  color_parser (::fhir::string_pskel& p)
  {
    this->color_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  imprint_parser (::fhir::string_pskel& p)
  {
    this->imprint_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  image_parser (::fhir::Attachment_pskel& p)
  {
    this->image_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  scoring_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->scoring_parser_ = &p;
  }

  void ProdCharacteristic_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Quantity_pskel& height,
           ::fhir::Quantity_pskel& width,
           ::fhir::Quantity_pskel& depth,
           ::fhir::Quantity_pskel& weight,
           ::fhir::Quantity_pskel& nominalVolume,
           ::fhir::Quantity_pskel& externalDiameter,
           ::fhir::string_pskel& shape,
           ::fhir::string_pskel& color,
           ::fhir::string_pskel& imprint,
           ::fhir::Attachment_pskel& image,
           ::fhir::CodeableConcept_pskel& scoring)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->height_parser_ = &height;
    this->width_parser_ = &width;
    this->depth_parser_ = &depth;
    this->weight_parser_ = &weight;
    this->nominalVolume_parser_ = &nominalVolume;
    this->externalDiameter_parser_ = &externalDiameter;
    this->shape_parser_ = &shape;
    this->color_parser_ = &color;
    this->imprint_parser_ = &imprint;
    this->image_parser_ = &image;
    this->scoring_parser_ = &scoring;
  }

  ProdCharacteristic_pskel::
  ProdCharacteristic_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ProdCharacteristic_impl_ (0),
    height_parser_ (0),
    width_parser_ (0),
    depth_parser_ (0),
    weight_parser_ (0),
    nominalVolume_parser_ (0),
    externalDiameter_parser_ (0),
    shape_parser_ (0),
    color_parser_ (0),
    imprint_parser_ (0),
    image_parser_ (0),
    scoring_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ProdCharacteristic_pskel::
  ProdCharacteristic_pskel (ProdCharacteristic_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ProdCharacteristic_impl_ (impl),
    height_parser_ (0),
    width_parser_ (0),
    depth_parser_ (0),
    weight_parser_ (0),
    nominalVolume_parser_ (0),
    externalDiameter_parser_ (0),
    shape_parser_ (0),
    color_parser_ (0),
    imprint_parser_ (0),
    image_parser_ (0),
    scoring_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CodeableConcept_pskel
  //

  void CodeableConcept_pskel::
  coding_parser (::fhir::Coding_pskel& p)
  {
    this->coding_parser_ = &p;
  }

  void CodeableConcept_pskel::
  text_parser (::fhir::string_pskel& p)
  {
    this->text_parser_ = &p;
  }

  void CodeableConcept_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Coding_pskel& coding,
           ::fhir::string_pskel& text)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->coding_parser_ = &coding;
    this->text_parser_ = &text;
  }

  CodeableConcept_pskel::
  CodeableConcept_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    CodeableConcept_impl_ (0),
    coding_parser_ (0),
    text_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CodeableConcept_pskel::
  CodeableConcept_pskel (CodeableConcept_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    CodeableConcept_impl_ (impl),
    coding_parser_ (0),
    text_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ParameterDefinition_pskel
  //

  void ParameterDefinition_pskel::
  name_parser (::fhir::code_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  use_parser (::fhir::code_pskel& p)
  {
    this->use_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  min_parser (::fhir::integer_pskel& p)
  {
    this->min_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  max_parser (::fhir::string_pskel& p)
  {
    this->max_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  documentation_parser (::fhir::string_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  type_parser (::fhir::code_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  profile_parser (::fhir::canonical_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void ParameterDefinition_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::code_pskel& name,
           ::fhir::code_pskel& use,
           ::fhir::integer_pskel& min,
           ::fhir::string_pskel& max,
           ::fhir::string_pskel& documentation,
           ::fhir::code_pskel& type,
           ::fhir::canonical_pskel& profile)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->name_parser_ = &name;
    this->use_parser_ = &use;
    this->min_parser_ = &min;
    this->max_parser_ = &max;
    this->documentation_parser_ = &documentation;
    this->type_parser_ = &type;
    this->profile_parser_ = &profile;
  }

  ParameterDefinition_pskel::
  ParameterDefinition_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ParameterDefinition_impl_ (0),
    name_parser_ (0),
    use_parser_ (0),
    min_parser_ (0),
    max_parser_ (0),
    documentation_parser_ (0),
    type_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ParameterDefinition_pskel::
  ParameterDefinition_pskel (ParameterDefinition_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ParameterDefinition_impl_ (impl),
    name_parser_ (0),
    use_parser_ (0),
    min_parser_ (0),
    max_parser_ (0),
    documentation_parser_ (0),
    type_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_pskel
  //

  void ElementDefinition_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void ElementDefinition_pskel::
  representation_parser (::fhir::PropertyRepresentation_pskel& p)
  {
    this->representation_parser_ = &p;
  }

  void ElementDefinition_pskel::
  sliceName_parser (::fhir::string_pskel& p)
  {
    this->sliceName_parser_ = &p;
  }

  void ElementDefinition_pskel::
  sliceIsConstraining_parser (::fhir::boolean_pskel& p)
  {
    this->sliceIsConstraining_parser_ = &p;
  }

  void ElementDefinition_pskel::
  label_parser (::fhir::string_pskel& p)
  {
    this->label_parser_ = &p;
  }

  void ElementDefinition_pskel::
  code_parser (::fhir::Coding_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void ElementDefinition_pskel::
  slicing_parser (::fhir::ElementDefinition_Slicing_pskel& p)
  {
    this->slicing_parser_ = &p;
  }

  void ElementDefinition_pskel::
  short__parser (::fhir::string_pskel& p)
  {
    this->short__parser_ = &p;
  }

  void ElementDefinition_pskel::
  definition_parser (::fhir::markdown_pskel& p)
  {
    this->definition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  comment_parser (::fhir::markdown_pskel& p)
  {
    this->comment_parser_ = &p;
  }

  void ElementDefinition_pskel::
  requirements_parser (::fhir::markdown_pskel& p)
  {
    this->requirements_parser_ = &p;
  }

  void ElementDefinition_pskel::
  alias_parser (::fhir::string_pskel& p)
  {
    this->alias_parser_ = &p;
  }

  void ElementDefinition_pskel::
  min_parser (::fhir::unsignedInt_pskel& p)
  {
    this->min_parser_ = &p;
  }

  void ElementDefinition_pskel::
  max_parser (::fhir::string_pskel& p)
  {
    this->max_parser_ = &p;
  }

  void ElementDefinition_pskel::
  base_parser (::fhir::ElementDefinition_Base_pskel& p)
  {
    this->base_parser_ = &p;
  }

  void ElementDefinition_pskel::
  contentReference_parser (::fhir::uri_pskel& p)
  {
    this->contentReference_parser_ = &p;
  }

  void ElementDefinition_pskel::
  type_parser (::fhir::ElementDefinition_Type_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueBase64Binary_parser (::fhir::base64Binary_pskel& p)
  {
    this->defaultValueBase64Binary_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueBoolean_parser (::fhir::boolean_pskel& p)
  {
    this->defaultValueBoolean_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueCanonical_parser (::fhir::canonical_pskel& p)
  {
    this->defaultValueCanonical_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueCode_parser (::fhir::code_pskel& p)
  {
    this->defaultValueCode_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDate_parser (::fhir::date_pskel& p)
  {
    this->defaultValueDate_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->defaultValueDateTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->defaultValueDecimal_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueId_parser (::fhir::id_pskel& p)
  {
    this->defaultValueId_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueInstant_parser (::fhir::instant_pskel& p)
  {
    this->defaultValueInstant_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueInteger_parser (::fhir::integer_pskel& p)
  {
    this->defaultValueInteger_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueMarkdown_parser (::fhir::markdown_pskel& p)
  {
    this->defaultValueMarkdown_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueOid_parser (::fhir::oid_pskel& p)
  {
    this->defaultValueOid_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValuePositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->defaultValuePositiveInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueString_parser (::fhir::string_pskel& p)
  {
    this->defaultValueString_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueTime_parser (::fhir::time_pskel& p)
  {
    this->defaultValueTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->defaultValueUnsignedInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueUri_parser (::fhir::uri_pskel& p)
  {
    this->defaultValueUri_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueUrl_parser (::fhir::url_pskel& p)
  {
    this->defaultValueUrl_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueUuid_parser (::fhir::uuid_pskel& p)
  {
    this->defaultValueUuid_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueAddress_parser (::fhir::Address_pskel& p)
  {
    this->defaultValueAddress_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueAge_parser (::fhir::Age_pskel& p)
  {
    this->defaultValueAge_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueAnnotation_parser (::fhir::Annotation_pskel& p)
  {
    this->defaultValueAnnotation_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueAttachment_parser (::fhir::Attachment_pskel& p)
  {
    this->defaultValueAttachment_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->defaultValueCodeableConcept_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueCoding_parser (::fhir::Coding_pskel& p)
  {
    this->defaultValueCoding_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueContactPoint_parser (::fhir::ContactPoint_pskel& p)
  {
    this->defaultValueContactPoint_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueCount_parser (::fhir::Count_pskel& p)
  {
    this->defaultValueCount_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDistance_parser (::fhir::Distance_pskel& p)
  {
    this->defaultValueDistance_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDuration_parser (::fhir::Duration_pskel& p)
  {
    this->defaultValueDuration_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueHumanName_parser (::fhir::HumanName_pskel& p)
  {
    this->defaultValueHumanName_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueIdentifier_parser (::fhir::Identifier_pskel& p)
  {
    this->defaultValueIdentifier_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueMoney_parser (::fhir::Money_pskel& p)
  {
    this->defaultValueMoney_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValuePeriod_parser (::fhir::Period_pskel& p)
  {
    this->defaultValuePeriod_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->defaultValueQuantity_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueRange_parser (::fhir::Range_pskel& p)
  {
    this->defaultValueRange_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueRatio_parser (::fhir::Ratio_pskel& p)
  {
    this->defaultValueRatio_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueReference_parser (::fhir::Reference_pskel& p)
  {
    this->defaultValueReference_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueSampledData_parser (::fhir::SampledData_pskel& p)
  {
    this->defaultValueSampledData_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueSignature_parser (::fhir::Signature_pskel& p)
  {
    this->defaultValueSignature_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueTiming_parser (::fhir::Timing_pskel& p)
  {
    this->defaultValueTiming_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueContactDetail_parser (::fhir::ContactDetail_pskel& p)
  {
    this->defaultValueContactDetail_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueContributor_parser (::fhir::Contributor_pskel& p)
  {
    this->defaultValueContributor_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDataRequirement_parser (::fhir::DataRequirement_pskel& p)
  {
    this->defaultValueDataRequirement_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueExpression_parser (::fhir::Expression_pskel& p)
  {
    this->defaultValueExpression_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueParameterDefinition_parser (::fhir::ParameterDefinition_pskel& p)
  {
    this->defaultValueParameterDefinition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueRelatedArtifact_parser (::fhir::RelatedArtifact_pskel& p)
  {
    this->defaultValueRelatedArtifact_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueTriggerDefinition_parser (::fhir::TriggerDefinition_pskel& p)
  {
    this->defaultValueTriggerDefinition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueUsageContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->defaultValueUsageContext_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueDosage_parser (::fhir::Dosage_pskel& p)
  {
    this->defaultValueDosage_parser_ = &p;
  }

  void ElementDefinition_pskel::
  defaultValueMeta_parser (::fhir::Meta_pskel& p)
  {
    this->defaultValueMeta_parser_ = &p;
  }

  void ElementDefinition_pskel::
  meaningWhenMissing_parser (::fhir::markdown_pskel& p)
  {
    this->meaningWhenMissing_parser_ = &p;
  }

  void ElementDefinition_pskel::
  orderMeaning_parser (::fhir::string_pskel& p)
  {
    this->orderMeaning_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedBase64Binary_parser (::fhir::base64Binary_pskel& p)
  {
    this->fixedBase64Binary_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedBoolean_parser (::fhir::boolean_pskel& p)
  {
    this->fixedBoolean_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedCanonical_parser (::fhir::canonical_pskel& p)
  {
    this->fixedCanonical_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedCode_parser (::fhir::code_pskel& p)
  {
    this->fixedCode_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDate_parser (::fhir::date_pskel& p)
  {
    this->fixedDate_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->fixedDateTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->fixedDecimal_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedId_parser (::fhir::id_pskel& p)
  {
    this->fixedId_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedInstant_parser (::fhir::instant_pskel& p)
  {
    this->fixedInstant_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedInteger_parser (::fhir::integer_pskel& p)
  {
    this->fixedInteger_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedMarkdown_parser (::fhir::markdown_pskel& p)
  {
    this->fixedMarkdown_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedOid_parser (::fhir::oid_pskel& p)
  {
    this->fixedOid_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedPositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->fixedPositiveInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedString_parser (::fhir::string_pskel& p)
  {
    this->fixedString_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedTime_parser (::fhir::time_pskel& p)
  {
    this->fixedTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->fixedUnsignedInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedUri_parser (::fhir::uri_pskel& p)
  {
    this->fixedUri_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedUrl_parser (::fhir::url_pskel& p)
  {
    this->fixedUrl_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedUuid_parser (::fhir::uuid_pskel& p)
  {
    this->fixedUuid_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedAddress_parser (::fhir::Address_pskel& p)
  {
    this->fixedAddress_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedAge_parser (::fhir::Age_pskel& p)
  {
    this->fixedAge_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedAnnotation_parser (::fhir::Annotation_pskel& p)
  {
    this->fixedAnnotation_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedAttachment_parser (::fhir::Attachment_pskel& p)
  {
    this->fixedAttachment_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->fixedCodeableConcept_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedCoding_parser (::fhir::Coding_pskel& p)
  {
    this->fixedCoding_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedContactPoint_parser (::fhir::ContactPoint_pskel& p)
  {
    this->fixedContactPoint_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedCount_parser (::fhir::Count_pskel& p)
  {
    this->fixedCount_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDistance_parser (::fhir::Distance_pskel& p)
  {
    this->fixedDistance_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDuration_parser (::fhir::Duration_pskel& p)
  {
    this->fixedDuration_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedHumanName_parser (::fhir::HumanName_pskel& p)
  {
    this->fixedHumanName_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedIdentifier_parser (::fhir::Identifier_pskel& p)
  {
    this->fixedIdentifier_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedMoney_parser (::fhir::Money_pskel& p)
  {
    this->fixedMoney_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedPeriod_parser (::fhir::Period_pskel& p)
  {
    this->fixedPeriod_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->fixedQuantity_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedRange_parser (::fhir::Range_pskel& p)
  {
    this->fixedRange_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedRatio_parser (::fhir::Ratio_pskel& p)
  {
    this->fixedRatio_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedReference_parser (::fhir::Reference_pskel& p)
  {
    this->fixedReference_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedSampledData_parser (::fhir::SampledData_pskel& p)
  {
    this->fixedSampledData_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedSignature_parser (::fhir::Signature_pskel& p)
  {
    this->fixedSignature_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedTiming_parser (::fhir::Timing_pskel& p)
  {
    this->fixedTiming_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedContactDetail_parser (::fhir::ContactDetail_pskel& p)
  {
    this->fixedContactDetail_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedContributor_parser (::fhir::Contributor_pskel& p)
  {
    this->fixedContributor_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDataRequirement_parser (::fhir::DataRequirement_pskel& p)
  {
    this->fixedDataRequirement_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedExpression_parser (::fhir::Expression_pskel& p)
  {
    this->fixedExpression_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedParameterDefinition_parser (::fhir::ParameterDefinition_pskel& p)
  {
    this->fixedParameterDefinition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedRelatedArtifact_parser (::fhir::RelatedArtifact_pskel& p)
  {
    this->fixedRelatedArtifact_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedTriggerDefinition_parser (::fhir::TriggerDefinition_pskel& p)
  {
    this->fixedTriggerDefinition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedUsageContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->fixedUsageContext_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedDosage_parser (::fhir::Dosage_pskel& p)
  {
    this->fixedDosage_parser_ = &p;
  }

  void ElementDefinition_pskel::
  fixedMeta_parser (::fhir::Meta_pskel& p)
  {
    this->fixedMeta_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternBase64Binary_parser (::fhir::base64Binary_pskel& p)
  {
    this->patternBase64Binary_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternBoolean_parser (::fhir::boolean_pskel& p)
  {
    this->patternBoolean_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternCanonical_parser (::fhir::canonical_pskel& p)
  {
    this->patternCanonical_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternCode_parser (::fhir::code_pskel& p)
  {
    this->patternCode_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDate_parser (::fhir::date_pskel& p)
  {
    this->patternDate_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->patternDateTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->patternDecimal_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternId_parser (::fhir::id_pskel& p)
  {
    this->patternId_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternInstant_parser (::fhir::instant_pskel& p)
  {
    this->patternInstant_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternInteger_parser (::fhir::integer_pskel& p)
  {
    this->patternInteger_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternMarkdown_parser (::fhir::markdown_pskel& p)
  {
    this->patternMarkdown_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternOid_parser (::fhir::oid_pskel& p)
  {
    this->patternOid_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternPositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->patternPositiveInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternString_parser (::fhir::string_pskel& p)
  {
    this->patternString_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternTime_parser (::fhir::time_pskel& p)
  {
    this->patternTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->patternUnsignedInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternUri_parser (::fhir::uri_pskel& p)
  {
    this->patternUri_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternUrl_parser (::fhir::url_pskel& p)
  {
    this->patternUrl_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternUuid_parser (::fhir::uuid_pskel& p)
  {
    this->patternUuid_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternAddress_parser (::fhir::Address_pskel& p)
  {
    this->patternAddress_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternAge_parser (::fhir::Age_pskel& p)
  {
    this->patternAge_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternAnnotation_parser (::fhir::Annotation_pskel& p)
  {
    this->patternAnnotation_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternAttachment_parser (::fhir::Attachment_pskel& p)
  {
    this->patternAttachment_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->patternCodeableConcept_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternCoding_parser (::fhir::Coding_pskel& p)
  {
    this->patternCoding_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternContactPoint_parser (::fhir::ContactPoint_pskel& p)
  {
    this->patternContactPoint_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternCount_parser (::fhir::Count_pskel& p)
  {
    this->patternCount_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDistance_parser (::fhir::Distance_pskel& p)
  {
    this->patternDistance_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDuration_parser (::fhir::Duration_pskel& p)
  {
    this->patternDuration_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternHumanName_parser (::fhir::HumanName_pskel& p)
  {
    this->patternHumanName_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternIdentifier_parser (::fhir::Identifier_pskel& p)
  {
    this->patternIdentifier_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternMoney_parser (::fhir::Money_pskel& p)
  {
    this->patternMoney_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternPeriod_parser (::fhir::Period_pskel& p)
  {
    this->patternPeriod_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->patternQuantity_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternRange_parser (::fhir::Range_pskel& p)
  {
    this->patternRange_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternRatio_parser (::fhir::Ratio_pskel& p)
  {
    this->patternRatio_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternReference_parser (::fhir::Reference_pskel& p)
  {
    this->patternReference_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternSampledData_parser (::fhir::SampledData_pskel& p)
  {
    this->patternSampledData_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternSignature_parser (::fhir::Signature_pskel& p)
  {
    this->patternSignature_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternTiming_parser (::fhir::Timing_pskel& p)
  {
    this->patternTiming_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternContactDetail_parser (::fhir::ContactDetail_pskel& p)
  {
    this->patternContactDetail_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternContributor_parser (::fhir::Contributor_pskel& p)
  {
    this->patternContributor_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDataRequirement_parser (::fhir::DataRequirement_pskel& p)
  {
    this->patternDataRequirement_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternExpression_parser (::fhir::Expression_pskel& p)
  {
    this->patternExpression_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternParameterDefinition_parser (::fhir::ParameterDefinition_pskel& p)
  {
    this->patternParameterDefinition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternRelatedArtifact_parser (::fhir::RelatedArtifact_pskel& p)
  {
    this->patternRelatedArtifact_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternTriggerDefinition_parser (::fhir::TriggerDefinition_pskel& p)
  {
    this->patternTriggerDefinition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternUsageContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->patternUsageContext_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternDosage_parser (::fhir::Dosage_pskel& p)
  {
    this->patternDosage_parser_ = &p;
  }

  void ElementDefinition_pskel::
  patternMeta_parser (::fhir::Meta_pskel& p)
  {
    this->patternMeta_parser_ = &p;
  }

  void ElementDefinition_pskel::
  example_parser (::fhir::ElementDefinition_Example_pskel& p)
  {
    this->example_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueDate_parser (::fhir::date_pskel& p)
  {
    this->minValueDate_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->minValueDateTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueInstant_parser (::fhir::instant_pskel& p)
  {
    this->minValueInstant_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueTime_parser (::fhir::time_pskel& p)
  {
    this->minValueTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->minValueDecimal_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueInteger_parser (::fhir::integer_pskel& p)
  {
    this->minValueInteger_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValuePositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->minValuePositiveInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->minValueUnsignedInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  minValueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->minValueQuantity_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueDate_parser (::fhir::date_pskel& p)
  {
    this->maxValueDate_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->maxValueDateTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueInstant_parser (::fhir::instant_pskel& p)
  {
    this->maxValueInstant_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueTime_parser (::fhir::time_pskel& p)
  {
    this->maxValueTime_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->maxValueDecimal_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueInteger_parser (::fhir::integer_pskel& p)
  {
    this->maxValueInteger_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValuePositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->maxValuePositiveInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->maxValueUnsignedInt_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxValueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->maxValueQuantity_parser_ = &p;
  }

  void ElementDefinition_pskel::
  maxLength_parser (::fhir::integer_pskel& p)
  {
    this->maxLength_parser_ = &p;
  }

  void ElementDefinition_pskel::
  condition_parser (::fhir::id_pskel& p)
  {
    this->condition_parser_ = &p;
  }

  void ElementDefinition_pskel::
  constraint_parser (::fhir::ElementDefinition_Constraint_pskel& p)
  {
    this->constraint_parser_ = &p;
  }

  void ElementDefinition_pskel::
  mustSupport_parser (::fhir::boolean_pskel& p)
  {
    this->mustSupport_parser_ = &p;
  }

  void ElementDefinition_pskel::
  isModifier_parser (::fhir::boolean_pskel& p)
  {
    this->isModifier_parser_ = &p;
  }

  void ElementDefinition_pskel::
  isModifierReason_parser (::fhir::string_pskel& p)
  {
    this->isModifierReason_parser_ = &p;
  }

  void ElementDefinition_pskel::
  isSummary_parser (::fhir::boolean_pskel& p)
  {
    this->isSummary_parser_ = &p;
  }

  void ElementDefinition_pskel::
  binding_parser (::fhir::ElementDefinition_Binding_pskel& p)
  {
    this->binding_parser_ = &p;
  }

  void ElementDefinition_pskel::
  mapping_parser (::fhir::ElementDefinition_Mapping_pskel& p)
  {
    this->mapping_parser_ = &p;
  }

  void ElementDefinition_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& path,
           ::fhir::PropertyRepresentation_pskel& representation,
           ::fhir::string_pskel& sliceName,
           ::fhir::boolean_pskel& sliceIsConstraining,
           ::fhir::string_pskel& label,
           ::fhir::Coding_pskel& code,
           ::fhir::ElementDefinition_Slicing_pskel& slicing,
           ::fhir::string_pskel& short_,
           ::fhir::markdown_pskel& definition,
           ::fhir::markdown_pskel& comment,
           ::fhir::markdown_pskel& requirements,
           ::fhir::string_pskel& alias,
           ::fhir::unsignedInt_pskel& min,
           ::fhir::string_pskel& max,
           ::fhir::ElementDefinition_Base_pskel& base,
           ::fhir::uri_pskel& contentReference,
           ::fhir::ElementDefinition_Type_pskel& type,
           ::fhir::base64Binary_pskel& defaultValueBase64Binary,
           ::fhir::boolean_pskel& defaultValueBoolean,
           ::fhir::canonical_pskel& defaultValueCanonical,
           ::fhir::code_pskel& defaultValueCode,
           ::fhir::date_pskel& defaultValueDate,
           ::fhir::dateTime_pskel& defaultValueDateTime,
           ::fhir::decimal_pskel& defaultValueDecimal,
           ::fhir::id_pskel& defaultValueId,
           ::fhir::instant_pskel& defaultValueInstant,
           ::fhir::integer_pskel& defaultValueInteger,
           ::fhir::markdown_pskel& defaultValueMarkdown,
           ::fhir::oid_pskel& defaultValueOid,
           ::fhir::positiveInt_pskel& defaultValuePositiveInt,
           ::fhir::string_pskel& defaultValueString,
           ::fhir::time_pskel& defaultValueTime,
           ::fhir::unsignedInt_pskel& defaultValueUnsignedInt,
           ::fhir::uri_pskel& defaultValueUri,
           ::fhir::url_pskel& defaultValueUrl,
           ::fhir::uuid_pskel& defaultValueUuid,
           ::fhir::Address_pskel& defaultValueAddress,
           ::fhir::Age_pskel& defaultValueAge,
           ::fhir::Annotation_pskel& defaultValueAnnotation,
           ::fhir::Attachment_pskel& defaultValueAttachment,
           ::fhir::CodeableConcept_pskel& defaultValueCodeableConcept,
           ::fhir::Coding_pskel& defaultValueCoding,
           ::fhir::ContactPoint_pskel& defaultValueContactPoint,
           ::fhir::Count_pskel& defaultValueCount,
           ::fhir::Distance_pskel& defaultValueDistance,
           ::fhir::Duration_pskel& defaultValueDuration,
           ::fhir::HumanName_pskel& defaultValueHumanName,
           ::fhir::Identifier_pskel& defaultValueIdentifier,
           ::fhir::Money_pskel& defaultValueMoney,
           ::fhir::Period_pskel& defaultValuePeriod,
           ::fhir::Quantity_pskel& defaultValueQuantity,
           ::fhir::Range_pskel& defaultValueRange,
           ::fhir::Ratio_pskel& defaultValueRatio,
           ::fhir::Reference_pskel& defaultValueReference,
           ::fhir::SampledData_pskel& defaultValueSampledData,
           ::fhir::Signature_pskel& defaultValueSignature,
           ::fhir::Timing_pskel& defaultValueTiming,
           ::fhir::ContactDetail_pskel& defaultValueContactDetail,
           ::fhir::Contributor_pskel& defaultValueContributor,
           ::fhir::DataRequirement_pskel& defaultValueDataRequirement,
           ::fhir::Expression_pskel& defaultValueExpression,
           ::fhir::ParameterDefinition_pskel& defaultValueParameterDefinition,
           ::fhir::RelatedArtifact_pskel& defaultValueRelatedArtifact,
           ::fhir::TriggerDefinition_pskel& defaultValueTriggerDefinition,
           ::fhir::UsageContext_pskel& defaultValueUsageContext,
           ::fhir::Dosage_pskel& defaultValueDosage,
           ::fhir::Meta_pskel& defaultValueMeta,
           ::fhir::markdown_pskel& meaningWhenMissing,
           ::fhir::string_pskel& orderMeaning,
           ::fhir::base64Binary_pskel& fixedBase64Binary,
           ::fhir::boolean_pskel& fixedBoolean,
           ::fhir::canonical_pskel& fixedCanonical,
           ::fhir::code_pskel& fixedCode,
           ::fhir::date_pskel& fixedDate,
           ::fhir::dateTime_pskel& fixedDateTime,
           ::fhir::decimal_pskel& fixedDecimal,
           ::fhir::id_pskel& fixedId,
           ::fhir::instant_pskel& fixedInstant,
           ::fhir::integer_pskel& fixedInteger,
           ::fhir::markdown_pskel& fixedMarkdown,
           ::fhir::oid_pskel& fixedOid,
           ::fhir::positiveInt_pskel& fixedPositiveInt,
           ::fhir::string_pskel& fixedString,
           ::fhir::time_pskel& fixedTime,
           ::fhir::unsignedInt_pskel& fixedUnsignedInt,
           ::fhir::uri_pskel& fixedUri,
           ::fhir::url_pskel& fixedUrl,
           ::fhir::uuid_pskel& fixedUuid,
           ::fhir::Address_pskel& fixedAddress,
           ::fhir::Age_pskel& fixedAge,
           ::fhir::Annotation_pskel& fixedAnnotation,
           ::fhir::Attachment_pskel& fixedAttachment,
           ::fhir::CodeableConcept_pskel& fixedCodeableConcept,
           ::fhir::Coding_pskel& fixedCoding,
           ::fhir::ContactPoint_pskel& fixedContactPoint,
           ::fhir::Count_pskel& fixedCount,
           ::fhir::Distance_pskel& fixedDistance,
           ::fhir::Duration_pskel& fixedDuration,
           ::fhir::HumanName_pskel& fixedHumanName,
           ::fhir::Identifier_pskel& fixedIdentifier,
           ::fhir::Money_pskel& fixedMoney,
           ::fhir::Period_pskel& fixedPeriod,
           ::fhir::Quantity_pskel& fixedQuantity,
           ::fhir::Range_pskel& fixedRange,
           ::fhir::Ratio_pskel& fixedRatio,
           ::fhir::Reference_pskel& fixedReference,
           ::fhir::SampledData_pskel& fixedSampledData,
           ::fhir::Signature_pskel& fixedSignature,
           ::fhir::Timing_pskel& fixedTiming,
           ::fhir::ContactDetail_pskel& fixedContactDetail,
           ::fhir::Contributor_pskel& fixedContributor,
           ::fhir::DataRequirement_pskel& fixedDataRequirement,
           ::fhir::Expression_pskel& fixedExpression,
           ::fhir::ParameterDefinition_pskel& fixedParameterDefinition,
           ::fhir::RelatedArtifact_pskel& fixedRelatedArtifact,
           ::fhir::TriggerDefinition_pskel& fixedTriggerDefinition,
           ::fhir::UsageContext_pskel& fixedUsageContext,
           ::fhir::Dosage_pskel& fixedDosage,
           ::fhir::Meta_pskel& fixedMeta,
           ::fhir::base64Binary_pskel& patternBase64Binary,
           ::fhir::boolean_pskel& patternBoolean,
           ::fhir::canonical_pskel& patternCanonical,
           ::fhir::code_pskel& patternCode,
           ::fhir::date_pskel& patternDate,
           ::fhir::dateTime_pskel& patternDateTime,
           ::fhir::decimal_pskel& patternDecimal,
           ::fhir::id_pskel& patternId,
           ::fhir::instant_pskel& patternInstant,
           ::fhir::integer_pskel& patternInteger,
           ::fhir::markdown_pskel& patternMarkdown,
           ::fhir::oid_pskel& patternOid,
           ::fhir::positiveInt_pskel& patternPositiveInt,
           ::fhir::string_pskel& patternString,
           ::fhir::time_pskel& patternTime,
           ::fhir::unsignedInt_pskel& patternUnsignedInt,
           ::fhir::uri_pskel& patternUri,
           ::fhir::url_pskel& patternUrl,
           ::fhir::uuid_pskel& patternUuid,
           ::fhir::Address_pskel& patternAddress,
           ::fhir::Age_pskel& patternAge,
           ::fhir::Annotation_pskel& patternAnnotation,
           ::fhir::Attachment_pskel& patternAttachment,
           ::fhir::CodeableConcept_pskel& patternCodeableConcept,
           ::fhir::Coding_pskel& patternCoding,
           ::fhir::ContactPoint_pskel& patternContactPoint,
           ::fhir::Count_pskel& patternCount,
           ::fhir::Distance_pskel& patternDistance,
           ::fhir::Duration_pskel& patternDuration,
           ::fhir::HumanName_pskel& patternHumanName,
           ::fhir::Identifier_pskel& patternIdentifier,
           ::fhir::Money_pskel& patternMoney,
           ::fhir::Period_pskel& patternPeriod,
           ::fhir::Quantity_pskel& patternQuantity,
           ::fhir::Range_pskel& patternRange,
           ::fhir::Ratio_pskel& patternRatio,
           ::fhir::Reference_pskel& patternReference,
           ::fhir::SampledData_pskel& patternSampledData,
           ::fhir::Signature_pskel& patternSignature,
           ::fhir::Timing_pskel& patternTiming,
           ::fhir::ContactDetail_pskel& patternContactDetail,
           ::fhir::Contributor_pskel& patternContributor,
           ::fhir::DataRequirement_pskel& patternDataRequirement,
           ::fhir::Expression_pskel& patternExpression,
           ::fhir::ParameterDefinition_pskel& patternParameterDefinition,
           ::fhir::RelatedArtifact_pskel& patternRelatedArtifact,
           ::fhir::TriggerDefinition_pskel& patternTriggerDefinition,
           ::fhir::UsageContext_pskel& patternUsageContext,
           ::fhir::Dosage_pskel& patternDosage,
           ::fhir::Meta_pskel& patternMeta,
           ::fhir::ElementDefinition_Example_pskel& example,
           ::fhir::date_pskel& minValueDate,
           ::fhir::dateTime_pskel& minValueDateTime,
           ::fhir::instant_pskel& minValueInstant,
           ::fhir::time_pskel& minValueTime,
           ::fhir::decimal_pskel& minValueDecimal,
           ::fhir::integer_pskel& minValueInteger,
           ::fhir::positiveInt_pskel& minValuePositiveInt,
           ::fhir::unsignedInt_pskel& minValueUnsignedInt,
           ::fhir::Quantity_pskel& minValueQuantity,
           ::fhir::date_pskel& maxValueDate,
           ::fhir::dateTime_pskel& maxValueDateTime,
           ::fhir::instant_pskel& maxValueInstant,
           ::fhir::time_pskel& maxValueTime,
           ::fhir::decimal_pskel& maxValueDecimal,
           ::fhir::integer_pskel& maxValueInteger,
           ::fhir::positiveInt_pskel& maxValuePositiveInt,
           ::fhir::unsignedInt_pskel& maxValueUnsignedInt,
           ::fhir::Quantity_pskel& maxValueQuantity,
           ::fhir::integer_pskel& maxLength,
           ::fhir::id_pskel& condition,
           ::fhir::ElementDefinition_Constraint_pskel& constraint,
           ::fhir::boolean_pskel& mustSupport,
           ::fhir::boolean_pskel& isModifier,
           ::fhir::string_pskel& isModifierReason,
           ::fhir::boolean_pskel& isSummary,
           ::fhir::ElementDefinition_Binding_pskel& binding,
           ::fhir::ElementDefinition_Mapping_pskel& mapping)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->path_parser_ = &path;
    this->representation_parser_ = &representation;
    this->sliceName_parser_ = &sliceName;
    this->sliceIsConstraining_parser_ = &sliceIsConstraining;
    this->label_parser_ = &label;
    this->code_parser_ = &code;
    this->slicing_parser_ = &slicing;
    this->short__parser_ = &short_;
    this->definition_parser_ = &definition;
    this->comment_parser_ = &comment;
    this->requirements_parser_ = &requirements;
    this->alias_parser_ = &alias;
    this->min_parser_ = &min;
    this->max_parser_ = &max;
    this->base_parser_ = &base;
    this->contentReference_parser_ = &contentReference;
    this->type_parser_ = &type;
    this->defaultValueBase64Binary_parser_ = &defaultValueBase64Binary;
    this->defaultValueBoolean_parser_ = &defaultValueBoolean;
    this->defaultValueCanonical_parser_ = &defaultValueCanonical;
    this->defaultValueCode_parser_ = &defaultValueCode;
    this->defaultValueDate_parser_ = &defaultValueDate;
    this->defaultValueDateTime_parser_ = &defaultValueDateTime;
    this->defaultValueDecimal_parser_ = &defaultValueDecimal;
    this->defaultValueId_parser_ = &defaultValueId;
    this->defaultValueInstant_parser_ = &defaultValueInstant;
    this->defaultValueInteger_parser_ = &defaultValueInteger;
    this->defaultValueMarkdown_parser_ = &defaultValueMarkdown;
    this->defaultValueOid_parser_ = &defaultValueOid;
    this->defaultValuePositiveInt_parser_ = &defaultValuePositiveInt;
    this->defaultValueString_parser_ = &defaultValueString;
    this->defaultValueTime_parser_ = &defaultValueTime;
    this->defaultValueUnsignedInt_parser_ = &defaultValueUnsignedInt;
    this->defaultValueUri_parser_ = &defaultValueUri;
    this->defaultValueUrl_parser_ = &defaultValueUrl;
    this->defaultValueUuid_parser_ = &defaultValueUuid;
    this->defaultValueAddress_parser_ = &defaultValueAddress;
    this->defaultValueAge_parser_ = &defaultValueAge;
    this->defaultValueAnnotation_parser_ = &defaultValueAnnotation;
    this->defaultValueAttachment_parser_ = &defaultValueAttachment;
    this->defaultValueCodeableConcept_parser_ = &defaultValueCodeableConcept;
    this->defaultValueCoding_parser_ = &defaultValueCoding;
    this->defaultValueContactPoint_parser_ = &defaultValueContactPoint;
    this->defaultValueCount_parser_ = &defaultValueCount;
    this->defaultValueDistance_parser_ = &defaultValueDistance;
    this->defaultValueDuration_parser_ = &defaultValueDuration;
    this->defaultValueHumanName_parser_ = &defaultValueHumanName;
    this->defaultValueIdentifier_parser_ = &defaultValueIdentifier;
    this->defaultValueMoney_parser_ = &defaultValueMoney;
    this->defaultValuePeriod_parser_ = &defaultValuePeriod;
    this->defaultValueQuantity_parser_ = &defaultValueQuantity;
    this->defaultValueRange_parser_ = &defaultValueRange;
    this->defaultValueRatio_parser_ = &defaultValueRatio;
    this->defaultValueReference_parser_ = &defaultValueReference;
    this->defaultValueSampledData_parser_ = &defaultValueSampledData;
    this->defaultValueSignature_parser_ = &defaultValueSignature;
    this->defaultValueTiming_parser_ = &defaultValueTiming;
    this->defaultValueContactDetail_parser_ = &defaultValueContactDetail;
    this->defaultValueContributor_parser_ = &defaultValueContributor;
    this->defaultValueDataRequirement_parser_ = &defaultValueDataRequirement;
    this->defaultValueExpression_parser_ = &defaultValueExpression;
    this->defaultValueParameterDefinition_parser_ = &defaultValueParameterDefinition;
    this->defaultValueRelatedArtifact_parser_ = &defaultValueRelatedArtifact;
    this->defaultValueTriggerDefinition_parser_ = &defaultValueTriggerDefinition;
    this->defaultValueUsageContext_parser_ = &defaultValueUsageContext;
    this->defaultValueDosage_parser_ = &defaultValueDosage;
    this->defaultValueMeta_parser_ = &defaultValueMeta;
    this->meaningWhenMissing_parser_ = &meaningWhenMissing;
    this->orderMeaning_parser_ = &orderMeaning;
    this->fixedBase64Binary_parser_ = &fixedBase64Binary;
    this->fixedBoolean_parser_ = &fixedBoolean;
    this->fixedCanonical_parser_ = &fixedCanonical;
    this->fixedCode_parser_ = &fixedCode;
    this->fixedDate_parser_ = &fixedDate;
    this->fixedDateTime_parser_ = &fixedDateTime;
    this->fixedDecimal_parser_ = &fixedDecimal;
    this->fixedId_parser_ = &fixedId;
    this->fixedInstant_parser_ = &fixedInstant;
    this->fixedInteger_parser_ = &fixedInteger;
    this->fixedMarkdown_parser_ = &fixedMarkdown;
    this->fixedOid_parser_ = &fixedOid;
    this->fixedPositiveInt_parser_ = &fixedPositiveInt;
    this->fixedString_parser_ = &fixedString;
    this->fixedTime_parser_ = &fixedTime;
    this->fixedUnsignedInt_parser_ = &fixedUnsignedInt;
    this->fixedUri_parser_ = &fixedUri;
    this->fixedUrl_parser_ = &fixedUrl;
    this->fixedUuid_parser_ = &fixedUuid;
    this->fixedAddress_parser_ = &fixedAddress;
    this->fixedAge_parser_ = &fixedAge;
    this->fixedAnnotation_parser_ = &fixedAnnotation;
    this->fixedAttachment_parser_ = &fixedAttachment;
    this->fixedCodeableConcept_parser_ = &fixedCodeableConcept;
    this->fixedCoding_parser_ = &fixedCoding;
    this->fixedContactPoint_parser_ = &fixedContactPoint;
    this->fixedCount_parser_ = &fixedCount;
    this->fixedDistance_parser_ = &fixedDistance;
    this->fixedDuration_parser_ = &fixedDuration;
    this->fixedHumanName_parser_ = &fixedHumanName;
    this->fixedIdentifier_parser_ = &fixedIdentifier;
    this->fixedMoney_parser_ = &fixedMoney;
    this->fixedPeriod_parser_ = &fixedPeriod;
    this->fixedQuantity_parser_ = &fixedQuantity;
    this->fixedRange_parser_ = &fixedRange;
    this->fixedRatio_parser_ = &fixedRatio;
    this->fixedReference_parser_ = &fixedReference;
    this->fixedSampledData_parser_ = &fixedSampledData;
    this->fixedSignature_parser_ = &fixedSignature;
    this->fixedTiming_parser_ = &fixedTiming;
    this->fixedContactDetail_parser_ = &fixedContactDetail;
    this->fixedContributor_parser_ = &fixedContributor;
    this->fixedDataRequirement_parser_ = &fixedDataRequirement;
    this->fixedExpression_parser_ = &fixedExpression;
    this->fixedParameterDefinition_parser_ = &fixedParameterDefinition;
    this->fixedRelatedArtifact_parser_ = &fixedRelatedArtifact;
    this->fixedTriggerDefinition_parser_ = &fixedTriggerDefinition;
    this->fixedUsageContext_parser_ = &fixedUsageContext;
    this->fixedDosage_parser_ = &fixedDosage;
    this->fixedMeta_parser_ = &fixedMeta;
    this->patternBase64Binary_parser_ = &patternBase64Binary;
    this->patternBoolean_parser_ = &patternBoolean;
    this->patternCanonical_parser_ = &patternCanonical;
    this->patternCode_parser_ = &patternCode;
    this->patternDate_parser_ = &patternDate;
    this->patternDateTime_parser_ = &patternDateTime;
    this->patternDecimal_parser_ = &patternDecimal;
    this->patternId_parser_ = &patternId;
    this->patternInstant_parser_ = &patternInstant;
    this->patternInteger_parser_ = &patternInteger;
    this->patternMarkdown_parser_ = &patternMarkdown;
    this->patternOid_parser_ = &patternOid;
    this->patternPositiveInt_parser_ = &patternPositiveInt;
    this->patternString_parser_ = &patternString;
    this->patternTime_parser_ = &patternTime;
    this->patternUnsignedInt_parser_ = &patternUnsignedInt;
    this->patternUri_parser_ = &patternUri;
    this->patternUrl_parser_ = &patternUrl;
    this->patternUuid_parser_ = &patternUuid;
    this->patternAddress_parser_ = &patternAddress;
    this->patternAge_parser_ = &patternAge;
    this->patternAnnotation_parser_ = &patternAnnotation;
    this->patternAttachment_parser_ = &patternAttachment;
    this->patternCodeableConcept_parser_ = &patternCodeableConcept;
    this->patternCoding_parser_ = &patternCoding;
    this->patternContactPoint_parser_ = &patternContactPoint;
    this->patternCount_parser_ = &patternCount;
    this->patternDistance_parser_ = &patternDistance;
    this->patternDuration_parser_ = &patternDuration;
    this->patternHumanName_parser_ = &patternHumanName;
    this->patternIdentifier_parser_ = &patternIdentifier;
    this->patternMoney_parser_ = &patternMoney;
    this->patternPeriod_parser_ = &patternPeriod;
    this->patternQuantity_parser_ = &patternQuantity;
    this->patternRange_parser_ = &patternRange;
    this->patternRatio_parser_ = &patternRatio;
    this->patternReference_parser_ = &patternReference;
    this->patternSampledData_parser_ = &patternSampledData;
    this->patternSignature_parser_ = &patternSignature;
    this->patternTiming_parser_ = &patternTiming;
    this->patternContactDetail_parser_ = &patternContactDetail;
    this->patternContributor_parser_ = &patternContributor;
    this->patternDataRequirement_parser_ = &patternDataRequirement;
    this->patternExpression_parser_ = &patternExpression;
    this->patternParameterDefinition_parser_ = &patternParameterDefinition;
    this->patternRelatedArtifact_parser_ = &patternRelatedArtifact;
    this->patternTriggerDefinition_parser_ = &patternTriggerDefinition;
    this->patternUsageContext_parser_ = &patternUsageContext;
    this->patternDosage_parser_ = &patternDosage;
    this->patternMeta_parser_ = &patternMeta;
    this->example_parser_ = &example;
    this->minValueDate_parser_ = &minValueDate;
    this->minValueDateTime_parser_ = &minValueDateTime;
    this->minValueInstant_parser_ = &minValueInstant;
    this->minValueTime_parser_ = &minValueTime;
    this->minValueDecimal_parser_ = &minValueDecimal;
    this->minValueInteger_parser_ = &minValueInteger;
    this->minValuePositiveInt_parser_ = &minValuePositiveInt;
    this->minValueUnsignedInt_parser_ = &minValueUnsignedInt;
    this->minValueQuantity_parser_ = &minValueQuantity;
    this->maxValueDate_parser_ = &maxValueDate;
    this->maxValueDateTime_parser_ = &maxValueDateTime;
    this->maxValueInstant_parser_ = &maxValueInstant;
    this->maxValueTime_parser_ = &maxValueTime;
    this->maxValueDecimal_parser_ = &maxValueDecimal;
    this->maxValueInteger_parser_ = &maxValueInteger;
    this->maxValuePositiveInt_parser_ = &maxValuePositiveInt;
    this->maxValueUnsignedInt_parser_ = &maxValueUnsignedInt;
    this->maxValueQuantity_parser_ = &maxValueQuantity;
    this->maxLength_parser_ = &maxLength;
    this->condition_parser_ = &condition;
    this->constraint_parser_ = &constraint;
    this->mustSupport_parser_ = &mustSupport;
    this->isModifier_parser_ = &isModifier;
    this->isModifierReason_parser_ = &isModifierReason;
    this->isSummary_parser_ = &isSummary;
    this->binding_parser_ = &binding;
    this->mapping_parser_ = &mapping;
  }

  ElementDefinition_pskel::
  ElementDefinition_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_impl_ (0),
    path_parser_ (0),
    representation_parser_ (0),
    sliceName_parser_ (0),
    sliceIsConstraining_parser_ (0),
    label_parser_ (0),
    code_parser_ (0),
    slicing_parser_ (0),
    short__parser_ (0),
    definition_parser_ (0),
    comment_parser_ (0),
    requirements_parser_ (0),
    alias_parser_ (0),
    min_parser_ (0),
    max_parser_ (0),
    base_parser_ (0),
    contentReference_parser_ (0),
    type_parser_ (0),
    defaultValueBase64Binary_parser_ (0),
    defaultValueBoolean_parser_ (0),
    defaultValueCanonical_parser_ (0),
    defaultValueCode_parser_ (0),
    defaultValueDate_parser_ (0),
    defaultValueDateTime_parser_ (0),
    defaultValueDecimal_parser_ (0),
    defaultValueId_parser_ (0),
    defaultValueInstant_parser_ (0),
    defaultValueInteger_parser_ (0),
    defaultValueMarkdown_parser_ (0),
    defaultValueOid_parser_ (0),
    defaultValuePositiveInt_parser_ (0),
    defaultValueString_parser_ (0),
    defaultValueTime_parser_ (0),
    defaultValueUnsignedInt_parser_ (0),
    defaultValueUri_parser_ (0),
    defaultValueUrl_parser_ (0),
    defaultValueUuid_parser_ (0),
    defaultValueAddress_parser_ (0),
    defaultValueAge_parser_ (0),
    defaultValueAnnotation_parser_ (0),
    defaultValueAttachment_parser_ (0),
    defaultValueCodeableConcept_parser_ (0),
    defaultValueCoding_parser_ (0),
    defaultValueContactPoint_parser_ (0),
    defaultValueCount_parser_ (0),
    defaultValueDistance_parser_ (0),
    defaultValueDuration_parser_ (0),
    defaultValueHumanName_parser_ (0),
    defaultValueIdentifier_parser_ (0),
    defaultValueMoney_parser_ (0),
    defaultValuePeriod_parser_ (0),
    defaultValueQuantity_parser_ (0),
    defaultValueRange_parser_ (0),
    defaultValueRatio_parser_ (0),
    defaultValueReference_parser_ (0),
    defaultValueSampledData_parser_ (0),
    defaultValueSignature_parser_ (0),
    defaultValueTiming_parser_ (0),
    defaultValueContactDetail_parser_ (0),
    defaultValueContributor_parser_ (0),
    defaultValueDataRequirement_parser_ (0),
    defaultValueExpression_parser_ (0),
    defaultValueParameterDefinition_parser_ (0),
    defaultValueRelatedArtifact_parser_ (0),
    defaultValueTriggerDefinition_parser_ (0),
    defaultValueUsageContext_parser_ (0),
    defaultValueDosage_parser_ (0),
    defaultValueMeta_parser_ (0),
    meaningWhenMissing_parser_ (0),
    orderMeaning_parser_ (0),
    fixedBase64Binary_parser_ (0),
    fixedBoolean_parser_ (0),
    fixedCanonical_parser_ (0),
    fixedCode_parser_ (0),
    fixedDate_parser_ (0),
    fixedDateTime_parser_ (0),
    fixedDecimal_parser_ (0),
    fixedId_parser_ (0),
    fixedInstant_parser_ (0),
    fixedInteger_parser_ (0),
    fixedMarkdown_parser_ (0),
    fixedOid_parser_ (0),
    fixedPositiveInt_parser_ (0),
    fixedString_parser_ (0),
    fixedTime_parser_ (0),
    fixedUnsignedInt_parser_ (0),
    fixedUri_parser_ (0),
    fixedUrl_parser_ (0),
    fixedUuid_parser_ (0),
    fixedAddress_parser_ (0),
    fixedAge_parser_ (0),
    fixedAnnotation_parser_ (0),
    fixedAttachment_parser_ (0),
    fixedCodeableConcept_parser_ (0),
    fixedCoding_parser_ (0),
    fixedContactPoint_parser_ (0),
    fixedCount_parser_ (0),
    fixedDistance_parser_ (0),
    fixedDuration_parser_ (0),
    fixedHumanName_parser_ (0),
    fixedIdentifier_parser_ (0),
    fixedMoney_parser_ (0),
    fixedPeriod_parser_ (0),
    fixedQuantity_parser_ (0),
    fixedRange_parser_ (0),
    fixedRatio_parser_ (0),
    fixedReference_parser_ (0),
    fixedSampledData_parser_ (0),
    fixedSignature_parser_ (0),
    fixedTiming_parser_ (0),
    fixedContactDetail_parser_ (0),
    fixedContributor_parser_ (0),
    fixedDataRequirement_parser_ (0),
    fixedExpression_parser_ (0),
    fixedParameterDefinition_parser_ (0),
    fixedRelatedArtifact_parser_ (0),
    fixedTriggerDefinition_parser_ (0),
    fixedUsageContext_parser_ (0),
    fixedDosage_parser_ (0),
    fixedMeta_parser_ (0),
    patternBase64Binary_parser_ (0),
    patternBoolean_parser_ (0),
    patternCanonical_parser_ (0),
    patternCode_parser_ (0),
    patternDate_parser_ (0),
    patternDateTime_parser_ (0),
    patternDecimal_parser_ (0),
    patternId_parser_ (0),
    patternInstant_parser_ (0),
    patternInteger_parser_ (0),
    patternMarkdown_parser_ (0),
    patternOid_parser_ (0),
    patternPositiveInt_parser_ (0),
    patternString_parser_ (0),
    patternTime_parser_ (0),
    patternUnsignedInt_parser_ (0),
    patternUri_parser_ (0),
    patternUrl_parser_ (0),
    patternUuid_parser_ (0),
    patternAddress_parser_ (0),
    patternAge_parser_ (0),
    patternAnnotation_parser_ (0),
    patternAttachment_parser_ (0),
    patternCodeableConcept_parser_ (0),
    patternCoding_parser_ (0),
    patternContactPoint_parser_ (0),
    patternCount_parser_ (0),
    patternDistance_parser_ (0),
    patternDuration_parser_ (0),
    patternHumanName_parser_ (0),
    patternIdentifier_parser_ (0),
    patternMoney_parser_ (0),
    patternPeriod_parser_ (0),
    patternQuantity_parser_ (0),
    patternRange_parser_ (0),
    patternRatio_parser_ (0),
    patternReference_parser_ (0),
    patternSampledData_parser_ (0),
    patternSignature_parser_ (0),
    patternTiming_parser_ (0),
    patternContactDetail_parser_ (0),
    patternContributor_parser_ (0),
    patternDataRequirement_parser_ (0),
    patternExpression_parser_ (0),
    patternParameterDefinition_parser_ (0),
    patternRelatedArtifact_parser_ (0),
    patternTriggerDefinition_parser_ (0),
    patternUsageContext_parser_ (0),
    patternDosage_parser_ (0),
    patternMeta_parser_ (0),
    example_parser_ (0),
    minValueDate_parser_ (0),
    minValueDateTime_parser_ (0),
    minValueInstant_parser_ (0),
    minValueTime_parser_ (0),
    minValueDecimal_parser_ (0),
    minValueInteger_parser_ (0),
    minValuePositiveInt_parser_ (0),
    minValueUnsignedInt_parser_ (0),
    minValueQuantity_parser_ (0),
    maxValueDate_parser_ (0),
    maxValueDateTime_parser_ (0),
    maxValueInstant_parser_ (0),
    maxValueTime_parser_ (0),
    maxValueDecimal_parser_ (0),
    maxValueInteger_parser_ (0),
    maxValuePositiveInt_parser_ (0),
    maxValueUnsignedInt_parser_ (0),
    maxValueQuantity_parser_ (0),
    maxLength_parser_ (0),
    condition_parser_ (0),
    constraint_parser_ (0),
    mustSupport_parser_ (0),
    isModifier_parser_ (0),
    isModifierReason_parser_ (0),
    isSummary_parser_ (0),
    binding_parser_ (0),
    mapping_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_pskel::
  ElementDefinition_pskel (ElementDefinition_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_impl_ (impl),
    path_parser_ (0),
    representation_parser_ (0),
    sliceName_parser_ (0),
    sliceIsConstraining_parser_ (0),
    label_parser_ (0),
    code_parser_ (0),
    slicing_parser_ (0),
    short__parser_ (0),
    definition_parser_ (0),
    comment_parser_ (0),
    requirements_parser_ (0),
    alias_parser_ (0),
    min_parser_ (0),
    max_parser_ (0),
    base_parser_ (0),
    contentReference_parser_ (0),
    type_parser_ (0),
    defaultValueBase64Binary_parser_ (0),
    defaultValueBoolean_parser_ (0),
    defaultValueCanonical_parser_ (0),
    defaultValueCode_parser_ (0),
    defaultValueDate_parser_ (0),
    defaultValueDateTime_parser_ (0),
    defaultValueDecimal_parser_ (0),
    defaultValueId_parser_ (0),
    defaultValueInstant_parser_ (0),
    defaultValueInteger_parser_ (0),
    defaultValueMarkdown_parser_ (0),
    defaultValueOid_parser_ (0),
    defaultValuePositiveInt_parser_ (0),
    defaultValueString_parser_ (0),
    defaultValueTime_parser_ (0),
    defaultValueUnsignedInt_parser_ (0),
    defaultValueUri_parser_ (0),
    defaultValueUrl_parser_ (0),
    defaultValueUuid_parser_ (0),
    defaultValueAddress_parser_ (0),
    defaultValueAge_parser_ (0),
    defaultValueAnnotation_parser_ (0),
    defaultValueAttachment_parser_ (0),
    defaultValueCodeableConcept_parser_ (0),
    defaultValueCoding_parser_ (0),
    defaultValueContactPoint_parser_ (0),
    defaultValueCount_parser_ (0),
    defaultValueDistance_parser_ (0),
    defaultValueDuration_parser_ (0),
    defaultValueHumanName_parser_ (0),
    defaultValueIdentifier_parser_ (0),
    defaultValueMoney_parser_ (0),
    defaultValuePeriod_parser_ (0),
    defaultValueQuantity_parser_ (0),
    defaultValueRange_parser_ (0),
    defaultValueRatio_parser_ (0),
    defaultValueReference_parser_ (0),
    defaultValueSampledData_parser_ (0),
    defaultValueSignature_parser_ (0),
    defaultValueTiming_parser_ (0),
    defaultValueContactDetail_parser_ (0),
    defaultValueContributor_parser_ (0),
    defaultValueDataRequirement_parser_ (0),
    defaultValueExpression_parser_ (0),
    defaultValueParameterDefinition_parser_ (0),
    defaultValueRelatedArtifact_parser_ (0),
    defaultValueTriggerDefinition_parser_ (0),
    defaultValueUsageContext_parser_ (0),
    defaultValueDosage_parser_ (0),
    defaultValueMeta_parser_ (0),
    meaningWhenMissing_parser_ (0),
    orderMeaning_parser_ (0),
    fixedBase64Binary_parser_ (0),
    fixedBoolean_parser_ (0),
    fixedCanonical_parser_ (0),
    fixedCode_parser_ (0),
    fixedDate_parser_ (0),
    fixedDateTime_parser_ (0),
    fixedDecimal_parser_ (0),
    fixedId_parser_ (0),
    fixedInstant_parser_ (0),
    fixedInteger_parser_ (0),
    fixedMarkdown_parser_ (0),
    fixedOid_parser_ (0),
    fixedPositiveInt_parser_ (0),
    fixedString_parser_ (0),
    fixedTime_parser_ (0),
    fixedUnsignedInt_parser_ (0),
    fixedUri_parser_ (0),
    fixedUrl_parser_ (0),
    fixedUuid_parser_ (0),
    fixedAddress_parser_ (0),
    fixedAge_parser_ (0),
    fixedAnnotation_parser_ (0),
    fixedAttachment_parser_ (0),
    fixedCodeableConcept_parser_ (0),
    fixedCoding_parser_ (0),
    fixedContactPoint_parser_ (0),
    fixedCount_parser_ (0),
    fixedDistance_parser_ (0),
    fixedDuration_parser_ (0),
    fixedHumanName_parser_ (0),
    fixedIdentifier_parser_ (0),
    fixedMoney_parser_ (0),
    fixedPeriod_parser_ (0),
    fixedQuantity_parser_ (0),
    fixedRange_parser_ (0),
    fixedRatio_parser_ (0),
    fixedReference_parser_ (0),
    fixedSampledData_parser_ (0),
    fixedSignature_parser_ (0),
    fixedTiming_parser_ (0),
    fixedContactDetail_parser_ (0),
    fixedContributor_parser_ (0),
    fixedDataRequirement_parser_ (0),
    fixedExpression_parser_ (0),
    fixedParameterDefinition_parser_ (0),
    fixedRelatedArtifact_parser_ (0),
    fixedTriggerDefinition_parser_ (0),
    fixedUsageContext_parser_ (0),
    fixedDosage_parser_ (0),
    fixedMeta_parser_ (0),
    patternBase64Binary_parser_ (0),
    patternBoolean_parser_ (0),
    patternCanonical_parser_ (0),
    patternCode_parser_ (0),
    patternDate_parser_ (0),
    patternDateTime_parser_ (0),
    patternDecimal_parser_ (0),
    patternId_parser_ (0),
    patternInstant_parser_ (0),
    patternInteger_parser_ (0),
    patternMarkdown_parser_ (0),
    patternOid_parser_ (0),
    patternPositiveInt_parser_ (0),
    patternString_parser_ (0),
    patternTime_parser_ (0),
    patternUnsignedInt_parser_ (0),
    patternUri_parser_ (0),
    patternUrl_parser_ (0),
    patternUuid_parser_ (0),
    patternAddress_parser_ (0),
    patternAge_parser_ (0),
    patternAnnotation_parser_ (0),
    patternAttachment_parser_ (0),
    patternCodeableConcept_parser_ (0),
    patternCoding_parser_ (0),
    patternContactPoint_parser_ (0),
    patternCount_parser_ (0),
    patternDistance_parser_ (0),
    patternDuration_parser_ (0),
    patternHumanName_parser_ (0),
    patternIdentifier_parser_ (0),
    patternMoney_parser_ (0),
    patternPeriod_parser_ (0),
    patternQuantity_parser_ (0),
    patternRange_parser_ (0),
    patternRatio_parser_ (0),
    patternReference_parser_ (0),
    patternSampledData_parser_ (0),
    patternSignature_parser_ (0),
    patternTiming_parser_ (0),
    patternContactDetail_parser_ (0),
    patternContributor_parser_ (0),
    patternDataRequirement_parser_ (0),
    patternExpression_parser_ (0),
    patternParameterDefinition_parser_ (0),
    patternRelatedArtifact_parser_ (0),
    patternTriggerDefinition_parser_ (0),
    patternUsageContext_parser_ (0),
    patternDosage_parser_ (0),
    patternMeta_parser_ (0),
    example_parser_ (0),
    minValueDate_parser_ (0),
    minValueDateTime_parser_ (0),
    minValueInstant_parser_ (0),
    minValueTime_parser_ (0),
    minValueDecimal_parser_ (0),
    minValueInteger_parser_ (0),
    minValuePositiveInt_parser_ (0),
    minValueUnsignedInt_parser_ (0),
    minValueQuantity_parser_ (0),
    maxValueDate_parser_ (0),
    maxValueDateTime_parser_ (0),
    maxValueInstant_parser_ (0),
    maxValueTime_parser_ (0),
    maxValueDecimal_parser_ (0),
    maxValueInteger_parser_ (0),
    maxValuePositiveInt_parser_ (0),
    maxValueUnsignedInt_parser_ (0),
    maxValueQuantity_parser_ (0),
    maxLength_parser_ (0),
    condition_parser_ (0),
    constraint_parser_ (0),
    mustSupport_parser_ (0),
    isModifier_parser_ (0),
    isModifierReason_parser_ (0),
    isSummary_parser_ (0),
    binding_parser_ (0),
    mapping_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Constraint_pskel
  //

  void ElementDefinition_Constraint_pskel::
  key_parser (::fhir::id_pskel& p)
  {
    this->key_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  requirements_parser (::fhir::string_pskel& p)
  {
    this->requirements_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  severity_parser (::fhir::ConstraintSeverity_pskel& p)
  {
    this->severity_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  human_parser (::fhir::string_pskel& p)
  {
    this->human_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  expression_parser (::fhir::string_pskel& p)
  {
    this->expression_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  xpath_parser (::fhir::string_pskel& p)
  {
    this->xpath_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  source_parser (::fhir::canonical_pskel& p)
  {
    this->source_parser_ = &p;
  }

  void ElementDefinition_Constraint_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::id_pskel& key,
           ::fhir::string_pskel& requirements,
           ::fhir::ConstraintSeverity_pskel& severity,
           ::fhir::string_pskel& human,
           ::fhir::string_pskel& expression,
           ::fhir::string_pskel& xpath,
           ::fhir::canonical_pskel& source)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->key_parser_ = &key;
    this->requirements_parser_ = &requirements;
    this->severity_parser_ = &severity;
    this->human_parser_ = &human;
    this->expression_parser_ = &expression;
    this->xpath_parser_ = &xpath;
    this->source_parser_ = &source;
  }

  ElementDefinition_Constraint_pskel::
  ElementDefinition_Constraint_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Constraint_impl_ (0),
    key_parser_ (0),
    requirements_parser_ (0),
    severity_parser_ (0),
    human_parser_ (0),
    expression_parser_ (0),
    xpath_parser_ (0),
    source_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Constraint_pskel::
  ElementDefinition_Constraint_pskel (ElementDefinition_Constraint_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Constraint_impl_ (impl),
    key_parser_ (0),
    requirements_parser_ (0),
    severity_parser_ (0),
    human_parser_ (0),
    expression_parser_ (0),
    xpath_parser_ (0),
    source_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Mapping_pskel
  //

  void ElementDefinition_Mapping_pskel::
  identity_parser (::fhir::id_pskel& p)
  {
    this->identity_parser_ = &p;
  }

  void ElementDefinition_Mapping_pskel::
  language_parser (::fhir::code_pskel& p)
  {
    this->language_parser_ = &p;
  }

  void ElementDefinition_Mapping_pskel::
  map_parser (::fhir::string_pskel& p)
  {
    this->map_parser_ = &p;
  }

  void ElementDefinition_Mapping_pskel::
  comment_parser (::fhir::string_pskel& p)
  {
    this->comment_parser_ = &p;
  }

  void ElementDefinition_Mapping_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::id_pskel& identity,
           ::fhir::code_pskel& language,
           ::fhir::string_pskel& map,
           ::fhir::string_pskel& comment)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->identity_parser_ = &identity;
    this->language_parser_ = &language;
    this->map_parser_ = &map;
    this->comment_parser_ = &comment;
  }

  ElementDefinition_Mapping_pskel::
  ElementDefinition_Mapping_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Mapping_impl_ (0),
    identity_parser_ (0),
    language_parser_ (0),
    map_parser_ (0),
    comment_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Mapping_pskel::
  ElementDefinition_Mapping_pskel (ElementDefinition_Mapping_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Mapping_impl_ (impl),
    identity_parser_ (0),
    language_parser_ (0),
    map_parser_ (0),
    comment_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Base_pskel
  //

  void ElementDefinition_Base_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void ElementDefinition_Base_pskel::
  min_parser (::fhir::unsignedInt_pskel& p)
  {
    this->min_parser_ = &p;
  }

  void ElementDefinition_Base_pskel::
  max_parser (::fhir::string_pskel& p)
  {
    this->max_parser_ = &p;
  }

  void ElementDefinition_Base_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& path,
           ::fhir::unsignedInt_pskel& min,
           ::fhir::string_pskel& max)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->path_parser_ = &path;
    this->min_parser_ = &min;
    this->max_parser_ = &max;
  }

  ElementDefinition_Base_pskel::
  ElementDefinition_Base_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Base_impl_ (0),
    path_parser_ (0),
    min_parser_ (0),
    max_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Base_pskel::
  ElementDefinition_Base_pskel (ElementDefinition_Base_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Base_impl_ (impl),
    path_parser_ (0),
    min_parser_ (0),
    max_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Type_pskel
  //

  void ElementDefinition_Type_pskel::
  code_parser (::fhir::uri_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void ElementDefinition_Type_pskel::
  profile_parser (::fhir::canonical_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void ElementDefinition_Type_pskel::
  targetProfile_parser (::fhir::canonical_pskel& p)
  {
    this->targetProfile_parser_ = &p;
  }

  void ElementDefinition_Type_pskel::
  aggregation_parser (::fhir::AggregationMode_pskel& p)
  {
    this->aggregation_parser_ = &p;
  }

  void ElementDefinition_Type_pskel::
  versioning_parser (::fhir::ReferenceVersionRules_pskel& p)
  {
    this->versioning_parser_ = &p;
  }

  void ElementDefinition_Type_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::uri_pskel& code,
           ::fhir::canonical_pskel& profile,
           ::fhir::canonical_pskel& targetProfile,
           ::fhir::AggregationMode_pskel& aggregation,
           ::fhir::ReferenceVersionRules_pskel& versioning)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->code_parser_ = &code;
    this->profile_parser_ = &profile;
    this->targetProfile_parser_ = &targetProfile;
    this->aggregation_parser_ = &aggregation;
    this->versioning_parser_ = &versioning;
  }

  ElementDefinition_Type_pskel::
  ElementDefinition_Type_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Type_impl_ (0),
    code_parser_ (0),
    profile_parser_ (0),
    targetProfile_parser_ (0),
    aggregation_parser_ (0),
    versioning_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Type_pskel::
  ElementDefinition_Type_pskel (ElementDefinition_Type_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Type_impl_ (impl),
    code_parser_ (0),
    profile_parser_ (0),
    targetProfile_parser_ (0),
    aggregation_parser_ (0),
    versioning_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Example_pskel
  //

  void ElementDefinition_Example_pskel::
  label_parser (::fhir::string_pskel& p)
  {
    this->label_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueBase64Binary_parser (::fhir::base64Binary_pskel& p)
  {
    this->valueBase64Binary_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueBoolean_parser (::fhir::boolean_pskel& p)
  {
    this->valueBoolean_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueCanonical_parser (::fhir::canonical_pskel& p)
  {
    this->valueCanonical_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueCode_parser (::fhir::code_pskel& p)
  {
    this->valueCode_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDate_parser (::fhir::date_pskel& p)
  {
    this->valueDate_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDateTime_parser (::fhir::dateTime_pskel& p)
  {
    this->valueDateTime_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDecimal_parser (::fhir::decimal_pskel& p)
  {
    this->valueDecimal_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueId_parser (::fhir::id_pskel& p)
  {
    this->valueId_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueInstant_parser (::fhir::instant_pskel& p)
  {
    this->valueInstant_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueInteger_parser (::fhir::integer_pskel& p)
  {
    this->valueInteger_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueMarkdown_parser (::fhir::markdown_pskel& p)
  {
    this->valueMarkdown_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueOid_parser (::fhir::oid_pskel& p)
  {
    this->valueOid_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valuePositiveInt_parser (::fhir::positiveInt_pskel& p)
  {
    this->valuePositiveInt_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueString_parser (::fhir::string_pskel& p)
  {
    this->valueString_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueTime_parser (::fhir::time_pskel& p)
  {
    this->valueTime_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueUnsignedInt_parser (::fhir::unsignedInt_pskel& p)
  {
    this->valueUnsignedInt_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueUri_parser (::fhir::uri_pskel& p)
  {
    this->valueUri_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueUrl_parser (::fhir::url_pskel& p)
  {
    this->valueUrl_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueUuid_parser (::fhir::uuid_pskel& p)
  {
    this->valueUuid_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueAddress_parser (::fhir::Address_pskel& p)
  {
    this->valueAddress_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueAge_parser (::fhir::Age_pskel& p)
  {
    this->valueAge_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueAnnotation_parser (::fhir::Annotation_pskel& p)
  {
    this->valueAnnotation_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueAttachment_parser (::fhir::Attachment_pskel& p)
  {
    this->valueAttachment_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->valueCodeableConcept_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueCoding_parser (::fhir::Coding_pskel& p)
  {
    this->valueCoding_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueContactPoint_parser (::fhir::ContactPoint_pskel& p)
  {
    this->valueContactPoint_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueCount_parser (::fhir::Count_pskel& p)
  {
    this->valueCount_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDistance_parser (::fhir::Distance_pskel& p)
  {
    this->valueDistance_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDuration_parser (::fhir::Duration_pskel& p)
  {
    this->valueDuration_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueHumanName_parser (::fhir::HumanName_pskel& p)
  {
    this->valueHumanName_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueIdentifier_parser (::fhir::Identifier_pskel& p)
  {
    this->valueIdentifier_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueMoney_parser (::fhir::Money_pskel& p)
  {
    this->valueMoney_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valuePeriod_parser (::fhir::Period_pskel& p)
  {
    this->valuePeriod_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->valueQuantity_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueRange_parser (::fhir::Range_pskel& p)
  {
    this->valueRange_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueRatio_parser (::fhir::Ratio_pskel& p)
  {
    this->valueRatio_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueReference_parser (::fhir::Reference_pskel& p)
  {
    this->valueReference_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueSampledData_parser (::fhir::SampledData_pskel& p)
  {
    this->valueSampledData_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueSignature_parser (::fhir::Signature_pskel& p)
  {
    this->valueSignature_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueTiming_parser (::fhir::Timing_pskel& p)
  {
    this->valueTiming_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueContactDetail_parser (::fhir::ContactDetail_pskel& p)
  {
    this->valueContactDetail_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueContributor_parser (::fhir::Contributor_pskel& p)
  {
    this->valueContributor_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDataRequirement_parser (::fhir::DataRequirement_pskel& p)
  {
    this->valueDataRequirement_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueExpression_parser (::fhir::Expression_pskel& p)
  {
    this->valueExpression_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueParameterDefinition_parser (::fhir::ParameterDefinition_pskel& p)
  {
    this->valueParameterDefinition_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueRelatedArtifact_parser (::fhir::RelatedArtifact_pskel& p)
  {
    this->valueRelatedArtifact_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueTriggerDefinition_parser (::fhir::TriggerDefinition_pskel& p)
  {
    this->valueTriggerDefinition_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueUsageContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->valueUsageContext_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueDosage_parser (::fhir::Dosage_pskel& p)
  {
    this->valueDosage_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  valueMeta_parser (::fhir::Meta_pskel& p)
  {
    this->valueMeta_parser_ = &p;
  }

  void ElementDefinition_Example_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& label,
           ::fhir::base64Binary_pskel& valueBase64Binary,
           ::fhir::boolean_pskel& valueBoolean,
           ::fhir::canonical_pskel& valueCanonical,
           ::fhir::code_pskel& valueCode,
           ::fhir::date_pskel& valueDate,
           ::fhir::dateTime_pskel& valueDateTime,
           ::fhir::decimal_pskel& valueDecimal,
           ::fhir::id_pskel& valueId,
           ::fhir::instant_pskel& valueInstant,
           ::fhir::integer_pskel& valueInteger,
           ::fhir::markdown_pskel& valueMarkdown,
           ::fhir::oid_pskel& valueOid,
           ::fhir::positiveInt_pskel& valuePositiveInt,
           ::fhir::string_pskel& valueString,
           ::fhir::time_pskel& valueTime,
           ::fhir::unsignedInt_pskel& valueUnsignedInt,
           ::fhir::uri_pskel& valueUri,
           ::fhir::url_pskel& valueUrl,
           ::fhir::uuid_pskel& valueUuid,
           ::fhir::Address_pskel& valueAddress,
           ::fhir::Age_pskel& valueAge,
           ::fhir::Annotation_pskel& valueAnnotation,
           ::fhir::Attachment_pskel& valueAttachment,
           ::fhir::CodeableConcept_pskel& valueCodeableConcept,
           ::fhir::Coding_pskel& valueCoding,
           ::fhir::ContactPoint_pskel& valueContactPoint,
           ::fhir::Count_pskel& valueCount,
           ::fhir::Distance_pskel& valueDistance,
           ::fhir::Duration_pskel& valueDuration,
           ::fhir::HumanName_pskel& valueHumanName,
           ::fhir::Identifier_pskel& valueIdentifier,
           ::fhir::Money_pskel& valueMoney,
           ::fhir::Period_pskel& valuePeriod,
           ::fhir::Quantity_pskel& valueQuantity,
           ::fhir::Range_pskel& valueRange,
           ::fhir::Ratio_pskel& valueRatio,
           ::fhir::Reference_pskel& valueReference,
           ::fhir::SampledData_pskel& valueSampledData,
           ::fhir::Signature_pskel& valueSignature,
           ::fhir::Timing_pskel& valueTiming,
           ::fhir::ContactDetail_pskel& valueContactDetail,
           ::fhir::Contributor_pskel& valueContributor,
           ::fhir::DataRequirement_pskel& valueDataRequirement,
           ::fhir::Expression_pskel& valueExpression,
           ::fhir::ParameterDefinition_pskel& valueParameterDefinition,
           ::fhir::RelatedArtifact_pskel& valueRelatedArtifact,
           ::fhir::TriggerDefinition_pskel& valueTriggerDefinition,
           ::fhir::UsageContext_pskel& valueUsageContext,
           ::fhir::Dosage_pskel& valueDosage,
           ::fhir::Meta_pskel& valueMeta)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->label_parser_ = &label;
    this->valueBase64Binary_parser_ = &valueBase64Binary;
    this->valueBoolean_parser_ = &valueBoolean;
    this->valueCanonical_parser_ = &valueCanonical;
    this->valueCode_parser_ = &valueCode;
    this->valueDate_parser_ = &valueDate;
    this->valueDateTime_parser_ = &valueDateTime;
    this->valueDecimal_parser_ = &valueDecimal;
    this->valueId_parser_ = &valueId;
    this->valueInstant_parser_ = &valueInstant;
    this->valueInteger_parser_ = &valueInteger;
    this->valueMarkdown_parser_ = &valueMarkdown;
    this->valueOid_parser_ = &valueOid;
    this->valuePositiveInt_parser_ = &valuePositiveInt;
    this->valueString_parser_ = &valueString;
    this->valueTime_parser_ = &valueTime;
    this->valueUnsignedInt_parser_ = &valueUnsignedInt;
    this->valueUri_parser_ = &valueUri;
    this->valueUrl_parser_ = &valueUrl;
    this->valueUuid_parser_ = &valueUuid;
    this->valueAddress_parser_ = &valueAddress;
    this->valueAge_parser_ = &valueAge;
    this->valueAnnotation_parser_ = &valueAnnotation;
    this->valueAttachment_parser_ = &valueAttachment;
    this->valueCodeableConcept_parser_ = &valueCodeableConcept;
    this->valueCoding_parser_ = &valueCoding;
    this->valueContactPoint_parser_ = &valueContactPoint;
    this->valueCount_parser_ = &valueCount;
    this->valueDistance_parser_ = &valueDistance;
    this->valueDuration_parser_ = &valueDuration;
    this->valueHumanName_parser_ = &valueHumanName;
    this->valueIdentifier_parser_ = &valueIdentifier;
    this->valueMoney_parser_ = &valueMoney;
    this->valuePeriod_parser_ = &valuePeriod;
    this->valueQuantity_parser_ = &valueQuantity;
    this->valueRange_parser_ = &valueRange;
    this->valueRatio_parser_ = &valueRatio;
    this->valueReference_parser_ = &valueReference;
    this->valueSampledData_parser_ = &valueSampledData;
    this->valueSignature_parser_ = &valueSignature;
    this->valueTiming_parser_ = &valueTiming;
    this->valueContactDetail_parser_ = &valueContactDetail;
    this->valueContributor_parser_ = &valueContributor;
    this->valueDataRequirement_parser_ = &valueDataRequirement;
    this->valueExpression_parser_ = &valueExpression;
    this->valueParameterDefinition_parser_ = &valueParameterDefinition;
    this->valueRelatedArtifact_parser_ = &valueRelatedArtifact;
    this->valueTriggerDefinition_parser_ = &valueTriggerDefinition;
    this->valueUsageContext_parser_ = &valueUsageContext;
    this->valueDosage_parser_ = &valueDosage;
    this->valueMeta_parser_ = &valueMeta;
  }

  ElementDefinition_Example_pskel::
  ElementDefinition_Example_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Example_impl_ (0),
    label_parser_ (0),
    valueBase64Binary_parser_ (0),
    valueBoolean_parser_ (0),
    valueCanonical_parser_ (0),
    valueCode_parser_ (0),
    valueDate_parser_ (0),
    valueDateTime_parser_ (0),
    valueDecimal_parser_ (0),
    valueId_parser_ (0),
    valueInstant_parser_ (0),
    valueInteger_parser_ (0),
    valueMarkdown_parser_ (0),
    valueOid_parser_ (0),
    valuePositiveInt_parser_ (0),
    valueString_parser_ (0),
    valueTime_parser_ (0),
    valueUnsignedInt_parser_ (0),
    valueUri_parser_ (0),
    valueUrl_parser_ (0),
    valueUuid_parser_ (0),
    valueAddress_parser_ (0),
    valueAge_parser_ (0),
    valueAnnotation_parser_ (0),
    valueAttachment_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueCoding_parser_ (0),
    valueContactPoint_parser_ (0),
    valueCount_parser_ (0),
    valueDistance_parser_ (0),
    valueDuration_parser_ (0),
    valueHumanName_parser_ (0),
    valueIdentifier_parser_ (0),
    valueMoney_parser_ (0),
    valuePeriod_parser_ (0),
    valueQuantity_parser_ (0),
    valueRange_parser_ (0),
    valueRatio_parser_ (0),
    valueReference_parser_ (0),
    valueSampledData_parser_ (0),
    valueSignature_parser_ (0),
    valueTiming_parser_ (0),
    valueContactDetail_parser_ (0),
    valueContributor_parser_ (0),
    valueDataRequirement_parser_ (0),
    valueExpression_parser_ (0),
    valueParameterDefinition_parser_ (0),
    valueRelatedArtifact_parser_ (0),
    valueTriggerDefinition_parser_ (0),
    valueUsageContext_parser_ (0),
    valueDosage_parser_ (0),
    valueMeta_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Example_pskel::
  ElementDefinition_Example_pskel (ElementDefinition_Example_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Example_impl_ (impl),
    label_parser_ (0),
    valueBase64Binary_parser_ (0),
    valueBoolean_parser_ (0),
    valueCanonical_parser_ (0),
    valueCode_parser_ (0),
    valueDate_parser_ (0),
    valueDateTime_parser_ (0),
    valueDecimal_parser_ (0),
    valueId_parser_ (0),
    valueInstant_parser_ (0),
    valueInteger_parser_ (0),
    valueMarkdown_parser_ (0),
    valueOid_parser_ (0),
    valuePositiveInt_parser_ (0),
    valueString_parser_ (0),
    valueTime_parser_ (0),
    valueUnsignedInt_parser_ (0),
    valueUri_parser_ (0),
    valueUrl_parser_ (0),
    valueUuid_parser_ (0),
    valueAddress_parser_ (0),
    valueAge_parser_ (0),
    valueAnnotation_parser_ (0),
    valueAttachment_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueCoding_parser_ (0),
    valueContactPoint_parser_ (0),
    valueCount_parser_ (0),
    valueDistance_parser_ (0),
    valueDuration_parser_ (0),
    valueHumanName_parser_ (0),
    valueIdentifier_parser_ (0),
    valueMoney_parser_ (0),
    valuePeriod_parser_ (0),
    valueQuantity_parser_ (0),
    valueRange_parser_ (0),
    valueRatio_parser_ (0),
    valueReference_parser_ (0),
    valueSampledData_parser_ (0),
    valueSignature_parser_ (0),
    valueTiming_parser_ (0),
    valueContactDetail_parser_ (0),
    valueContributor_parser_ (0),
    valueDataRequirement_parser_ (0),
    valueExpression_parser_ (0),
    valueParameterDefinition_parser_ (0),
    valueRelatedArtifact_parser_ (0),
    valueTriggerDefinition_parser_ (0),
    valueUsageContext_parser_ (0),
    valueDosage_parser_ (0),
    valueMeta_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Slicing_pskel
  //

  void ElementDefinition_Slicing_pskel::
  discriminator_parser (::fhir::ElementDefinition_Discriminator_pskel& p)
  {
    this->discriminator_parser_ = &p;
  }

  void ElementDefinition_Slicing_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void ElementDefinition_Slicing_pskel::
  ordered_parser (::fhir::boolean_pskel& p)
  {
    this->ordered_parser_ = &p;
  }

  void ElementDefinition_Slicing_pskel::
  rules_parser (::fhir::SlicingRules_pskel& p)
  {
    this->rules_parser_ = &p;
  }

  void ElementDefinition_Slicing_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::ElementDefinition_Discriminator_pskel& discriminator,
           ::fhir::string_pskel& description,
           ::fhir::boolean_pskel& ordered,
           ::fhir::SlicingRules_pskel& rules)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->discriminator_parser_ = &discriminator;
    this->description_parser_ = &description;
    this->ordered_parser_ = &ordered;
    this->rules_parser_ = &rules;
  }

  ElementDefinition_Slicing_pskel::
  ElementDefinition_Slicing_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Slicing_impl_ (0),
    discriminator_parser_ (0),
    description_parser_ (0),
    ordered_parser_ (0),
    rules_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Slicing_pskel::
  ElementDefinition_Slicing_pskel (ElementDefinition_Slicing_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Slicing_impl_ (impl),
    discriminator_parser_ (0),
    description_parser_ (0),
    ordered_parser_ (0),
    rules_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Binding_pskel
  //

  void ElementDefinition_Binding_pskel::
  strength_parser (::fhir::BindingStrength_pskel& p)
  {
    this->strength_parser_ = &p;
  }

  void ElementDefinition_Binding_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void ElementDefinition_Binding_pskel::
  valueSet_parser (::fhir::canonical_pskel& p)
  {
    this->valueSet_parser_ = &p;
  }

  void ElementDefinition_Binding_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::BindingStrength_pskel& strength,
           ::fhir::string_pskel& description,
           ::fhir::canonical_pskel& valueSet)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->strength_parser_ = &strength;
    this->description_parser_ = &description;
    this->valueSet_parser_ = &valueSet;
  }

  ElementDefinition_Binding_pskel::
  ElementDefinition_Binding_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Binding_impl_ (0),
    strength_parser_ (0),
    description_parser_ (0),
    valueSet_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Binding_pskel::
  ElementDefinition_Binding_pskel (ElementDefinition_Binding_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Binding_impl_ (impl),
    strength_parser_ (0),
    description_parser_ (0),
    valueSet_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // ElementDefinition_Discriminator_pskel
  //

  void ElementDefinition_Discriminator_pskel::
  type_parser (::fhir::DiscriminatorType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void ElementDefinition_Discriminator_pskel::
  path_parser (::fhir::string_pskel& p)
  {
    this->path_parser_ = &p;
  }

  void ElementDefinition_Discriminator_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::DiscriminatorType_pskel& type,
           ::fhir::string_pskel& path)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->path_parser_ = &path;
  }

  ElementDefinition_Discriminator_pskel::
  ElementDefinition_Discriminator_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    ElementDefinition_Discriminator_impl_ (0),
    type_parser_ (0),
    path_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  ElementDefinition_Discriminator_pskel::
  ElementDefinition_Discriminator_pskel (ElementDefinition_Discriminator_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    ElementDefinition_Discriminator_impl_ (impl),
    type_parser_ (0),
    path_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // PropertyRepresentation_list_pskel
  //

  PropertyRepresentation_list_pskel::
  PropertyRepresentation_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    PropertyRepresentation_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_PropertyRepresentation_list_pskel_enums_, 5UL);
  }

  PropertyRepresentation_list_pskel::
  PropertyRepresentation_list_pskel (PropertyRepresentation_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    PropertyRepresentation_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_PropertyRepresentation_list_pskel_enums_, 5UL);
  }

  // PropertyRepresentation_pskel
  //

  void PropertyRepresentation_pskel::
  value_parser (::fhir::PropertyRepresentation_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void PropertyRepresentation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::PropertyRepresentation_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  PropertyRepresentation_pskel::
  PropertyRepresentation_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    PropertyRepresentation_impl_ (0),
    value_parser_ (0)
  {
  }

  PropertyRepresentation_pskel::
  PropertyRepresentation_pskel (PropertyRepresentation_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    PropertyRepresentation_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ConstraintSeverity_list_pskel
  //

  ConstraintSeverity_list_pskel::
  ConstraintSeverity_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ConstraintSeverity_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ConstraintSeverity_list_pskel_enums_, 2UL);
  }

  ConstraintSeverity_list_pskel::
  ConstraintSeverity_list_pskel (ConstraintSeverity_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ConstraintSeverity_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ConstraintSeverity_list_pskel_enums_, 2UL);
  }

  // ConstraintSeverity_pskel
  //

  void ConstraintSeverity_pskel::
  value_parser (::fhir::ConstraintSeverity_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ConstraintSeverity_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ConstraintSeverity_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ConstraintSeverity_pskel::
  ConstraintSeverity_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ConstraintSeverity_impl_ (0),
    value_parser_ (0)
  {
  }

  ConstraintSeverity_pskel::
  ConstraintSeverity_pskel (ConstraintSeverity_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ConstraintSeverity_impl_ (impl),
    value_parser_ (0)
  {
  }

  // AggregationMode_list_pskel
  //

  AggregationMode_list_pskel::
  AggregationMode_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AggregationMode_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AggregationMode_list_pskel_enums_, 3UL);
  }

  AggregationMode_list_pskel::
  AggregationMode_list_pskel (AggregationMode_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AggregationMode_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AggregationMode_list_pskel_enums_, 3UL);
  }

  // AggregationMode_pskel
  //

  void AggregationMode_pskel::
  value_parser (::fhir::AggregationMode_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AggregationMode_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AggregationMode_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AggregationMode_pskel::
  AggregationMode_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AggregationMode_impl_ (0),
    value_parser_ (0)
  {
  }

  AggregationMode_pskel::
  AggregationMode_pskel (AggregationMode_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AggregationMode_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ReferenceVersionRules_list_pskel
  //

  ReferenceVersionRules_list_pskel::
  ReferenceVersionRules_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ReferenceVersionRules_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ReferenceVersionRules_list_pskel_enums_, 3UL);
  }

  ReferenceVersionRules_list_pskel::
  ReferenceVersionRules_list_pskel (ReferenceVersionRules_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ReferenceVersionRules_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ReferenceVersionRules_list_pskel_enums_, 3UL);
  }

  // ReferenceVersionRules_pskel
  //

  void ReferenceVersionRules_pskel::
  value_parser (::fhir::ReferenceVersionRules_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ReferenceVersionRules_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ReferenceVersionRules_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ReferenceVersionRules_pskel::
  ReferenceVersionRules_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ReferenceVersionRules_impl_ (0),
    value_parser_ (0)
  {
  }

  ReferenceVersionRules_pskel::
  ReferenceVersionRules_pskel (ReferenceVersionRules_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ReferenceVersionRules_impl_ (impl),
    value_parser_ (0)
  {
  }

  // SlicingRules_list_pskel
  //

  SlicingRules_list_pskel::
  SlicingRules_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    SlicingRules_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_SlicingRules_list_pskel_enums_, 3UL);
  }

  SlicingRules_list_pskel::
  SlicingRules_list_pskel (SlicingRules_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    SlicingRules_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_SlicingRules_list_pskel_enums_, 3UL);
  }

  // SlicingRules_pskel
  //

  void SlicingRules_pskel::
  value_parser (::fhir::SlicingRules_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void SlicingRules_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::SlicingRules_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  SlicingRules_pskel::
  SlicingRules_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SlicingRules_impl_ (0),
    value_parser_ (0)
  {
  }

  SlicingRules_pskel::
  SlicingRules_pskel (SlicingRules_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SlicingRules_impl_ (impl),
    value_parser_ (0)
  {
  }

  // BindingStrength_list_pskel
  //

  BindingStrength_list_pskel::
  BindingStrength_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    BindingStrength_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_BindingStrength_list_pskel_enums_, 4UL);
  }

  BindingStrength_list_pskel::
  BindingStrength_list_pskel (BindingStrength_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    BindingStrength_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_BindingStrength_list_pskel_enums_, 4UL);
  }

  // BindingStrength_pskel
  //

  void BindingStrength_pskel::
  value_parser (::fhir::BindingStrength_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void BindingStrength_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::BindingStrength_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  BindingStrength_pskel::
  BindingStrength_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    BindingStrength_impl_ (0),
    value_parser_ (0)
  {
  }

  BindingStrength_pskel::
  BindingStrength_pskel (BindingStrength_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    BindingStrength_impl_ (impl),
    value_parser_ (0)
  {
  }

  // DiscriminatorType_list_pskel
  //

  DiscriminatorType_list_pskel::
  DiscriminatorType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    DiscriminatorType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_DiscriminatorType_list_pskel_enums_, 5UL);
  }

  DiscriminatorType_list_pskel::
  DiscriminatorType_list_pskel (DiscriminatorType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    DiscriminatorType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_DiscriminatorType_list_pskel_enums_, 5UL);
  }

  // DiscriminatorType_pskel
  //

  void DiscriminatorType_pskel::
  value_parser (::fhir::DiscriminatorType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void DiscriminatorType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::DiscriminatorType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  DiscriminatorType_pskel::
  DiscriminatorType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DiscriminatorType_impl_ (0),
    value_parser_ (0)
  {
  }

  DiscriminatorType_pskel::
  DiscriminatorType_pskel (DiscriminatorType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DiscriminatorType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // Resource_pskel
  //

  void Resource_pskel::
  id_parser (::fhir::id_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void Resource_pskel::
  meta_parser (::fhir::Meta_pskel& p)
  {
    this->meta_parser_ = &p;
  }

  void Resource_pskel::
  implicitRules_parser (::fhir::uri_pskel& p)
  {
    this->implicitRules_parser_ = &p;
  }

  void Resource_pskel::
  language_parser (::fhir::code_pskel& p)
  {
    this->language_parser_ = &p;
  }

  void Resource_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
  }

  Resource_pskel::
  Resource_pskel ()
  : Resource_impl_ (0),
    id_parser_ (0),
    meta_parser_ (0),
    implicitRules_parser_ (0),
    language_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  Resource_pskel::
  Resource_pskel (Resource_pskel* impl, void*)
  : ::xsde::cxx::parser::validating::complex_content (impl, 0),
    Resource_impl_ (impl),
    id_parser_ (0),
    meta_parser_ (0),
    implicitRules_parser_ (0),
    language_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // DomainResource_pskel
  //

  void DomainResource_pskel::
  text_parser (::fhir::Narrative_pskel& p)
  {
    this->text_parser_ = &p;
  }

  void DomainResource_pskel::
  contained_parser (::fhir::ResourceContainer_pskel& p)
  {
    this->contained_parser_ = &p;
  }

  void DomainResource_pskel::
  extension_parser (::fhir::Extension_pskel& p)
  {
    this->extension_parser_ = &p;
  }

  void DomainResource_pskel::
  modifierExtension_parser (::fhir::Extension_pskel& p)
  {
    this->modifierExtension_parser_ = &p;
  }

  void DomainResource_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
  }

  DomainResource_pskel::
  DomainResource_pskel (::fhir::Resource_pskel* tiein)
  : ::fhir::Resource_pskel (tiein, 0),
    DomainResource_impl_ (0),
    text_parser_ (0),
    contained_parser_ (0),
    extension_parser_ (0),
    modifierExtension_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  DomainResource_pskel::
  DomainResource_pskel (DomainResource_pskel* impl, void*)
  : ::fhir::Resource_pskel (impl, 0),
    DomainResource_impl_ (impl),
    text_parser_ (0),
    contained_parser_ (0),
    extension_parser_ (0),
    modifierExtension_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // PublicationStatus_list_pskel
  //

  PublicationStatus_list_pskel::
  PublicationStatus_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    PublicationStatus_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_PublicationStatus_list_pskel_enums_, 4UL);
  }

  PublicationStatus_list_pskel::
  PublicationStatus_list_pskel (PublicationStatus_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    PublicationStatus_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_PublicationStatus_list_pskel_enums_, 4UL);
  }

  // PublicationStatus_pskel
  //

  void PublicationStatus_pskel::
  value_parser (::fhir::PublicationStatus_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void PublicationStatus_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::PublicationStatus_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  PublicationStatus_pskel::
  PublicationStatus_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    PublicationStatus_impl_ (0),
    value_parser_ (0)
  {
  }

  PublicationStatus_pskel::
  PublicationStatus_pskel (PublicationStatus_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    PublicationStatus_impl_ (impl),
    value_parser_ (0)
  {
  }

  // SearchParamType_list_pskel
  //

  SearchParamType_list_pskel::
  SearchParamType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    SearchParamType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_SearchParamType_list_pskel_enums_, 9UL);
  }

  SearchParamType_list_pskel::
  SearchParamType_list_pskel (SearchParamType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    SearchParamType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_SearchParamType_list_pskel_enums_, 9UL);
  }

  // SearchParamType_pskel
  //

  void SearchParamType_pskel::
  value_parser (::fhir::SearchParamType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void SearchParamType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::SearchParamType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  SearchParamType_pskel::
  SearchParamType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SearchParamType_impl_ (0),
    value_parser_ (0)
  {
  }

  SearchParamType_pskel::
  SearchParamType_pskel (SearchParamType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SearchParamType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // AdministrativeGender_list_pskel
  //

  AdministrativeGender_list_pskel::
  AdministrativeGender_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    AdministrativeGender_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_AdministrativeGender_list_pskel_enums_, 4UL);
  }

  AdministrativeGender_list_pskel::
  AdministrativeGender_list_pskel (AdministrativeGender_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    AdministrativeGender_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_AdministrativeGender_list_pskel_enums_, 4UL);
  }

  // AdministrativeGender_pskel
  //

  void AdministrativeGender_pskel::
  value_parser (::fhir::AdministrativeGender_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void AdministrativeGender_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::AdministrativeGender_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  AdministrativeGender_pskel::
  AdministrativeGender_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    AdministrativeGender_impl_ (0),
    value_parser_ (0)
  {
  }

  AdministrativeGender_pskel::
  AdministrativeGender_pskel (AdministrativeGender_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    AdministrativeGender_impl_ (impl),
    value_parser_ (0)
  {
  }

  // FHIRVersion_list_pskel
  //

  FHIRVersion_list_pskel::
  FHIRVersion_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    FHIRVersion_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_FHIRVersion_list_pskel_enums_, 22UL);
  }

  FHIRVersion_list_pskel::
  FHIRVersion_list_pskel (FHIRVersion_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    FHIRVersion_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_FHIRVersion_list_pskel_enums_, 22UL);
  }

  // FHIRVersion_pskel
  //

  void FHIRVersion_pskel::
  value_parser (::fhir::FHIRVersion_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void FHIRVersion_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::FHIRVersion_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  FHIRVersion_pskel::
  FHIRVersion_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    FHIRVersion_impl_ (0),
    value_parser_ (0)
  {
  }

  FHIRVersion_pskel::
  FHIRVersion_pskel (FHIRVersion_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    FHIRVersion_impl_ (impl),
    value_parser_ (0)
  {
  }

  // NoteType_list_pskel
  //

  NoteType_list_pskel::
  NoteType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    NoteType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_NoteType_list_pskel_enums_, 3UL);
  }

  NoteType_list_pskel::
  NoteType_list_pskel (NoteType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    NoteType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_NoteType_list_pskel_enums_, 3UL);
  }

  // NoteType_pskel
  //

  void NoteType_pskel::
  value_parser (::fhir::NoteType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void NoteType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::NoteType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  NoteType_pskel::
  NoteType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    NoteType_impl_ (0),
    value_parser_ (0)
  {
  }

  NoteType_pskel::
  NoteType_pskel (NoteType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    NoteType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // RemittanceOutcome_list_pskel
  //

  RemittanceOutcome_list_pskel::
  RemittanceOutcome_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    RemittanceOutcome_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_RemittanceOutcome_list_pskel_enums_, 4UL);
  }

  RemittanceOutcome_list_pskel::
  RemittanceOutcome_list_pskel (RemittanceOutcome_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    RemittanceOutcome_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_RemittanceOutcome_list_pskel_enums_, 4UL);
  }

  // RemittanceOutcome_pskel
  //

  void RemittanceOutcome_pskel::
  value_parser (::fhir::RemittanceOutcome_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void RemittanceOutcome_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::RemittanceOutcome_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  RemittanceOutcome_pskel::
  RemittanceOutcome_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    RemittanceOutcome_impl_ (0),
    value_parser_ (0)
  {
  }

  RemittanceOutcome_pskel::
  RemittanceOutcome_pskel (RemittanceOutcome_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    RemittanceOutcome_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ConceptMapEquivalence_list_pskel
  //

  ConceptMapEquivalence_list_pskel::
  ConceptMapEquivalence_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ConceptMapEquivalence_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ConceptMapEquivalence_list_pskel_enums_, 10UL);
  }

  ConceptMapEquivalence_list_pskel::
  ConceptMapEquivalence_list_pskel (ConceptMapEquivalence_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ConceptMapEquivalence_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ConceptMapEquivalence_list_pskel_enums_, 10UL);
  }

  // ConceptMapEquivalence_pskel
  //

  void ConceptMapEquivalence_pskel::
  value_parser (::fhir::ConceptMapEquivalence_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ConceptMapEquivalence_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ConceptMapEquivalence_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ConceptMapEquivalence_pskel::
  ConceptMapEquivalence_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ConceptMapEquivalence_impl_ (0),
    value_parser_ (0)
  {
  }

  ConceptMapEquivalence_pskel::
  ConceptMapEquivalence_pskel (ConceptMapEquivalence_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ConceptMapEquivalence_impl_ (impl),
    value_parser_ (0)
  {
  }

  // DocumentReferenceStatus_list_pskel
  //

  DocumentReferenceStatus_list_pskel::
  DocumentReferenceStatus_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    DocumentReferenceStatus_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_DocumentReferenceStatus_list_pskel_enums_, 3UL);
  }

  DocumentReferenceStatus_list_pskel::
  DocumentReferenceStatus_list_pskel (DocumentReferenceStatus_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    DocumentReferenceStatus_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_DocumentReferenceStatus_list_pskel_enums_, 3UL);
  }

  // DocumentReferenceStatus_pskel
  //

  void DocumentReferenceStatus_pskel::
  value_parser (::fhir::DocumentReferenceStatus_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void DocumentReferenceStatus_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::DocumentReferenceStatus_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  DocumentReferenceStatus_pskel::
  DocumentReferenceStatus_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DocumentReferenceStatus_impl_ (0),
    value_parser_ (0)
  {
  }

  DocumentReferenceStatus_pskel::
  DocumentReferenceStatus_pskel (DocumentReferenceStatus_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DocumentReferenceStatus_impl_ (impl),
    value_parser_ (0)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // date_primitive_base_pskel
  //

  void date_primitive_base_pskel::
  post_date_primitive_base ()
  {
    if (this->date_primitive_base_impl_)
      this->date_primitive_base_impl_->post_date_primitive_base ();
  }

  // date_primitive_pskel
  //

  void date_primitive_pskel::
  post_date_primitive ()
  {
    if (this->date_primitive_impl_)
      this->date_primitive_impl_->post_date_primitive ();
    else
      post_date_primitive_base ();
  }

  // Element_pskel
  //

  void Element_pskel::
  id ()
  {
    if (this->Element_impl_)
      this->Element_impl_->id ();
  }

  void Element_pskel::
  extension ()
  {
    if (this->Element_impl_)
      this->Element_impl_->extension ();
  }

  void Element_pskel::
  post_Element ()
  {
    if (this->Element_impl_)
      this->Element_impl_->post_Element ();
  }

  void Element_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    if (this->id_parser_)
      this->id_parser_->_reset ();

    this->resetting_ = true;

    if (this->extension_parser_)
      this->extension_parser_->_reset ();

    this->resetting_ = false;
  }

  // date_pskel
  //

  void date_pskel::
  value ()
  {
    if (this->date_impl_)
      this->date_impl_->value ();
  }

  void date_pskel::
  post_date ()
  {
    if (this->date_impl_)
      this->date_impl_->post_date ();
    else
      post_Element ();
  }

  void date_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // dateTime_primitive_base_pskel
  //

  void dateTime_primitive_base_pskel::
  post_dateTime_primitive_base ()
  {
    if (this->dateTime_primitive_base_impl_)
      this->dateTime_primitive_base_impl_->post_dateTime_primitive_base ();
  }

  // dateTime_primitive_pskel
  //

  void dateTime_primitive_pskel::
  post_dateTime_primitive ()
  {
    if (this->dateTime_primitive_impl_)
      this->dateTime_primitive_impl_->post_dateTime_primitive ();
    else
      post_dateTime_primitive_base ();
  }

  // dateTime_pskel
  //

  void dateTime_pskel::
  value ()
  {
    if (this->dateTime_impl_)
      this->dateTime_impl_->value ();
  }

  void dateTime_pskel::
  post_dateTime ()
  {
    if (this->dateTime_impl_)
      this->dateTime_impl_->post_dateTime ();
    else
      post_Element ();
  }

  void dateTime_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // code_primitive_pskel
  //

  void code_primitive_pskel::
  post_code_primitive ()
  {
    if (this->code_primitive_impl_)
      this->code_primitive_impl_->post_code_primitive ();
  }

  ::std::string code_primitive_pskel::
  post_token ()
  {
    assert (this->token_impl_);
    return this->token_impl_->post_token ();
  }

  // code_pskel
  //

  void code_pskel::
  value ()
  {
    if (this->code_impl_)
      this->code_impl_->value ();
  }

  void code_pskel::
  post_code ()
  {
    if (this->code_impl_)
      this->code_impl_->post_code ();
    else
      post_Element ();
  }

  void code_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // string_primitive_pskel
  //

  void string_primitive_pskel::
  post_string_primitive ()
  {
    if (this->string_primitive_impl_)
      this->string_primitive_impl_->post_string_primitive ();
  }

  ::std::string string_primitive_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // string_pskel
  //

  void string_pskel::
  value ()
  {
    if (this->string_impl_)
      this->string_impl_->value ();
  }

  void string_pskel::
  post_string ()
  {
    if (this->string_impl_)
      this->string_impl_->post_string ();
    else
      post_Element ();
  }

  void string_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // integer_primitive_pskel
  //

  void integer_primitive_pskel::
  post_integer_primitive ()
  {
    if (this->integer_primitive_impl_)
      this->integer_primitive_impl_->post_integer_primitive ();
  }

  int integer_primitive_pskel::
  post_int ()
  {
    assert (this->int_impl_);
    return this->int_impl_->post_int ();
  }

  // integer_pskel
  //

  void integer_pskel::
  value ()
  {
    if (this->integer_impl_)
      this->integer_impl_->value ();
  }

  void integer_pskel::
  post_integer ()
  {
    if (this->integer_impl_)
      this->integer_impl_->post_integer ();
    else
      post_Element ();
  }

  void integer_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // oid_primitive_pskel
  //

  void oid_primitive_pskel::
  post_oid_primitive ()
  {
    if (this->oid_primitive_impl_)
      this->oid_primitive_impl_->post_oid_primitive ();
  }

  ::std::string oid_primitive_pskel::
  post_uri ()
  {
    assert (this->uri_impl_);
    return this->uri_impl_->post_uri ();
  }

  // oid_pskel
  //

  void oid_pskel::
  value ()
  {
    if (this->oid_impl_)
      this->oid_impl_->value ();
  }

  void oid_pskel::
  post_oid ()
  {
    if (this->oid_impl_)
      this->oid_impl_->post_oid ();
    else
      post_Element ();
  }

  void oid_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // canonical_primitive_pskel
  //

  void canonical_primitive_pskel::
  post_canonical_primitive ()
  {
    if (this->canonical_primitive_impl_)
      this->canonical_primitive_impl_->post_canonical_primitive ();
  }

  ::std::string canonical_primitive_pskel::
  post_uri ()
  {
    assert (this->uri_impl_);
    return this->uri_impl_->post_uri ();
  }

  // canonical_pskel
  //

  void canonical_pskel::
  value ()
  {
    if (this->canonical_impl_)
      this->canonical_impl_->value ();
  }

  void canonical_pskel::
  post_canonical ()
  {
    if (this->canonical_impl_)
      this->canonical_impl_->post_canonical ();
    else
      post_Element ();
  }

  void canonical_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // uri_primitive_pskel
  //

  void uri_primitive_pskel::
  post_uri_primitive ()
  {
    if (this->uri_primitive_impl_)
      this->uri_primitive_impl_->post_uri_primitive ();
  }

  ::std::string uri_primitive_pskel::
  post_uri ()
  {
    assert (this->uri_impl_);
    return this->uri_impl_->post_uri ();
  }

  // uri_pskel
  //

  void uri_pskel::
  value ()
  {
    if (this->uri_impl_)
      this->uri_impl_->value ();
  }

  void uri_pskel::
  post_uri ()
  {
    if (this->uri_impl_)
      this->uri_impl_->post_uri ();
    else
      post_Element ();
  }

  void uri_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // uuid_primitive_pskel
  //

  void uuid_primitive_pskel::
  post_uuid_primitive ()
  {
    if (this->uuid_primitive_impl_)
      this->uuid_primitive_impl_->post_uuid_primitive ();
  }

  ::std::string uuid_primitive_pskel::
  post_uri ()
  {
    assert (this->uri_impl_);
    return this->uri_impl_->post_uri ();
  }

  // uuid_pskel
  //

  void uuid_pskel::
  value ()
  {
    if (this->uuid_impl_)
      this->uuid_impl_->value ();
  }

  void uuid_pskel::
  post_uuid ()
  {
    if (this->uuid_impl_)
      this->uuid_impl_->post_uuid ();
    else
      post_Element ();
  }

  void uuid_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // url_primitive_pskel
  //

  void url_primitive_pskel::
  post_url_primitive ()
  {
    if (this->url_primitive_impl_)
      this->url_primitive_impl_->post_url_primitive ();
  }

  ::std::string url_primitive_pskel::
  post_uri ()
  {
    assert (this->uri_impl_);
    return this->uri_impl_->post_uri ();
  }

  // url_pskel
  //

  void url_pskel::
  value ()
  {
    if (this->url_impl_)
      this->url_impl_->value ();
  }

  void url_pskel::
  post_url ()
  {
    if (this->url_impl_)
      this->url_impl_->post_url ();
    else
      post_Element ();
  }

  void url_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // instant_primitive_pskel
  //

  void instant_primitive_pskel::
  post_instant_primitive ()
  {
    if (this->instant_primitive_impl_)
      this->instant_primitive_impl_->post_instant_primitive ();
  }

  ::xml_schema::date_time instant_primitive_pskel::
  post_date_time ()
  {
    assert (this->date_time_impl_);
    return this->date_time_impl_->post_date_time ();
  }

  // instant_pskel
  //

  void instant_pskel::
  value ()
  {
    if (this->instant_impl_)
      this->instant_impl_->value ();
  }

  void instant_pskel::
  post_instant ()
  {
    if (this->instant_impl_)
      this->instant_impl_->post_instant ();
    else
      post_Element ();
  }

  void instant_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // boolean_primitive_pskel
  //

  void boolean_primitive_pskel::
  post_boolean_primitive ()
  {
    if (this->boolean_primitive_impl_)
      this->boolean_primitive_impl_->post_boolean_primitive ();
  }

  bool boolean_primitive_pskel::
  post_boolean ()
  {
    assert (this->boolean_impl_);
    return this->boolean_impl_->post_boolean ();
  }

  // boolean_pskel
  //

  void boolean_pskel::
  value ()
  {
    if (this->boolean_impl_)
      this->boolean_impl_->value ();
  }

  void boolean_pskel::
  post_boolean ()
  {
    if (this->boolean_impl_)
      this->boolean_impl_->post_boolean ();
    else
      post_Element ();
  }

  void boolean_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // base64Binary_primitive_pskel
  //

  void base64Binary_primitive_pskel::
  post_base64Binary_primitive ()
  {
    if (this->base64Binary_primitive_impl_)
      this->base64Binary_primitive_impl_->post_base64Binary_primitive ();
  }

  ::xml_schema::buffer* base64Binary_primitive_pskel::
  post_base64_binary ()
  {
    assert (this->base64_binary_impl_);
    return this->base64_binary_impl_->post_base64_binary ();
  }

  // base64Binary_pskel
  //

  void base64Binary_pskel::
  value ()
  {
    if (this->base64Binary_impl_)
      this->base64Binary_impl_->value ();
  }

  void base64Binary_pskel::
  post_base64Binary ()
  {
    if (this->base64Binary_impl_)
      this->base64Binary_impl_->post_base64Binary ();
    else
      post_Element ();
  }

  void base64Binary_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // unsignedInt_primitive_pskel
  //

  void unsignedInt_primitive_pskel::
  post_unsignedInt_primitive ()
  {
    if (this->unsignedInt_primitive_impl_)
      this->unsignedInt_primitive_impl_->post_unsignedInt_primitive ();
  }

  unsigned long unsignedInt_primitive_pskel::
  post_non_negative_integer ()
  {
    assert (this->non_negative_integer_impl_);
    return this->non_negative_integer_impl_->post_non_negative_integer ();
  }

  // unsignedInt_pskel
  //

  void unsignedInt_pskel::
  value ()
  {
    if (this->unsignedInt_impl_)
      this->unsignedInt_impl_->value ();
  }

  void unsignedInt_pskel::
  post_unsignedInt ()
  {
    if (this->unsignedInt_impl_)
      this->unsignedInt_impl_->post_unsignedInt ();
    else
      post_Element ();
  }

  void unsignedInt_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // markdown_primitive_pskel
  //

  void markdown_primitive_pskel::
  post_markdown_primitive ()
  {
    if (this->markdown_primitive_impl_)
      this->markdown_primitive_impl_->post_markdown_primitive ();
  }

  ::std::string markdown_primitive_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // markdown_pskel
  //

  void markdown_pskel::
  value ()
  {
    if (this->markdown_impl_)
      this->markdown_impl_->value ();
  }

  void markdown_pskel::
  post_markdown ()
  {
    if (this->markdown_impl_)
      this->markdown_impl_->post_markdown ();
    else
      post_Element ();
  }

  void markdown_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // time_primitive_pskel
  //

  void time_primitive_pskel::
  post_time_primitive ()
  {
    if (this->time_primitive_impl_)
      this->time_primitive_impl_->post_time_primitive ();
  }

  ::xml_schema::time time_primitive_pskel::
  post_time ()
  {
    assert (this->time_impl_);
    return this->time_impl_->post_time ();
  }

  // time_pskel
  //

  void time_pskel::
  value ()
  {
    if (this->time_impl_)
      this->time_impl_->value ();
  }

  void time_pskel::
  post_time ()
  {
    if (this->time_impl_)
      this->time_impl_->post_time ();
    else
      post_Element ();
  }

  void time_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // id_primitive_pskel
  //

  void id_primitive_pskel::
  post_id_primitive ()
  {
    if (this->id_primitive_impl_)
      this->id_primitive_impl_->post_id_primitive ();
  }

  ::std::string id_primitive_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // id_pskel
  //

  void id_pskel::
  value ()
  {
    if (this->id_impl_)
      this->id_impl_->value ();
  }

  void id_pskel::
  post_id ()
  {
    if (this->id_impl_)
      this->id_impl_->post_id ();
    else
      post_Element ();
  }

  void id_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // positiveInt_primitive_pskel
  //

  void positiveInt_primitive_pskel::
  post_positiveInt_primitive ()
  {
    if (this->positiveInt_primitive_impl_)
      this->positiveInt_primitive_impl_->post_positiveInt_primitive ();
  }

  unsigned long positiveInt_primitive_pskel::
  post_positive_integer ()
  {
    assert (this->positive_integer_impl_);
    return this->positive_integer_impl_->post_positive_integer ();
  }

  // positiveInt_pskel
  //

  void positiveInt_pskel::
  value ()
  {
    if (this->positiveInt_impl_)
      this->positiveInt_impl_->value ();
  }

  void positiveInt_pskel::
  post_positiveInt ()
  {
    if (this->positiveInt_impl_)
      this->positiveInt_impl_->post_positiveInt ();
    else
      post_Element ();
  }

  void positiveInt_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // decimal_primitive_pskel
  //

  void decimal_primitive_pskel::
  post_decimal_primitive ()
  {
    if (this->decimal_primitive_impl_)
      this->decimal_primitive_impl_->post_decimal_primitive ();
  }

  // decimal_pskel
  //

  void decimal_pskel::
  value ()
  {
    if (this->decimal_impl_)
      this->decimal_impl_->value ();
  }

  void decimal_pskel::
  post_decimal ()
  {
    if (this->decimal_impl_)
      this->decimal_impl_->post_decimal ();
    else
      post_Element ();
  }

  void decimal_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ResourceContainer_pskel
  //

  void ResourceContainer_pskel::
  Account ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Account ();
  }

  void ResourceContainer_pskel::
  ActivityDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ActivityDefinition ();
  }

  void ResourceContainer_pskel::
  AdverseEvent ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->AdverseEvent ();
  }

  void ResourceContainer_pskel::
  AllergyIntolerance ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->AllergyIntolerance ();
  }

  void ResourceContainer_pskel::
  Appointment ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Appointment ();
  }

  void ResourceContainer_pskel::
  AppointmentResponse ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->AppointmentResponse ();
  }

  void ResourceContainer_pskel::
  AuditEvent ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->AuditEvent ();
  }

  void ResourceContainer_pskel::
  Basic ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Basic ();
  }

  void ResourceContainer_pskel::
  Binary ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Binary ();
  }

  void ResourceContainer_pskel::
  BiologicallyDerivedProduct ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->BiologicallyDerivedProduct ();
  }

  void ResourceContainer_pskel::
  BodyStructure ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->BodyStructure ();
  }

  void ResourceContainer_pskel::
  Bundle ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Bundle ();
  }

  void ResourceContainer_pskel::
  CapabilityStatement ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CapabilityStatement ();
  }

  void ResourceContainer_pskel::
  CarePlan ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CarePlan ();
  }

  void ResourceContainer_pskel::
  CareTeam ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CareTeam ();
  }

  void ResourceContainer_pskel::
  CatalogEntry ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CatalogEntry ();
  }

  void ResourceContainer_pskel::
  ChargeItem ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ChargeItem ();
  }

  void ResourceContainer_pskel::
  ChargeItemDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ChargeItemDefinition ();
  }

  void ResourceContainer_pskel::
  Claim ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Claim ();
  }

  void ResourceContainer_pskel::
  ClaimResponse ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ClaimResponse ();
  }

  void ResourceContainer_pskel::
  ClinicalImpression ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ClinicalImpression ();
  }

  void ResourceContainer_pskel::
  CodeSystem ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CodeSystem ();
  }

  void ResourceContainer_pskel::
  Communication ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Communication ();
  }

  void ResourceContainer_pskel::
  CommunicationRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CommunicationRequest ();
  }

  void ResourceContainer_pskel::
  CompartmentDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CompartmentDefinition ();
  }

  void ResourceContainer_pskel::
  Composition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Composition ();
  }

  void ResourceContainer_pskel::
  ConceptMap ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ConceptMap ();
  }

  void ResourceContainer_pskel::
  Condition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Condition ();
  }

  void ResourceContainer_pskel::
  Consent ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Consent ();
  }

  void ResourceContainer_pskel::
  Contract ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Contract ();
  }

  void ResourceContainer_pskel::
  Coverage ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Coverage ();
  }

  void ResourceContainer_pskel::
  CoverageEligibilityRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CoverageEligibilityRequest ();
  }

  void ResourceContainer_pskel::
  CoverageEligibilityResponse ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->CoverageEligibilityResponse ();
  }

  void ResourceContainer_pskel::
  DetectedIssue ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DetectedIssue ();
  }

  void ResourceContainer_pskel::
  Device ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Device ();
  }

  void ResourceContainer_pskel::
  DeviceDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DeviceDefinition ();
  }

  void ResourceContainer_pskel::
  DeviceMetric ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DeviceMetric ();
  }

  void ResourceContainer_pskel::
  DeviceRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DeviceRequest ();
  }

  void ResourceContainer_pskel::
  DeviceUseStatement ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DeviceUseStatement ();
  }

  void ResourceContainer_pskel::
  DiagnosticReport ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DiagnosticReport ();
  }

  void ResourceContainer_pskel::
  DocumentManifest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DocumentManifest ();
  }

  void ResourceContainer_pskel::
  DocumentReference ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->DocumentReference ();
  }

  void ResourceContainer_pskel::
  EffectEvidenceSynthesis ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->EffectEvidenceSynthesis ();
  }

  void ResourceContainer_pskel::
  Encounter ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Encounter ();
  }

  void ResourceContainer_pskel::
  Endpoint ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Endpoint ();
  }

  void ResourceContainer_pskel::
  EnrollmentRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->EnrollmentRequest ();
  }

  void ResourceContainer_pskel::
  EnrollmentResponse ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->EnrollmentResponse ();
  }

  void ResourceContainer_pskel::
  EpisodeOfCare ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->EpisodeOfCare ();
  }

  void ResourceContainer_pskel::
  EventDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->EventDefinition ();
  }

  void ResourceContainer_pskel::
  Evidence ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Evidence ();
  }

  void ResourceContainer_pskel::
  EvidenceVariable ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->EvidenceVariable ();
  }

  void ResourceContainer_pskel::
  ExampleScenario ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ExampleScenario ();
  }

  void ResourceContainer_pskel::
  ExplanationOfBenefit ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ExplanationOfBenefit ();
  }

  void ResourceContainer_pskel::
  FamilyMemberHistory ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->FamilyMemberHistory ();
  }

  void ResourceContainer_pskel::
  Flag ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Flag ();
  }

  void ResourceContainer_pskel::
  Goal ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Goal ();
  }

  void ResourceContainer_pskel::
  GraphDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->GraphDefinition ();
  }

  void ResourceContainer_pskel::
  Group ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Group ();
  }

  void ResourceContainer_pskel::
  GuidanceResponse ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->GuidanceResponse ();
  }

  void ResourceContainer_pskel::
  HealthcareService ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->HealthcareService ();
  }

  void ResourceContainer_pskel::
  ImagingStudy ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ImagingStudy ();
  }

  void ResourceContainer_pskel::
  Immunization ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Immunization ();
  }

  void ResourceContainer_pskel::
  ImmunizationEvaluation ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ImmunizationEvaluation ();
  }

  void ResourceContainer_pskel::
  ImmunizationRecommendation ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ImmunizationRecommendation ();
  }

  void ResourceContainer_pskel::
  ImplementationGuide ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ImplementationGuide ();
  }

  void ResourceContainer_pskel::
  InsurancePlan ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->InsurancePlan ();
  }

  void ResourceContainer_pskel::
  Invoice ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Invoice ();
  }

  void ResourceContainer_pskel::
  Library ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Library ();
  }

  void ResourceContainer_pskel::
  Linkage ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Linkage ();
  }

  void ResourceContainer_pskel::
  List ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->List ();
  }

  void ResourceContainer_pskel::
  Location ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Location ();
  }

  void ResourceContainer_pskel::
  Measure ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Measure ();
  }

  void ResourceContainer_pskel::
  MeasureReport ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MeasureReport ();
  }

  void ResourceContainer_pskel::
  Media ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Media ();
  }

  void ResourceContainer_pskel::
  Medication ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Medication ();
  }

  void ResourceContainer_pskel::
  MedicationAdministration ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicationAdministration ();
  }

  void ResourceContainer_pskel::
  MedicationDispense ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicationDispense ();
  }

  void ResourceContainer_pskel::
  MedicationKnowledge ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicationKnowledge ();
  }

  void ResourceContainer_pskel::
  MedicationRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicationRequest ();
  }

  void ResourceContainer_pskel::
  MedicationStatement ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicationStatement ();
  }

  void ResourceContainer_pskel::
  MedicinalProduct ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProduct ();
  }

  void ResourceContainer_pskel::
  MedicinalProductAuthorization ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductAuthorization ();
  }

  void ResourceContainer_pskel::
  MedicinalProductContraindication ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductContraindication ();
  }

  void ResourceContainer_pskel::
  MedicinalProductIndication ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductIndication ();
  }

  void ResourceContainer_pskel::
  MedicinalProductIngredient ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductIngredient ();
  }

  void ResourceContainer_pskel::
  MedicinalProductInteraction ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductInteraction ();
  }

  void ResourceContainer_pskel::
  MedicinalProductManufactured ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductManufactured ();
  }

  void ResourceContainer_pskel::
  MedicinalProductPackaged ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductPackaged ();
  }

  void ResourceContainer_pskel::
  MedicinalProductPharmaceutical ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductPharmaceutical ();
  }

  void ResourceContainer_pskel::
  MedicinalProductUndesirableEffect ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MedicinalProductUndesirableEffect ();
  }

  void ResourceContainer_pskel::
  MessageDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MessageDefinition ();
  }

  void ResourceContainer_pskel::
  MessageHeader ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MessageHeader ();
  }

  void ResourceContainer_pskel::
  MolecularSequence ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->MolecularSequence ();
  }

  void ResourceContainer_pskel::
  NamingSystem ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->NamingSystem ();
  }

  void ResourceContainer_pskel::
  NutritionOrder ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->NutritionOrder ();
  }

  void ResourceContainer_pskel::
  Observation ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Observation ();
  }

  void ResourceContainer_pskel::
  ObservationDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ObservationDefinition ();
  }

  void ResourceContainer_pskel::
  OperationDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->OperationDefinition ();
  }

  void ResourceContainer_pskel::
  OperationOutcome ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->OperationOutcome ();
  }

  void ResourceContainer_pskel::
  Organization ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Organization ();
  }

  void ResourceContainer_pskel::
  OrganizationAffiliation ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->OrganizationAffiliation ();
  }

  void ResourceContainer_pskel::
  Patient ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Patient ();
  }

  void ResourceContainer_pskel::
  PaymentNotice ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->PaymentNotice ();
  }

  void ResourceContainer_pskel::
  PaymentReconciliation ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->PaymentReconciliation ();
  }

  void ResourceContainer_pskel::
  Person ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Person ();
  }

  void ResourceContainer_pskel::
  PlanDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->PlanDefinition ();
  }

  void ResourceContainer_pskel::
  Practitioner ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Practitioner ();
  }

  void ResourceContainer_pskel::
  PractitionerRole ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->PractitionerRole ();
  }

  void ResourceContainer_pskel::
  Procedure ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Procedure ();
  }

  void ResourceContainer_pskel::
  Provenance ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Provenance ();
  }

  void ResourceContainer_pskel::
  Questionnaire ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Questionnaire ();
  }

  void ResourceContainer_pskel::
  QuestionnaireResponse ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->QuestionnaireResponse ();
  }

  void ResourceContainer_pskel::
  RelatedPerson ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->RelatedPerson ();
  }

  void ResourceContainer_pskel::
  RequestGroup ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->RequestGroup ();
  }

  void ResourceContainer_pskel::
  ResearchDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ResearchDefinition ();
  }

  void ResourceContainer_pskel::
  ResearchElementDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ResearchElementDefinition ();
  }

  void ResourceContainer_pskel::
  ResearchStudy ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ResearchStudy ();
  }

  void ResourceContainer_pskel::
  ResearchSubject ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ResearchSubject ();
  }

  void ResourceContainer_pskel::
  RiskAssessment ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->RiskAssessment ();
  }

  void ResourceContainer_pskel::
  RiskEvidenceSynthesis ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->RiskEvidenceSynthesis ();
  }

  void ResourceContainer_pskel::
  Schedule ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Schedule ();
  }

  void ResourceContainer_pskel::
  SearchParameter ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SearchParameter ();
  }

  void ResourceContainer_pskel::
  ServiceRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ServiceRequest ();
  }

  void ResourceContainer_pskel::
  Slot ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Slot ();
  }

  void ResourceContainer_pskel::
  Specimen ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Specimen ();
  }

  void ResourceContainer_pskel::
  SpecimenDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SpecimenDefinition ();
  }

  void ResourceContainer_pskel::
  StructureDefinition ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->StructureDefinition ();
  }

  void ResourceContainer_pskel::
  StructureMap ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->StructureMap ();
  }

  void ResourceContainer_pskel::
  Subscription ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Subscription ();
  }

  void ResourceContainer_pskel::
  Substance ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Substance ();
  }

  void ResourceContainer_pskel::
  SubstanceNucleicAcid ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SubstanceNucleicAcid ();
  }

  void ResourceContainer_pskel::
  SubstancePolymer ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SubstancePolymer ();
  }

  void ResourceContainer_pskel::
  SubstanceProtein ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SubstanceProtein ();
  }

  void ResourceContainer_pskel::
  SubstanceReferenceInformation ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SubstanceReferenceInformation ();
  }

  void ResourceContainer_pskel::
  SubstanceSourceMaterial ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SubstanceSourceMaterial ();
  }

  void ResourceContainer_pskel::
  SubstanceSpecification ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SubstanceSpecification ();
  }

  void ResourceContainer_pskel::
  SupplyDelivery ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SupplyDelivery ();
  }

  void ResourceContainer_pskel::
  SupplyRequest ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->SupplyRequest ();
  }

  void ResourceContainer_pskel::
  Task ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Task ();
  }

  void ResourceContainer_pskel::
  TerminologyCapabilities ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->TerminologyCapabilities ();
  }

  void ResourceContainer_pskel::
  TestReport ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->TestReport ();
  }

  void ResourceContainer_pskel::
  TestScript ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->TestScript ();
  }

  void ResourceContainer_pskel::
  ValueSet ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->ValueSet ();
  }

  void ResourceContainer_pskel::
  VerificationResult ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->VerificationResult ();
  }

  void ResourceContainer_pskel::
  VisionPrescription ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->VisionPrescription ();
  }

  void ResourceContainer_pskel::
  Parameters ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->Parameters ();
  }

  void ResourceContainer_pskel::
  post_ResourceContainer ()
  {
    if (this->ResourceContainer_impl_)
      this->ResourceContainer_impl_->post_ResourceContainer ();
  }

  void ResourceContainer_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->Account_parser_)
      this->Account_parser_->_reset ();

    if (this->ActivityDefinition_parser_)
      this->ActivityDefinition_parser_->_reset ();

    if (this->AdverseEvent_parser_)
      this->AdverseEvent_parser_->_reset ();

    if (this->AllergyIntolerance_parser_)
      this->AllergyIntolerance_parser_->_reset ();

    if (this->Appointment_parser_)
      this->Appointment_parser_->_reset ();

    if (this->AppointmentResponse_parser_)
      this->AppointmentResponse_parser_->_reset ();

    if (this->AuditEvent_parser_)
      this->AuditEvent_parser_->_reset ();

    if (this->Basic_parser_)
      this->Basic_parser_->_reset ();

    if (this->Binary_parser_)
      this->Binary_parser_->_reset ();

    if (this->BiologicallyDerivedProduct_parser_)
      this->BiologicallyDerivedProduct_parser_->_reset ();

    if (this->BodyStructure_parser_)
      this->BodyStructure_parser_->_reset ();

    if (this->Bundle_parser_)
      this->Bundle_parser_->_reset ();

    if (this->CapabilityStatement_parser_)
      this->CapabilityStatement_parser_->_reset ();

    if (this->CarePlan_parser_)
      this->CarePlan_parser_->_reset ();

    if (this->CareTeam_parser_)
      this->CareTeam_parser_->_reset ();

    if (this->CatalogEntry_parser_)
      this->CatalogEntry_parser_->_reset ();

    if (this->ChargeItem_parser_)
      this->ChargeItem_parser_->_reset ();

    if (this->ChargeItemDefinition_parser_)
      this->ChargeItemDefinition_parser_->_reset ();

    if (this->Claim_parser_)
      this->Claim_parser_->_reset ();

    if (this->ClaimResponse_parser_)
      this->ClaimResponse_parser_->_reset ();

    if (this->ClinicalImpression_parser_)
      this->ClinicalImpression_parser_->_reset ();

    if (this->CodeSystem_parser_)
      this->CodeSystem_parser_->_reset ();

    if (this->Communication_parser_)
      this->Communication_parser_->_reset ();

    if (this->CommunicationRequest_parser_)
      this->CommunicationRequest_parser_->_reset ();

    if (this->CompartmentDefinition_parser_)
      this->CompartmentDefinition_parser_->_reset ();

    if (this->Composition_parser_)
      this->Composition_parser_->_reset ();

    if (this->ConceptMap_parser_)
      this->ConceptMap_parser_->_reset ();

    if (this->Condition_parser_)
      this->Condition_parser_->_reset ();

    if (this->Consent_parser_)
      this->Consent_parser_->_reset ();

    if (this->Contract_parser_)
      this->Contract_parser_->_reset ();

    if (this->Coverage_parser_)
      this->Coverage_parser_->_reset ();

    if (this->CoverageEligibilityRequest_parser_)
      this->CoverageEligibilityRequest_parser_->_reset ();

    if (this->CoverageEligibilityResponse_parser_)
      this->CoverageEligibilityResponse_parser_->_reset ();

    if (this->DetectedIssue_parser_)
      this->DetectedIssue_parser_->_reset ();

    if (this->Device_parser_)
      this->Device_parser_->_reset ();

    if (this->DeviceDefinition_parser_)
      this->DeviceDefinition_parser_->_reset ();

    if (this->DeviceMetric_parser_)
      this->DeviceMetric_parser_->_reset ();

    if (this->DeviceRequest_parser_)
      this->DeviceRequest_parser_->_reset ();

    if (this->DeviceUseStatement_parser_)
      this->DeviceUseStatement_parser_->_reset ();

    if (this->DiagnosticReport_parser_)
      this->DiagnosticReport_parser_->_reset ();

    if (this->DocumentManifest_parser_)
      this->DocumentManifest_parser_->_reset ();

    if (this->DocumentReference_parser_)
      this->DocumentReference_parser_->_reset ();

    if (this->EffectEvidenceSynthesis_parser_)
      this->EffectEvidenceSynthesis_parser_->_reset ();

    if (this->Encounter_parser_)
      this->Encounter_parser_->_reset ();

    if (this->Endpoint_parser_)
      this->Endpoint_parser_->_reset ();

    if (this->EnrollmentRequest_parser_)
      this->EnrollmentRequest_parser_->_reset ();

    if (this->EnrollmentResponse_parser_)
      this->EnrollmentResponse_parser_->_reset ();

    if (this->EpisodeOfCare_parser_)
      this->EpisodeOfCare_parser_->_reset ();

    if (this->EventDefinition_parser_)
      this->EventDefinition_parser_->_reset ();

    if (this->Evidence_parser_)
      this->Evidence_parser_->_reset ();

    if (this->EvidenceVariable_parser_)
      this->EvidenceVariable_parser_->_reset ();

    if (this->ExampleScenario_parser_)
      this->ExampleScenario_parser_->_reset ();

    if (this->ExplanationOfBenefit_parser_)
      this->ExplanationOfBenefit_parser_->_reset ();

    if (this->FamilyMemberHistory_parser_)
      this->FamilyMemberHistory_parser_->_reset ();

    if (this->Flag_parser_)
      this->Flag_parser_->_reset ();

    if (this->Goal_parser_)
      this->Goal_parser_->_reset ();

    if (this->GraphDefinition_parser_)
      this->GraphDefinition_parser_->_reset ();

    if (this->Group_parser_)
      this->Group_parser_->_reset ();

    if (this->GuidanceResponse_parser_)
      this->GuidanceResponse_parser_->_reset ();

    if (this->HealthcareService_parser_)
      this->HealthcareService_parser_->_reset ();

    if (this->ImagingStudy_parser_)
      this->ImagingStudy_parser_->_reset ();

    if (this->Immunization_parser_)
      this->Immunization_parser_->_reset ();

    if (this->ImmunizationEvaluation_parser_)
      this->ImmunizationEvaluation_parser_->_reset ();

    if (this->ImmunizationRecommendation_parser_)
      this->ImmunizationRecommendation_parser_->_reset ();

    if (this->ImplementationGuide_parser_)
      this->ImplementationGuide_parser_->_reset ();

    if (this->InsurancePlan_parser_)
      this->InsurancePlan_parser_->_reset ();

    if (this->Invoice_parser_)
      this->Invoice_parser_->_reset ();

    if (this->Library_parser_)
      this->Library_parser_->_reset ();

    if (this->Linkage_parser_)
      this->Linkage_parser_->_reset ();

    if (this->List_parser_)
      this->List_parser_->_reset ();

    if (this->Location_parser_)
      this->Location_parser_->_reset ();

    if (this->Measure_parser_)
      this->Measure_parser_->_reset ();

    if (this->MeasureReport_parser_)
      this->MeasureReport_parser_->_reset ();

    if (this->Media_parser_)
      this->Media_parser_->_reset ();

    if (this->Medication_parser_)
      this->Medication_parser_->_reset ();

    if (this->MedicationAdministration_parser_)
      this->MedicationAdministration_parser_->_reset ();

    if (this->MedicationDispense_parser_)
      this->MedicationDispense_parser_->_reset ();

    if (this->MedicationKnowledge_parser_)
      this->MedicationKnowledge_parser_->_reset ();

    if (this->MedicationRequest_parser_)
      this->MedicationRequest_parser_->_reset ();

    if (this->MedicationStatement_parser_)
      this->MedicationStatement_parser_->_reset ();

    if (this->MedicinalProduct_parser_)
      this->MedicinalProduct_parser_->_reset ();

    if (this->MedicinalProductAuthorization_parser_)
      this->MedicinalProductAuthorization_parser_->_reset ();

    if (this->MedicinalProductContraindication_parser_)
      this->MedicinalProductContraindication_parser_->_reset ();

    if (this->MedicinalProductIndication_parser_)
      this->MedicinalProductIndication_parser_->_reset ();

    if (this->MedicinalProductIngredient_parser_)
      this->MedicinalProductIngredient_parser_->_reset ();

    if (this->MedicinalProductInteraction_parser_)
      this->MedicinalProductInteraction_parser_->_reset ();

    if (this->MedicinalProductManufactured_parser_)
      this->MedicinalProductManufactured_parser_->_reset ();

    if (this->MedicinalProductPackaged_parser_)
      this->MedicinalProductPackaged_parser_->_reset ();

    if (this->MedicinalProductPharmaceutical_parser_)
      this->MedicinalProductPharmaceutical_parser_->_reset ();

    if (this->MedicinalProductUndesirableEffect_parser_)
      this->MedicinalProductUndesirableEffect_parser_->_reset ();

    if (this->MessageDefinition_parser_)
      this->MessageDefinition_parser_->_reset ();

    if (this->MessageHeader_parser_)
      this->MessageHeader_parser_->_reset ();

    if (this->MolecularSequence_parser_)
      this->MolecularSequence_parser_->_reset ();

    if (this->NamingSystem_parser_)
      this->NamingSystem_parser_->_reset ();

    if (this->NutritionOrder_parser_)
      this->NutritionOrder_parser_->_reset ();

    if (this->Observation_parser_)
      this->Observation_parser_->_reset ();

    if (this->ObservationDefinition_parser_)
      this->ObservationDefinition_parser_->_reset ();

    if (this->OperationDefinition_parser_)
      this->OperationDefinition_parser_->_reset ();

    if (this->OperationOutcome_parser_)
      this->OperationOutcome_parser_->_reset ();

    if (this->Organization_parser_)
      this->Organization_parser_->_reset ();

    if (this->OrganizationAffiliation_parser_)
      this->OrganizationAffiliation_parser_->_reset ();

    if (this->Patient_parser_)
      this->Patient_parser_->_reset ();

    if (this->PaymentNotice_parser_)
      this->PaymentNotice_parser_->_reset ();

    if (this->PaymentReconciliation_parser_)
      this->PaymentReconciliation_parser_->_reset ();

    if (this->Person_parser_)
      this->Person_parser_->_reset ();

    if (this->PlanDefinition_parser_)
      this->PlanDefinition_parser_->_reset ();

    if (this->Practitioner_parser_)
      this->Practitioner_parser_->_reset ();

    if (this->PractitionerRole_parser_)
      this->PractitionerRole_parser_->_reset ();

    if (this->Procedure_parser_)
      this->Procedure_parser_->_reset ();

    if (this->Provenance_parser_)
      this->Provenance_parser_->_reset ();

    if (this->Questionnaire_parser_)
      this->Questionnaire_parser_->_reset ();

    if (this->QuestionnaireResponse_parser_)
      this->QuestionnaireResponse_parser_->_reset ();

    if (this->RelatedPerson_parser_)
      this->RelatedPerson_parser_->_reset ();

    if (this->RequestGroup_parser_)
      this->RequestGroup_parser_->_reset ();

    if (this->ResearchDefinition_parser_)
      this->ResearchDefinition_parser_->_reset ();

    if (this->ResearchElementDefinition_parser_)
      this->ResearchElementDefinition_parser_->_reset ();

    if (this->ResearchStudy_parser_)
      this->ResearchStudy_parser_->_reset ();

    if (this->ResearchSubject_parser_)
      this->ResearchSubject_parser_->_reset ();

    if (this->RiskAssessment_parser_)
      this->RiskAssessment_parser_->_reset ();

    if (this->RiskEvidenceSynthesis_parser_)
      this->RiskEvidenceSynthesis_parser_->_reset ();

    if (this->Schedule_parser_)
      this->Schedule_parser_->_reset ();

    if (this->SearchParameter_parser_)
      this->SearchParameter_parser_->_reset ();

    if (this->ServiceRequest_parser_)
      this->ServiceRequest_parser_->_reset ();

    if (this->Slot_parser_)
      this->Slot_parser_->_reset ();

    if (this->Specimen_parser_)
      this->Specimen_parser_->_reset ();

    if (this->SpecimenDefinition_parser_)
      this->SpecimenDefinition_parser_->_reset ();

    if (this->StructureDefinition_parser_)
      this->StructureDefinition_parser_->_reset ();

    if (this->StructureMap_parser_)
      this->StructureMap_parser_->_reset ();

    if (this->Subscription_parser_)
      this->Subscription_parser_->_reset ();

    if (this->Substance_parser_)
      this->Substance_parser_->_reset ();

    if (this->SubstanceNucleicAcid_parser_)
      this->SubstanceNucleicAcid_parser_->_reset ();

    if (this->SubstancePolymer_parser_)
      this->SubstancePolymer_parser_->_reset ();

    if (this->SubstanceProtein_parser_)
      this->SubstanceProtein_parser_->_reset ();

    if (this->SubstanceReferenceInformation_parser_)
      this->SubstanceReferenceInformation_parser_->_reset ();

    if (this->SubstanceSourceMaterial_parser_)
      this->SubstanceSourceMaterial_parser_->_reset ();

    if (this->SubstanceSpecification_parser_)
      this->SubstanceSpecification_parser_->_reset ();

    if (this->SupplyDelivery_parser_)
      this->SupplyDelivery_parser_->_reset ();

    if (this->SupplyRequest_parser_)
      this->SupplyRequest_parser_->_reset ();

    if (this->Task_parser_)
      this->Task_parser_->_reset ();

    if (this->TerminologyCapabilities_parser_)
      this->TerminologyCapabilities_parser_->_reset ();

    if (this->TestReport_parser_)
      this->TestReport_parser_->_reset ();

    if (this->TestScript_parser_)
      this->TestScript_parser_->_reset ();

    if (this->ValueSet_parser_)
      this->ValueSet_parser_->_reset ();

    if (this->VerificationResult_parser_)
      this->VerificationResult_parser_->_reset ();

    if (this->VisionPrescription_parser_)
      this->VisionPrescription_parser_->_reset ();

    if (this->Parameters_parser_)
      this->Parameters_parser_->_reset ();

    this->resetting_ = false;
  }

  // Extension_pskel
  //

  void Extension_pskel::
  url ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->url ();
  }

  void Extension_pskel::
  valueBase64Binary ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueBase64Binary ();
  }

  void Extension_pskel::
  valueBoolean ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueBoolean ();
  }

  void Extension_pskel::
  valueCanonical ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueCanonical ();
  }

  void Extension_pskel::
  valueCode ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueCode ();
  }

  void Extension_pskel::
  valueDate ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDate ();
  }

  void Extension_pskel::
  valueDateTime ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDateTime ();
  }

  void Extension_pskel::
  valueDecimal ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDecimal ();
  }

  void Extension_pskel::
  valueId ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueId ();
  }

  void Extension_pskel::
  valueInstant ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueInstant ();
  }

  void Extension_pskel::
  valueInteger ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueInteger ();
  }

  void Extension_pskel::
  valueMarkdown ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueMarkdown ();
  }

  void Extension_pskel::
  valueOid ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueOid ();
  }

  void Extension_pskel::
  valuePositiveInt ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valuePositiveInt ();
  }

  void Extension_pskel::
  valueString ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueString ();
  }

  void Extension_pskel::
  valueTime ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueTime ();
  }

  void Extension_pskel::
  valueUnsignedInt ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueUnsignedInt ();
  }

  void Extension_pskel::
  valueUri ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueUri ();
  }

  void Extension_pskel::
  valueUrl ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueUrl ();
  }

  void Extension_pskel::
  valueUuid ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueUuid ();
  }

  void Extension_pskel::
  valueAddress ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueAddress ();
  }

  void Extension_pskel::
  valueAge ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueAge ();
  }

  void Extension_pskel::
  valueAnnotation ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueAnnotation ();
  }

  void Extension_pskel::
  valueAttachment ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueAttachment ();
  }

  void Extension_pskel::
  valueCodeableConcept ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueCodeableConcept ();
  }

  void Extension_pskel::
  valueCoding ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueCoding ();
  }

  void Extension_pskel::
  valueContactPoint ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueContactPoint ();
  }

  void Extension_pskel::
  valueCount ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueCount ();
  }

  void Extension_pskel::
  valueDistance ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDistance ();
  }

  void Extension_pskel::
  valueDuration ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDuration ();
  }

  void Extension_pskel::
  valueHumanName ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueHumanName ();
  }

  void Extension_pskel::
  valueIdentifier ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueIdentifier ();
  }

  void Extension_pskel::
  valueMoney ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueMoney ();
  }

  void Extension_pskel::
  valuePeriod ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valuePeriod ();
  }

  void Extension_pskel::
  valueQuantity ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueQuantity ();
  }

  void Extension_pskel::
  valueRange ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueRange ();
  }

  void Extension_pskel::
  valueRatio ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueRatio ();
  }

  void Extension_pskel::
  valueReference ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueReference ();
  }

  void Extension_pskel::
  valueSampledData ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueSampledData ();
  }

  void Extension_pskel::
  valueSignature ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueSignature ();
  }

  void Extension_pskel::
  valueTiming ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueTiming ();
  }

  void Extension_pskel::
  valueContactDetail ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueContactDetail ();
  }

  void Extension_pskel::
  valueContributor ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueContributor ();
  }

  void Extension_pskel::
  valueDataRequirement ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDataRequirement ();
  }

  void Extension_pskel::
  valueExpression ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueExpression ();
  }

  void Extension_pskel::
  valueParameterDefinition ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueParameterDefinition ();
  }

  void Extension_pskel::
  valueRelatedArtifact ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueRelatedArtifact ();
  }

  void Extension_pskel::
  valueTriggerDefinition ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueTriggerDefinition ();
  }

  void Extension_pskel::
  valueUsageContext ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueUsageContext ();
  }

  void Extension_pskel::
  valueDosage ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueDosage ();
  }

  void Extension_pskel::
  valueMeta ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->valueMeta ();
  }

  void Extension_pskel::
  post_Extension ()
  {
    if (this->Extension_impl_)
      this->Extension_impl_->post_Extension ();
    else
      post_Element ();
  }

  void Extension_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->v_state_attr_stack_.clear ();

    if (this->url_parser_)
      this->url_parser_->_reset ();

    this->resetting_ = true;

    if (this->valueBase64Binary_parser_)
      this->valueBase64Binary_parser_->_reset ();

    if (this->valueBoolean_parser_)
      this->valueBoolean_parser_->_reset ();

    if (this->valueCanonical_parser_)
      this->valueCanonical_parser_->_reset ();

    if (this->valueCode_parser_)
      this->valueCode_parser_->_reset ();

    if (this->valueDate_parser_)
      this->valueDate_parser_->_reset ();

    if (this->valueDateTime_parser_)
      this->valueDateTime_parser_->_reset ();

    if (this->valueDecimal_parser_)
      this->valueDecimal_parser_->_reset ();

    if (this->valueId_parser_)
      this->valueId_parser_->_reset ();

    if (this->valueInstant_parser_)
      this->valueInstant_parser_->_reset ();

    if (this->valueInteger_parser_)
      this->valueInteger_parser_->_reset ();

    if (this->valueMarkdown_parser_)
      this->valueMarkdown_parser_->_reset ();

    if (this->valueOid_parser_)
      this->valueOid_parser_->_reset ();

    if (this->valuePositiveInt_parser_)
      this->valuePositiveInt_parser_->_reset ();

    if (this->valueString_parser_)
      this->valueString_parser_->_reset ();

    if (this->valueTime_parser_)
      this->valueTime_parser_->_reset ();

    if (this->valueUnsignedInt_parser_)
      this->valueUnsignedInt_parser_->_reset ();

    if (this->valueUri_parser_)
      this->valueUri_parser_->_reset ();

    if (this->valueUrl_parser_)
      this->valueUrl_parser_->_reset ();

    if (this->valueUuid_parser_)
      this->valueUuid_parser_->_reset ();

    if (this->valueAddress_parser_)
      this->valueAddress_parser_->_reset ();

    if (this->valueAge_parser_)
      this->valueAge_parser_->_reset ();

    if (this->valueAnnotation_parser_)
      this->valueAnnotation_parser_->_reset ();

    if (this->valueAttachment_parser_)
      this->valueAttachment_parser_->_reset ();

    if (this->valueCodeableConcept_parser_)
      this->valueCodeableConcept_parser_->_reset ();

    if (this->valueCoding_parser_)
      this->valueCoding_parser_->_reset ();

    if (this->valueContactPoint_parser_)
      this->valueContactPoint_parser_->_reset ();

    if (this->valueCount_parser_)
      this->valueCount_parser_->_reset ();

    if (this->valueDistance_parser_)
      this->valueDistance_parser_->_reset ();

    if (this->valueDuration_parser_)
      this->valueDuration_parser_->_reset ();

    if (this->valueHumanName_parser_)
      this->valueHumanName_parser_->_reset ();

    if (this->valueIdentifier_parser_)
      this->valueIdentifier_parser_->_reset ();

    if (this->valueMoney_parser_)
      this->valueMoney_parser_->_reset ();

    if (this->valuePeriod_parser_)
      this->valuePeriod_parser_->_reset ();

    if (this->valueQuantity_parser_)
      this->valueQuantity_parser_->_reset ();

    if (this->valueRange_parser_)
      this->valueRange_parser_->_reset ();

    if (this->valueRatio_parser_)
      this->valueRatio_parser_->_reset ();

    if (this->valueReference_parser_)
      this->valueReference_parser_->_reset ();

    if (this->valueSampledData_parser_)
      this->valueSampledData_parser_->_reset ();

    if (this->valueSignature_parser_)
      this->valueSignature_parser_->_reset ();

    if (this->valueTiming_parser_)
      this->valueTiming_parser_->_reset ();

    if (this->valueContactDetail_parser_)
      this->valueContactDetail_parser_->_reset ();

    if (this->valueContributor_parser_)
      this->valueContributor_parser_->_reset ();

    if (this->valueDataRequirement_parser_)
      this->valueDataRequirement_parser_->_reset ();

    if (this->valueExpression_parser_)
      this->valueExpression_parser_->_reset ();

    if (this->valueParameterDefinition_parser_)
      this->valueParameterDefinition_parser_->_reset ();

    if (this->valueRelatedArtifact_parser_)
      this->valueRelatedArtifact_parser_->_reset ();

    if (this->valueTriggerDefinition_parser_)
      this->valueTriggerDefinition_parser_->_reset ();

    if (this->valueUsageContext_parser_)
      this->valueUsageContext_parser_->_reset ();

    if (this->valueDosage_parser_)
      this->valueDosage_parser_->_reset ();

    if (this->valueMeta_parser_)
      this->valueMeta_parser_->_reset ();

    this->resetting_ = false;
  }

  // BackboneElement_pskel
  //

  void BackboneElement_pskel::
  modifierExtension ()
  {
    if (this->BackboneElement_impl_)
      this->BackboneElement_impl_->modifierExtension ();
  }

  void BackboneElement_pskel::
  post_BackboneElement ()
  {
    if (this->BackboneElement_impl_)
      this->BackboneElement_impl_->post_BackboneElement ();
    else
      post_Element ();
  }

  void BackboneElement_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->modifierExtension_parser_)
      this->modifierExtension_parser_->_reset ();

    this->resetting_ = false;
  }

  // Narrative_pskel
  //

  void Narrative_pskel::
  status ()
  {
    if (this->Narrative_impl_)
      this->Narrative_impl_->status ();
  }

  void Narrative_pskel::
  div ()
  {
    if (this->Narrative_impl_)
      this->Narrative_impl_->div ();
  }

  void Narrative_pskel::
  post_Narrative ()
  {
    if (this->Narrative_impl_)
      this->Narrative_impl_->post_Narrative ();
    else
      post_Element ();
  }

  void Narrative_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->status_parser_)
      this->status_parser_->_reset ();

    if (this->div_parser_)
      this->div_parser_->_reset ();

    this->resetting_ = false;
  }

  // NarrativeStatus_list_pskel
  //

  void NarrativeStatus_list_pskel::
  post_NarrativeStatus_list ()
  {
    if (this->NarrativeStatus_list_impl_)
      this->NarrativeStatus_list_impl_->post_NarrativeStatus_list ();
    else
      post_code_primitive ();
  }

  const char* const NarrativeStatus_list_pskel::_xsde_NarrativeStatus_list_pskel_enums_[4UL] = 
  {
    "additional",
    "empty",
    "extensions",
    "generated"
  };

  // NarrativeStatus_pskel
  //

  void NarrativeStatus_pskel::
  value ()
  {
    if (this->NarrativeStatus_impl_)
      this->NarrativeStatus_impl_->value ();
  }

  void NarrativeStatus_pskel::
  post_NarrativeStatus ()
  {
    if (this->NarrativeStatus_impl_)
      this->NarrativeStatus_impl_->post_NarrativeStatus ();
    else
      post_Element ();
  }

  void NarrativeStatus_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Meta_pskel
  //

  void Meta_pskel::
  versionId ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->versionId ();
  }

  void Meta_pskel::
  lastUpdated ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->lastUpdated ();
  }

  void Meta_pskel::
  source ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->source ();
  }

  void Meta_pskel::
  profile ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->profile ();
  }

  void Meta_pskel::
  security ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->security ();
  }

  void Meta_pskel::
  tag ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->tag ();
  }

  void Meta_pskel::
  post_Meta ()
  {
    if (this->Meta_impl_)
      this->Meta_impl_->post_Meta ();
    else
      post_Element ();
  }

  void Meta_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->versionId_parser_)
      this->versionId_parser_->_reset ();

    if (this->lastUpdated_parser_)
      this->lastUpdated_parser_->_reset ();

    if (this->source_parser_)
      this->source_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    if (this->security_parser_)
      this->security_parser_->_reset ();

    if (this->tag_parser_)
      this->tag_parser_->_reset ();

    this->resetting_ = false;
  }

  // Address_pskel
  //

  void Address_pskel::
  use ()
  {
    if (this->Address_impl_)
      this->Address_impl_->use ();
  }

  void Address_pskel::
  type ()
  {
    if (this->Address_impl_)
      this->Address_impl_->type ();
  }

  void Address_pskel::
  text ()
  {
    if (this->Address_impl_)
      this->Address_impl_->text ();
  }

  void Address_pskel::
  line ()
  {
    if (this->Address_impl_)
      this->Address_impl_->line ();
  }

  void Address_pskel::
  city ()
  {
    if (this->Address_impl_)
      this->Address_impl_->city ();
  }

  void Address_pskel::
  district ()
  {
    if (this->Address_impl_)
      this->Address_impl_->district ();
  }

  void Address_pskel::
  state ()
  {
    if (this->Address_impl_)
      this->Address_impl_->state ();
  }

  void Address_pskel::
  postalCode ()
  {
    if (this->Address_impl_)
      this->Address_impl_->postalCode ();
  }

  void Address_pskel::
  country ()
  {
    if (this->Address_impl_)
      this->Address_impl_->country ();
  }

  void Address_pskel::
  period ()
  {
    if (this->Address_impl_)
      this->Address_impl_->period ();
  }

  void Address_pskel::
  post_Address ()
  {
    if (this->Address_impl_)
      this->Address_impl_->post_Address ();
    else
      post_Element ();
  }

  void Address_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->use_parser_)
      this->use_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->text_parser_)
      this->text_parser_->_reset ();

    if (this->line_parser_)
      this->line_parser_->_reset ();

    if (this->city_parser_)
      this->city_parser_->_reset ();

    if (this->district_parser_)
      this->district_parser_->_reset ();

    if (this->state_parser_)
      this->state_parser_->_reset ();

    if (this->postalCode_parser_)
      this->postalCode_parser_->_reset ();

    if (this->country_parser_)
      this->country_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    this->resetting_ = false;
  }

  // AddressUse_list_pskel
  //

  void AddressUse_list_pskel::
  post_AddressUse_list ()
  {
    if (this->AddressUse_list_impl_)
      this->AddressUse_list_impl_->post_AddressUse_list ();
    else
      post_code_primitive ();
  }

  const char* const AddressUse_list_pskel::_xsde_AddressUse_list_pskel_enums_[5UL] = 
  {
    "billing",
    "home",
    "old",
    "temp",
    "work"
  };

  // AddressUse_pskel
  //

  void AddressUse_pskel::
  value ()
  {
    if (this->AddressUse_impl_)
      this->AddressUse_impl_->value ();
  }

  void AddressUse_pskel::
  post_AddressUse ()
  {
    if (this->AddressUse_impl_)
      this->AddressUse_impl_->post_AddressUse ();
    else
      post_Element ();
  }

  void AddressUse_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // AddressType_list_pskel
  //

  void AddressType_list_pskel::
  post_AddressType_list ()
  {
    if (this->AddressType_list_impl_)
      this->AddressType_list_impl_->post_AddressType_list ();
    else
      post_code_primitive ();
  }

  const char* const AddressType_list_pskel::_xsde_AddressType_list_pskel_enums_[3UL] = 
  {
    "both",
    "physical",
    "postal"
  };

  // AddressType_pskel
  //

  void AddressType_pskel::
  value ()
  {
    if (this->AddressType_impl_)
      this->AddressType_impl_->value ();
  }

  void AddressType_pskel::
  post_AddressType ()
  {
    if (this->AddressType_impl_)
      this->AddressType_impl_->post_AddressType ();
    else
      post_Element ();
  }

  void AddressType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Contributor_pskel
  //

  void Contributor_pskel::
  type ()
  {
    if (this->Contributor_impl_)
      this->Contributor_impl_->type ();
  }

  void Contributor_pskel::
  name ()
  {
    if (this->Contributor_impl_)
      this->Contributor_impl_->name ();
  }

  void Contributor_pskel::
  contact ()
  {
    if (this->Contributor_impl_)
      this->Contributor_impl_->contact ();
  }

  void Contributor_pskel::
  post_Contributor ()
  {
    if (this->Contributor_impl_)
      this->Contributor_impl_->post_Contributor ();
    else
      post_Element ();
  }

  void Contributor_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->contact_parser_)
      this->contact_parser_->_reset ();

    this->resetting_ = false;
  }

  // ContributorType_list_pskel
  //

  void ContributorType_list_pskel::
  post_ContributorType_list ()
  {
    if (this->ContributorType_list_impl_)
      this->ContributorType_list_impl_->post_ContributorType_list ();
    else
      post_code_primitive ();
  }

  const char* const ContributorType_list_pskel::_xsde_ContributorType_list_pskel_enums_[4UL] = 
  {
    "author",
    "editor",
    "endorser",
    "reviewer"
  };

  // ContributorType_pskel
  //

  void ContributorType_pskel::
  value ()
  {
    if (this->ContributorType_impl_)
      this->ContributorType_impl_->value ();
  }

  void ContributorType_pskel::
  post_ContributorType ()
  {
    if (this->ContributorType_impl_)
      this->ContributorType_impl_->post_ContributorType ();
    else
      post_Element ();
  }

  void ContributorType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Attachment_pskel
  //

  void Attachment_pskel::
  contentType ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->contentType ();
  }

  void Attachment_pskel::
  language ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->language ();
  }

  void Attachment_pskel::
  data ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->data ();
  }

  void Attachment_pskel::
  url ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->url ();
  }

  void Attachment_pskel::
  size ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->size ();
  }

  void Attachment_pskel::
  hash ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->hash ();
  }

  void Attachment_pskel::
  title ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->title ();
  }

  void Attachment_pskel::
  creation ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->creation ();
  }

  void Attachment_pskel::
  post_Attachment ()
  {
    if (this->Attachment_impl_)
      this->Attachment_impl_->post_Attachment ();
    else
      post_Element ();
  }

  void Attachment_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->contentType_parser_)
      this->contentType_parser_->_reset ();

    if (this->language_parser_)
      this->language_parser_->_reset ();

    if (this->data_parser_)
      this->data_parser_->_reset ();

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->size_parser_)
      this->size_parser_->_reset ();

    if (this->hash_parser_)
      this->hash_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->creation_parser_)
      this->creation_parser_->_reset ();

    this->resetting_ = false;
  }

  // Quantity_pskel
  //

  void Quantity_pskel::
  value ()
  {
    if (this->Quantity_impl_)
      this->Quantity_impl_->value ();
  }

  void Quantity_pskel::
  comparator ()
  {
    if (this->Quantity_impl_)
      this->Quantity_impl_->comparator ();
  }

  void Quantity_pskel::
  unit ()
  {
    if (this->Quantity_impl_)
      this->Quantity_impl_->unit ();
  }

  void Quantity_pskel::
  system ()
  {
    if (this->Quantity_impl_)
      this->Quantity_impl_->system ();
  }

  void Quantity_pskel::
  code ()
  {
    if (this->Quantity_impl_)
      this->Quantity_impl_->code ();
  }

  void Quantity_pskel::
  post_Quantity ()
  {
    if (this->Quantity_impl_)
      this->Quantity_impl_->post_Quantity ();
    else
      post_Element ();
  }

  void Quantity_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->value_parser_)
      this->value_parser_->_reset ();

    if (this->comparator_parser_)
      this->comparator_parser_->_reset ();

    if (this->unit_parser_)
      this->unit_parser_->_reset ();

    if (this->system_parser_)
      this->system_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    this->resetting_ = false;
  }

  // Count_pskel
  //

  void Count_pskel::
  post_Count ()
  {
    if (this->Count_impl_)
      this->Count_impl_->post_Count ();
    else
      post_Quantity ();
  }

  // DataRequirement_pskel
  //

  void DataRequirement_pskel::
  type ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->type ();
  }

  void DataRequirement_pskel::
  profile ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->profile ();
  }

  void DataRequirement_pskel::
  subjectCodeableConcept ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->subjectCodeableConcept ();
  }

  void DataRequirement_pskel::
  subjectReference ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->subjectReference ();
  }

  void DataRequirement_pskel::
  mustSupport ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->mustSupport ();
  }

  void DataRequirement_pskel::
  codeFilter ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->codeFilter ();
  }

  void DataRequirement_pskel::
  dateFilter ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->dateFilter ();
  }

  void DataRequirement_pskel::
  limit ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->limit ();
  }

  void DataRequirement_pskel::
  sort ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->sort ();
  }

  void DataRequirement_pskel::
  post_DataRequirement ()
  {
    if (this->DataRequirement_impl_)
      this->DataRequirement_impl_->post_DataRequirement ();
    else
      post_Element ();
  }

  void DataRequirement_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    if (this->subjectCodeableConcept_parser_)
      this->subjectCodeableConcept_parser_->_reset ();

    if (this->subjectReference_parser_)
      this->subjectReference_parser_->_reset ();

    if (this->mustSupport_parser_)
      this->mustSupport_parser_->_reset ();

    if (this->codeFilter_parser_)
      this->codeFilter_parser_->_reset ();

    if (this->dateFilter_parser_)
      this->dateFilter_parser_->_reset ();

    if (this->limit_parser_)
      this->limit_parser_->_reset ();

    if (this->sort_parser_)
      this->sort_parser_->_reset ();

    this->resetting_ = false;
  }

  // DataRequirement_CodeFilter_pskel
  //

  void DataRequirement_CodeFilter_pskel::
  path ()
  {
    if (this->DataRequirement_CodeFilter_impl_)
      this->DataRequirement_CodeFilter_impl_->path ();
  }

  void DataRequirement_CodeFilter_pskel::
  searchParam ()
  {
    if (this->DataRequirement_CodeFilter_impl_)
      this->DataRequirement_CodeFilter_impl_->searchParam ();
  }

  void DataRequirement_CodeFilter_pskel::
  valueSet ()
  {
    if (this->DataRequirement_CodeFilter_impl_)
      this->DataRequirement_CodeFilter_impl_->valueSet ();
  }

  void DataRequirement_CodeFilter_pskel::
  code ()
  {
    if (this->DataRequirement_CodeFilter_impl_)
      this->DataRequirement_CodeFilter_impl_->code ();
  }

  void DataRequirement_CodeFilter_pskel::
  post_DataRequirement_CodeFilter ()
  {
    if (this->DataRequirement_CodeFilter_impl_)
      this->DataRequirement_CodeFilter_impl_->post_DataRequirement_CodeFilter ();
    else
      post_Element ();
  }

  void DataRequirement_CodeFilter_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->searchParam_parser_)
      this->searchParam_parser_->_reset ();

    if (this->valueSet_parser_)
      this->valueSet_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    this->resetting_ = false;
  }

  // DataRequirement_DateFilter_pskel
  //

  void DataRequirement_DateFilter_pskel::
  path ()
  {
    if (this->DataRequirement_DateFilter_impl_)
      this->DataRequirement_DateFilter_impl_->path ();
  }

  void DataRequirement_DateFilter_pskel::
  searchParam ()
  {
    if (this->DataRequirement_DateFilter_impl_)
      this->DataRequirement_DateFilter_impl_->searchParam ();
  }

  void DataRequirement_DateFilter_pskel::
  valueDateTime ()
  {
    if (this->DataRequirement_DateFilter_impl_)
      this->DataRequirement_DateFilter_impl_->valueDateTime ();
  }

  void DataRequirement_DateFilter_pskel::
  valuePeriod ()
  {
    if (this->DataRequirement_DateFilter_impl_)
      this->DataRequirement_DateFilter_impl_->valuePeriod ();
  }

  void DataRequirement_DateFilter_pskel::
  valueDuration ()
  {
    if (this->DataRequirement_DateFilter_impl_)
      this->DataRequirement_DateFilter_impl_->valueDuration ();
  }

  void DataRequirement_DateFilter_pskel::
  post_DataRequirement_DateFilter ()
  {
    if (this->DataRequirement_DateFilter_impl_)
      this->DataRequirement_DateFilter_impl_->post_DataRequirement_DateFilter ();
    else
      post_Element ();
  }

  void DataRequirement_DateFilter_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->searchParam_parser_)
      this->searchParam_parser_->_reset ();

    if (this->valueDateTime_parser_)
      this->valueDateTime_parser_->_reset ();

    if (this->valuePeriod_parser_)
      this->valuePeriod_parser_->_reset ();

    if (this->valueDuration_parser_)
      this->valueDuration_parser_->_reset ();

    this->resetting_ = false;
  }

  // DataRequirement_Sort_pskel
  //

  void DataRequirement_Sort_pskel::
  path ()
  {
    if (this->DataRequirement_Sort_impl_)
      this->DataRequirement_Sort_impl_->path ();
  }

  void DataRequirement_Sort_pskel::
  direction ()
  {
    if (this->DataRequirement_Sort_impl_)
      this->DataRequirement_Sort_impl_->direction ();
  }

  void DataRequirement_Sort_pskel::
  post_DataRequirement_Sort ()
  {
    if (this->DataRequirement_Sort_impl_)
      this->DataRequirement_Sort_impl_->post_DataRequirement_Sort ();
    else
      post_Element ();
  }

  void DataRequirement_Sort_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->direction_parser_)
      this->direction_parser_->_reset ();

    this->resetting_ = false;
  }

  // SortDirection_list_pskel
  //

  void SortDirection_list_pskel::
  post_SortDirection_list ()
  {
    if (this->SortDirection_list_impl_)
      this->SortDirection_list_impl_->post_SortDirection_list ();
    else
      post_code_primitive ();
  }

  const char* const SortDirection_list_pskel::_xsde_SortDirection_list_pskel_enums_[2UL] = 
  {
    "ascending",
    "descending"
  };

  // SortDirection_pskel
  //

  void SortDirection_pskel::
  value ()
  {
    if (this->SortDirection_impl_)
      this->SortDirection_impl_->value ();
  }

  void SortDirection_pskel::
  post_SortDirection ()
  {
    if (this->SortDirection_impl_)
      this->SortDirection_impl_->post_SortDirection ();
    else
      post_Element ();
  }

  void SortDirection_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Dosage_pskel
  //

  void Dosage_pskel::
  sequence ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->sequence ();
  }

  void Dosage_pskel::
  text ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->text ();
  }

  void Dosage_pskel::
  additionalInstruction ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->additionalInstruction ();
  }

  void Dosage_pskel::
  patientInstruction ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->patientInstruction ();
  }

  void Dosage_pskel::
  timing ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->timing ();
  }

  void Dosage_pskel::
  asNeededBoolean ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->asNeededBoolean ();
  }

  void Dosage_pskel::
  asNeededCodeableConcept ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->asNeededCodeableConcept ();
  }

  void Dosage_pskel::
  site ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->site ();
  }

  void Dosage_pskel::
  route ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->route ();
  }

  void Dosage_pskel::
  method ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->method ();
  }

  void Dosage_pskel::
  doseAndRate ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->doseAndRate ();
  }

  void Dosage_pskel::
  maxDosePerPeriod ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->maxDosePerPeriod ();
  }

  void Dosage_pskel::
  maxDosePerAdministration ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->maxDosePerAdministration ();
  }

  void Dosage_pskel::
  maxDosePerLifetime ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->maxDosePerLifetime ();
  }

  void Dosage_pskel::
  post_Dosage ()
  {
    if (this->Dosage_impl_)
      this->Dosage_impl_->post_Dosage ();
    else
      post_BackboneElement ();
  }

  void Dosage_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->sequence_parser_)
      this->sequence_parser_->_reset ();

    if (this->text_parser_)
      this->text_parser_->_reset ();

    if (this->additionalInstruction_parser_)
      this->additionalInstruction_parser_->_reset ();

    if (this->patientInstruction_parser_)
      this->patientInstruction_parser_->_reset ();

    if (this->timing_parser_)
      this->timing_parser_->_reset ();

    if (this->asNeededBoolean_parser_)
      this->asNeededBoolean_parser_->_reset ();

    if (this->asNeededCodeableConcept_parser_)
      this->asNeededCodeableConcept_parser_->_reset ();

    if (this->site_parser_)
      this->site_parser_->_reset ();

    if (this->route_parser_)
      this->route_parser_->_reset ();

    if (this->method_parser_)
      this->method_parser_->_reset ();

    if (this->doseAndRate_parser_)
      this->doseAndRate_parser_->_reset ();

    if (this->maxDosePerPeriod_parser_)
      this->maxDosePerPeriod_parser_->_reset ();

    if (this->maxDosePerAdministration_parser_)
      this->maxDosePerAdministration_parser_->_reset ();

    if (this->maxDosePerLifetime_parser_)
      this->maxDosePerLifetime_parser_->_reset ();

    this->resetting_ = false;
  }

  // Dosage_DoseAndRate_pskel
  //

  void Dosage_DoseAndRate_pskel::
  type ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->type ();
  }

  void Dosage_DoseAndRate_pskel::
  doseRange ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->doseRange ();
  }

  void Dosage_DoseAndRate_pskel::
  doseQuantity ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->doseQuantity ();
  }

  void Dosage_DoseAndRate_pskel::
  rateRatio ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->rateRatio ();
  }

  void Dosage_DoseAndRate_pskel::
  rateRange ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->rateRange ();
  }

  void Dosage_DoseAndRate_pskel::
  rateQuantity ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->rateQuantity ();
  }

  void Dosage_DoseAndRate_pskel::
  post_Dosage_DoseAndRate ()
  {
    if (this->Dosage_DoseAndRate_impl_)
      this->Dosage_DoseAndRate_impl_->post_Dosage_DoseAndRate ();
    else
      post_BackboneElement ();
  }

  void Dosage_DoseAndRate_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->doseRange_parser_)
      this->doseRange_parser_->_reset ();

    if (this->doseQuantity_parser_)
      this->doseQuantity_parser_->_reset ();

    if (this->rateRatio_parser_)
      this->rateRatio_parser_->_reset ();

    if (this->rateRange_parser_)
      this->rateRange_parser_->_reset ();

    if (this->rateQuantity_parser_)
      this->rateQuantity_parser_->_reset ();

    this->resetting_ = false;
  }

  // Money_pskel
  //

  void Money_pskel::
  value ()
  {
    if (this->Money_impl_)
      this->Money_impl_->value ();
  }

  void Money_pskel::
  currency ()
  {
    if (this->Money_impl_)
      this->Money_impl_->currency ();
  }

  void Money_pskel::
  post_Money ()
  {
    if (this->Money_impl_)
      this->Money_impl_->post_Money ();
    else
      post_Element ();
  }

  void Money_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->value_parser_)
      this->value_parser_->_reset ();

    if (this->currency_parser_)
      this->currency_parser_->_reset ();

    this->resetting_ = false;
  }

  // HumanName_pskel
  //

  void HumanName_pskel::
  use ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->use ();
  }

  void HumanName_pskel::
  text ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->text ();
  }

  void HumanName_pskel::
  family ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->family ();
  }

  void HumanName_pskel::
  given ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->given ();
  }

  void HumanName_pskel::
  prefix ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->prefix ();
  }

  void HumanName_pskel::
  suffix ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->suffix ();
  }

  void HumanName_pskel::
  period ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->period ();
  }

  void HumanName_pskel::
  post_HumanName ()
  {
    if (this->HumanName_impl_)
      this->HumanName_impl_->post_HumanName ();
    else
      post_Element ();
  }

  void HumanName_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->use_parser_)
      this->use_parser_->_reset ();

    if (this->text_parser_)
      this->text_parser_->_reset ();

    if (this->family_parser_)
      this->family_parser_->_reset ();

    if (this->given_parser_)
      this->given_parser_->_reset ();

    if (this->prefix_parser_)
      this->prefix_parser_->_reset ();

    if (this->suffix_parser_)
      this->suffix_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    this->resetting_ = false;
  }

  // NameUse_list_pskel
  //

  void NameUse_list_pskel::
  post_NameUse_list ()
  {
    if (this->NameUse_list_impl_)
      this->NameUse_list_impl_->post_NameUse_list ();
    else
      post_code_primitive ();
  }

  const char* const NameUse_list_pskel::_xsde_NameUse_list_pskel_enums_[7UL] = 
  {
    "anonymous",
    "maiden",
    "nickname",
    "official",
    "old",
    "temp",
    "usual"
  };

  // NameUse_pskel
  //

  void NameUse_pskel::
  value ()
  {
    if (this->NameUse_impl_)
      this->NameUse_impl_->value ();
  }

  void NameUse_pskel::
  post_NameUse ()
  {
    if (this->NameUse_impl_)
      this->NameUse_impl_->post_NameUse ();
    else
      post_Element ();
  }

  void NameUse_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ContactPoint_pskel
  //

  void ContactPoint_pskel::
  system ()
  {
    if (this->ContactPoint_impl_)
      this->ContactPoint_impl_->system ();
  }

  void ContactPoint_pskel::
  value ()
  {
    if (this->ContactPoint_impl_)
      this->ContactPoint_impl_->value ();
  }

  void ContactPoint_pskel::
  use ()
  {
    if (this->ContactPoint_impl_)
      this->ContactPoint_impl_->use ();
  }

  void ContactPoint_pskel::
  rank ()
  {
    if (this->ContactPoint_impl_)
      this->ContactPoint_impl_->rank ();
  }

  void ContactPoint_pskel::
  period ()
  {
    if (this->ContactPoint_impl_)
      this->ContactPoint_impl_->period ();
  }

  void ContactPoint_pskel::
  post_ContactPoint ()
  {
    if (this->ContactPoint_impl_)
      this->ContactPoint_impl_->post_ContactPoint ();
    else
      post_Element ();
  }

  void ContactPoint_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->system_parser_)
      this->system_parser_->_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();

    if (this->use_parser_)
      this->use_parser_->_reset ();

    if (this->rank_parser_)
      this->rank_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    this->resetting_ = false;
  }

  // ContactPointSystem_list_pskel
  //

  void ContactPointSystem_list_pskel::
  post_ContactPointSystem_list ()
  {
    if (this->ContactPointSystem_list_impl_)
      this->ContactPointSystem_list_impl_->post_ContactPointSystem_list ();
    else
      post_code_primitive ();
  }

  const char* const ContactPointSystem_list_pskel::_xsde_ContactPointSystem_list_pskel_enums_[7UL] = 
  {
    "email",
    "fax",
    "other",
    "pager",
    "phone",
    "sms",
    "url"
  };

  // ContactPointSystem_pskel
  //

  void ContactPointSystem_pskel::
  value ()
  {
    if (this->ContactPointSystem_impl_)
      this->ContactPointSystem_impl_->value ();
  }

  void ContactPointSystem_pskel::
  post_ContactPointSystem ()
  {
    if (this->ContactPointSystem_impl_)
      this->ContactPointSystem_impl_->post_ContactPointSystem ();
    else
      post_Element ();
  }

  void ContactPointSystem_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ContactPointUse_list_pskel
  //

  void ContactPointUse_list_pskel::
  post_ContactPointUse_list ()
  {
    if (this->ContactPointUse_list_impl_)
      this->ContactPointUse_list_impl_->post_ContactPointUse_list ();
    else
      post_code_primitive ();
  }

  const char* const ContactPointUse_list_pskel::_xsde_ContactPointUse_list_pskel_enums_[5UL] = 
  {
    "home",
    "mobile",
    "old",
    "temp",
    "work"
  };

  // ContactPointUse_pskel
  //

  void ContactPointUse_pskel::
  value ()
  {
    if (this->ContactPointUse_impl_)
      this->ContactPointUse_impl_->value ();
  }

  void ContactPointUse_pskel::
  post_ContactPointUse ()
  {
    if (this->ContactPointUse_impl_)
      this->ContactPointUse_impl_->post_ContactPointUse ();
    else
      post_Element ();
  }

  void ContactPointUse_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // MarketingStatus_pskel
  //

  void MarketingStatus_pskel::
  country ()
  {
    if (this->MarketingStatus_impl_)
      this->MarketingStatus_impl_->country ();
  }

  void MarketingStatus_pskel::
  jurisdiction ()
  {
    if (this->MarketingStatus_impl_)
      this->MarketingStatus_impl_->jurisdiction ();
  }

  void MarketingStatus_pskel::
  status ()
  {
    if (this->MarketingStatus_impl_)
      this->MarketingStatus_impl_->status ();
  }

  void MarketingStatus_pskel::
  dateRange ()
  {
    if (this->MarketingStatus_impl_)
      this->MarketingStatus_impl_->dateRange ();
  }

  void MarketingStatus_pskel::
  restoreDate ()
  {
    if (this->MarketingStatus_impl_)
      this->MarketingStatus_impl_->restoreDate ();
  }

  void MarketingStatus_pskel::
  post_MarketingStatus ()
  {
    if (this->MarketingStatus_impl_)
      this->MarketingStatus_impl_->post_MarketingStatus ();
    else
      post_BackboneElement ();
  }

  void MarketingStatus_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->country_parser_)
      this->country_parser_->_reset ();

    if (this->jurisdiction_parser_)
      this->jurisdiction_parser_->_reset ();

    if (this->status_parser_)
      this->status_parser_->_reset ();

    if (this->dateRange_parser_)
      this->dateRange_parser_->_reset ();

    if (this->restoreDate_parser_)
      this->restoreDate_parser_->_reset ();

    this->resetting_ = false;
  }

  // Identifier_pskel
  //

  void Identifier_pskel::
  use ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->use ();
  }

  void Identifier_pskel::
  type ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->type ();
  }

  void Identifier_pskel::
  system ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->system ();
  }

  void Identifier_pskel::
  value ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->value ();
  }

  void Identifier_pskel::
  period ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->period ();
  }

  void Identifier_pskel::
  assigner ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->assigner ();
  }

  void Identifier_pskel::
  post_Identifier ()
  {
    if (this->Identifier_impl_)
      this->Identifier_impl_->post_Identifier ();
    else
      post_Element ();
  }

  void Identifier_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->use_parser_)
      this->use_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->system_parser_)
      this->system_parser_->_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    if (this->assigner_parser_)
      this->assigner_parser_->_reset ();

    this->resetting_ = false;
  }

  // IdentifierUse_list_pskel
  //

  void IdentifierUse_list_pskel::
  post_IdentifierUse_list ()
  {
    if (this->IdentifierUse_list_impl_)
      this->IdentifierUse_list_impl_->post_IdentifierUse_list ();
    else
      post_code_primitive ();
  }

  const char* const IdentifierUse_list_pskel::_xsde_IdentifierUse_list_pskel_enums_[5UL] = 
  {
    "official",
    "old",
    "secondary",
    "temp",
    "usual"
  };

  // IdentifierUse_pskel
  //

  void IdentifierUse_pskel::
  value ()
  {
    if (this->IdentifierUse_impl_)
      this->IdentifierUse_impl_->value ();
  }

  void IdentifierUse_pskel::
  post_IdentifierUse ()
  {
    if (this->IdentifierUse_impl_)
      this->IdentifierUse_impl_->post_IdentifierUse ();
    else
      post_Element ();
  }

  void IdentifierUse_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // SubstanceAmount_pskel
  //

  void SubstanceAmount_pskel::
  amountQuantity ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->amountQuantity ();
  }

  void SubstanceAmount_pskel::
  amountRange ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->amountRange ();
  }

  void SubstanceAmount_pskel::
  amountString ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->amountString ();
  }

  void SubstanceAmount_pskel::
  amountType ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->amountType ();
  }

  void SubstanceAmount_pskel::
  amountText ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->amountText ();
  }

  void SubstanceAmount_pskel::
  referenceRange ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->referenceRange ();
  }

  void SubstanceAmount_pskel::
  post_SubstanceAmount ()
  {
    if (this->SubstanceAmount_impl_)
      this->SubstanceAmount_impl_->post_SubstanceAmount ();
    else
      post_BackboneElement ();
  }

  void SubstanceAmount_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->amountQuantity_parser_)
      this->amountQuantity_parser_->_reset ();

    if (this->amountRange_parser_)
      this->amountRange_parser_->_reset ();

    if (this->amountString_parser_)
      this->amountString_parser_->_reset ();

    if (this->amountType_parser_)
      this->amountType_parser_->_reset ();

    if (this->amountText_parser_)
      this->amountText_parser_->_reset ();

    if (this->referenceRange_parser_)
      this->referenceRange_parser_->_reset ();

    this->resetting_ = false;
  }

  // SubstanceAmount_ReferenceRange_pskel
  //

  void SubstanceAmount_ReferenceRange_pskel::
  lowLimit ()
  {
    if (this->SubstanceAmount_ReferenceRange_impl_)
      this->SubstanceAmount_ReferenceRange_impl_->lowLimit ();
  }

  void SubstanceAmount_ReferenceRange_pskel::
  highLimit ()
  {
    if (this->SubstanceAmount_ReferenceRange_impl_)
      this->SubstanceAmount_ReferenceRange_impl_->highLimit ();
  }

  void SubstanceAmount_ReferenceRange_pskel::
  post_SubstanceAmount_ReferenceRange ()
  {
    if (this->SubstanceAmount_ReferenceRange_impl_)
      this->SubstanceAmount_ReferenceRange_impl_->post_SubstanceAmount_ReferenceRange ();
    else
      post_BackboneElement ();
  }

  void SubstanceAmount_ReferenceRange_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->lowLimit_parser_)
      this->lowLimit_parser_->_reset ();

    if (this->highLimit_parser_)
      this->highLimit_parser_->_reset ();

    this->resetting_ = false;
  }

  // Coding_pskel
  //

  void Coding_pskel::
  system ()
  {
    if (this->Coding_impl_)
      this->Coding_impl_->system ();
  }

  void Coding_pskel::
  version ()
  {
    if (this->Coding_impl_)
      this->Coding_impl_->version ();
  }

  void Coding_pskel::
  code ()
  {
    if (this->Coding_impl_)
      this->Coding_impl_->code ();
  }

  void Coding_pskel::
  display ()
  {
    if (this->Coding_impl_)
      this->Coding_impl_->display ();
  }

  void Coding_pskel::
  userSelected ()
  {
    if (this->Coding_impl_)
      this->Coding_impl_->userSelected ();
  }

  void Coding_pskel::
  post_Coding ()
  {
    if (this->Coding_impl_)
      this->Coding_impl_->post_Coding ();
    else
      post_Element ();
  }

  void Coding_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->system_parser_)
      this->system_parser_->_reset ();

    if (this->version_parser_)
      this->version_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->display_parser_)
      this->display_parser_->_reset ();

    if (this->userSelected_parser_)
      this->userSelected_parser_->_reset ();

    this->resetting_ = false;
  }

  // SampledData_pskel
  //

  void SampledData_pskel::
  origin ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->origin ();
  }

  void SampledData_pskel::
  period ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->period ();
  }

  void SampledData_pskel::
  factor ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->factor ();
  }

  void SampledData_pskel::
  lowerLimit ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->lowerLimit ();
  }

  void SampledData_pskel::
  upperLimit ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->upperLimit ();
  }

  void SampledData_pskel::
  dimensions ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->dimensions ();
  }

  void SampledData_pskel::
  data ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->data ();
  }

  void SampledData_pskel::
  post_SampledData ()
  {
    if (this->SampledData_impl_)
      this->SampledData_impl_->post_SampledData ();
    else
      post_Element ();
  }

  void SampledData_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->origin_parser_)
      this->origin_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    if (this->factor_parser_)
      this->factor_parser_->_reset ();

    if (this->lowerLimit_parser_)
      this->lowerLimit_parser_->_reset ();

    if (this->upperLimit_parser_)
      this->upperLimit_parser_->_reset ();

    if (this->dimensions_parser_)
      this->dimensions_parser_->_reset ();

    if (this->data_parser_)
      this->data_parser_->_reset ();

    this->resetting_ = false;
  }

  // SampledDataDataType_primitive_pskel
  //

  void SampledDataDataType_primitive_pskel::
  post_SampledDataDataType_primitive ()
  {
    if (this->SampledDataDataType_primitive_impl_)
      this->SampledDataDataType_primitive_impl_->post_SampledDataDataType_primitive ();
  }

  ::std::string SampledDataDataType_primitive_pskel::
  post_string ()
  {
    assert (this->string_impl_);
    return this->string_impl_->post_string ();
  }

  // SampledDataDataType_pskel
  //

  void SampledDataDataType_pskel::
  value ()
  {
    if (this->SampledDataDataType_impl_)
      this->SampledDataDataType_impl_->value ();
  }

  void SampledDataDataType_pskel::
  post_SampledDataDataType ()
  {
    if (this->SampledDataDataType_impl_)
      this->SampledDataDataType_impl_->post_SampledDataDataType ();
    else
      post_Element ();
  }

  void SampledDataDataType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Population_pskel
  //

  void Population_pskel::
  ageRange ()
  {
    if (this->Population_impl_)
      this->Population_impl_->ageRange ();
  }

  void Population_pskel::
  ageCodeableConcept ()
  {
    if (this->Population_impl_)
      this->Population_impl_->ageCodeableConcept ();
  }

  void Population_pskel::
  gender ()
  {
    if (this->Population_impl_)
      this->Population_impl_->gender ();
  }

  void Population_pskel::
  race ()
  {
    if (this->Population_impl_)
      this->Population_impl_->race ();
  }

  void Population_pskel::
  physiologicalCondition ()
  {
    if (this->Population_impl_)
      this->Population_impl_->physiologicalCondition ();
  }

  void Population_pskel::
  post_Population ()
  {
    if (this->Population_impl_)
      this->Population_impl_->post_Population ();
    else
      post_BackboneElement ();
  }

  void Population_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->ageRange_parser_)
      this->ageRange_parser_->_reset ();

    if (this->ageCodeableConcept_parser_)
      this->ageCodeableConcept_parser_->_reset ();

    if (this->gender_parser_)
      this->gender_parser_->_reset ();

    if (this->race_parser_)
      this->race_parser_->_reset ();

    if (this->physiologicalCondition_parser_)
      this->physiologicalCondition_parser_->_reset ();

    this->resetting_ = false;
  }

  // Ratio_pskel
  //

  void Ratio_pskel::
  numerator ()
  {
    if (this->Ratio_impl_)
      this->Ratio_impl_->numerator ();
  }

  void Ratio_pskel::
  denominator ()
  {
    if (this->Ratio_impl_)
      this->Ratio_impl_->denominator ();
  }

  void Ratio_pskel::
  post_Ratio ()
  {
    if (this->Ratio_impl_)
      this->Ratio_impl_->post_Ratio ();
    else
      post_Element ();
  }

  void Ratio_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->numerator_parser_)
      this->numerator_parser_->_reset ();

    if (this->denominator_parser_)
      this->denominator_parser_->_reset ();

    this->resetting_ = false;
  }

  // Distance_pskel
  //

  void Distance_pskel::
  post_Distance ()
  {
    if (this->Distance_impl_)
      this->Distance_impl_->post_Distance ();
    else
      post_Quantity ();
  }

  // Age_pskel
  //

  void Age_pskel::
  post_Age ()
  {
    if (this->Age_impl_)
      this->Age_impl_->post_Age ();
    else
      post_Quantity ();
  }

  // Reference_pskel
  //

  void Reference_pskel::
  reference ()
  {
    if (this->Reference_impl_)
      this->Reference_impl_->reference ();
  }

  void Reference_pskel::
  type ()
  {
    if (this->Reference_impl_)
      this->Reference_impl_->type ();
  }

  void Reference_pskel::
  identifier ()
  {
    if (this->Reference_impl_)
      this->Reference_impl_->identifier ();
  }

  void Reference_pskel::
  display ()
  {
    if (this->Reference_impl_)
      this->Reference_impl_->display ();
  }

  void Reference_pskel::
  post_Reference ()
  {
    if (this->Reference_impl_)
      this->Reference_impl_->post_Reference ();
    else
      post_Element ();
  }

  void Reference_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->reference_parser_)
      this->reference_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->display_parser_)
      this->display_parser_->_reset ();

    this->resetting_ = false;
  }

  // TriggerDefinition_pskel
  //

  void TriggerDefinition_pskel::
  type ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->type ();
  }

  void TriggerDefinition_pskel::
  name ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->name ();
  }

  void TriggerDefinition_pskel::
  timingTiming ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->timingTiming ();
  }

  void TriggerDefinition_pskel::
  timingReference ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->timingReference ();
  }

  void TriggerDefinition_pskel::
  timingDate ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->timingDate ();
  }

  void TriggerDefinition_pskel::
  timingDateTime ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->timingDateTime ();
  }

  void TriggerDefinition_pskel::
  data ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->data ();
  }

  void TriggerDefinition_pskel::
  condition ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->condition ();
  }

  void TriggerDefinition_pskel::
  post_TriggerDefinition ()
  {
    if (this->TriggerDefinition_impl_)
      this->TriggerDefinition_impl_->post_TriggerDefinition ();
    else
      post_Element ();
  }

  void TriggerDefinition_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->timingTiming_parser_)
      this->timingTiming_parser_->_reset ();

    if (this->timingReference_parser_)
      this->timingReference_parser_->_reset ();

    if (this->timingDate_parser_)
      this->timingDate_parser_->_reset ();

    if (this->timingDateTime_parser_)
      this->timingDateTime_parser_->_reset ();

    if (this->data_parser_)
      this->data_parser_->_reset ();

    if (this->condition_parser_)
      this->condition_parser_->_reset ();

    this->resetting_ = false;
  }

  // TriggerType_list_pskel
  //

  void TriggerType_list_pskel::
  post_TriggerType_list ()
  {
    if (this->TriggerType_list_impl_)
      this->TriggerType_list_impl_->post_TriggerType_list ();
    else
      post_code_primitive ();
  }

  const char* const TriggerType_list_pskel::_xsde_TriggerType_list_pskel_enums_[8UL] = 
  {
    "data-access-ended",
    "data-accessed",
    "data-added",
    "data-changed",
    "data-modified",
    "data-removed",
    "named-event",
    "periodic"
  };

  // TriggerType_pskel
  //

  void TriggerType_pskel::
  value ()
  {
    if (this->TriggerType_impl_)
      this->TriggerType_impl_->value ();
  }

  void TriggerType_pskel::
  post_TriggerType ()
  {
    if (this->TriggerType_impl_)
      this->TriggerType_impl_->post_TriggerType ();
    else
      post_Element ();
  }

  void TriggerType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // QuantityComparator_list_pskel
  //

  void QuantityComparator_list_pskel::
  post_QuantityComparator_list ()
  {
    if (this->QuantityComparator_list_impl_)
      this->QuantityComparator_list_impl_->post_QuantityComparator_list ();
    else
      post_code_primitive ();
  }

  const char* const QuantityComparator_list_pskel::_xsde_QuantityComparator_list_pskel_enums_[4UL] = 
  {
    "<",
    "<=",
    ">",
    ">="
  };

  // QuantityComparator_pskel
  //

  void QuantityComparator_pskel::
  value ()
  {
    if (this->QuantityComparator_impl_)
      this->QuantityComparator_impl_->value ();
  }

  void QuantityComparator_pskel::
  post_QuantityComparator ()
  {
    if (this->QuantityComparator_impl_)
      this->QuantityComparator_impl_->post_QuantityComparator ();
    else
      post_Element ();
  }

  void QuantityComparator_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Period_pskel
  //

  void Period_pskel::
  start ()
  {
    if (this->Period_impl_)
      this->Period_impl_->start ();
  }

  void Period_pskel::
  end ()
  {
    if (this->Period_impl_)
      this->Period_impl_->end ();
  }

  void Period_pskel::
  post_Period ()
  {
    if (this->Period_impl_)
      this->Period_impl_->post_Period ();
    else
      post_Element ();
  }

  void Period_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->start_parser_)
      this->start_parser_->_reset ();

    if (this->end_parser_)
      this->end_parser_->_reset ();

    this->resetting_ = false;
  }

  // Duration_pskel
  //

  void Duration_pskel::
  post_Duration ()
  {
    if (this->Duration_impl_)
      this->Duration_impl_->post_Duration ();
    else
      post_Quantity ();
  }

  // Range_pskel
  //

  void Range_pskel::
  low ()
  {
    if (this->Range_impl_)
      this->Range_impl_->low ();
  }

  void Range_pskel::
  high ()
  {
    if (this->Range_impl_)
      this->Range_impl_->high ();
  }

  void Range_pskel::
  post_Range ()
  {
    if (this->Range_impl_)
      this->Range_impl_->post_Range ();
    else
      post_Element ();
  }

  void Range_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->low_parser_)
      this->low_parser_->_reset ();

    if (this->high_parser_)
      this->high_parser_->_reset ();

    this->resetting_ = false;
  }

  // RelatedArtifact_pskel
  //

  void RelatedArtifact_pskel::
  type ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->type ();
  }

  void RelatedArtifact_pskel::
  label ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->label ();
  }

  void RelatedArtifact_pskel::
  display ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->display ();
  }

  void RelatedArtifact_pskel::
  citation ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->citation ();
  }

  void RelatedArtifact_pskel::
  url ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->url ();
  }

  void RelatedArtifact_pskel::
  document ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->document ();
  }

  void RelatedArtifact_pskel::
  resource ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->resource ();
  }

  void RelatedArtifact_pskel::
  post_RelatedArtifact ()
  {
    if (this->RelatedArtifact_impl_)
      this->RelatedArtifact_impl_->post_RelatedArtifact ();
    else
      post_Element ();
  }

  void RelatedArtifact_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->label_parser_)
      this->label_parser_->_reset ();

    if (this->display_parser_)
      this->display_parser_->_reset ();

    if (this->citation_parser_)
      this->citation_parser_->_reset ();

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->document_parser_)
      this->document_parser_->_reset ();

    if (this->resource_parser_)
      this->resource_parser_->_reset ();

    this->resetting_ = false;
  }

  // RelatedArtifactType_list_pskel
  //

  void RelatedArtifactType_list_pskel::
  post_RelatedArtifactType_list ()
  {
    if (this->RelatedArtifactType_list_impl_)
      this->RelatedArtifactType_list_impl_->post_RelatedArtifactType_list ();
    else
      post_code_primitive ();
  }

  const char* const RelatedArtifactType_list_pskel::_xsde_RelatedArtifactType_list_pskel_enums_[8UL] = 
  {
    "citation",
    "composed-of",
    "depends-on",
    "derived-from",
    "documentation",
    "justification",
    "predecessor",
    "successor"
  };

  // RelatedArtifactType_pskel
  //

  void RelatedArtifactType_pskel::
  value ()
  {
    if (this->RelatedArtifactType_impl_)
      this->RelatedArtifactType_impl_->value ();
  }

  void RelatedArtifactType_pskel::
  post_RelatedArtifactType ()
  {
    if (this->RelatedArtifactType_impl_)
      this->RelatedArtifactType_impl_->post_RelatedArtifactType ();
    else
      post_Element ();
  }

  void RelatedArtifactType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Annotation_pskel
  //

  void Annotation_pskel::
  authorReference ()
  {
    if (this->Annotation_impl_)
      this->Annotation_impl_->authorReference ();
  }

  void Annotation_pskel::
  authorString ()
  {
    if (this->Annotation_impl_)
      this->Annotation_impl_->authorString ();
  }

  void Annotation_pskel::
  time ()
  {
    if (this->Annotation_impl_)
      this->Annotation_impl_->time ();
  }

  void Annotation_pskel::
  text ()
  {
    if (this->Annotation_impl_)
      this->Annotation_impl_->text ();
  }

  void Annotation_pskel::
  post_Annotation ()
  {
    if (this->Annotation_impl_)
      this->Annotation_impl_->post_Annotation ();
    else
      post_Element ();
  }

  void Annotation_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->authorReference_parser_)
      this->authorReference_parser_->_reset ();

    if (this->authorString_parser_)
      this->authorString_parser_->_reset ();

    if (this->time_parser_)
      this->time_parser_->_reset ();

    if (this->text_parser_)
      this->text_parser_->_reset ();

    this->resetting_ = false;
  }

  // ProductShelfLife_pskel
  //

  void ProductShelfLife_pskel::
  identifier ()
  {
    if (this->ProductShelfLife_impl_)
      this->ProductShelfLife_impl_->identifier ();
  }

  void ProductShelfLife_pskel::
  type ()
  {
    if (this->ProductShelfLife_impl_)
      this->ProductShelfLife_impl_->type ();
  }

  void ProductShelfLife_pskel::
  period ()
  {
    if (this->ProductShelfLife_impl_)
      this->ProductShelfLife_impl_->period ();
  }

  void ProductShelfLife_pskel::
  specialPrecautionsForStorage ()
  {
    if (this->ProductShelfLife_impl_)
      this->ProductShelfLife_impl_->specialPrecautionsForStorage ();
  }

  void ProductShelfLife_pskel::
  post_ProductShelfLife ()
  {
    if (this->ProductShelfLife_impl_)
      this->ProductShelfLife_impl_->post_ProductShelfLife ();
    else
      post_BackboneElement ();
  }

  void ProductShelfLife_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    if (this->specialPrecautionsForStorage_parser_)
      this->specialPrecautionsForStorage_parser_->_reset ();

    this->resetting_ = false;
  }

  // ContactDetail_pskel
  //

  void ContactDetail_pskel::
  name ()
  {
    if (this->ContactDetail_impl_)
      this->ContactDetail_impl_->name ();
  }

  void ContactDetail_pskel::
  telecom ()
  {
    if (this->ContactDetail_impl_)
      this->ContactDetail_impl_->telecom ();
  }

  void ContactDetail_pskel::
  post_ContactDetail ()
  {
    if (this->ContactDetail_impl_)
      this->ContactDetail_impl_->post_ContactDetail ();
    else
      post_Element ();
  }

  void ContactDetail_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->telecom_parser_)
      this->telecom_parser_->_reset ();

    this->resetting_ = false;
  }

  // UsageContext_pskel
  //

  void UsageContext_pskel::
  code ()
  {
    if (this->UsageContext_impl_)
      this->UsageContext_impl_->code ();
  }

  void UsageContext_pskel::
  valueCodeableConcept ()
  {
    if (this->UsageContext_impl_)
      this->UsageContext_impl_->valueCodeableConcept ();
  }

  void UsageContext_pskel::
  valueQuantity ()
  {
    if (this->UsageContext_impl_)
      this->UsageContext_impl_->valueQuantity ();
  }

  void UsageContext_pskel::
  valueRange ()
  {
    if (this->UsageContext_impl_)
      this->UsageContext_impl_->valueRange ();
  }

  void UsageContext_pskel::
  valueReference ()
  {
    if (this->UsageContext_impl_)
      this->UsageContext_impl_->valueReference ();
  }

  void UsageContext_pskel::
  post_UsageContext ()
  {
    if (this->UsageContext_impl_)
      this->UsageContext_impl_->post_UsageContext ();
    else
      post_Element ();
  }

  void UsageContext_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->valueCodeableConcept_parser_)
      this->valueCodeableConcept_parser_->_reset ();

    if (this->valueQuantity_parser_)
      this->valueQuantity_parser_->_reset ();

    if (this->valueRange_parser_)
      this->valueRange_parser_->_reset ();

    if (this->valueReference_parser_)
      this->valueReference_parser_->_reset ();

    this->resetting_ = false;
  }

  // Expression_pskel
  //

  void Expression_pskel::
  description ()
  {
    if (this->Expression_impl_)
      this->Expression_impl_->description ();
  }

  void Expression_pskel::
  name ()
  {
    if (this->Expression_impl_)
      this->Expression_impl_->name ();
  }

  void Expression_pskel::
  language ()
  {
    if (this->Expression_impl_)
      this->Expression_impl_->language ();
  }

  void Expression_pskel::
  expression ()
  {
    if (this->Expression_impl_)
      this->Expression_impl_->expression ();
  }

  void Expression_pskel::
  reference ()
  {
    if (this->Expression_impl_)
      this->Expression_impl_->reference ();
  }

  void Expression_pskel::
  post_Expression ()
  {
    if (this->Expression_impl_)
      this->Expression_impl_->post_Expression ();
    else
      post_Element ();
  }

  void Expression_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->language_parser_)
      this->language_parser_->_reset ();

    if (this->expression_parser_)
      this->expression_parser_->_reset ();

    if (this->reference_parser_)
      this->reference_parser_->_reset ();

    this->resetting_ = false;
  }

  // ExpressionLanguage_list_pskel
  //

  void ExpressionLanguage_list_pskel::
  post_ExpressionLanguage_list ()
  {
    if (this->ExpressionLanguage_list_impl_)
      this->ExpressionLanguage_list_impl_->post_ExpressionLanguage_list ();
    else
      post_code_primitive ();
  }

  const char* const ExpressionLanguage_list_pskel::_xsde_ExpressionLanguage_list_pskel_enums_[3UL] = 
  {
    "application/x-fhir-query",
    "text/cql",
    "text/fhirpath"
  };

  // ExpressionLanguage_pskel
  //

  void ExpressionLanguage_pskel::
  value ()
  {
    if (this->ExpressionLanguage_impl_)
      this->ExpressionLanguage_impl_->value ();
  }

  void ExpressionLanguage_pskel::
  post_ExpressionLanguage ()
  {
    if (this->ExpressionLanguage_impl_)
      this->ExpressionLanguage_impl_->post_ExpressionLanguage ();
    else
      post_Element ();
  }

  void ExpressionLanguage_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Signature_pskel
  //

  void Signature_pskel::
  type ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->type ();
  }

  void Signature_pskel::
  when ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->when ();
  }

  void Signature_pskel::
  who ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->who ();
  }

  void Signature_pskel::
  onBehalfOf ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->onBehalfOf ();
  }

  void Signature_pskel::
  targetFormat ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->targetFormat ();
  }

  void Signature_pskel::
  sigFormat ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->sigFormat ();
  }

  void Signature_pskel::
  data ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->data ();
  }

  void Signature_pskel::
  post_Signature ()
  {
    if (this->Signature_impl_)
      this->Signature_impl_->post_Signature ();
    else
      post_Element ();
  }

  void Signature_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->when_parser_)
      this->when_parser_->_reset ();

    if (this->who_parser_)
      this->who_parser_->_reset ();

    if (this->onBehalfOf_parser_)
      this->onBehalfOf_parser_->_reset ();

    if (this->targetFormat_parser_)
      this->targetFormat_parser_->_reset ();

    if (this->sigFormat_parser_)
      this->sigFormat_parser_->_reset ();

    if (this->data_parser_)
      this->data_parser_->_reset ();

    this->resetting_ = false;
  }

  // Timing_pskel
  //

  void Timing_pskel::
  event ()
  {
    if (this->Timing_impl_)
      this->Timing_impl_->event ();
  }

  void Timing_pskel::
  repeat ()
  {
    if (this->Timing_impl_)
      this->Timing_impl_->repeat ();
  }

  void Timing_pskel::
  code ()
  {
    if (this->Timing_impl_)
      this->Timing_impl_->code ();
  }

  void Timing_pskel::
  post_Timing ()
  {
    if (this->Timing_impl_)
      this->Timing_impl_->post_Timing ();
    else
      post_BackboneElement ();
  }

  void Timing_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->event_parser_)
      this->event_parser_->_reset ();

    if (this->repeat_parser_)
      this->repeat_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    this->resetting_ = false;
  }

  // Timing_Repeat_pskel
  //

  void Timing_Repeat_pskel::
  boundsDuration ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->boundsDuration ();
  }

  void Timing_Repeat_pskel::
  boundsRange ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->boundsRange ();
  }

  void Timing_Repeat_pskel::
  boundsPeriod ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->boundsPeriod ();
  }

  void Timing_Repeat_pskel::
  count ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->count ();
  }

  void Timing_Repeat_pskel::
  countMax ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->countMax ();
  }

  void Timing_Repeat_pskel::
  duration ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->duration ();
  }

  void Timing_Repeat_pskel::
  durationMax ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->durationMax ();
  }

  void Timing_Repeat_pskel::
  durationUnit ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->durationUnit ();
  }

  void Timing_Repeat_pskel::
  frequency ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->frequency ();
  }

  void Timing_Repeat_pskel::
  frequencyMax ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->frequencyMax ();
  }

  void Timing_Repeat_pskel::
  period ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->period ();
  }

  void Timing_Repeat_pskel::
  periodMax ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->periodMax ();
  }

  void Timing_Repeat_pskel::
  periodUnit ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->periodUnit ();
  }

  void Timing_Repeat_pskel::
  dayOfWeek ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->dayOfWeek ();
  }

  void Timing_Repeat_pskel::
  timeOfDay ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->timeOfDay ();
  }

  void Timing_Repeat_pskel::
  when ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->when ();
  }

  void Timing_Repeat_pskel::
  offset ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->offset ();
  }

  void Timing_Repeat_pskel::
  post_Timing_Repeat ()
  {
    if (this->Timing_Repeat_impl_)
      this->Timing_Repeat_impl_->post_Timing_Repeat ();
    else
      post_BackboneElement ();
  }

  void Timing_Repeat_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->boundsDuration_parser_)
      this->boundsDuration_parser_->_reset ();

    if (this->boundsRange_parser_)
      this->boundsRange_parser_->_reset ();

    if (this->boundsPeriod_parser_)
      this->boundsPeriod_parser_->_reset ();

    if (this->count_parser_)
      this->count_parser_->_reset ();

    if (this->countMax_parser_)
      this->countMax_parser_->_reset ();

    if (this->duration_parser_)
      this->duration_parser_->_reset ();

    if (this->durationMax_parser_)
      this->durationMax_parser_->_reset ();

    if (this->durationUnit_parser_)
      this->durationUnit_parser_->_reset ();

    if (this->frequency_parser_)
      this->frequency_parser_->_reset ();

    if (this->frequencyMax_parser_)
      this->frequencyMax_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    if (this->periodMax_parser_)
      this->periodMax_parser_->_reset ();

    if (this->periodUnit_parser_)
      this->periodUnit_parser_->_reset ();

    if (this->dayOfWeek_parser_)
      this->dayOfWeek_parser_->_reset ();

    if (this->timeOfDay_parser_)
      this->timeOfDay_parser_->_reset ();

    if (this->when_parser_)
      this->when_parser_->_reset ();

    if (this->offset_parser_)
      this->offset_parser_->_reset ();

    this->resetting_ = false;
  }

  // UnitsOfTime_list_pskel
  //

  void UnitsOfTime_list_pskel::
  post_UnitsOfTime_list ()
  {
    if (this->UnitsOfTime_list_impl_)
      this->UnitsOfTime_list_impl_->post_UnitsOfTime_list ();
    else
      post_code_primitive ();
  }

  const char* const UnitsOfTime_list_pskel::_xsde_UnitsOfTime_list_pskel_enums_[7UL] = 
  {
    "a",
    "d",
    "h",
    "min",
    "mo",
    "s",
    "wk"
  };

  // UnitsOfTime_pskel
  //

  void UnitsOfTime_pskel::
  value ()
  {
    if (this->UnitsOfTime_impl_)
      this->UnitsOfTime_impl_->value ();
  }

  void UnitsOfTime_pskel::
  post_UnitsOfTime ()
  {
    if (this->UnitsOfTime_impl_)
      this->UnitsOfTime_impl_->post_UnitsOfTime ();
    else
      post_Element ();
  }

  void UnitsOfTime_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // EventTiming_list_pskel
  //

  void EventTiming_list_pskel::
  post_EventTiming_list ()
  {
    if (this->EventTiming_list_impl_)
      this->EventTiming_list_impl_->post_EventTiming_list ();
    else
      post_code_primitive ();
  }

  const char* const EventTiming_list_pskel::_xsde_EventTiming_list_pskel_enums_[26UL] = 
  {
    "AC",
    "ACD",
    "ACM",
    "ACV",
    "AFT",
    "AFT.early",
    "AFT.late",
    "C",
    "CD",
    "CM",
    "CV",
    "EVE",
    "EVE.early",
    "EVE.late",
    "HS",
    "MORN",
    "MORN.early",
    "MORN.late",
    "NIGHT",
    "NOON",
    "PC",
    "PCD",
    "PCM",
    "PCV",
    "PHS",
    "WAKE"
  };

  // EventTiming_pskel
  //

  void EventTiming_pskel::
  value ()
  {
    if (this->EventTiming_impl_)
      this->EventTiming_impl_->value ();
  }

  void EventTiming_pskel::
  post_EventTiming ()
  {
    if (this->EventTiming_impl_)
      this->EventTiming_impl_->post_EventTiming ();
    else
      post_Element ();
  }

  void EventTiming_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ProdCharacteristic_pskel
  //

  void ProdCharacteristic_pskel::
  height ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->height ();
  }

  void ProdCharacteristic_pskel::
  width ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->width ();
  }

  void ProdCharacteristic_pskel::
  depth ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->depth ();
  }

  void ProdCharacteristic_pskel::
  weight ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->weight ();
  }

  void ProdCharacteristic_pskel::
  nominalVolume ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->nominalVolume ();
  }

  void ProdCharacteristic_pskel::
  externalDiameter ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->externalDiameter ();
  }

  void ProdCharacteristic_pskel::
  shape ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->shape ();
  }

  void ProdCharacteristic_pskel::
  color ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->color ();
  }

  void ProdCharacteristic_pskel::
  imprint ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->imprint ();
  }

  void ProdCharacteristic_pskel::
  image ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->image ();
  }

  void ProdCharacteristic_pskel::
  scoring ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->scoring ();
  }

  void ProdCharacteristic_pskel::
  post_ProdCharacteristic ()
  {
    if (this->ProdCharacteristic_impl_)
      this->ProdCharacteristic_impl_->post_ProdCharacteristic ();
    else
      post_BackboneElement ();
  }

  void ProdCharacteristic_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->height_parser_)
      this->height_parser_->_reset ();

    if (this->width_parser_)
      this->width_parser_->_reset ();

    if (this->depth_parser_)
      this->depth_parser_->_reset ();

    if (this->weight_parser_)
      this->weight_parser_->_reset ();

    if (this->nominalVolume_parser_)
      this->nominalVolume_parser_->_reset ();

    if (this->externalDiameter_parser_)
      this->externalDiameter_parser_->_reset ();

    if (this->shape_parser_)
      this->shape_parser_->_reset ();

    if (this->color_parser_)
      this->color_parser_->_reset ();

    if (this->imprint_parser_)
      this->imprint_parser_->_reset ();

    if (this->image_parser_)
      this->image_parser_->_reset ();

    if (this->scoring_parser_)
      this->scoring_parser_->_reset ();

    this->resetting_ = false;
  }

  // CodeableConcept_pskel
  //

  void CodeableConcept_pskel::
  coding ()
  {
    if (this->CodeableConcept_impl_)
      this->CodeableConcept_impl_->coding ();
  }

  void CodeableConcept_pskel::
  text ()
  {
    if (this->CodeableConcept_impl_)
      this->CodeableConcept_impl_->text ();
  }

  void CodeableConcept_pskel::
  post_CodeableConcept ()
  {
    if (this->CodeableConcept_impl_)
      this->CodeableConcept_impl_->post_CodeableConcept ();
    else
      post_Element ();
  }

  void CodeableConcept_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->coding_parser_)
      this->coding_parser_->_reset ();

    if (this->text_parser_)
      this->text_parser_->_reset ();

    this->resetting_ = false;
  }

  // ParameterDefinition_pskel
  //

  void ParameterDefinition_pskel::
  name ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->name ();
  }

  void ParameterDefinition_pskel::
  use ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->use ();
  }

  void ParameterDefinition_pskel::
  min ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->min ();
  }

  void ParameterDefinition_pskel::
  max ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->max ();
  }

  void ParameterDefinition_pskel::
  documentation ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->documentation ();
  }

  void ParameterDefinition_pskel::
  type ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->type ();
  }

  void ParameterDefinition_pskel::
  profile ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->profile ();
  }

  void ParameterDefinition_pskel::
  post_ParameterDefinition ()
  {
    if (this->ParameterDefinition_impl_)
      this->ParameterDefinition_impl_->post_ParameterDefinition ();
    else
      post_Element ();
  }

  void ParameterDefinition_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Element_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->use_parser_)
      this->use_parser_->_reset ();

    if (this->min_parser_)
      this->min_parser_->_reset ();

    if (this->max_parser_)
      this->max_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_pskel
  //

  void ElementDefinition_pskel::
  path ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->path ();
  }

  void ElementDefinition_pskel::
  representation ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->representation ();
  }

  void ElementDefinition_pskel::
  sliceName ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->sliceName ();
  }

  void ElementDefinition_pskel::
  sliceIsConstraining ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->sliceIsConstraining ();
  }

  void ElementDefinition_pskel::
  label ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->label ();
  }

  void ElementDefinition_pskel::
  code ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->code ();
  }

  void ElementDefinition_pskel::
  slicing ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->slicing ();
  }

  void ElementDefinition_pskel::
  short_ ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->short_ ();
  }

  void ElementDefinition_pskel::
  definition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->definition ();
  }

  void ElementDefinition_pskel::
  comment ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->comment ();
  }

  void ElementDefinition_pskel::
  requirements ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->requirements ();
  }

  void ElementDefinition_pskel::
  alias ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->alias ();
  }

  void ElementDefinition_pskel::
  min ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->min ();
  }

  void ElementDefinition_pskel::
  max ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->max ();
  }

  void ElementDefinition_pskel::
  base ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->base ();
  }

  void ElementDefinition_pskel::
  contentReference ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->contentReference ();
  }

  void ElementDefinition_pskel::
  type ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->type ();
  }

  void ElementDefinition_pskel::
  defaultValueBase64Binary ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueBase64Binary ();
  }

  void ElementDefinition_pskel::
  defaultValueBoolean ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueBoolean ();
  }

  void ElementDefinition_pskel::
  defaultValueCanonical ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueCanonical ();
  }

  void ElementDefinition_pskel::
  defaultValueCode ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueCode ();
  }

  void ElementDefinition_pskel::
  defaultValueDate ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDate ();
  }

  void ElementDefinition_pskel::
  defaultValueDateTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDateTime ();
  }

  void ElementDefinition_pskel::
  defaultValueDecimal ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDecimal ();
  }

  void ElementDefinition_pskel::
  defaultValueId ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueId ();
  }

  void ElementDefinition_pskel::
  defaultValueInstant ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueInstant ();
  }

  void ElementDefinition_pskel::
  defaultValueInteger ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueInteger ();
  }

  void ElementDefinition_pskel::
  defaultValueMarkdown ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueMarkdown ();
  }

  void ElementDefinition_pskel::
  defaultValueOid ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueOid ();
  }

  void ElementDefinition_pskel::
  defaultValuePositiveInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValuePositiveInt ();
  }

  void ElementDefinition_pskel::
  defaultValueString ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueString ();
  }

  void ElementDefinition_pskel::
  defaultValueTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueTime ();
  }

  void ElementDefinition_pskel::
  defaultValueUnsignedInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueUnsignedInt ();
  }

  void ElementDefinition_pskel::
  defaultValueUri ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueUri ();
  }

  void ElementDefinition_pskel::
  defaultValueUrl ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueUrl ();
  }

  void ElementDefinition_pskel::
  defaultValueUuid ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueUuid ();
  }

  void ElementDefinition_pskel::
  defaultValueAddress ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueAddress ();
  }

  void ElementDefinition_pskel::
  defaultValueAge ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueAge ();
  }

  void ElementDefinition_pskel::
  defaultValueAnnotation ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueAnnotation ();
  }

  void ElementDefinition_pskel::
  defaultValueAttachment ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueAttachment ();
  }

  void ElementDefinition_pskel::
  defaultValueCodeableConcept ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueCodeableConcept ();
  }

  void ElementDefinition_pskel::
  defaultValueCoding ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueCoding ();
  }

  void ElementDefinition_pskel::
  defaultValueContactPoint ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueContactPoint ();
  }

  void ElementDefinition_pskel::
  defaultValueCount ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueCount ();
  }

  void ElementDefinition_pskel::
  defaultValueDistance ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDistance ();
  }

  void ElementDefinition_pskel::
  defaultValueDuration ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDuration ();
  }

  void ElementDefinition_pskel::
  defaultValueHumanName ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueHumanName ();
  }

  void ElementDefinition_pskel::
  defaultValueIdentifier ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueIdentifier ();
  }

  void ElementDefinition_pskel::
  defaultValueMoney ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueMoney ();
  }

  void ElementDefinition_pskel::
  defaultValuePeriod ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValuePeriod ();
  }

  void ElementDefinition_pskel::
  defaultValueQuantity ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueQuantity ();
  }

  void ElementDefinition_pskel::
  defaultValueRange ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueRange ();
  }

  void ElementDefinition_pskel::
  defaultValueRatio ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueRatio ();
  }

  void ElementDefinition_pskel::
  defaultValueReference ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueReference ();
  }

  void ElementDefinition_pskel::
  defaultValueSampledData ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueSampledData ();
  }

  void ElementDefinition_pskel::
  defaultValueSignature ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueSignature ();
  }

  void ElementDefinition_pskel::
  defaultValueTiming ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueTiming ();
  }

  void ElementDefinition_pskel::
  defaultValueContactDetail ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueContactDetail ();
  }

  void ElementDefinition_pskel::
  defaultValueContributor ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueContributor ();
  }

  void ElementDefinition_pskel::
  defaultValueDataRequirement ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDataRequirement ();
  }

  void ElementDefinition_pskel::
  defaultValueExpression ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueExpression ();
  }

  void ElementDefinition_pskel::
  defaultValueParameterDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueParameterDefinition ();
  }

  void ElementDefinition_pskel::
  defaultValueRelatedArtifact ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueRelatedArtifact ();
  }

  void ElementDefinition_pskel::
  defaultValueTriggerDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueTriggerDefinition ();
  }

  void ElementDefinition_pskel::
  defaultValueUsageContext ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueUsageContext ();
  }

  void ElementDefinition_pskel::
  defaultValueDosage ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueDosage ();
  }

  void ElementDefinition_pskel::
  defaultValueMeta ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->defaultValueMeta ();
  }

  void ElementDefinition_pskel::
  meaningWhenMissing ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->meaningWhenMissing ();
  }

  void ElementDefinition_pskel::
  orderMeaning ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->orderMeaning ();
  }

  void ElementDefinition_pskel::
  fixedBase64Binary ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedBase64Binary ();
  }

  void ElementDefinition_pskel::
  fixedBoolean ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedBoolean ();
  }

  void ElementDefinition_pskel::
  fixedCanonical ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedCanonical ();
  }

  void ElementDefinition_pskel::
  fixedCode ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedCode ();
  }

  void ElementDefinition_pskel::
  fixedDate ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDate ();
  }

  void ElementDefinition_pskel::
  fixedDateTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDateTime ();
  }

  void ElementDefinition_pskel::
  fixedDecimal ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDecimal ();
  }

  void ElementDefinition_pskel::
  fixedId ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedId ();
  }

  void ElementDefinition_pskel::
  fixedInstant ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedInstant ();
  }

  void ElementDefinition_pskel::
  fixedInteger ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedInteger ();
  }

  void ElementDefinition_pskel::
  fixedMarkdown ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedMarkdown ();
  }

  void ElementDefinition_pskel::
  fixedOid ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedOid ();
  }

  void ElementDefinition_pskel::
  fixedPositiveInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedPositiveInt ();
  }

  void ElementDefinition_pskel::
  fixedString ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedString ();
  }

  void ElementDefinition_pskel::
  fixedTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedTime ();
  }

  void ElementDefinition_pskel::
  fixedUnsignedInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedUnsignedInt ();
  }

  void ElementDefinition_pskel::
  fixedUri ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedUri ();
  }

  void ElementDefinition_pskel::
  fixedUrl ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedUrl ();
  }

  void ElementDefinition_pskel::
  fixedUuid ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedUuid ();
  }

  void ElementDefinition_pskel::
  fixedAddress ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedAddress ();
  }

  void ElementDefinition_pskel::
  fixedAge ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedAge ();
  }

  void ElementDefinition_pskel::
  fixedAnnotation ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedAnnotation ();
  }

  void ElementDefinition_pskel::
  fixedAttachment ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedAttachment ();
  }

  void ElementDefinition_pskel::
  fixedCodeableConcept ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedCodeableConcept ();
  }

  void ElementDefinition_pskel::
  fixedCoding ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedCoding ();
  }

  void ElementDefinition_pskel::
  fixedContactPoint ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedContactPoint ();
  }

  void ElementDefinition_pskel::
  fixedCount ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedCount ();
  }

  void ElementDefinition_pskel::
  fixedDistance ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDistance ();
  }

  void ElementDefinition_pskel::
  fixedDuration ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDuration ();
  }

  void ElementDefinition_pskel::
  fixedHumanName ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedHumanName ();
  }

  void ElementDefinition_pskel::
  fixedIdentifier ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedIdentifier ();
  }

  void ElementDefinition_pskel::
  fixedMoney ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedMoney ();
  }

  void ElementDefinition_pskel::
  fixedPeriod ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedPeriod ();
  }

  void ElementDefinition_pskel::
  fixedQuantity ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedQuantity ();
  }

  void ElementDefinition_pskel::
  fixedRange ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedRange ();
  }

  void ElementDefinition_pskel::
  fixedRatio ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedRatio ();
  }

  void ElementDefinition_pskel::
  fixedReference ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedReference ();
  }

  void ElementDefinition_pskel::
  fixedSampledData ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedSampledData ();
  }

  void ElementDefinition_pskel::
  fixedSignature ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedSignature ();
  }

  void ElementDefinition_pskel::
  fixedTiming ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedTiming ();
  }

  void ElementDefinition_pskel::
  fixedContactDetail ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedContactDetail ();
  }

  void ElementDefinition_pskel::
  fixedContributor ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedContributor ();
  }

  void ElementDefinition_pskel::
  fixedDataRequirement ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDataRequirement ();
  }

  void ElementDefinition_pskel::
  fixedExpression ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedExpression ();
  }

  void ElementDefinition_pskel::
  fixedParameterDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedParameterDefinition ();
  }

  void ElementDefinition_pskel::
  fixedRelatedArtifact ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedRelatedArtifact ();
  }

  void ElementDefinition_pskel::
  fixedTriggerDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedTriggerDefinition ();
  }

  void ElementDefinition_pskel::
  fixedUsageContext ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedUsageContext ();
  }

  void ElementDefinition_pskel::
  fixedDosage ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedDosage ();
  }

  void ElementDefinition_pskel::
  fixedMeta ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->fixedMeta ();
  }

  void ElementDefinition_pskel::
  patternBase64Binary ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternBase64Binary ();
  }

  void ElementDefinition_pskel::
  patternBoolean ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternBoolean ();
  }

  void ElementDefinition_pskel::
  patternCanonical ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternCanonical ();
  }

  void ElementDefinition_pskel::
  patternCode ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternCode ();
  }

  void ElementDefinition_pskel::
  patternDate ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDate ();
  }

  void ElementDefinition_pskel::
  patternDateTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDateTime ();
  }

  void ElementDefinition_pskel::
  patternDecimal ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDecimal ();
  }

  void ElementDefinition_pskel::
  patternId ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternId ();
  }

  void ElementDefinition_pskel::
  patternInstant ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternInstant ();
  }

  void ElementDefinition_pskel::
  patternInteger ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternInteger ();
  }

  void ElementDefinition_pskel::
  patternMarkdown ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternMarkdown ();
  }

  void ElementDefinition_pskel::
  patternOid ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternOid ();
  }

  void ElementDefinition_pskel::
  patternPositiveInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternPositiveInt ();
  }

  void ElementDefinition_pskel::
  patternString ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternString ();
  }

  void ElementDefinition_pskel::
  patternTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternTime ();
  }

  void ElementDefinition_pskel::
  patternUnsignedInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternUnsignedInt ();
  }

  void ElementDefinition_pskel::
  patternUri ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternUri ();
  }

  void ElementDefinition_pskel::
  patternUrl ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternUrl ();
  }

  void ElementDefinition_pskel::
  patternUuid ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternUuid ();
  }

  void ElementDefinition_pskel::
  patternAddress ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternAddress ();
  }

  void ElementDefinition_pskel::
  patternAge ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternAge ();
  }

  void ElementDefinition_pskel::
  patternAnnotation ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternAnnotation ();
  }

  void ElementDefinition_pskel::
  patternAttachment ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternAttachment ();
  }

  void ElementDefinition_pskel::
  patternCodeableConcept ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternCodeableConcept ();
  }

  void ElementDefinition_pskel::
  patternCoding ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternCoding ();
  }

  void ElementDefinition_pskel::
  patternContactPoint ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternContactPoint ();
  }

  void ElementDefinition_pskel::
  patternCount ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternCount ();
  }

  void ElementDefinition_pskel::
  patternDistance ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDistance ();
  }

  void ElementDefinition_pskel::
  patternDuration ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDuration ();
  }

  void ElementDefinition_pskel::
  patternHumanName ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternHumanName ();
  }

  void ElementDefinition_pskel::
  patternIdentifier ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternIdentifier ();
  }

  void ElementDefinition_pskel::
  patternMoney ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternMoney ();
  }

  void ElementDefinition_pskel::
  patternPeriod ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternPeriod ();
  }

  void ElementDefinition_pskel::
  patternQuantity ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternQuantity ();
  }

  void ElementDefinition_pskel::
  patternRange ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternRange ();
  }

  void ElementDefinition_pskel::
  patternRatio ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternRatio ();
  }

  void ElementDefinition_pskel::
  patternReference ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternReference ();
  }

  void ElementDefinition_pskel::
  patternSampledData ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternSampledData ();
  }

  void ElementDefinition_pskel::
  patternSignature ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternSignature ();
  }

  void ElementDefinition_pskel::
  patternTiming ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternTiming ();
  }

  void ElementDefinition_pskel::
  patternContactDetail ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternContactDetail ();
  }

  void ElementDefinition_pskel::
  patternContributor ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternContributor ();
  }

  void ElementDefinition_pskel::
  patternDataRequirement ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDataRequirement ();
  }

  void ElementDefinition_pskel::
  patternExpression ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternExpression ();
  }

  void ElementDefinition_pskel::
  patternParameterDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternParameterDefinition ();
  }

  void ElementDefinition_pskel::
  patternRelatedArtifact ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternRelatedArtifact ();
  }

  void ElementDefinition_pskel::
  patternTriggerDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternTriggerDefinition ();
  }

  void ElementDefinition_pskel::
  patternUsageContext ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternUsageContext ();
  }

  void ElementDefinition_pskel::
  patternDosage ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternDosage ();
  }

  void ElementDefinition_pskel::
  patternMeta ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->patternMeta ();
  }

  void ElementDefinition_pskel::
  example ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->example ();
  }

  void ElementDefinition_pskel::
  minValueDate ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueDate ();
  }

  void ElementDefinition_pskel::
  minValueDateTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueDateTime ();
  }

  void ElementDefinition_pskel::
  minValueInstant ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueInstant ();
  }

  void ElementDefinition_pskel::
  minValueTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueTime ();
  }

  void ElementDefinition_pskel::
  minValueDecimal ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueDecimal ();
  }

  void ElementDefinition_pskel::
  minValueInteger ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueInteger ();
  }

  void ElementDefinition_pskel::
  minValuePositiveInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValuePositiveInt ();
  }

  void ElementDefinition_pskel::
  minValueUnsignedInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueUnsignedInt ();
  }

  void ElementDefinition_pskel::
  minValueQuantity ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->minValueQuantity ();
  }

  void ElementDefinition_pskel::
  maxValueDate ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueDate ();
  }

  void ElementDefinition_pskel::
  maxValueDateTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueDateTime ();
  }

  void ElementDefinition_pskel::
  maxValueInstant ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueInstant ();
  }

  void ElementDefinition_pskel::
  maxValueTime ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueTime ();
  }

  void ElementDefinition_pskel::
  maxValueDecimal ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueDecimal ();
  }

  void ElementDefinition_pskel::
  maxValueInteger ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueInteger ();
  }

  void ElementDefinition_pskel::
  maxValuePositiveInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValuePositiveInt ();
  }

  void ElementDefinition_pskel::
  maxValueUnsignedInt ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueUnsignedInt ();
  }

  void ElementDefinition_pskel::
  maxValueQuantity ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxValueQuantity ();
  }

  void ElementDefinition_pskel::
  maxLength ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->maxLength ();
  }

  void ElementDefinition_pskel::
  condition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->condition ();
  }

  void ElementDefinition_pskel::
  constraint ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->constraint ();
  }

  void ElementDefinition_pskel::
  mustSupport ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->mustSupport ();
  }

  void ElementDefinition_pskel::
  isModifier ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->isModifier ();
  }

  void ElementDefinition_pskel::
  isModifierReason ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->isModifierReason ();
  }

  void ElementDefinition_pskel::
  isSummary ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->isSummary ();
  }

  void ElementDefinition_pskel::
  binding ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->binding ();
  }

  void ElementDefinition_pskel::
  mapping ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->mapping ();
  }

  void ElementDefinition_pskel::
  post_ElementDefinition ()
  {
    if (this->ElementDefinition_impl_)
      this->ElementDefinition_impl_->post_ElementDefinition ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->representation_parser_)
      this->representation_parser_->_reset ();

    if (this->sliceName_parser_)
      this->sliceName_parser_->_reset ();

    if (this->sliceIsConstraining_parser_)
      this->sliceIsConstraining_parser_->_reset ();

    if (this->label_parser_)
      this->label_parser_->_reset ();

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->slicing_parser_)
      this->slicing_parser_->_reset ();

    if (this->short__parser_)
      this->short__parser_->_reset ();

    if (this->definition_parser_)
      this->definition_parser_->_reset ();

    if (this->comment_parser_)
      this->comment_parser_->_reset ();

    if (this->requirements_parser_)
      this->requirements_parser_->_reset ();

    if (this->alias_parser_)
      this->alias_parser_->_reset ();

    if (this->min_parser_)
      this->min_parser_->_reset ();

    if (this->max_parser_)
      this->max_parser_->_reset ();

    if (this->base_parser_)
      this->base_parser_->_reset ();

    if (this->contentReference_parser_)
      this->contentReference_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->defaultValueBase64Binary_parser_)
      this->defaultValueBase64Binary_parser_->_reset ();

    if (this->defaultValueBoolean_parser_)
      this->defaultValueBoolean_parser_->_reset ();

    if (this->defaultValueCanonical_parser_)
      this->defaultValueCanonical_parser_->_reset ();

    if (this->defaultValueCode_parser_)
      this->defaultValueCode_parser_->_reset ();

    if (this->defaultValueDate_parser_)
      this->defaultValueDate_parser_->_reset ();

    if (this->defaultValueDateTime_parser_)
      this->defaultValueDateTime_parser_->_reset ();

    if (this->defaultValueDecimal_parser_)
      this->defaultValueDecimal_parser_->_reset ();

    if (this->defaultValueId_parser_)
      this->defaultValueId_parser_->_reset ();

    if (this->defaultValueInstant_parser_)
      this->defaultValueInstant_parser_->_reset ();

    if (this->defaultValueInteger_parser_)
      this->defaultValueInteger_parser_->_reset ();

    if (this->defaultValueMarkdown_parser_)
      this->defaultValueMarkdown_parser_->_reset ();

    if (this->defaultValueOid_parser_)
      this->defaultValueOid_parser_->_reset ();

    if (this->defaultValuePositiveInt_parser_)
      this->defaultValuePositiveInt_parser_->_reset ();

    if (this->defaultValueString_parser_)
      this->defaultValueString_parser_->_reset ();

    if (this->defaultValueTime_parser_)
      this->defaultValueTime_parser_->_reset ();

    if (this->defaultValueUnsignedInt_parser_)
      this->defaultValueUnsignedInt_parser_->_reset ();

    if (this->defaultValueUri_parser_)
      this->defaultValueUri_parser_->_reset ();

    if (this->defaultValueUrl_parser_)
      this->defaultValueUrl_parser_->_reset ();

    if (this->defaultValueUuid_parser_)
      this->defaultValueUuid_parser_->_reset ();

    if (this->defaultValueAddress_parser_)
      this->defaultValueAddress_parser_->_reset ();

    if (this->defaultValueAge_parser_)
      this->defaultValueAge_parser_->_reset ();

    if (this->defaultValueAnnotation_parser_)
      this->defaultValueAnnotation_parser_->_reset ();

    if (this->defaultValueAttachment_parser_)
      this->defaultValueAttachment_parser_->_reset ();

    if (this->defaultValueCodeableConcept_parser_)
      this->defaultValueCodeableConcept_parser_->_reset ();

    if (this->defaultValueCoding_parser_)
      this->defaultValueCoding_parser_->_reset ();

    if (this->defaultValueContactPoint_parser_)
      this->defaultValueContactPoint_parser_->_reset ();

    if (this->defaultValueCount_parser_)
      this->defaultValueCount_parser_->_reset ();

    if (this->defaultValueDistance_parser_)
      this->defaultValueDistance_parser_->_reset ();

    if (this->defaultValueDuration_parser_)
      this->defaultValueDuration_parser_->_reset ();

    if (this->defaultValueHumanName_parser_)
      this->defaultValueHumanName_parser_->_reset ();

    if (this->defaultValueIdentifier_parser_)
      this->defaultValueIdentifier_parser_->_reset ();

    if (this->defaultValueMoney_parser_)
      this->defaultValueMoney_parser_->_reset ();

    if (this->defaultValuePeriod_parser_)
      this->defaultValuePeriod_parser_->_reset ();

    if (this->defaultValueQuantity_parser_)
      this->defaultValueQuantity_parser_->_reset ();

    if (this->defaultValueRange_parser_)
      this->defaultValueRange_parser_->_reset ();

    if (this->defaultValueRatio_parser_)
      this->defaultValueRatio_parser_->_reset ();

    if (this->defaultValueReference_parser_)
      this->defaultValueReference_parser_->_reset ();

    if (this->defaultValueSampledData_parser_)
      this->defaultValueSampledData_parser_->_reset ();

    if (this->defaultValueSignature_parser_)
      this->defaultValueSignature_parser_->_reset ();

    if (this->defaultValueTiming_parser_)
      this->defaultValueTiming_parser_->_reset ();

    if (this->defaultValueContactDetail_parser_)
      this->defaultValueContactDetail_parser_->_reset ();

    if (this->defaultValueContributor_parser_)
      this->defaultValueContributor_parser_->_reset ();

    if (this->defaultValueDataRequirement_parser_)
      this->defaultValueDataRequirement_parser_->_reset ();

    if (this->defaultValueExpression_parser_)
      this->defaultValueExpression_parser_->_reset ();

    if (this->defaultValueParameterDefinition_parser_)
      this->defaultValueParameterDefinition_parser_->_reset ();

    if (this->defaultValueRelatedArtifact_parser_)
      this->defaultValueRelatedArtifact_parser_->_reset ();

    if (this->defaultValueTriggerDefinition_parser_)
      this->defaultValueTriggerDefinition_parser_->_reset ();

    if (this->defaultValueUsageContext_parser_)
      this->defaultValueUsageContext_parser_->_reset ();

    if (this->defaultValueDosage_parser_)
      this->defaultValueDosage_parser_->_reset ();

    if (this->defaultValueMeta_parser_)
      this->defaultValueMeta_parser_->_reset ();

    if (this->meaningWhenMissing_parser_)
      this->meaningWhenMissing_parser_->_reset ();

    if (this->orderMeaning_parser_)
      this->orderMeaning_parser_->_reset ();

    if (this->fixedBase64Binary_parser_)
      this->fixedBase64Binary_parser_->_reset ();

    if (this->fixedBoolean_parser_)
      this->fixedBoolean_parser_->_reset ();

    if (this->fixedCanonical_parser_)
      this->fixedCanonical_parser_->_reset ();

    if (this->fixedCode_parser_)
      this->fixedCode_parser_->_reset ();

    if (this->fixedDate_parser_)
      this->fixedDate_parser_->_reset ();

    if (this->fixedDateTime_parser_)
      this->fixedDateTime_parser_->_reset ();

    if (this->fixedDecimal_parser_)
      this->fixedDecimal_parser_->_reset ();

    if (this->fixedId_parser_)
      this->fixedId_parser_->_reset ();

    if (this->fixedInstant_parser_)
      this->fixedInstant_parser_->_reset ();

    if (this->fixedInteger_parser_)
      this->fixedInteger_parser_->_reset ();

    if (this->fixedMarkdown_parser_)
      this->fixedMarkdown_parser_->_reset ();

    if (this->fixedOid_parser_)
      this->fixedOid_parser_->_reset ();

    if (this->fixedPositiveInt_parser_)
      this->fixedPositiveInt_parser_->_reset ();

    if (this->fixedString_parser_)
      this->fixedString_parser_->_reset ();

    if (this->fixedTime_parser_)
      this->fixedTime_parser_->_reset ();

    if (this->fixedUnsignedInt_parser_)
      this->fixedUnsignedInt_parser_->_reset ();

    if (this->fixedUri_parser_)
      this->fixedUri_parser_->_reset ();

    if (this->fixedUrl_parser_)
      this->fixedUrl_parser_->_reset ();

    if (this->fixedUuid_parser_)
      this->fixedUuid_parser_->_reset ();

    if (this->fixedAddress_parser_)
      this->fixedAddress_parser_->_reset ();

    if (this->fixedAge_parser_)
      this->fixedAge_parser_->_reset ();

    if (this->fixedAnnotation_parser_)
      this->fixedAnnotation_parser_->_reset ();

    if (this->fixedAttachment_parser_)
      this->fixedAttachment_parser_->_reset ();

    if (this->fixedCodeableConcept_parser_)
      this->fixedCodeableConcept_parser_->_reset ();

    if (this->fixedCoding_parser_)
      this->fixedCoding_parser_->_reset ();

    if (this->fixedContactPoint_parser_)
      this->fixedContactPoint_parser_->_reset ();

    if (this->fixedCount_parser_)
      this->fixedCount_parser_->_reset ();

    if (this->fixedDistance_parser_)
      this->fixedDistance_parser_->_reset ();

    if (this->fixedDuration_parser_)
      this->fixedDuration_parser_->_reset ();

    if (this->fixedHumanName_parser_)
      this->fixedHumanName_parser_->_reset ();

    if (this->fixedIdentifier_parser_)
      this->fixedIdentifier_parser_->_reset ();

    if (this->fixedMoney_parser_)
      this->fixedMoney_parser_->_reset ();

    if (this->fixedPeriod_parser_)
      this->fixedPeriod_parser_->_reset ();

    if (this->fixedQuantity_parser_)
      this->fixedQuantity_parser_->_reset ();

    if (this->fixedRange_parser_)
      this->fixedRange_parser_->_reset ();

    if (this->fixedRatio_parser_)
      this->fixedRatio_parser_->_reset ();

    if (this->fixedReference_parser_)
      this->fixedReference_parser_->_reset ();

    if (this->fixedSampledData_parser_)
      this->fixedSampledData_parser_->_reset ();

    if (this->fixedSignature_parser_)
      this->fixedSignature_parser_->_reset ();

    if (this->fixedTiming_parser_)
      this->fixedTiming_parser_->_reset ();

    if (this->fixedContactDetail_parser_)
      this->fixedContactDetail_parser_->_reset ();

    if (this->fixedContributor_parser_)
      this->fixedContributor_parser_->_reset ();

    if (this->fixedDataRequirement_parser_)
      this->fixedDataRequirement_parser_->_reset ();

    if (this->fixedExpression_parser_)
      this->fixedExpression_parser_->_reset ();

    if (this->fixedParameterDefinition_parser_)
      this->fixedParameterDefinition_parser_->_reset ();

    if (this->fixedRelatedArtifact_parser_)
      this->fixedRelatedArtifact_parser_->_reset ();

    if (this->fixedTriggerDefinition_parser_)
      this->fixedTriggerDefinition_parser_->_reset ();

    if (this->fixedUsageContext_parser_)
      this->fixedUsageContext_parser_->_reset ();

    if (this->fixedDosage_parser_)
      this->fixedDosage_parser_->_reset ();

    if (this->fixedMeta_parser_)
      this->fixedMeta_parser_->_reset ();

    if (this->patternBase64Binary_parser_)
      this->patternBase64Binary_parser_->_reset ();

    if (this->patternBoolean_parser_)
      this->patternBoolean_parser_->_reset ();

    if (this->patternCanonical_parser_)
      this->patternCanonical_parser_->_reset ();

    if (this->patternCode_parser_)
      this->patternCode_parser_->_reset ();

    if (this->patternDate_parser_)
      this->patternDate_parser_->_reset ();

    if (this->patternDateTime_parser_)
      this->patternDateTime_parser_->_reset ();

    if (this->patternDecimal_parser_)
      this->patternDecimal_parser_->_reset ();

    if (this->patternId_parser_)
      this->patternId_parser_->_reset ();

    if (this->patternInstant_parser_)
      this->patternInstant_parser_->_reset ();

    if (this->patternInteger_parser_)
      this->patternInteger_parser_->_reset ();

    if (this->patternMarkdown_parser_)
      this->patternMarkdown_parser_->_reset ();

    if (this->patternOid_parser_)
      this->patternOid_parser_->_reset ();

    if (this->patternPositiveInt_parser_)
      this->patternPositiveInt_parser_->_reset ();

    if (this->patternString_parser_)
      this->patternString_parser_->_reset ();

    if (this->patternTime_parser_)
      this->patternTime_parser_->_reset ();

    if (this->patternUnsignedInt_parser_)
      this->patternUnsignedInt_parser_->_reset ();

    if (this->patternUri_parser_)
      this->patternUri_parser_->_reset ();

    if (this->patternUrl_parser_)
      this->patternUrl_parser_->_reset ();

    if (this->patternUuid_parser_)
      this->patternUuid_parser_->_reset ();

    if (this->patternAddress_parser_)
      this->patternAddress_parser_->_reset ();

    if (this->patternAge_parser_)
      this->patternAge_parser_->_reset ();

    if (this->patternAnnotation_parser_)
      this->patternAnnotation_parser_->_reset ();

    if (this->patternAttachment_parser_)
      this->patternAttachment_parser_->_reset ();

    if (this->patternCodeableConcept_parser_)
      this->patternCodeableConcept_parser_->_reset ();

    if (this->patternCoding_parser_)
      this->patternCoding_parser_->_reset ();

    if (this->patternContactPoint_parser_)
      this->patternContactPoint_parser_->_reset ();

    if (this->patternCount_parser_)
      this->patternCount_parser_->_reset ();

    if (this->patternDistance_parser_)
      this->patternDistance_parser_->_reset ();

    if (this->patternDuration_parser_)
      this->patternDuration_parser_->_reset ();

    if (this->patternHumanName_parser_)
      this->patternHumanName_parser_->_reset ();

    if (this->patternIdentifier_parser_)
      this->patternIdentifier_parser_->_reset ();

    if (this->patternMoney_parser_)
      this->patternMoney_parser_->_reset ();

    if (this->patternPeriod_parser_)
      this->patternPeriod_parser_->_reset ();

    if (this->patternQuantity_parser_)
      this->patternQuantity_parser_->_reset ();

    if (this->patternRange_parser_)
      this->patternRange_parser_->_reset ();

    if (this->patternRatio_parser_)
      this->patternRatio_parser_->_reset ();

    if (this->patternReference_parser_)
      this->patternReference_parser_->_reset ();

    if (this->patternSampledData_parser_)
      this->patternSampledData_parser_->_reset ();

    if (this->patternSignature_parser_)
      this->patternSignature_parser_->_reset ();

    if (this->patternTiming_parser_)
      this->patternTiming_parser_->_reset ();

    if (this->patternContactDetail_parser_)
      this->patternContactDetail_parser_->_reset ();

    if (this->patternContributor_parser_)
      this->patternContributor_parser_->_reset ();

    if (this->patternDataRequirement_parser_)
      this->patternDataRequirement_parser_->_reset ();

    if (this->patternExpression_parser_)
      this->patternExpression_parser_->_reset ();

    if (this->patternParameterDefinition_parser_)
      this->patternParameterDefinition_parser_->_reset ();

    if (this->patternRelatedArtifact_parser_)
      this->patternRelatedArtifact_parser_->_reset ();

    if (this->patternTriggerDefinition_parser_)
      this->patternTriggerDefinition_parser_->_reset ();

    if (this->patternUsageContext_parser_)
      this->patternUsageContext_parser_->_reset ();

    if (this->patternDosage_parser_)
      this->patternDosage_parser_->_reset ();

    if (this->patternMeta_parser_)
      this->patternMeta_parser_->_reset ();

    if (this->example_parser_)
      this->example_parser_->_reset ();

    if (this->minValueDate_parser_)
      this->minValueDate_parser_->_reset ();

    if (this->minValueDateTime_parser_)
      this->minValueDateTime_parser_->_reset ();

    if (this->minValueInstant_parser_)
      this->minValueInstant_parser_->_reset ();

    if (this->minValueTime_parser_)
      this->minValueTime_parser_->_reset ();

    if (this->minValueDecimal_parser_)
      this->minValueDecimal_parser_->_reset ();

    if (this->minValueInteger_parser_)
      this->minValueInteger_parser_->_reset ();

    if (this->minValuePositiveInt_parser_)
      this->minValuePositiveInt_parser_->_reset ();

    if (this->minValueUnsignedInt_parser_)
      this->minValueUnsignedInt_parser_->_reset ();

    if (this->minValueQuantity_parser_)
      this->minValueQuantity_parser_->_reset ();

    if (this->maxValueDate_parser_)
      this->maxValueDate_parser_->_reset ();

    if (this->maxValueDateTime_parser_)
      this->maxValueDateTime_parser_->_reset ();

    if (this->maxValueInstant_parser_)
      this->maxValueInstant_parser_->_reset ();

    if (this->maxValueTime_parser_)
      this->maxValueTime_parser_->_reset ();

    if (this->maxValueDecimal_parser_)
      this->maxValueDecimal_parser_->_reset ();

    if (this->maxValueInteger_parser_)
      this->maxValueInteger_parser_->_reset ();

    if (this->maxValuePositiveInt_parser_)
      this->maxValuePositiveInt_parser_->_reset ();

    if (this->maxValueUnsignedInt_parser_)
      this->maxValueUnsignedInt_parser_->_reset ();

    if (this->maxValueQuantity_parser_)
      this->maxValueQuantity_parser_->_reset ();

    if (this->maxLength_parser_)
      this->maxLength_parser_->_reset ();

    if (this->condition_parser_)
      this->condition_parser_->_reset ();

    if (this->constraint_parser_)
      this->constraint_parser_->_reset ();

    if (this->mustSupport_parser_)
      this->mustSupport_parser_->_reset ();

    if (this->isModifier_parser_)
      this->isModifier_parser_->_reset ();

    if (this->isModifierReason_parser_)
      this->isModifierReason_parser_->_reset ();

    if (this->isSummary_parser_)
      this->isSummary_parser_->_reset ();

    if (this->binding_parser_)
      this->binding_parser_->_reset ();

    if (this->mapping_parser_)
      this->mapping_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Constraint_pskel
  //

  void ElementDefinition_Constraint_pskel::
  key ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->key ();
  }

  void ElementDefinition_Constraint_pskel::
  requirements ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->requirements ();
  }

  void ElementDefinition_Constraint_pskel::
  severity ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->severity ();
  }

  void ElementDefinition_Constraint_pskel::
  human ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->human ();
  }

  void ElementDefinition_Constraint_pskel::
  expression ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->expression ();
  }

  void ElementDefinition_Constraint_pskel::
  xpath ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->xpath ();
  }

  void ElementDefinition_Constraint_pskel::
  source ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->source ();
  }

  void ElementDefinition_Constraint_pskel::
  post_ElementDefinition_Constraint ()
  {
    if (this->ElementDefinition_Constraint_impl_)
      this->ElementDefinition_Constraint_impl_->post_ElementDefinition_Constraint ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Constraint_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->key_parser_)
      this->key_parser_->_reset ();

    if (this->requirements_parser_)
      this->requirements_parser_->_reset ();

    if (this->severity_parser_)
      this->severity_parser_->_reset ();

    if (this->human_parser_)
      this->human_parser_->_reset ();

    if (this->expression_parser_)
      this->expression_parser_->_reset ();

    if (this->xpath_parser_)
      this->xpath_parser_->_reset ();

    if (this->source_parser_)
      this->source_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Mapping_pskel
  //

  void ElementDefinition_Mapping_pskel::
  identity ()
  {
    if (this->ElementDefinition_Mapping_impl_)
      this->ElementDefinition_Mapping_impl_->identity ();
  }

  void ElementDefinition_Mapping_pskel::
  language ()
  {
    if (this->ElementDefinition_Mapping_impl_)
      this->ElementDefinition_Mapping_impl_->language ();
  }

  void ElementDefinition_Mapping_pskel::
  map ()
  {
    if (this->ElementDefinition_Mapping_impl_)
      this->ElementDefinition_Mapping_impl_->map ();
  }

  void ElementDefinition_Mapping_pskel::
  comment ()
  {
    if (this->ElementDefinition_Mapping_impl_)
      this->ElementDefinition_Mapping_impl_->comment ();
  }

  void ElementDefinition_Mapping_pskel::
  post_ElementDefinition_Mapping ()
  {
    if (this->ElementDefinition_Mapping_impl_)
      this->ElementDefinition_Mapping_impl_->post_ElementDefinition_Mapping ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Mapping_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->identity_parser_)
      this->identity_parser_->_reset ();

    if (this->language_parser_)
      this->language_parser_->_reset ();

    if (this->map_parser_)
      this->map_parser_->_reset ();

    if (this->comment_parser_)
      this->comment_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Base_pskel
  //

  void ElementDefinition_Base_pskel::
  path ()
  {
    if (this->ElementDefinition_Base_impl_)
      this->ElementDefinition_Base_impl_->path ();
  }

  void ElementDefinition_Base_pskel::
  min ()
  {
    if (this->ElementDefinition_Base_impl_)
      this->ElementDefinition_Base_impl_->min ();
  }

  void ElementDefinition_Base_pskel::
  max ()
  {
    if (this->ElementDefinition_Base_impl_)
      this->ElementDefinition_Base_impl_->max ();
  }

  void ElementDefinition_Base_pskel::
  post_ElementDefinition_Base ()
  {
    if (this->ElementDefinition_Base_impl_)
      this->ElementDefinition_Base_impl_->post_ElementDefinition_Base ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Base_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->path_parser_)
      this->path_parser_->_reset ();

    if (this->min_parser_)
      this->min_parser_->_reset ();

    if (this->max_parser_)
      this->max_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Type_pskel
  //

  void ElementDefinition_Type_pskel::
  code ()
  {
    if (this->ElementDefinition_Type_impl_)
      this->ElementDefinition_Type_impl_->code ();
  }

  void ElementDefinition_Type_pskel::
  profile ()
  {
    if (this->ElementDefinition_Type_impl_)
      this->ElementDefinition_Type_impl_->profile ();
  }

  void ElementDefinition_Type_pskel::
  targetProfile ()
  {
    if (this->ElementDefinition_Type_impl_)
      this->ElementDefinition_Type_impl_->targetProfile ();
  }

  void ElementDefinition_Type_pskel::
  aggregation ()
  {
    if (this->ElementDefinition_Type_impl_)
      this->ElementDefinition_Type_impl_->aggregation ();
  }

  void ElementDefinition_Type_pskel::
  versioning ()
  {
    if (this->ElementDefinition_Type_impl_)
      this->ElementDefinition_Type_impl_->versioning ();
  }

  void ElementDefinition_Type_pskel::
  post_ElementDefinition_Type ()
  {
    if (this->ElementDefinition_Type_impl_)
      this->ElementDefinition_Type_impl_->post_ElementDefinition_Type ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Type_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    if (this->targetProfile_parser_)
      this->targetProfile_parser_->_reset ();

    if (this->aggregation_parser_)
      this->aggregation_parser_->_reset ();

    if (this->versioning_parser_)
      this->versioning_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Example_pskel
  //

  void ElementDefinition_Example_pskel::
  label ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->label ();
  }

  void ElementDefinition_Example_pskel::
  valueBase64Binary ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueBase64Binary ();
  }

  void ElementDefinition_Example_pskel::
  valueBoolean ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueBoolean ();
  }

  void ElementDefinition_Example_pskel::
  valueCanonical ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueCanonical ();
  }

  void ElementDefinition_Example_pskel::
  valueCode ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueCode ();
  }

  void ElementDefinition_Example_pskel::
  valueDate ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDate ();
  }

  void ElementDefinition_Example_pskel::
  valueDateTime ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDateTime ();
  }

  void ElementDefinition_Example_pskel::
  valueDecimal ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDecimal ();
  }

  void ElementDefinition_Example_pskel::
  valueId ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueId ();
  }

  void ElementDefinition_Example_pskel::
  valueInstant ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueInstant ();
  }

  void ElementDefinition_Example_pskel::
  valueInteger ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueInteger ();
  }

  void ElementDefinition_Example_pskel::
  valueMarkdown ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueMarkdown ();
  }

  void ElementDefinition_Example_pskel::
  valueOid ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueOid ();
  }

  void ElementDefinition_Example_pskel::
  valuePositiveInt ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valuePositiveInt ();
  }

  void ElementDefinition_Example_pskel::
  valueString ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueString ();
  }

  void ElementDefinition_Example_pskel::
  valueTime ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueTime ();
  }

  void ElementDefinition_Example_pskel::
  valueUnsignedInt ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueUnsignedInt ();
  }

  void ElementDefinition_Example_pskel::
  valueUri ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueUri ();
  }

  void ElementDefinition_Example_pskel::
  valueUrl ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueUrl ();
  }

  void ElementDefinition_Example_pskel::
  valueUuid ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueUuid ();
  }

  void ElementDefinition_Example_pskel::
  valueAddress ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueAddress ();
  }

  void ElementDefinition_Example_pskel::
  valueAge ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueAge ();
  }

  void ElementDefinition_Example_pskel::
  valueAnnotation ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueAnnotation ();
  }

  void ElementDefinition_Example_pskel::
  valueAttachment ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueAttachment ();
  }

  void ElementDefinition_Example_pskel::
  valueCodeableConcept ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueCodeableConcept ();
  }

  void ElementDefinition_Example_pskel::
  valueCoding ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueCoding ();
  }

  void ElementDefinition_Example_pskel::
  valueContactPoint ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueContactPoint ();
  }

  void ElementDefinition_Example_pskel::
  valueCount ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueCount ();
  }

  void ElementDefinition_Example_pskel::
  valueDistance ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDistance ();
  }

  void ElementDefinition_Example_pskel::
  valueDuration ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDuration ();
  }

  void ElementDefinition_Example_pskel::
  valueHumanName ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueHumanName ();
  }

  void ElementDefinition_Example_pskel::
  valueIdentifier ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueIdentifier ();
  }

  void ElementDefinition_Example_pskel::
  valueMoney ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueMoney ();
  }

  void ElementDefinition_Example_pskel::
  valuePeriod ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valuePeriod ();
  }

  void ElementDefinition_Example_pskel::
  valueQuantity ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueQuantity ();
  }

  void ElementDefinition_Example_pskel::
  valueRange ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueRange ();
  }

  void ElementDefinition_Example_pskel::
  valueRatio ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueRatio ();
  }

  void ElementDefinition_Example_pskel::
  valueReference ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueReference ();
  }

  void ElementDefinition_Example_pskel::
  valueSampledData ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueSampledData ();
  }

  void ElementDefinition_Example_pskel::
  valueSignature ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueSignature ();
  }

  void ElementDefinition_Example_pskel::
  valueTiming ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueTiming ();
  }

  void ElementDefinition_Example_pskel::
  valueContactDetail ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueContactDetail ();
  }

  void ElementDefinition_Example_pskel::
  valueContributor ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueContributor ();
  }

  void ElementDefinition_Example_pskel::
  valueDataRequirement ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDataRequirement ();
  }

  void ElementDefinition_Example_pskel::
  valueExpression ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueExpression ();
  }

  void ElementDefinition_Example_pskel::
  valueParameterDefinition ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueParameterDefinition ();
  }

  void ElementDefinition_Example_pskel::
  valueRelatedArtifact ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueRelatedArtifact ();
  }

  void ElementDefinition_Example_pskel::
  valueTriggerDefinition ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueTriggerDefinition ();
  }

  void ElementDefinition_Example_pskel::
  valueUsageContext ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueUsageContext ();
  }

  void ElementDefinition_Example_pskel::
  valueDosage ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueDosage ();
  }

  void ElementDefinition_Example_pskel::
  valueMeta ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->valueMeta ();
  }

  void ElementDefinition_Example_pskel::
  post_ElementDefinition_Example ()
  {
    if (this->ElementDefinition_Example_impl_)
      this->ElementDefinition_Example_impl_->post_ElementDefinition_Example ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Example_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->label_parser_)
      this->label_parser_->_reset ();

    if (this->valueBase64Binary_parser_)
      this->valueBase64Binary_parser_->_reset ();

    if (this->valueBoolean_parser_)
      this->valueBoolean_parser_->_reset ();

    if (this->valueCanonical_parser_)
      this->valueCanonical_parser_->_reset ();

    if (this->valueCode_parser_)
      this->valueCode_parser_->_reset ();

    if (this->valueDate_parser_)
      this->valueDate_parser_->_reset ();

    if (this->valueDateTime_parser_)
      this->valueDateTime_parser_->_reset ();

    if (this->valueDecimal_parser_)
      this->valueDecimal_parser_->_reset ();

    if (this->valueId_parser_)
      this->valueId_parser_->_reset ();

    if (this->valueInstant_parser_)
      this->valueInstant_parser_->_reset ();

    if (this->valueInteger_parser_)
      this->valueInteger_parser_->_reset ();

    if (this->valueMarkdown_parser_)
      this->valueMarkdown_parser_->_reset ();

    if (this->valueOid_parser_)
      this->valueOid_parser_->_reset ();

    if (this->valuePositiveInt_parser_)
      this->valuePositiveInt_parser_->_reset ();

    if (this->valueString_parser_)
      this->valueString_parser_->_reset ();

    if (this->valueTime_parser_)
      this->valueTime_parser_->_reset ();

    if (this->valueUnsignedInt_parser_)
      this->valueUnsignedInt_parser_->_reset ();

    if (this->valueUri_parser_)
      this->valueUri_parser_->_reset ();

    if (this->valueUrl_parser_)
      this->valueUrl_parser_->_reset ();

    if (this->valueUuid_parser_)
      this->valueUuid_parser_->_reset ();

    if (this->valueAddress_parser_)
      this->valueAddress_parser_->_reset ();

    if (this->valueAge_parser_)
      this->valueAge_parser_->_reset ();

    if (this->valueAnnotation_parser_)
      this->valueAnnotation_parser_->_reset ();

    if (this->valueAttachment_parser_)
      this->valueAttachment_parser_->_reset ();

    if (this->valueCodeableConcept_parser_)
      this->valueCodeableConcept_parser_->_reset ();

    if (this->valueCoding_parser_)
      this->valueCoding_parser_->_reset ();

    if (this->valueContactPoint_parser_)
      this->valueContactPoint_parser_->_reset ();

    if (this->valueCount_parser_)
      this->valueCount_parser_->_reset ();

    if (this->valueDistance_parser_)
      this->valueDistance_parser_->_reset ();

    if (this->valueDuration_parser_)
      this->valueDuration_parser_->_reset ();

    if (this->valueHumanName_parser_)
      this->valueHumanName_parser_->_reset ();

    if (this->valueIdentifier_parser_)
      this->valueIdentifier_parser_->_reset ();

    if (this->valueMoney_parser_)
      this->valueMoney_parser_->_reset ();

    if (this->valuePeriod_parser_)
      this->valuePeriod_parser_->_reset ();

    if (this->valueQuantity_parser_)
      this->valueQuantity_parser_->_reset ();

    if (this->valueRange_parser_)
      this->valueRange_parser_->_reset ();

    if (this->valueRatio_parser_)
      this->valueRatio_parser_->_reset ();

    if (this->valueReference_parser_)
      this->valueReference_parser_->_reset ();

    if (this->valueSampledData_parser_)
      this->valueSampledData_parser_->_reset ();

    if (this->valueSignature_parser_)
      this->valueSignature_parser_->_reset ();

    if (this->valueTiming_parser_)
      this->valueTiming_parser_->_reset ();

    if (this->valueContactDetail_parser_)
      this->valueContactDetail_parser_->_reset ();

    if (this->valueContributor_parser_)
      this->valueContributor_parser_->_reset ();

    if (this->valueDataRequirement_parser_)
      this->valueDataRequirement_parser_->_reset ();

    if (this->valueExpression_parser_)
      this->valueExpression_parser_->_reset ();

    if (this->valueParameterDefinition_parser_)
      this->valueParameterDefinition_parser_->_reset ();

    if (this->valueRelatedArtifact_parser_)
      this->valueRelatedArtifact_parser_->_reset ();

    if (this->valueTriggerDefinition_parser_)
      this->valueTriggerDefinition_parser_->_reset ();

    if (this->valueUsageContext_parser_)
      this->valueUsageContext_parser_->_reset ();

    if (this->valueDosage_parser_)
      this->valueDosage_parser_->_reset ();

    if (this->valueMeta_parser_)
      this->valueMeta_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Slicing_pskel
  //

  void ElementDefinition_Slicing_pskel::
  discriminator ()
  {
    if (this->ElementDefinition_Slicing_impl_)
      this->ElementDefinition_Slicing_impl_->discriminator ();
  }

  void ElementDefinition_Slicing_pskel::
  description ()
  {
    if (this->ElementDefinition_Slicing_impl_)
      this->ElementDefinition_Slicing_impl_->description ();
  }

  void ElementDefinition_Slicing_pskel::
  ordered ()
  {
    if (this->ElementDefinition_Slicing_impl_)
      this->ElementDefinition_Slicing_impl_->ordered ();
  }

  void ElementDefinition_Slicing_pskel::
  rules ()
  {
    if (this->ElementDefinition_Slicing_impl_)
      this->ElementDefinition_Slicing_impl_->rules ();
  }

  void ElementDefinition_Slicing_pskel::
  post_ElementDefinition_Slicing ()
  {
    if (this->ElementDefinition_Slicing_impl_)
      this->ElementDefinition_Slicing_impl_->post_ElementDefinition_Slicing ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Slicing_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->discriminator_parser_)
      this->discriminator_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->ordered_parser_)
      this->ordered_parser_->_reset ();

    if (this->rules_parser_)
      this->rules_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Binding_pskel
  //

  void ElementDefinition_Binding_pskel::
  strength ()
  {
    if (this->ElementDefinition_Binding_impl_)
      this->ElementDefinition_Binding_impl_->strength ();
  }

  void ElementDefinition_Binding_pskel::
  description ()
  {
    if (this->ElementDefinition_Binding_impl_)
      this->ElementDefinition_Binding_impl_->description ();
  }

  void ElementDefinition_Binding_pskel::
  valueSet ()
  {
    if (this->ElementDefinition_Binding_impl_)
      this->ElementDefinition_Binding_impl_->valueSet ();
  }

  void ElementDefinition_Binding_pskel::
  post_ElementDefinition_Binding ()
  {
    if (this->ElementDefinition_Binding_impl_)
      this->ElementDefinition_Binding_impl_->post_ElementDefinition_Binding ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Binding_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->strength_parser_)
      this->strength_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->valueSet_parser_)
      this->valueSet_parser_->_reset ();

    this->resetting_ = false;
  }

  // ElementDefinition_Discriminator_pskel
  //

  void ElementDefinition_Discriminator_pskel::
  type ()
  {
    if (this->ElementDefinition_Discriminator_impl_)
      this->ElementDefinition_Discriminator_impl_->type ();
  }

  void ElementDefinition_Discriminator_pskel::
  path ()
  {
    if (this->ElementDefinition_Discriminator_impl_)
      this->ElementDefinition_Discriminator_impl_->path ();
  }

  void ElementDefinition_Discriminator_pskel::
  post_ElementDefinition_Discriminator ()
  {
    if (this->ElementDefinition_Discriminator_impl_)
      this->ElementDefinition_Discriminator_impl_->post_ElementDefinition_Discriminator ();
    else
      post_BackboneElement ();
  }

  void ElementDefinition_Discriminator_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->path_parser_)
      this->path_parser_->_reset ();

    this->resetting_ = false;
  }

  // PropertyRepresentation_list_pskel
  //

  void PropertyRepresentation_list_pskel::
  post_PropertyRepresentation_list ()
  {
    if (this->PropertyRepresentation_list_impl_)
      this->PropertyRepresentation_list_impl_->post_PropertyRepresentation_list ();
    else
      post_code_primitive ();
  }

  const char* const PropertyRepresentation_list_pskel::_xsde_PropertyRepresentation_list_pskel_enums_[5UL] = 
  {
    "cdaText",
    "typeAttr",
    "xhtml",
    "xmlAttr",
    "xmlText"
  };

  // PropertyRepresentation_pskel
  //

  void PropertyRepresentation_pskel::
  value ()
  {
    if (this->PropertyRepresentation_impl_)
      this->PropertyRepresentation_impl_->value ();
  }

  void PropertyRepresentation_pskel::
  post_PropertyRepresentation ()
  {
    if (this->PropertyRepresentation_impl_)
      this->PropertyRepresentation_impl_->post_PropertyRepresentation ();
    else
      post_Element ();
  }

  void PropertyRepresentation_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ConstraintSeverity_list_pskel
  //

  void ConstraintSeverity_list_pskel::
  post_ConstraintSeverity_list ()
  {
    if (this->ConstraintSeverity_list_impl_)
      this->ConstraintSeverity_list_impl_->post_ConstraintSeverity_list ();
    else
      post_code_primitive ();
  }

  const char* const ConstraintSeverity_list_pskel::_xsde_ConstraintSeverity_list_pskel_enums_[2UL] = 
  {
    "error",
    "warning"
  };

  // ConstraintSeverity_pskel
  //

  void ConstraintSeverity_pskel::
  value ()
  {
    if (this->ConstraintSeverity_impl_)
      this->ConstraintSeverity_impl_->value ();
  }

  void ConstraintSeverity_pskel::
  post_ConstraintSeverity ()
  {
    if (this->ConstraintSeverity_impl_)
      this->ConstraintSeverity_impl_->post_ConstraintSeverity ();
    else
      post_Element ();
  }

  void ConstraintSeverity_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // AggregationMode_list_pskel
  //

  void AggregationMode_list_pskel::
  post_AggregationMode_list ()
  {
    if (this->AggregationMode_list_impl_)
      this->AggregationMode_list_impl_->post_AggregationMode_list ();
    else
      post_code_primitive ();
  }

  const char* const AggregationMode_list_pskel::_xsde_AggregationMode_list_pskel_enums_[3UL] = 
  {
    "bundled",
    "contained",
    "referenced"
  };

  // AggregationMode_pskel
  //

  void AggregationMode_pskel::
  value ()
  {
    if (this->AggregationMode_impl_)
      this->AggregationMode_impl_->value ();
  }

  void AggregationMode_pskel::
  post_AggregationMode ()
  {
    if (this->AggregationMode_impl_)
      this->AggregationMode_impl_->post_AggregationMode ();
    else
      post_Element ();
  }

  void AggregationMode_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ReferenceVersionRules_list_pskel
  //

  void ReferenceVersionRules_list_pskel::
  post_ReferenceVersionRules_list ()
  {
    if (this->ReferenceVersionRules_list_impl_)
      this->ReferenceVersionRules_list_impl_->post_ReferenceVersionRules_list ();
    else
      post_code_primitive ();
  }

  const char* const ReferenceVersionRules_list_pskel::_xsde_ReferenceVersionRules_list_pskel_enums_[3UL] = 
  {
    "either",
    "independent",
    "specific"
  };

  // ReferenceVersionRules_pskel
  //

  void ReferenceVersionRules_pskel::
  value ()
  {
    if (this->ReferenceVersionRules_impl_)
      this->ReferenceVersionRules_impl_->value ();
  }

  void ReferenceVersionRules_pskel::
  post_ReferenceVersionRules ()
  {
    if (this->ReferenceVersionRules_impl_)
      this->ReferenceVersionRules_impl_->post_ReferenceVersionRules ();
    else
      post_Element ();
  }

  void ReferenceVersionRules_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // SlicingRules_list_pskel
  //

  void SlicingRules_list_pskel::
  post_SlicingRules_list ()
  {
    if (this->SlicingRules_list_impl_)
      this->SlicingRules_list_impl_->post_SlicingRules_list ();
    else
      post_code_primitive ();
  }

  const char* const SlicingRules_list_pskel::_xsde_SlicingRules_list_pskel_enums_[3UL] = 
  {
    "closed",
    "open",
    "openAtEnd"
  };

  // SlicingRules_pskel
  //

  void SlicingRules_pskel::
  value ()
  {
    if (this->SlicingRules_impl_)
      this->SlicingRules_impl_->value ();
  }

  void SlicingRules_pskel::
  post_SlicingRules ()
  {
    if (this->SlicingRules_impl_)
      this->SlicingRules_impl_->post_SlicingRules ();
    else
      post_Element ();
  }

  void SlicingRules_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // BindingStrength_list_pskel
  //

  void BindingStrength_list_pskel::
  post_BindingStrength_list ()
  {
    if (this->BindingStrength_list_impl_)
      this->BindingStrength_list_impl_->post_BindingStrength_list ();
    else
      post_code_primitive ();
  }

  const char* const BindingStrength_list_pskel::_xsde_BindingStrength_list_pskel_enums_[4UL] = 
  {
    "example",
    "extensible",
    "preferred",
    "required"
  };

  // BindingStrength_pskel
  //

  void BindingStrength_pskel::
  value ()
  {
    if (this->BindingStrength_impl_)
      this->BindingStrength_impl_->value ();
  }

  void BindingStrength_pskel::
  post_BindingStrength ()
  {
    if (this->BindingStrength_impl_)
      this->BindingStrength_impl_->post_BindingStrength ();
    else
      post_Element ();
  }

  void BindingStrength_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // DiscriminatorType_list_pskel
  //

  void DiscriminatorType_list_pskel::
  post_DiscriminatorType_list ()
  {
    if (this->DiscriminatorType_list_impl_)
      this->DiscriminatorType_list_impl_->post_DiscriminatorType_list ();
    else
      post_code_primitive ();
  }

  const char* const DiscriminatorType_list_pskel::_xsde_DiscriminatorType_list_pskel_enums_[5UL] = 
  {
    "exists",
    "pattern",
    "profile",
    "type",
    "value"
  };

  // DiscriminatorType_pskel
  //

  void DiscriminatorType_pskel::
  value ()
  {
    if (this->DiscriminatorType_impl_)
      this->DiscriminatorType_impl_->value ();
  }

  void DiscriminatorType_pskel::
  post_DiscriminatorType ()
  {
    if (this->DiscriminatorType_impl_)
      this->DiscriminatorType_impl_->post_DiscriminatorType ();
    else
      post_Element ();
  }

  void DiscriminatorType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // Resource_pskel
  //

  void Resource_pskel::
  id ()
  {
    if (this->Resource_impl_)
      this->Resource_impl_->id ();
  }

  void Resource_pskel::
  meta ()
  {
    if (this->Resource_impl_)
      this->Resource_impl_->meta ();
  }

  void Resource_pskel::
  implicitRules ()
  {
    if (this->Resource_impl_)
      this->Resource_impl_->implicitRules ();
  }

  void Resource_pskel::
  language ()
  {
    if (this->Resource_impl_)
      this->Resource_impl_->language ();
  }

  void Resource_pskel::
  post_Resource ()
  {
    if (this->Resource_impl_)
      this->Resource_impl_->post_Resource ();
  }

  void Resource_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::parser::validating::complex_content base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->id_parser_)
      this->id_parser_->_reset ();

    if (this->meta_parser_)
      this->meta_parser_->_reset ();

    if (this->implicitRules_parser_)
      this->implicitRules_parser_->_reset ();

    if (this->language_parser_)
      this->language_parser_->_reset ();

    this->resetting_ = false;
  }

  // DomainResource_pskel
  //

  void DomainResource_pskel::
  text ()
  {
    if (this->DomainResource_impl_)
      this->DomainResource_impl_->text ();
  }

  void DomainResource_pskel::
  contained ()
  {
    if (this->DomainResource_impl_)
      this->DomainResource_impl_->contained ();
  }

  void DomainResource_pskel::
  extension ()
  {
    if (this->DomainResource_impl_)
      this->DomainResource_impl_->extension ();
  }

  void DomainResource_pskel::
  modifierExtension ()
  {
    if (this->DomainResource_impl_)
      this->DomainResource_impl_->modifierExtension ();
  }

  void DomainResource_pskel::
  post_DomainResource ()
  {
    if (this->DomainResource_impl_)
      this->DomainResource_impl_->post_DomainResource ();
    else
      post_Resource ();
  }

  void DomainResource_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::Resource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->text_parser_)
      this->text_parser_->_reset ();

    if (this->contained_parser_)
      this->contained_parser_->_reset ();

    if (this->extension_parser_)
      this->extension_parser_->_reset ();

    if (this->modifierExtension_parser_)
      this->modifierExtension_parser_->_reset ();

    this->resetting_ = false;
  }

  // PublicationStatus_list_pskel
  //

  void PublicationStatus_list_pskel::
  post_PublicationStatus_list ()
  {
    if (this->PublicationStatus_list_impl_)
      this->PublicationStatus_list_impl_->post_PublicationStatus_list ();
    else
      post_code_primitive ();
  }

  const char* const PublicationStatus_list_pskel::_xsde_PublicationStatus_list_pskel_enums_[4UL] = 
  {
    "active",
    "draft",
    "retired",
    "unknown"
  };

  // PublicationStatus_pskel
  //

  void PublicationStatus_pskel::
  value ()
  {
    if (this->PublicationStatus_impl_)
      this->PublicationStatus_impl_->value ();
  }

  void PublicationStatus_pskel::
  post_PublicationStatus ()
  {
    if (this->PublicationStatus_impl_)
      this->PublicationStatus_impl_->post_PublicationStatus ();
    else
      post_Element ();
  }

  void PublicationStatus_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // SearchParamType_list_pskel
  //

  void SearchParamType_list_pskel::
  post_SearchParamType_list ()
  {
    if (this->SearchParamType_list_impl_)
      this->SearchParamType_list_impl_->post_SearchParamType_list ();
    else
      post_code_primitive ();
  }

  const char* const SearchParamType_list_pskel::_xsde_SearchParamType_list_pskel_enums_[9UL] = 
  {
    "composite",
    "date",
    "number",
    "quantity",
    "reference",
    "special",
    "string",
    "token",
    "uri"
  };

  // SearchParamType_pskel
  //

  void SearchParamType_pskel::
  value ()
  {
    if (this->SearchParamType_impl_)
      this->SearchParamType_impl_->value ();
  }

  void SearchParamType_pskel::
  post_SearchParamType ()
  {
    if (this->SearchParamType_impl_)
      this->SearchParamType_impl_->post_SearchParamType ();
    else
      post_Element ();
  }

  void SearchParamType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // AdministrativeGender_list_pskel
  //

  void AdministrativeGender_list_pskel::
  post_AdministrativeGender_list ()
  {
    if (this->AdministrativeGender_list_impl_)
      this->AdministrativeGender_list_impl_->post_AdministrativeGender_list ();
    else
      post_code_primitive ();
  }

  const char* const AdministrativeGender_list_pskel::_xsde_AdministrativeGender_list_pskel_enums_[4UL] = 
  {
    "female",
    "male",
    "other",
    "unknown"
  };

  // AdministrativeGender_pskel
  //

  void AdministrativeGender_pskel::
  value ()
  {
    if (this->AdministrativeGender_impl_)
      this->AdministrativeGender_impl_->value ();
  }

  void AdministrativeGender_pskel::
  post_AdministrativeGender ()
  {
    if (this->AdministrativeGender_impl_)
      this->AdministrativeGender_impl_->post_AdministrativeGender ();
    else
      post_Element ();
  }

  void AdministrativeGender_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // FHIRVersion_list_pskel
  //

  void FHIRVersion_list_pskel::
  post_FHIRVersion_list ()
  {
    if (this->FHIRVersion_list_impl_)
      this->FHIRVersion_list_impl_->post_FHIRVersion_list ();
    else
      post_code_primitive ();
  }

  const char* const FHIRVersion_list_pskel::_xsde_FHIRVersion_list_pskel_enums_[22UL] = 
  {
    "0.0.80",
    "0.0.81",
    "0.0.82",
    "0.01",
    "0.05",
    "0.06",
    "0.11",
    "0.4.0",
    "0.5.0",
    "1.0.0",
    "1.0.1",
    "1.0.2",
    "1.1.0",
    "1.4.0",
    "1.6.0",
    "1.8.0",
    "3.0.0",
    "3.0.1",
    "3.3.0",
    "3.5.0",
    "4.0.0",
    "4.0.1"
  };

  // FHIRVersion_pskel
  //

  void FHIRVersion_pskel::
  value ()
  {
    if (this->FHIRVersion_impl_)
      this->FHIRVersion_impl_->value ();
  }

  void FHIRVersion_pskel::
  post_FHIRVersion ()
  {
    if (this->FHIRVersion_impl_)
      this->FHIRVersion_impl_->post_FHIRVersion ();
    else
      post_Element ();
  }

  void FHIRVersion_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // NoteType_list_pskel
  //

  void NoteType_list_pskel::
  post_NoteType_list ()
  {
    if (this->NoteType_list_impl_)
      this->NoteType_list_impl_->post_NoteType_list ();
    else
      post_code_primitive ();
  }

  const char* const NoteType_list_pskel::_xsde_NoteType_list_pskel_enums_[3UL] = 
  {
    "display",
    "print",
    "printoper"
  };

  // NoteType_pskel
  //

  void NoteType_pskel::
  value ()
  {
    if (this->NoteType_impl_)
      this->NoteType_impl_->value ();
  }

  void NoteType_pskel::
  post_NoteType ()
  {
    if (this->NoteType_impl_)
      this->NoteType_impl_->post_NoteType ();
    else
      post_Element ();
  }

  void NoteType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // RemittanceOutcome_list_pskel
  //

  void RemittanceOutcome_list_pskel::
  post_RemittanceOutcome_list ()
  {
    if (this->RemittanceOutcome_list_impl_)
      this->RemittanceOutcome_list_impl_->post_RemittanceOutcome_list ();
    else
      post_code_primitive ();
  }

  const char* const RemittanceOutcome_list_pskel::_xsde_RemittanceOutcome_list_pskel_enums_[4UL] = 
  {
    "complete",
    "error",
    "partial",
    "queued"
  };

  // RemittanceOutcome_pskel
  //

  void RemittanceOutcome_pskel::
  value ()
  {
    if (this->RemittanceOutcome_impl_)
      this->RemittanceOutcome_impl_->value ();
  }

  void RemittanceOutcome_pskel::
  post_RemittanceOutcome ()
  {
    if (this->RemittanceOutcome_impl_)
      this->RemittanceOutcome_impl_->post_RemittanceOutcome ();
    else
      post_Element ();
  }

  void RemittanceOutcome_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ConceptMapEquivalence_list_pskel
  //

  void ConceptMapEquivalence_list_pskel::
  post_ConceptMapEquivalence_list ()
  {
    if (this->ConceptMapEquivalence_list_impl_)
      this->ConceptMapEquivalence_list_impl_->post_ConceptMapEquivalence_list ();
    else
      post_code_primitive ();
  }

  const char* const ConceptMapEquivalence_list_pskel::_xsde_ConceptMapEquivalence_list_pskel_enums_[10UL] = 
  {
    "disjoint",
    "equal",
    "equivalent",
    "inexact",
    "narrower",
    "relatedto",
    "specializes",
    "subsumes",
    "unmatched",
    "wider"
  };

  // ConceptMapEquivalence_pskel
  //

  void ConceptMapEquivalence_pskel::
  value ()
  {
    if (this->ConceptMapEquivalence_impl_)
      this->ConceptMapEquivalence_impl_->value ();
  }

  void ConceptMapEquivalence_pskel::
  post_ConceptMapEquivalence ()
  {
    if (this->ConceptMapEquivalence_impl_)
      this->ConceptMapEquivalence_impl_->post_ConceptMapEquivalence ();
    else
      post_Element ();
  }

  void ConceptMapEquivalence_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // DocumentReferenceStatus_list_pskel
  //

  void DocumentReferenceStatus_list_pskel::
  post_DocumentReferenceStatus_list ()
  {
    if (this->DocumentReferenceStatus_list_impl_)
      this->DocumentReferenceStatus_list_impl_->post_DocumentReferenceStatus_list ();
    else
      post_code_primitive ();
  }

  const char* const DocumentReferenceStatus_list_pskel::_xsde_DocumentReferenceStatus_list_pskel_enums_[3UL] = 
  {
    "current",
    "entered-in-error",
    "superseded"
  };

  // DocumentReferenceStatus_pskel
  //

  void DocumentReferenceStatus_pskel::
  value ()
  {
    if (this->DocumentReferenceStatus_impl_)
      this->DocumentReferenceStatus_impl_->value ();
  }

  void DocumentReferenceStatus_pskel::
  post_DocumentReferenceStatus ()
  {
    if (this->DocumentReferenceStatus_impl_)
      this->DocumentReferenceStatus_impl_->post_DocumentReferenceStatus ();
    else
      post_Element ();
  }

  void DocumentReferenceStatus_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for Element_pskel.
  //
  bool Element_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "extension" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Element_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Element_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Element_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Element_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Element_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "extension" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->extension_parser_)
            {
              this->extension_parser_->pre ();
              ctx.nested_parser (this->extension_parser_);
            }
          }
          else
          {
            if (this->extension_parser_ != 0)
            {
              this->extension_parser_->post_Extension ();
              this->extension ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ResourceContainer_pskel.
  //
  bool ResourceContainer_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "Account" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "ActivityDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "AdverseEvent" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "AllergyIntolerance" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "Appointment" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "AppointmentResponse" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "AuditEvent" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "Basic" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "Binary" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "BiologicallyDerivedProduct" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "BodyStructure" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "Bundle" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "CapabilityStatement" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "CarePlan" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;
        else if (n == "CareTeam" &&
                 ns == "http://hl7.org/fhir")
          s = 14UL;
        else if (n == "CatalogEntry" &&
                 ns == "http://hl7.org/fhir")
          s = 15UL;
        else if (n == "ChargeItem" &&
                 ns == "http://hl7.org/fhir")
          s = 16UL;
        else if (n == "ChargeItemDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 17UL;
        else if (n == "Claim" &&
                 ns == "http://hl7.org/fhir")
          s = 18UL;
        else if (n == "ClaimResponse" &&
                 ns == "http://hl7.org/fhir")
          s = 19UL;
        else if (n == "ClinicalImpression" &&
                 ns == "http://hl7.org/fhir")
          s = 20UL;
        else if (n == "CodeSystem" &&
                 ns == "http://hl7.org/fhir")
          s = 21UL;
        else if (n == "Communication" &&
                 ns == "http://hl7.org/fhir")
          s = 22UL;
        else if (n == "CommunicationRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 23UL;
        else if (n == "CompartmentDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 24UL;
        else if (n == "Composition" &&
                 ns == "http://hl7.org/fhir")
          s = 25UL;
        else if (n == "ConceptMap" &&
                 ns == "http://hl7.org/fhir")
          s = 26UL;
        else if (n == "Condition" &&
                 ns == "http://hl7.org/fhir")
          s = 27UL;
        else if (n == "Consent" &&
                 ns == "http://hl7.org/fhir")
          s = 28UL;
        else if (n == "Contract" &&
                 ns == "http://hl7.org/fhir")
          s = 29UL;
        else if (n == "Coverage" &&
                 ns == "http://hl7.org/fhir")
          s = 30UL;
        else if (n == "CoverageEligibilityRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 31UL;
        else if (n == "CoverageEligibilityResponse" &&
                 ns == "http://hl7.org/fhir")
          s = 32UL;
        else if (n == "DetectedIssue" &&
                 ns == "http://hl7.org/fhir")
          s = 33UL;
        else if (n == "Device" &&
                 ns == "http://hl7.org/fhir")
          s = 34UL;
        else if (n == "DeviceDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 35UL;
        else if (n == "DeviceMetric" &&
                 ns == "http://hl7.org/fhir")
          s = 36UL;
        else if (n == "DeviceRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 37UL;
        else if (n == "DeviceUseStatement" &&
                 ns == "http://hl7.org/fhir")
          s = 38UL;
        else if (n == "DiagnosticReport" &&
                 ns == "http://hl7.org/fhir")
          s = 39UL;
        else if (n == "DocumentManifest" &&
                 ns == "http://hl7.org/fhir")
          s = 40UL;
        else if (n == "DocumentReference" &&
                 ns == "http://hl7.org/fhir")
          s = 41UL;
        else if (n == "EffectEvidenceSynthesis" &&
                 ns == "http://hl7.org/fhir")
          s = 42UL;
        else if (n == "Encounter" &&
                 ns == "http://hl7.org/fhir")
          s = 43UL;
        else if (n == "Endpoint" &&
                 ns == "http://hl7.org/fhir")
          s = 44UL;
        else if (n == "EnrollmentRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 45UL;
        else if (n == "EnrollmentResponse" &&
                 ns == "http://hl7.org/fhir")
          s = 46UL;
        else if (n == "EpisodeOfCare" &&
                 ns == "http://hl7.org/fhir")
          s = 47UL;
        else if (n == "EventDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 48UL;
        else if (n == "Evidence" &&
                 ns == "http://hl7.org/fhir")
          s = 49UL;
        else if (n == "EvidenceVariable" &&
                 ns == "http://hl7.org/fhir")
          s = 50UL;
        else if (n == "ExampleScenario" &&
                 ns == "http://hl7.org/fhir")
          s = 51UL;
        else if (n == "ExplanationOfBenefit" &&
                 ns == "http://hl7.org/fhir")
          s = 52UL;
        else if (n == "FamilyMemberHistory" &&
                 ns == "http://hl7.org/fhir")
          s = 53UL;
        else if (n == "Flag" &&
                 ns == "http://hl7.org/fhir")
          s = 54UL;
        else if (n == "Goal" &&
                 ns == "http://hl7.org/fhir")
          s = 55UL;
        else if (n == "GraphDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 56UL;
        else if (n == "Group" &&
                 ns == "http://hl7.org/fhir")
          s = 57UL;
        else if (n == "GuidanceResponse" &&
                 ns == "http://hl7.org/fhir")
          s = 58UL;
        else if (n == "HealthcareService" &&
                 ns == "http://hl7.org/fhir")
          s = 59UL;
        else if (n == "ImagingStudy" &&
                 ns == "http://hl7.org/fhir")
          s = 60UL;
        else if (n == "Immunization" &&
                 ns == "http://hl7.org/fhir")
          s = 61UL;
        else if (n == "ImmunizationEvaluation" &&
                 ns == "http://hl7.org/fhir")
          s = 62UL;
        else if (n == "ImmunizationRecommendation" &&
                 ns == "http://hl7.org/fhir")
          s = 63UL;
        else if (n == "ImplementationGuide" &&
                 ns == "http://hl7.org/fhir")
          s = 64UL;
        else if (n == "InsurancePlan" &&
                 ns == "http://hl7.org/fhir")
          s = 65UL;
        else if (n == "Invoice" &&
                 ns == "http://hl7.org/fhir")
          s = 66UL;
        else if (n == "Library" &&
                 ns == "http://hl7.org/fhir")
          s = 67UL;
        else if (n == "Linkage" &&
                 ns == "http://hl7.org/fhir")
          s = 68UL;
        else if (n == "List" &&
                 ns == "http://hl7.org/fhir")
          s = 69UL;
        else if (n == "Location" &&
                 ns == "http://hl7.org/fhir")
          s = 70UL;
        else if (n == "Measure" &&
                 ns == "http://hl7.org/fhir")
          s = 71UL;
        else if (n == "MeasureReport" &&
                 ns == "http://hl7.org/fhir")
          s = 72UL;
        else if (n == "Media" &&
                 ns == "http://hl7.org/fhir")
          s = 73UL;
        else if (n == "Medication" &&
                 ns == "http://hl7.org/fhir")
          s = 74UL;
        else if (n == "MedicationAdministration" &&
                 ns == "http://hl7.org/fhir")
          s = 75UL;
        else if (n == "MedicationDispense" &&
                 ns == "http://hl7.org/fhir")
          s = 76UL;
        else if (n == "MedicationKnowledge" &&
                 ns == "http://hl7.org/fhir")
          s = 77UL;
        else if (n == "MedicationRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 78UL;
        else if (n == "MedicationStatement" &&
                 ns == "http://hl7.org/fhir")
          s = 79UL;
        else if (n == "MedicinalProduct" &&
                 ns == "http://hl7.org/fhir")
          s = 80UL;
        else if (n == "MedicinalProductAuthorization" &&
                 ns == "http://hl7.org/fhir")
          s = 81UL;
        else if (n == "MedicinalProductContraindication" &&
                 ns == "http://hl7.org/fhir")
          s = 82UL;
        else if (n == "MedicinalProductIndication" &&
                 ns == "http://hl7.org/fhir")
          s = 83UL;
        else if (n == "MedicinalProductIngredient" &&
                 ns == "http://hl7.org/fhir")
          s = 84UL;
        else if (n == "MedicinalProductInteraction" &&
                 ns == "http://hl7.org/fhir")
          s = 85UL;
        else if (n == "MedicinalProductManufactured" &&
                 ns == "http://hl7.org/fhir")
          s = 86UL;
        else if (n == "MedicinalProductPackaged" &&
                 ns == "http://hl7.org/fhir")
          s = 87UL;
        else if (n == "MedicinalProductPharmaceutical" &&
                 ns == "http://hl7.org/fhir")
          s = 88UL;
        else if (n == "MedicinalProductUndesirableEffect" &&
                 ns == "http://hl7.org/fhir")
          s = 89UL;
        else if (n == "MessageDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 90UL;
        else if (n == "MessageHeader" &&
                 ns == "http://hl7.org/fhir")
          s = 91UL;
        else if (n == "MolecularSequence" &&
                 ns == "http://hl7.org/fhir")
          s = 92UL;
        else if (n == "NamingSystem" &&
                 ns == "http://hl7.org/fhir")
          s = 93UL;
        else if (n == "NutritionOrder" &&
                 ns == "http://hl7.org/fhir")
          s = 94UL;
        else if (n == "Observation" &&
                 ns == "http://hl7.org/fhir")
          s = 95UL;
        else if (n == "ObservationDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 96UL;
        else if (n == "OperationDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 97UL;
        else if (n == "OperationOutcome" &&
                 ns == "http://hl7.org/fhir")
          s = 98UL;
        else if (n == "Organization" &&
                 ns == "http://hl7.org/fhir")
          s = 99UL;
        else if (n == "OrganizationAffiliation" &&
                 ns == "http://hl7.org/fhir")
          s = 100UL;
        else if (n == "Patient" &&
                 ns == "http://hl7.org/fhir")
          s = 101UL;
        else if (n == "PaymentNotice" &&
                 ns == "http://hl7.org/fhir")
          s = 102UL;
        else if (n == "PaymentReconciliation" &&
                 ns == "http://hl7.org/fhir")
          s = 103UL;
        else if (n == "Person" &&
                 ns == "http://hl7.org/fhir")
          s = 104UL;
        else if (n == "PlanDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 105UL;
        else if (n == "Practitioner" &&
                 ns == "http://hl7.org/fhir")
          s = 106UL;
        else if (n == "PractitionerRole" &&
                 ns == "http://hl7.org/fhir")
          s = 107UL;
        else if (n == "Procedure" &&
                 ns == "http://hl7.org/fhir")
          s = 108UL;
        else if (n == "Provenance" &&
                 ns == "http://hl7.org/fhir")
          s = 109UL;
        else if (n == "Questionnaire" &&
                 ns == "http://hl7.org/fhir")
          s = 110UL;
        else if (n == "QuestionnaireResponse" &&
                 ns == "http://hl7.org/fhir")
          s = 111UL;
        else if (n == "RelatedPerson" &&
                 ns == "http://hl7.org/fhir")
          s = 112UL;
        else if (n == "RequestGroup" &&
                 ns == "http://hl7.org/fhir")
          s = 113UL;
        else if (n == "ResearchDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 114UL;
        else if (n == "ResearchElementDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 115UL;
        else if (n == "ResearchStudy" &&
                 ns == "http://hl7.org/fhir")
          s = 116UL;
        else if (n == "ResearchSubject" &&
                 ns == "http://hl7.org/fhir")
          s = 117UL;
        else if (n == "RiskAssessment" &&
                 ns == "http://hl7.org/fhir")
          s = 118UL;
        else if (n == "RiskEvidenceSynthesis" &&
                 ns == "http://hl7.org/fhir")
          s = 119UL;
        else if (n == "Schedule" &&
                 ns == "http://hl7.org/fhir")
          s = 120UL;
        else if (n == "SearchParameter" &&
                 ns == "http://hl7.org/fhir")
          s = 121UL;
        else if (n == "ServiceRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 122UL;
        else if (n == "Slot" &&
                 ns == "http://hl7.org/fhir")
          s = 123UL;
        else if (n == "Specimen" &&
                 ns == "http://hl7.org/fhir")
          s = 124UL;
        else if (n == "SpecimenDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 125UL;
        else if (n == "StructureDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 126UL;
        else if (n == "StructureMap" &&
                 ns == "http://hl7.org/fhir")
          s = 127UL;
        else if (n == "Subscription" &&
                 ns == "http://hl7.org/fhir")
          s = 128UL;
        else if (n == "Substance" &&
                 ns == "http://hl7.org/fhir")
          s = 129UL;
        else if (n == "SubstanceNucleicAcid" &&
                 ns == "http://hl7.org/fhir")
          s = 130UL;
        else if (n == "SubstancePolymer" &&
                 ns == "http://hl7.org/fhir")
          s = 131UL;
        else if (n == "SubstanceProtein" &&
                 ns == "http://hl7.org/fhir")
          s = 132UL;
        else if (n == "SubstanceReferenceInformation" &&
                 ns == "http://hl7.org/fhir")
          s = 133UL;
        else if (n == "SubstanceSourceMaterial" &&
                 ns == "http://hl7.org/fhir")
          s = 134UL;
        else if (n == "SubstanceSpecification" &&
                 ns == "http://hl7.org/fhir")
          s = 135UL;
        else if (n == "SupplyDelivery" &&
                 ns == "http://hl7.org/fhir")
          s = 136UL;
        else if (n == "SupplyRequest" &&
                 ns == "http://hl7.org/fhir")
          s = 137UL;
        else if (n == "Task" &&
                 ns == "http://hl7.org/fhir")
          s = 138UL;
        else if (n == "TerminologyCapabilities" &&
                 ns == "http://hl7.org/fhir")
          s = 139UL;
        else if (n == "TestReport" &&
                 ns == "http://hl7.org/fhir")
          s = 140UL;
        else if (n == "TestScript" &&
                 ns == "http://hl7.org/fhir")
          s = 141UL;
        else if (n == "ValueSet" &&
                 ns == "http://hl7.org/fhir")
          s = 142UL;
        else if (n == "VerificationResult" &&
                 ns == "http://hl7.org/fhir")
          s = 143UL;
        else if (n == "VisionPrescription" &&
                 ns == "http://hl7.org/fhir")
          s = 144UL;
        else if (n == "Parameters" &&
                 ns == "http://hl7.org/fhir")
          s = 145UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ResourceContainer_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ResourceContainer_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ResourceContainer_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void ResourceContainer_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ResourceContainer_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "Account" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Account_parser_)
            {
              this->Account_parser_->pre ();
              ctx.nested_parser (this->Account_parser_);
            }
          }
          else
          {
            if (this->Account_parser_ != 0)
            {
              this->Account_parser_->post_Account ();
              this->Account ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ActivityDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ActivityDefinition_parser_)
            {
              this->ActivityDefinition_parser_->pre ();
              ctx.nested_parser (this->ActivityDefinition_parser_);
            }
          }
          else
          {
            if (this->ActivityDefinition_parser_ != 0)
            {
              this->ActivityDefinition_parser_->post_ActivityDefinition ();
              this->ActivityDefinition ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "AdverseEvent" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->AdverseEvent_parser_)
            {
              this->AdverseEvent_parser_->pre ();
              ctx.nested_parser (this->AdverseEvent_parser_);
            }
          }
          else
          {
            if (this->AdverseEvent_parser_ != 0)
            {
              this->AdverseEvent_parser_->post_AdverseEvent ();
              this->AdverseEvent ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "AllergyIntolerance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->AllergyIntolerance_parser_)
            {
              this->AllergyIntolerance_parser_->pre ();
              ctx.nested_parser (this->AllergyIntolerance_parser_);
            }
          }
          else
          {
            if (this->AllergyIntolerance_parser_ != 0)
            {
              this->AllergyIntolerance_parser_->post_AllergyIntolerance ();
              this->AllergyIntolerance ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "Appointment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Appointment_parser_)
            {
              this->Appointment_parser_->pre ();
              ctx.nested_parser (this->Appointment_parser_);
            }
          }
          else
          {
            if (this->Appointment_parser_ != 0)
            {
              this->Appointment_parser_->post_Appointment ();
              this->Appointment ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "AppointmentResponse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->AppointmentResponse_parser_)
            {
              this->AppointmentResponse_parser_->pre ();
              ctx.nested_parser (this->AppointmentResponse_parser_);
            }
          }
          else
          {
            if (this->AppointmentResponse_parser_ != 0)
            {
              this->AppointmentResponse_parser_->post_AppointmentResponse ();
              this->AppointmentResponse ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "AuditEvent" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->AuditEvent_parser_)
            {
              this->AuditEvent_parser_->pre ();
              ctx.nested_parser (this->AuditEvent_parser_);
            }
          }
          else
          {
            if (this->AuditEvent_parser_ != 0)
            {
              this->AuditEvent_parser_->post_AuditEvent ();
              this->AuditEvent ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "Basic" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Basic_parser_)
            {
              this->Basic_parser_->pre ();
              ctx.nested_parser (this->Basic_parser_);
            }
          }
          else
          {
            if (this->Basic_parser_ != 0)
            {
              this->Basic_parser_->post_Basic ();
              this->Basic ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Binary_parser_)
            {
              this->Binary_parser_->pre ();
              ctx.nested_parser (this->Binary_parser_);
            }
          }
          else
          {
            if (this->Binary_parser_ != 0)
            {
              this->Binary_parser_->post_Binary ();
              this->Binary ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "BiologicallyDerivedProduct" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->BiologicallyDerivedProduct_parser_)
            {
              this->BiologicallyDerivedProduct_parser_->pre ();
              ctx.nested_parser (this->BiologicallyDerivedProduct_parser_);
            }
          }
          else
          {
            if (this->BiologicallyDerivedProduct_parser_ != 0)
            {
              this->BiologicallyDerivedProduct_parser_->post_BiologicallyDerivedProduct ();
              this->BiologicallyDerivedProduct ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "BodyStructure" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->BodyStructure_parser_)
            {
              this->BodyStructure_parser_->pre ();
              ctx.nested_parser (this->BodyStructure_parser_);
            }
          }
          else
          {
            if (this->BodyStructure_parser_ != 0)
            {
              this->BodyStructure_parser_->post_BodyStructure ();
              this->BodyStructure ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "Bundle" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Bundle_parser_)
            {
              this->Bundle_parser_->pre ();
              ctx.nested_parser (this->Bundle_parser_);
            }
          }
          else
          {
            if (this->Bundle_parser_ != 0)
            {
              this->Bundle_parser_->post_Bundle ();
              this->Bundle ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "CapabilityStatement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CapabilityStatement_parser_)
            {
              this->CapabilityStatement_parser_->pre ();
              ctx.nested_parser (this->CapabilityStatement_parser_);
            }
          }
          else
          {
            if (this->CapabilityStatement_parser_ != 0)
            {
              this->CapabilityStatement_parser_->post_CapabilityStatement ();
              this->CapabilityStatement ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "CarePlan" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CarePlan_parser_)
            {
              this->CarePlan_parser_->pre ();
              ctx.nested_parser (this->CarePlan_parser_);
            }
          }
          else
          {
            if (this->CarePlan_parser_ != 0)
            {
              this->CarePlan_parser_->post_CarePlan ();
              this->CarePlan ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "CareTeam" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CareTeam_parser_)
            {
              this->CareTeam_parser_->pre ();
              ctx.nested_parser (this->CareTeam_parser_);
            }
          }
          else
          {
            if (this->CareTeam_parser_ != 0)
            {
              this->CareTeam_parser_->post_CareTeam ();
              this->CareTeam ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "CatalogEntry" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CatalogEntry_parser_)
            {
              this->CatalogEntry_parser_->pre ();
              ctx.nested_parser (this->CatalogEntry_parser_);
            }
          }
          else
          {
            if (this->CatalogEntry_parser_ != 0)
            {
              this->CatalogEntry_parser_->post_CatalogEntry ();
              this->CatalogEntry ();
            }

            count = 0;
            state = 16UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "ChargeItem" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ChargeItem_parser_)
            {
              this->ChargeItem_parser_->pre ();
              ctx.nested_parser (this->ChargeItem_parser_);
            }
          }
          else
          {
            if (this->ChargeItem_parser_ != 0)
            {
              this->ChargeItem_parser_->post_ChargeItem ();
              this->ChargeItem ();
            }

            count = 0;
            state = 17UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "ChargeItemDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ChargeItemDefinition_parser_)
            {
              this->ChargeItemDefinition_parser_->pre ();
              ctx.nested_parser (this->ChargeItemDefinition_parser_);
            }
          }
          else
          {
            if (this->ChargeItemDefinition_parser_ != 0)
            {
              this->ChargeItemDefinition_parser_->post_ChargeItemDefinition ();
              this->ChargeItemDefinition ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "Claim" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Claim_parser_)
            {
              this->Claim_parser_->pre ();
              ctx.nested_parser (this->Claim_parser_);
            }
          }
          else
          {
            if (this->Claim_parser_ != 0)
            {
              this->Claim_parser_->post_Claim ();
              this->Claim ();
            }

            count = 0;
            state = 19UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "ClaimResponse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ClaimResponse_parser_)
            {
              this->ClaimResponse_parser_->pre ();
              ctx.nested_parser (this->ClaimResponse_parser_);
            }
          }
          else
          {
            if (this->ClaimResponse_parser_ != 0)
            {
              this->ClaimResponse_parser_->post_ClaimResponse ();
              this->ClaimResponse ();
            }

            count = 0;
            state = 20UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "ClinicalImpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ClinicalImpression_parser_)
            {
              this->ClinicalImpression_parser_->pre ();
              ctx.nested_parser (this->ClinicalImpression_parser_);
            }
          }
          else
          {
            if (this->ClinicalImpression_parser_ != 0)
            {
              this->ClinicalImpression_parser_->post_ClinicalImpression ();
              this->ClinicalImpression ();
            }

            count = 0;
            state = 21UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "CodeSystem" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CodeSystem_parser_)
            {
              this->CodeSystem_parser_->pre ();
              ctx.nested_parser (this->CodeSystem_parser_);
            }
          }
          else
          {
            if (this->CodeSystem_parser_ != 0)
            {
              this->CodeSystem_parser_->post_CodeSystem ();
              this->CodeSystem ();
            }

            count = 0;
            state = 22UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 22UL;
          // Fall through.
        }
      }
      case 22UL:
      {
        if (n == "Communication" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Communication_parser_)
            {
              this->Communication_parser_->pre ();
              ctx.nested_parser (this->Communication_parser_);
            }
          }
          else
          {
            if (this->Communication_parser_ != 0)
            {
              this->Communication_parser_->post_Communication ();
              this->Communication ();
            }

            count = 0;
            state = 23UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 23UL;
          // Fall through.
        }
      }
      case 23UL:
      {
        if (n == "CommunicationRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CommunicationRequest_parser_)
            {
              this->CommunicationRequest_parser_->pre ();
              ctx.nested_parser (this->CommunicationRequest_parser_);
            }
          }
          else
          {
            if (this->CommunicationRequest_parser_ != 0)
            {
              this->CommunicationRequest_parser_->post_CommunicationRequest ();
              this->CommunicationRequest ();
            }

            count = 0;
            state = 24UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 24UL;
          // Fall through.
        }
      }
      case 24UL:
      {
        if (n == "CompartmentDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CompartmentDefinition_parser_)
            {
              this->CompartmentDefinition_parser_->pre ();
              ctx.nested_parser (this->CompartmentDefinition_parser_);
            }
          }
          else
          {
            if (this->CompartmentDefinition_parser_ != 0)
            {
              this->CompartmentDefinition_parser_->post_CompartmentDefinition ();
              this->CompartmentDefinition ();
            }

            count = 0;
            state = 25UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 25UL;
          // Fall through.
        }
      }
      case 25UL:
      {
        if (n == "Composition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Composition_parser_)
            {
              this->Composition_parser_->pre ();
              ctx.nested_parser (this->Composition_parser_);
            }
          }
          else
          {
            if (this->Composition_parser_ != 0)
            {
              this->Composition_parser_->post_Composition ();
              this->Composition ();
            }

            count = 0;
            state = 26UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 26UL;
          // Fall through.
        }
      }
      case 26UL:
      {
        if (n == "ConceptMap" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ConceptMap_parser_)
            {
              this->ConceptMap_parser_->pre ();
              ctx.nested_parser (this->ConceptMap_parser_);
            }
          }
          else
          {
            if (this->ConceptMap_parser_ != 0)
            {
              this->ConceptMap_parser_->post_ConceptMap ();
              this->ConceptMap ();
            }

            count = 0;
            state = 27UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 27UL;
          // Fall through.
        }
      }
      case 27UL:
      {
        if (n == "Condition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Condition_parser_)
            {
              this->Condition_parser_->pre ();
              ctx.nested_parser (this->Condition_parser_);
            }
          }
          else
          {
            if (this->Condition_parser_ != 0)
            {
              this->Condition_parser_->post_Condition ();
              this->Condition ();
            }

            count = 0;
            state = 28UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 28UL;
          // Fall through.
        }
      }
      case 28UL:
      {
        if (n == "Consent" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Consent_parser_)
            {
              this->Consent_parser_->pre ();
              ctx.nested_parser (this->Consent_parser_);
            }
          }
          else
          {
            if (this->Consent_parser_ != 0)
            {
              this->Consent_parser_->post_Consent ();
              this->Consent ();
            }

            count = 0;
            state = 29UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 29UL;
          // Fall through.
        }
      }
      case 29UL:
      {
        if (n == "Contract" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Contract_parser_)
            {
              this->Contract_parser_->pre ();
              ctx.nested_parser (this->Contract_parser_);
            }
          }
          else
          {
            if (this->Contract_parser_ != 0)
            {
              this->Contract_parser_->post_Contract ();
              this->Contract ();
            }

            count = 0;
            state = 30UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 30UL;
          // Fall through.
        }
      }
      case 30UL:
      {
        if (n == "Coverage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Coverage_parser_)
            {
              this->Coverage_parser_->pre ();
              ctx.nested_parser (this->Coverage_parser_);
            }
          }
          else
          {
            if (this->Coverage_parser_ != 0)
            {
              this->Coverage_parser_->post_Coverage ();
              this->Coverage ();
            }

            count = 0;
            state = 31UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 31UL;
          // Fall through.
        }
      }
      case 31UL:
      {
        if (n == "CoverageEligibilityRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CoverageEligibilityRequest_parser_)
            {
              this->CoverageEligibilityRequest_parser_->pre ();
              ctx.nested_parser (this->CoverageEligibilityRequest_parser_);
            }
          }
          else
          {
            if (this->CoverageEligibilityRequest_parser_ != 0)
            {
              this->CoverageEligibilityRequest_parser_->post_CoverageEligibilityRequest ();
              this->CoverageEligibilityRequest ();
            }

            count = 0;
            state = 32UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 32UL;
          // Fall through.
        }
      }
      case 32UL:
      {
        if (n == "CoverageEligibilityResponse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->CoverageEligibilityResponse_parser_)
            {
              this->CoverageEligibilityResponse_parser_->pre ();
              ctx.nested_parser (this->CoverageEligibilityResponse_parser_);
            }
          }
          else
          {
            if (this->CoverageEligibilityResponse_parser_ != 0)
            {
              this->CoverageEligibilityResponse_parser_->post_CoverageEligibilityResponse ();
              this->CoverageEligibilityResponse ();
            }

            count = 0;
            state = 33UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 33UL;
          // Fall through.
        }
      }
      case 33UL:
      {
        if (n == "DetectedIssue" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DetectedIssue_parser_)
            {
              this->DetectedIssue_parser_->pre ();
              ctx.nested_parser (this->DetectedIssue_parser_);
            }
          }
          else
          {
            if (this->DetectedIssue_parser_ != 0)
            {
              this->DetectedIssue_parser_->post_DetectedIssue ();
              this->DetectedIssue ();
            }

            count = 0;
            state = 34UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 34UL;
          // Fall through.
        }
      }
      case 34UL:
      {
        if (n == "Device" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Device_parser_)
            {
              this->Device_parser_->pre ();
              ctx.nested_parser (this->Device_parser_);
            }
          }
          else
          {
            if (this->Device_parser_ != 0)
            {
              this->Device_parser_->post_Device ();
              this->Device ();
            }

            count = 0;
            state = 35UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 35UL;
          // Fall through.
        }
      }
      case 35UL:
      {
        if (n == "DeviceDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DeviceDefinition_parser_)
            {
              this->DeviceDefinition_parser_->pre ();
              ctx.nested_parser (this->DeviceDefinition_parser_);
            }
          }
          else
          {
            if (this->DeviceDefinition_parser_ != 0)
            {
              this->DeviceDefinition_parser_->post_DeviceDefinition ();
              this->DeviceDefinition ();
            }

            count = 0;
            state = 36UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 36UL;
          // Fall through.
        }
      }
      case 36UL:
      {
        if (n == "DeviceMetric" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DeviceMetric_parser_)
            {
              this->DeviceMetric_parser_->pre ();
              ctx.nested_parser (this->DeviceMetric_parser_);
            }
          }
          else
          {
            if (this->DeviceMetric_parser_ != 0)
            {
              this->DeviceMetric_parser_->post_DeviceMetric ();
              this->DeviceMetric ();
            }

            count = 0;
            state = 37UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 37UL;
          // Fall through.
        }
      }
      case 37UL:
      {
        if (n == "DeviceRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DeviceRequest_parser_)
            {
              this->DeviceRequest_parser_->pre ();
              ctx.nested_parser (this->DeviceRequest_parser_);
            }
          }
          else
          {
            if (this->DeviceRequest_parser_ != 0)
            {
              this->DeviceRequest_parser_->post_DeviceRequest ();
              this->DeviceRequest ();
            }

            count = 0;
            state = 38UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 38UL;
          // Fall through.
        }
      }
      case 38UL:
      {
        if (n == "DeviceUseStatement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DeviceUseStatement_parser_)
            {
              this->DeviceUseStatement_parser_->pre ();
              ctx.nested_parser (this->DeviceUseStatement_parser_);
            }
          }
          else
          {
            if (this->DeviceUseStatement_parser_ != 0)
            {
              this->DeviceUseStatement_parser_->post_DeviceUseStatement ();
              this->DeviceUseStatement ();
            }

            count = 0;
            state = 39UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 39UL;
          // Fall through.
        }
      }
      case 39UL:
      {
        if (n == "DiagnosticReport" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DiagnosticReport_parser_)
            {
              this->DiagnosticReport_parser_->pre ();
              ctx.nested_parser (this->DiagnosticReport_parser_);
            }
          }
          else
          {
            if (this->DiagnosticReport_parser_ != 0)
            {
              this->DiagnosticReport_parser_->post_DiagnosticReport ();
              this->DiagnosticReport ();
            }

            count = 0;
            state = 40UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 40UL;
          // Fall through.
        }
      }
      case 40UL:
      {
        if (n == "DocumentManifest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DocumentManifest_parser_)
            {
              this->DocumentManifest_parser_->pre ();
              ctx.nested_parser (this->DocumentManifest_parser_);
            }
          }
          else
          {
            if (this->DocumentManifest_parser_ != 0)
            {
              this->DocumentManifest_parser_->post_DocumentManifest ();
              this->DocumentManifest ();
            }

            count = 0;
            state = 41UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 41UL;
          // Fall through.
        }
      }
      case 41UL:
      {
        if (n == "DocumentReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->DocumentReference_parser_)
            {
              this->DocumentReference_parser_->pre ();
              ctx.nested_parser (this->DocumentReference_parser_);
            }
          }
          else
          {
            if (this->DocumentReference_parser_ != 0)
            {
              this->DocumentReference_parser_->post_DocumentReference ();
              this->DocumentReference ();
            }

            count = 0;
            state = 42UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 42UL;
          // Fall through.
        }
      }
      case 42UL:
      {
        if (n == "EffectEvidenceSynthesis" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->EffectEvidenceSynthesis_parser_)
            {
              this->EffectEvidenceSynthesis_parser_->pre ();
              ctx.nested_parser (this->EffectEvidenceSynthesis_parser_);
            }
          }
          else
          {
            if (this->EffectEvidenceSynthesis_parser_ != 0)
            {
              this->EffectEvidenceSynthesis_parser_->post_EffectEvidenceSynthesis ();
              this->EffectEvidenceSynthesis ();
            }

            count = 0;
            state = 43UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 43UL;
          // Fall through.
        }
      }
      case 43UL:
      {
        if (n == "Encounter" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Encounter_parser_)
            {
              this->Encounter_parser_->pre ();
              ctx.nested_parser (this->Encounter_parser_);
            }
          }
          else
          {
            if (this->Encounter_parser_ != 0)
            {
              this->Encounter_parser_->post_Encounter ();
              this->Encounter ();
            }

            count = 0;
            state = 44UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 44UL;
          // Fall through.
        }
      }
      case 44UL:
      {
        if (n == "Endpoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Endpoint_parser_)
            {
              this->Endpoint_parser_->pre ();
              ctx.nested_parser (this->Endpoint_parser_);
            }
          }
          else
          {
            if (this->Endpoint_parser_ != 0)
            {
              this->Endpoint_parser_->post_Endpoint ();
              this->Endpoint ();
            }

            count = 0;
            state = 45UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 45UL;
          // Fall through.
        }
      }
      case 45UL:
      {
        if (n == "EnrollmentRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->EnrollmentRequest_parser_)
            {
              this->EnrollmentRequest_parser_->pre ();
              ctx.nested_parser (this->EnrollmentRequest_parser_);
            }
          }
          else
          {
            if (this->EnrollmentRequest_parser_ != 0)
            {
              this->EnrollmentRequest_parser_->post_EnrollmentRequest ();
              this->EnrollmentRequest ();
            }

            count = 0;
            state = 46UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 46UL;
          // Fall through.
        }
      }
      case 46UL:
      {
        if (n == "EnrollmentResponse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->EnrollmentResponse_parser_)
            {
              this->EnrollmentResponse_parser_->pre ();
              ctx.nested_parser (this->EnrollmentResponse_parser_);
            }
          }
          else
          {
            if (this->EnrollmentResponse_parser_ != 0)
            {
              this->EnrollmentResponse_parser_->post_EnrollmentResponse ();
              this->EnrollmentResponse ();
            }

            count = 0;
            state = 47UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 47UL;
          // Fall through.
        }
      }
      case 47UL:
      {
        if (n == "EpisodeOfCare" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->EpisodeOfCare_parser_)
            {
              this->EpisodeOfCare_parser_->pre ();
              ctx.nested_parser (this->EpisodeOfCare_parser_);
            }
          }
          else
          {
            if (this->EpisodeOfCare_parser_ != 0)
            {
              this->EpisodeOfCare_parser_->post_EpisodeOfCare ();
              this->EpisodeOfCare ();
            }

            count = 0;
            state = 48UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 48UL;
          // Fall through.
        }
      }
      case 48UL:
      {
        if (n == "EventDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->EventDefinition_parser_)
            {
              this->EventDefinition_parser_->pre ();
              ctx.nested_parser (this->EventDefinition_parser_);
            }
          }
          else
          {
            if (this->EventDefinition_parser_ != 0)
            {
              this->EventDefinition_parser_->post_EventDefinition ();
              this->EventDefinition ();
            }

            count = 0;
            state = 49UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 49UL;
          // Fall through.
        }
      }
      case 49UL:
      {
        if (n == "Evidence" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Evidence_parser_)
            {
              this->Evidence_parser_->pre ();
              ctx.nested_parser (this->Evidence_parser_);
            }
          }
          else
          {
            if (this->Evidence_parser_ != 0)
            {
              this->Evidence_parser_->post_Evidence ();
              this->Evidence ();
            }

            count = 0;
            state = 50UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 50UL;
          // Fall through.
        }
      }
      case 50UL:
      {
        if (n == "EvidenceVariable" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->EvidenceVariable_parser_)
            {
              this->EvidenceVariable_parser_->pre ();
              ctx.nested_parser (this->EvidenceVariable_parser_);
            }
          }
          else
          {
            if (this->EvidenceVariable_parser_ != 0)
            {
              this->EvidenceVariable_parser_->post_EvidenceVariable ();
              this->EvidenceVariable ();
            }

            count = 0;
            state = 51UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 51UL;
          // Fall through.
        }
      }
      case 51UL:
      {
        if (n == "ExampleScenario" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ExampleScenario_parser_)
            {
              this->ExampleScenario_parser_->pre ();
              ctx.nested_parser (this->ExampleScenario_parser_);
            }
          }
          else
          {
            if (this->ExampleScenario_parser_ != 0)
            {
              this->ExampleScenario_parser_->post_ExampleScenario ();
              this->ExampleScenario ();
            }

            count = 0;
            state = 52UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 52UL;
          // Fall through.
        }
      }
      case 52UL:
      {
        if (n == "ExplanationOfBenefit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ExplanationOfBenefit_parser_)
            {
              this->ExplanationOfBenefit_parser_->pre ();
              ctx.nested_parser (this->ExplanationOfBenefit_parser_);
            }
          }
          else
          {
            if (this->ExplanationOfBenefit_parser_ != 0)
            {
              this->ExplanationOfBenefit_parser_->post_ExplanationOfBenefit ();
              this->ExplanationOfBenefit ();
            }

            count = 0;
            state = 53UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 53UL;
          // Fall through.
        }
      }
      case 53UL:
      {
        if (n == "FamilyMemberHistory" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->FamilyMemberHistory_parser_)
            {
              this->FamilyMemberHistory_parser_->pre ();
              ctx.nested_parser (this->FamilyMemberHistory_parser_);
            }
          }
          else
          {
            if (this->FamilyMemberHistory_parser_ != 0)
            {
              this->FamilyMemberHistory_parser_->post_FamilyMemberHistory ();
              this->FamilyMemberHistory ();
            }

            count = 0;
            state = 54UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 54UL;
          // Fall through.
        }
      }
      case 54UL:
      {
        if (n == "Flag" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Flag_parser_)
            {
              this->Flag_parser_->pre ();
              ctx.nested_parser (this->Flag_parser_);
            }
          }
          else
          {
            if (this->Flag_parser_ != 0)
            {
              this->Flag_parser_->post_Flag ();
              this->Flag ();
            }

            count = 0;
            state = 55UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 55UL;
          // Fall through.
        }
      }
      case 55UL:
      {
        if (n == "Goal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Goal_parser_)
            {
              this->Goal_parser_->pre ();
              ctx.nested_parser (this->Goal_parser_);
            }
          }
          else
          {
            if (this->Goal_parser_ != 0)
            {
              this->Goal_parser_->post_Goal ();
              this->Goal ();
            }

            count = 0;
            state = 56UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 56UL;
          // Fall through.
        }
      }
      case 56UL:
      {
        if (n == "GraphDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->GraphDefinition_parser_)
            {
              this->GraphDefinition_parser_->pre ();
              ctx.nested_parser (this->GraphDefinition_parser_);
            }
          }
          else
          {
            if (this->GraphDefinition_parser_ != 0)
            {
              this->GraphDefinition_parser_->post_GraphDefinition ();
              this->GraphDefinition ();
            }

            count = 0;
            state = 57UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 57UL;
          // Fall through.
        }
      }
      case 57UL:
      {
        if (n == "Group" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Group_parser_)
            {
              this->Group_parser_->pre ();
              ctx.nested_parser (this->Group_parser_);
            }
          }
          else
          {
            if (this->Group_parser_ != 0)
            {
              this->Group_parser_->post_Group ();
              this->Group ();
            }

            count = 0;
            state = 58UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 58UL;
          // Fall through.
        }
      }
      case 58UL:
      {
        if (n == "GuidanceResponse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->GuidanceResponse_parser_)
            {
              this->GuidanceResponse_parser_->pre ();
              ctx.nested_parser (this->GuidanceResponse_parser_);
            }
          }
          else
          {
            if (this->GuidanceResponse_parser_ != 0)
            {
              this->GuidanceResponse_parser_->post_GuidanceResponse ();
              this->GuidanceResponse ();
            }

            count = 0;
            state = 59UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 59UL;
          // Fall through.
        }
      }
      case 59UL:
      {
        if (n == "HealthcareService" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->HealthcareService_parser_)
            {
              this->HealthcareService_parser_->pre ();
              ctx.nested_parser (this->HealthcareService_parser_);
            }
          }
          else
          {
            if (this->HealthcareService_parser_ != 0)
            {
              this->HealthcareService_parser_->post_HealthcareService ();
              this->HealthcareService ();
            }

            count = 0;
            state = 60UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 60UL;
          // Fall through.
        }
      }
      case 60UL:
      {
        if (n == "ImagingStudy" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ImagingStudy_parser_)
            {
              this->ImagingStudy_parser_->pre ();
              ctx.nested_parser (this->ImagingStudy_parser_);
            }
          }
          else
          {
            if (this->ImagingStudy_parser_ != 0)
            {
              this->ImagingStudy_parser_->post_ImagingStudy ();
              this->ImagingStudy ();
            }

            count = 0;
            state = 61UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 61UL;
          // Fall through.
        }
      }
      case 61UL:
      {
        if (n == "Immunization" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Immunization_parser_)
            {
              this->Immunization_parser_->pre ();
              ctx.nested_parser (this->Immunization_parser_);
            }
          }
          else
          {
            if (this->Immunization_parser_ != 0)
            {
              this->Immunization_parser_->post_Immunization ();
              this->Immunization ();
            }

            count = 0;
            state = 62UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 62UL;
          // Fall through.
        }
      }
      case 62UL:
      {
        if (n == "ImmunizationEvaluation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ImmunizationEvaluation_parser_)
            {
              this->ImmunizationEvaluation_parser_->pre ();
              ctx.nested_parser (this->ImmunizationEvaluation_parser_);
            }
          }
          else
          {
            if (this->ImmunizationEvaluation_parser_ != 0)
            {
              this->ImmunizationEvaluation_parser_->post_ImmunizationEvaluation ();
              this->ImmunizationEvaluation ();
            }

            count = 0;
            state = 63UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 63UL;
          // Fall through.
        }
      }
      case 63UL:
      {
        if (n == "ImmunizationRecommendation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ImmunizationRecommendation_parser_)
            {
              this->ImmunizationRecommendation_parser_->pre ();
              ctx.nested_parser (this->ImmunizationRecommendation_parser_);
            }
          }
          else
          {
            if (this->ImmunizationRecommendation_parser_ != 0)
            {
              this->ImmunizationRecommendation_parser_->post_ImmunizationRecommendation ();
              this->ImmunizationRecommendation ();
            }

            count = 0;
            state = 64UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 64UL;
          // Fall through.
        }
      }
      case 64UL:
      {
        if (n == "ImplementationGuide" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ImplementationGuide_parser_)
            {
              this->ImplementationGuide_parser_->pre ();
              ctx.nested_parser (this->ImplementationGuide_parser_);
            }
          }
          else
          {
            if (this->ImplementationGuide_parser_ != 0)
            {
              this->ImplementationGuide_parser_->post_ImplementationGuide ();
              this->ImplementationGuide ();
            }

            count = 0;
            state = 65UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 65UL;
          // Fall through.
        }
      }
      case 65UL:
      {
        if (n == "InsurancePlan" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->InsurancePlan_parser_)
            {
              this->InsurancePlan_parser_->pre ();
              ctx.nested_parser (this->InsurancePlan_parser_);
            }
          }
          else
          {
            if (this->InsurancePlan_parser_ != 0)
            {
              this->InsurancePlan_parser_->post_InsurancePlan ();
              this->InsurancePlan ();
            }

            count = 0;
            state = 66UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 66UL;
          // Fall through.
        }
      }
      case 66UL:
      {
        if (n == "Invoice" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Invoice_parser_)
            {
              this->Invoice_parser_->pre ();
              ctx.nested_parser (this->Invoice_parser_);
            }
          }
          else
          {
            if (this->Invoice_parser_ != 0)
            {
              this->Invoice_parser_->post_Invoice ();
              this->Invoice ();
            }

            count = 0;
            state = 67UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 67UL;
          // Fall through.
        }
      }
      case 67UL:
      {
        if (n == "Library" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Library_parser_)
            {
              this->Library_parser_->pre ();
              ctx.nested_parser (this->Library_parser_);
            }
          }
          else
          {
            if (this->Library_parser_ != 0)
            {
              this->Library_parser_->post_Library ();
              this->Library ();
            }

            count = 0;
            state = 68UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 68UL;
          // Fall through.
        }
      }
      case 68UL:
      {
        if (n == "Linkage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Linkage_parser_)
            {
              this->Linkage_parser_->pre ();
              ctx.nested_parser (this->Linkage_parser_);
            }
          }
          else
          {
            if (this->Linkage_parser_ != 0)
            {
              this->Linkage_parser_->post_Linkage ();
              this->Linkage ();
            }

            count = 0;
            state = 69UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 69UL;
          // Fall through.
        }
      }
      case 69UL:
      {
        if (n == "List" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->List_parser_)
            {
              this->List_parser_->pre ();
              ctx.nested_parser (this->List_parser_);
            }
          }
          else
          {
            if (this->List_parser_ != 0)
            {
              this->List_parser_->post_List ();
              this->List ();
            }

            count = 0;
            state = 70UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 70UL;
          // Fall through.
        }
      }
      case 70UL:
      {
        if (n == "Location" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Location_parser_)
            {
              this->Location_parser_->pre ();
              ctx.nested_parser (this->Location_parser_);
            }
          }
          else
          {
            if (this->Location_parser_ != 0)
            {
              this->Location_parser_->post_Location ();
              this->Location ();
            }

            count = 0;
            state = 71UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 71UL;
          // Fall through.
        }
      }
      case 71UL:
      {
        if (n == "Measure" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Measure_parser_)
            {
              this->Measure_parser_->pre ();
              ctx.nested_parser (this->Measure_parser_);
            }
          }
          else
          {
            if (this->Measure_parser_ != 0)
            {
              this->Measure_parser_->post_Measure ();
              this->Measure ();
            }

            count = 0;
            state = 72UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 72UL;
          // Fall through.
        }
      }
      case 72UL:
      {
        if (n == "MeasureReport" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MeasureReport_parser_)
            {
              this->MeasureReport_parser_->pre ();
              ctx.nested_parser (this->MeasureReport_parser_);
            }
          }
          else
          {
            if (this->MeasureReport_parser_ != 0)
            {
              this->MeasureReport_parser_->post_MeasureReport ();
              this->MeasureReport ();
            }

            count = 0;
            state = 73UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 73UL;
          // Fall through.
        }
      }
      case 73UL:
      {
        if (n == "Media" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Media_parser_)
            {
              this->Media_parser_->pre ();
              ctx.nested_parser (this->Media_parser_);
            }
          }
          else
          {
            if (this->Media_parser_ != 0)
            {
              this->Media_parser_->post_Media ();
              this->Media ();
            }

            count = 0;
            state = 74UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 74UL;
          // Fall through.
        }
      }
      case 74UL:
      {
        if (n == "Medication" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Medication_parser_)
            {
              this->Medication_parser_->pre ();
              ctx.nested_parser (this->Medication_parser_);
            }
          }
          else
          {
            if (this->Medication_parser_ != 0)
            {
              this->Medication_parser_->post_Medication ();
              this->Medication ();
            }

            count = 0;
            state = 75UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 75UL;
          // Fall through.
        }
      }
      case 75UL:
      {
        if (n == "MedicationAdministration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicationAdministration_parser_)
            {
              this->MedicationAdministration_parser_->pre ();
              ctx.nested_parser (this->MedicationAdministration_parser_);
            }
          }
          else
          {
            if (this->MedicationAdministration_parser_ != 0)
            {
              this->MedicationAdministration_parser_->post_MedicationAdministration ();
              this->MedicationAdministration ();
            }

            count = 0;
            state = 76UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 76UL;
          // Fall through.
        }
      }
      case 76UL:
      {
        if (n == "MedicationDispense" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicationDispense_parser_)
            {
              this->MedicationDispense_parser_->pre ();
              ctx.nested_parser (this->MedicationDispense_parser_);
            }
          }
          else
          {
            if (this->MedicationDispense_parser_ != 0)
            {
              this->MedicationDispense_parser_->post_MedicationDispense ();
              this->MedicationDispense ();
            }

            count = 0;
            state = 77UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 77UL;
          // Fall through.
        }
      }
      case 77UL:
      {
        if (n == "MedicationKnowledge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicationKnowledge_parser_)
            {
              this->MedicationKnowledge_parser_->pre ();
              ctx.nested_parser (this->MedicationKnowledge_parser_);
            }
          }
          else
          {
            if (this->MedicationKnowledge_parser_ != 0)
            {
              this->MedicationKnowledge_parser_->post_MedicationKnowledge ();
              this->MedicationKnowledge ();
            }

            count = 0;
            state = 78UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 78UL;
          // Fall through.
        }
      }
      case 78UL:
      {
        if (n == "MedicationRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicationRequest_parser_)
            {
              this->MedicationRequest_parser_->pre ();
              ctx.nested_parser (this->MedicationRequest_parser_);
            }
          }
          else
          {
            if (this->MedicationRequest_parser_ != 0)
            {
              this->MedicationRequest_parser_->post_MedicationRequest ();
              this->MedicationRequest ();
            }

            count = 0;
            state = 79UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 79UL;
          // Fall through.
        }
      }
      case 79UL:
      {
        if (n == "MedicationStatement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicationStatement_parser_)
            {
              this->MedicationStatement_parser_->pre ();
              ctx.nested_parser (this->MedicationStatement_parser_);
            }
          }
          else
          {
            if (this->MedicationStatement_parser_ != 0)
            {
              this->MedicationStatement_parser_->post_MedicationStatement ();
              this->MedicationStatement ();
            }

            count = 0;
            state = 80UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 80UL;
          // Fall through.
        }
      }
      case 80UL:
      {
        if (n == "MedicinalProduct" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProduct_parser_)
            {
              this->MedicinalProduct_parser_->pre ();
              ctx.nested_parser (this->MedicinalProduct_parser_);
            }
          }
          else
          {
            if (this->MedicinalProduct_parser_ != 0)
            {
              this->MedicinalProduct_parser_->post_MedicinalProduct ();
              this->MedicinalProduct ();
            }

            count = 0;
            state = 81UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 81UL;
          // Fall through.
        }
      }
      case 81UL:
      {
        if (n == "MedicinalProductAuthorization" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductAuthorization_parser_)
            {
              this->MedicinalProductAuthorization_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductAuthorization_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductAuthorization_parser_ != 0)
            {
              this->MedicinalProductAuthorization_parser_->post_MedicinalProductAuthorization ();
              this->MedicinalProductAuthorization ();
            }

            count = 0;
            state = 82UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 82UL;
          // Fall through.
        }
      }
      case 82UL:
      {
        if (n == "MedicinalProductContraindication" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductContraindication_parser_)
            {
              this->MedicinalProductContraindication_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductContraindication_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductContraindication_parser_ != 0)
            {
              this->MedicinalProductContraindication_parser_->post_MedicinalProductContraindication ();
              this->MedicinalProductContraindication ();
            }

            count = 0;
            state = 83UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 83UL;
          // Fall through.
        }
      }
      case 83UL:
      {
        if (n == "MedicinalProductIndication" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductIndication_parser_)
            {
              this->MedicinalProductIndication_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductIndication_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductIndication_parser_ != 0)
            {
              this->MedicinalProductIndication_parser_->post_MedicinalProductIndication ();
              this->MedicinalProductIndication ();
            }

            count = 0;
            state = 84UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 84UL;
          // Fall through.
        }
      }
      case 84UL:
      {
        if (n == "MedicinalProductIngredient" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductIngredient_parser_)
            {
              this->MedicinalProductIngredient_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductIngredient_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductIngredient_parser_ != 0)
            {
              this->MedicinalProductIngredient_parser_->post_MedicinalProductIngredient ();
              this->MedicinalProductIngredient ();
            }

            count = 0;
            state = 85UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 85UL;
          // Fall through.
        }
      }
      case 85UL:
      {
        if (n == "MedicinalProductInteraction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductInteraction_parser_)
            {
              this->MedicinalProductInteraction_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductInteraction_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductInteraction_parser_ != 0)
            {
              this->MedicinalProductInteraction_parser_->post_MedicinalProductInteraction ();
              this->MedicinalProductInteraction ();
            }

            count = 0;
            state = 86UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 86UL;
          // Fall through.
        }
      }
      case 86UL:
      {
        if (n == "MedicinalProductManufactured" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductManufactured_parser_)
            {
              this->MedicinalProductManufactured_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductManufactured_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductManufactured_parser_ != 0)
            {
              this->MedicinalProductManufactured_parser_->post_MedicinalProductManufactured ();
              this->MedicinalProductManufactured ();
            }

            count = 0;
            state = 87UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 87UL;
          // Fall through.
        }
      }
      case 87UL:
      {
        if (n == "MedicinalProductPackaged" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductPackaged_parser_)
            {
              this->MedicinalProductPackaged_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductPackaged_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductPackaged_parser_ != 0)
            {
              this->MedicinalProductPackaged_parser_->post_MedicinalProductPackaged ();
              this->MedicinalProductPackaged ();
            }

            count = 0;
            state = 88UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 88UL;
          // Fall through.
        }
      }
      case 88UL:
      {
        if (n == "MedicinalProductPharmaceutical" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductPharmaceutical_parser_)
            {
              this->MedicinalProductPharmaceutical_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductPharmaceutical_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductPharmaceutical_parser_ != 0)
            {
              this->MedicinalProductPharmaceutical_parser_->post_MedicinalProductPharmaceutical ();
              this->MedicinalProductPharmaceutical ();
            }

            count = 0;
            state = 89UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 89UL;
          // Fall through.
        }
      }
      case 89UL:
      {
        if (n == "MedicinalProductUndesirableEffect" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MedicinalProductUndesirableEffect_parser_)
            {
              this->MedicinalProductUndesirableEffect_parser_->pre ();
              ctx.nested_parser (this->MedicinalProductUndesirableEffect_parser_);
            }
          }
          else
          {
            if (this->MedicinalProductUndesirableEffect_parser_ != 0)
            {
              this->MedicinalProductUndesirableEffect_parser_->post_MedicinalProductUndesirableEffect ();
              this->MedicinalProductUndesirableEffect ();
            }

            count = 0;
            state = 90UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 90UL;
          // Fall through.
        }
      }
      case 90UL:
      {
        if (n == "MessageDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MessageDefinition_parser_)
            {
              this->MessageDefinition_parser_->pre ();
              ctx.nested_parser (this->MessageDefinition_parser_);
            }
          }
          else
          {
            if (this->MessageDefinition_parser_ != 0)
            {
              this->MessageDefinition_parser_->post_MessageDefinition ();
              this->MessageDefinition ();
            }

            count = 0;
            state = 91UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 91UL;
          // Fall through.
        }
      }
      case 91UL:
      {
        if (n == "MessageHeader" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MessageHeader_parser_)
            {
              this->MessageHeader_parser_->pre ();
              ctx.nested_parser (this->MessageHeader_parser_);
            }
          }
          else
          {
            if (this->MessageHeader_parser_ != 0)
            {
              this->MessageHeader_parser_->post_MessageHeader ();
              this->MessageHeader ();
            }

            count = 0;
            state = 92UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 92UL;
          // Fall through.
        }
      }
      case 92UL:
      {
        if (n == "MolecularSequence" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->MolecularSequence_parser_)
            {
              this->MolecularSequence_parser_->pre ();
              ctx.nested_parser (this->MolecularSequence_parser_);
            }
          }
          else
          {
            if (this->MolecularSequence_parser_ != 0)
            {
              this->MolecularSequence_parser_->post_MolecularSequence ();
              this->MolecularSequence ();
            }

            count = 0;
            state = 93UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 93UL;
          // Fall through.
        }
      }
      case 93UL:
      {
        if (n == "NamingSystem" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->NamingSystem_parser_)
            {
              this->NamingSystem_parser_->pre ();
              ctx.nested_parser (this->NamingSystem_parser_);
            }
          }
          else
          {
            if (this->NamingSystem_parser_ != 0)
            {
              this->NamingSystem_parser_->post_NamingSystem ();
              this->NamingSystem ();
            }

            count = 0;
            state = 94UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 94UL;
          // Fall through.
        }
      }
      case 94UL:
      {
        if (n == "NutritionOrder" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->NutritionOrder_parser_)
            {
              this->NutritionOrder_parser_->pre ();
              ctx.nested_parser (this->NutritionOrder_parser_);
            }
          }
          else
          {
            if (this->NutritionOrder_parser_ != 0)
            {
              this->NutritionOrder_parser_->post_NutritionOrder ();
              this->NutritionOrder ();
            }

            count = 0;
            state = 95UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 95UL;
          // Fall through.
        }
      }
      case 95UL:
      {
        if (n == "Observation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Observation_parser_)
            {
              this->Observation_parser_->pre ();
              ctx.nested_parser (this->Observation_parser_);
            }
          }
          else
          {
            if (this->Observation_parser_ != 0)
            {
              this->Observation_parser_->post_Observation ();
              this->Observation ();
            }

            count = 0;
            state = 96UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 96UL;
          // Fall through.
        }
      }
      case 96UL:
      {
        if (n == "ObservationDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ObservationDefinition_parser_)
            {
              this->ObservationDefinition_parser_->pre ();
              ctx.nested_parser (this->ObservationDefinition_parser_);
            }
          }
          else
          {
            if (this->ObservationDefinition_parser_ != 0)
            {
              this->ObservationDefinition_parser_->post_ObservationDefinition ();
              this->ObservationDefinition ();
            }

            count = 0;
            state = 97UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 97UL;
          // Fall through.
        }
      }
      case 97UL:
      {
        if (n == "OperationDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->OperationDefinition_parser_)
            {
              this->OperationDefinition_parser_->pre ();
              ctx.nested_parser (this->OperationDefinition_parser_);
            }
          }
          else
          {
            if (this->OperationDefinition_parser_ != 0)
            {
              this->OperationDefinition_parser_->post_OperationDefinition ();
              this->OperationDefinition ();
            }

            count = 0;
            state = 98UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 98UL;
          // Fall through.
        }
      }
      case 98UL:
      {
        if (n == "OperationOutcome" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->OperationOutcome_parser_)
            {
              this->OperationOutcome_parser_->pre ();
              ctx.nested_parser (this->OperationOutcome_parser_);
            }
          }
          else
          {
            if (this->OperationOutcome_parser_ != 0)
            {
              this->OperationOutcome_parser_->post_OperationOutcome ();
              this->OperationOutcome ();
            }

            count = 0;
            state = 99UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 99UL;
          // Fall through.
        }
      }
      case 99UL:
      {
        if (n == "Organization" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Organization_parser_)
            {
              this->Organization_parser_->pre ();
              ctx.nested_parser (this->Organization_parser_);
            }
          }
          else
          {
            if (this->Organization_parser_ != 0)
            {
              this->Organization_parser_->post_Organization ();
              this->Organization ();
            }

            count = 0;
            state = 100UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 100UL;
          // Fall through.
        }
      }
      case 100UL:
      {
        if (n == "OrganizationAffiliation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->OrganizationAffiliation_parser_)
            {
              this->OrganizationAffiliation_parser_->pre ();
              ctx.nested_parser (this->OrganizationAffiliation_parser_);
            }
          }
          else
          {
            if (this->OrganizationAffiliation_parser_ != 0)
            {
              this->OrganizationAffiliation_parser_->post_OrganizationAffiliation ();
              this->OrganizationAffiliation ();
            }

            count = 0;
            state = 101UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 101UL;
          // Fall through.
        }
      }
      case 101UL:
      {
        if (n == "Patient" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Patient_parser_)
            {
              this->Patient_parser_->pre ();
              ctx.nested_parser (this->Patient_parser_);
            }
          }
          else
          {
            if (this->Patient_parser_ != 0)
            {
              this->Patient_parser_->post_Patient ();
              this->Patient ();
            }

            count = 0;
            state = 102UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 102UL;
          // Fall through.
        }
      }
      case 102UL:
      {
        if (n == "PaymentNotice" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->PaymentNotice_parser_)
            {
              this->PaymentNotice_parser_->pre ();
              ctx.nested_parser (this->PaymentNotice_parser_);
            }
          }
          else
          {
            if (this->PaymentNotice_parser_ != 0)
            {
              this->PaymentNotice_parser_->post_PaymentNotice ();
              this->PaymentNotice ();
            }

            count = 0;
            state = 103UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 103UL;
          // Fall through.
        }
      }
      case 103UL:
      {
        if (n == "PaymentReconciliation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->PaymentReconciliation_parser_)
            {
              this->PaymentReconciliation_parser_->pre ();
              ctx.nested_parser (this->PaymentReconciliation_parser_);
            }
          }
          else
          {
            if (this->PaymentReconciliation_parser_ != 0)
            {
              this->PaymentReconciliation_parser_->post_PaymentReconciliation ();
              this->PaymentReconciliation ();
            }

            count = 0;
            state = 104UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 104UL;
          // Fall through.
        }
      }
      case 104UL:
      {
        if (n == "Person" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Person_parser_)
            {
              this->Person_parser_->pre ();
              ctx.nested_parser (this->Person_parser_);
            }
          }
          else
          {
            if (this->Person_parser_ != 0)
            {
              this->Person_parser_->post_Person ();
              this->Person ();
            }

            count = 0;
            state = 105UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 105UL;
          // Fall through.
        }
      }
      case 105UL:
      {
        if (n == "PlanDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->PlanDefinition_parser_)
            {
              this->PlanDefinition_parser_->pre ();
              ctx.nested_parser (this->PlanDefinition_parser_);
            }
          }
          else
          {
            if (this->PlanDefinition_parser_ != 0)
            {
              this->PlanDefinition_parser_->post_PlanDefinition ();
              this->PlanDefinition ();
            }

            count = 0;
            state = 106UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 106UL;
          // Fall through.
        }
      }
      case 106UL:
      {
        if (n == "Practitioner" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Practitioner_parser_)
            {
              this->Practitioner_parser_->pre ();
              ctx.nested_parser (this->Practitioner_parser_);
            }
          }
          else
          {
            if (this->Practitioner_parser_ != 0)
            {
              this->Practitioner_parser_->post_Practitioner ();
              this->Practitioner ();
            }

            count = 0;
            state = 107UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 107UL;
          // Fall through.
        }
      }
      case 107UL:
      {
        if (n == "PractitionerRole" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->PractitionerRole_parser_)
            {
              this->PractitionerRole_parser_->pre ();
              ctx.nested_parser (this->PractitionerRole_parser_);
            }
          }
          else
          {
            if (this->PractitionerRole_parser_ != 0)
            {
              this->PractitionerRole_parser_->post_PractitionerRole ();
              this->PractitionerRole ();
            }

            count = 0;
            state = 108UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 108UL;
          // Fall through.
        }
      }
      case 108UL:
      {
        if (n == "Procedure" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Procedure_parser_)
            {
              this->Procedure_parser_->pre ();
              ctx.nested_parser (this->Procedure_parser_);
            }
          }
          else
          {
            if (this->Procedure_parser_ != 0)
            {
              this->Procedure_parser_->post_Procedure ();
              this->Procedure ();
            }

            count = 0;
            state = 109UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 109UL;
          // Fall through.
        }
      }
      case 109UL:
      {
        if (n == "Provenance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Provenance_parser_)
            {
              this->Provenance_parser_->pre ();
              ctx.nested_parser (this->Provenance_parser_);
            }
          }
          else
          {
            if (this->Provenance_parser_ != 0)
            {
              this->Provenance_parser_->post_Provenance ();
              this->Provenance ();
            }

            count = 0;
            state = 110UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 110UL;
          // Fall through.
        }
      }
      case 110UL:
      {
        if (n == "Questionnaire" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Questionnaire_parser_)
            {
              this->Questionnaire_parser_->pre ();
              ctx.nested_parser (this->Questionnaire_parser_);
            }
          }
          else
          {
            if (this->Questionnaire_parser_ != 0)
            {
              this->Questionnaire_parser_->post_Questionnaire ();
              this->Questionnaire ();
            }

            count = 0;
            state = 111UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 111UL;
          // Fall through.
        }
      }
      case 111UL:
      {
        if (n == "QuestionnaireResponse" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->QuestionnaireResponse_parser_)
            {
              this->QuestionnaireResponse_parser_->pre ();
              ctx.nested_parser (this->QuestionnaireResponse_parser_);
            }
          }
          else
          {
            if (this->QuestionnaireResponse_parser_ != 0)
            {
              this->QuestionnaireResponse_parser_->post_QuestionnaireResponse ();
              this->QuestionnaireResponse ();
            }

            count = 0;
            state = 112UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 112UL;
          // Fall through.
        }
      }
      case 112UL:
      {
        if (n == "RelatedPerson" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->RelatedPerson_parser_)
            {
              this->RelatedPerson_parser_->pre ();
              ctx.nested_parser (this->RelatedPerson_parser_);
            }
          }
          else
          {
            if (this->RelatedPerson_parser_ != 0)
            {
              this->RelatedPerson_parser_->post_RelatedPerson ();
              this->RelatedPerson ();
            }

            count = 0;
            state = 113UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 113UL;
          // Fall through.
        }
      }
      case 113UL:
      {
        if (n == "RequestGroup" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->RequestGroup_parser_)
            {
              this->RequestGroup_parser_->pre ();
              ctx.nested_parser (this->RequestGroup_parser_);
            }
          }
          else
          {
            if (this->RequestGroup_parser_ != 0)
            {
              this->RequestGroup_parser_->post_RequestGroup ();
              this->RequestGroup ();
            }

            count = 0;
            state = 114UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 114UL;
          // Fall through.
        }
      }
      case 114UL:
      {
        if (n == "ResearchDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ResearchDefinition_parser_)
            {
              this->ResearchDefinition_parser_->pre ();
              ctx.nested_parser (this->ResearchDefinition_parser_);
            }
          }
          else
          {
            if (this->ResearchDefinition_parser_ != 0)
            {
              this->ResearchDefinition_parser_->post_ResearchDefinition ();
              this->ResearchDefinition ();
            }

            count = 0;
            state = 115UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 115UL;
          // Fall through.
        }
      }
      case 115UL:
      {
        if (n == "ResearchElementDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ResearchElementDefinition_parser_)
            {
              this->ResearchElementDefinition_parser_->pre ();
              ctx.nested_parser (this->ResearchElementDefinition_parser_);
            }
          }
          else
          {
            if (this->ResearchElementDefinition_parser_ != 0)
            {
              this->ResearchElementDefinition_parser_->post_ResearchElementDefinition ();
              this->ResearchElementDefinition ();
            }

            count = 0;
            state = 116UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 116UL;
          // Fall through.
        }
      }
      case 116UL:
      {
        if (n == "ResearchStudy" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ResearchStudy_parser_)
            {
              this->ResearchStudy_parser_->pre ();
              ctx.nested_parser (this->ResearchStudy_parser_);
            }
          }
          else
          {
            if (this->ResearchStudy_parser_ != 0)
            {
              this->ResearchStudy_parser_->post_ResearchStudy ();
              this->ResearchStudy ();
            }

            count = 0;
            state = 117UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 117UL;
          // Fall through.
        }
      }
      case 117UL:
      {
        if (n == "ResearchSubject" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ResearchSubject_parser_)
            {
              this->ResearchSubject_parser_->pre ();
              ctx.nested_parser (this->ResearchSubject_parser_);
            }
          }
          else
          {
            if (this->ResearchSubject_parser_ != 0)
            {
              this->ResearchSubject_parser_->post_ResearchSubject ();
              this->ResearchSubject ();
            }

            count = 0;
            state = 118UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 118UL;
          // Fall through.
        }
      }
      case 118UL:
      {
        if (n == "RiskAssessment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->RiskAssessment_parser_)
            {
              this->RiskAssessment_parser_->pre ();
              ctx.nested_parser (this->RiskAssessment_parser_);
            }
          }
          else
          {
            if (this->RiskAssessment_parser_ != 0)
            {
              this->RiskAssessment_parser_->post_RiskAssessment ();
              this->RiskAssessment ();
            }

            count = 0;
            state = 119UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 119UL;
          // Fall through.
        }
      }
      case 119UL:
      {
        if (n == "RiskEvidenceSynthesis" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->RiskEvidenceSynthesis_parser_)
            {
              this->RiskEvidenceSynthesis_parser_->pre ();
              ctx.nested_parser (this->RiskEvidenceSynthesis_parser_);
            }
          }
          else
          {
            if (this->RiskEvidenceSynthesis_parser_ != 0)
            {
              this->RiskEvidenceSynthesis_parser_->post_RiskEvidenceSynthesis ();
              this->RiskEvidenceSynthesis ();
            }

            count = 0;
            state = 120UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 120UL;
          // Fall through.
        }
      }
      case 120UL:
      {
        if (n == "Schedule" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Schedule_parser_)
            {
              this->Schedule_parser_->pre ();
              ctx.nested_parser (this->Schedule_parser_);
            }
          }
          else
          {
            if (this->Schedule_parser_ != 0)
            {
              this->Schedule_parser_->post_Schedule ();
              this->Schedule ();
            }

            count = 0;
            state = 121UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 121UL;
          // Fall through.
        }
      }
      case 121UL:
      {
        if (n == "SearchParameter" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SearchParameter_parser_)
            {
              this->SearchParameter_parser_->pre ();
              ctx.nested_parser (this->SearchParameter_parser_);
            }
          }
          else
          {
            if (this->SearchParameter_parser_ != 0)
            {
              this->SearchParameter_parser_->post_SearchParameter ();
              this->SearchParameter ();
            }

            count = 0;
            state = 122UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 122UL;
          // Fall through.
        }
      }
      case 122UL:
      {
        if (n == "ServiceRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ServiceRequest_parser_)
            {
              this->ServiceRequest_parser_->pre ();
              ctx.nested_parser (this->ServiceRequest_parser_);
            }
          }
          else
          {
            if (this->ServiceRequest_parser_ != 0)
            {
              this->ServiceRequest_parser_->post_ServiceRequest ();
              this->ServiceRequest ();
            }

            count = 0;
            state = 123UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 123UL;
          // Fall through.
        }
      }
      case 123UL:
      {
        if (n == "Slot" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Slot_parser_)
            {
              this->Slot_parser_->pre ();
              ctx.nested_parser (this->Slot_parser_);
            }
          }
          else
          {
            if (this->Slot_parser_ != 0)
            {
              this->Slot_parser_->post_Slot ();
              this->Slot ();
            }

            count = 0;
            state = 124UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 124UL;
          // Fall through.
        }
      }
      case 124UL:
      {
        if (n == "Specimen" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Specimen_parser_)
            {
              this->Specimen_parser_->pre ();
              ctx.nested_parser (this->Specimen_parser_);
            }
          }
          else
          {
            if (this->Specimen_parser_ != 0)
            {
              this->Specimen_parser_->post_Specimen ();
              this->Specimen ();
            }

            count = 0;
            state = 125UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 125UL;
          // Fall through.
        }
      }
      case 125UL:
      {
        if (n == "SpecimenDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SpecimenDefinition_parser_)
            {
              this->SpecimenDefinition_parser_->pre ();
              ctx.nested_parser (this->SpecimenDefinition_parser_);
            }
          }
          else
          {
            if (this->SpecimenDefinition_parser_ != 0)
            {
              this->SpecimenDefinition_parser_->post_SpecimenDefinition ();
              this->SpecimenDefinition ();
            }

            count = 0;
            state = 126UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 126UL;
          // Fall through.
        }
      }
      case 126UL:
      {
        if (n == "StructureDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->StructureDefinition_parser_)
            {
              this->StructureDefinition_parser_->pre ();
              ctx.nested_parser (this->StructureDefinition_parser_);
            }
          }
          else
          {
            if (this->StructureDefinition_parser_ != 0)
            {
              this->StructureDefinition_parser_->post_StructureDefinition ();
              this->StructureDefinition ();
            }

            count = 0;
            state = 127UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 127UL;
          // Fall through.
        }
      }
      case 127UL:
      {
        if (n == "StructureMap" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->StructureMap_parser_)
            {
              this->StructureMap_parser_->pre ();
              ctx.nested_parser (this->StructureMap_parser_);
            }
          }
          else
          {
            if (this->StructureMap_parser_ != 0)
            {
              this->StructureMap_parser_->post_StructureMap ();
              this->StructureMap ();
            }

            count = 0;
            state = 128UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 128UL;
          // Fall through.
        }
      }
      case 128UL:
      {
        if (n == "Subscription" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Subscription_parser_)
            {
              this->Subscription_parser_->pre ();
              ctx.nested_parser (this->Subscription_parser_);
            }
          }
          else
          {
            if (this->Subscription_parser_ != 0)
            {
              this->Subscription_parser_->post_Subscription ();
              this->Subscription ();
            }

            count = 0;
            state = 129UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 129UL;
          // Fall through.
        }
      }
      case 129UL:
      {
        if (n == "Substance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Substance_parser_)
            {
              this->Substance_parser_->pre ();
              ctx.nested_parser (this->Substance_parser_);
            }
          }
          else
          {
            if (this->Substance_parser_ != 0)
            {
              this->Substance_parser_->post_Substance ();
              this->Substance ();
            }

            count = 0;
            state = 130UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 130UL;
          // Fall through.
        }
      }
      case 130UL:
      {
        if (n == "SubstanceNucleicAcid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SubstanceNucleicAcid_parser_)
            {
              this->SubstanceNucleicAcid_parser_->pre ();
              ctx.nested_parser (this->SubstanceNucleicAcid_parser_);
            }
          }
          else
          {
            if (this->SubstanceNucleicAcid_parser_ != 0)
            {
              this->SubstanceNucleicAcid_parser_->post_SubstanceNucleicAcid ();
              this->SubstanceNucleicAcid ();
            }

            count = 0;
            state = 131UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 131UL;
          // Fall through.
        }
      }
      case 131UL:
      {
        if (n == "SubstancePolymer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SubstancePolymer_parser_)
            {
              this->SubstancePolymer_parser_->pre ();
              ctx.nested_parser (this->SubstancePolymer_parser_);
            }
          }
          else
          {
            if (this->SubstancePolymer_parser_ != 0)
            {
              this->SubstancePolymer_parser_->post_SubstancePolymer ();
              this->SubstancePolymer ();
            }

            count = 0;
            state = 132UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 132UL;
          // Fall through.
        }
      }
      case 132UL:
      {
        if (n == "SubstanceProtein" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SubstanceProtein_parser_)
            {
              this->SubstanceProtein_parser_->pre ();
              ctx.nested_parser (this->SubstanceProtein_parser_);
            }
          }
          else
          {
            if (this->SubstanceProtein_parser_ != 0)
            {
              this->SubstanceProtein_parser_->post_SubstanceProtein ();
              this->SubstanceProtein ();
            }

            count = 0;
            state = 133UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 133UL;
          // Fall through.
        }
      }
      case 133UL:
      {
        if (n == "SubstanceReferenceInformation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SubstanceReferenceInformation_parser_)
            {
              this->SubstanceReferenceInformation_parser_->pre ();
              ctx.nested_parser (this->SubstanceReferenceInformation_parser_);
            }
          }
          else
          {
            if (this->SubstanceReferenceInformation_parser_ != 0)
            {
              this->SubstanceReferenceInformation_parser_->post_SubstanceReferenceInformation ();
              this->SubstanceReferenceInformation ();
            }

            count = 0;
            state = 134UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 134UL;
          // Fall through.
        }
      }
      case 134UL:
      {
        if (n == "SubstanceSourceMaterial" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SubstanceSourceMaterial_parser_)
            {
              this->SubstanceSourceMaterial_parser_->pre ();
              ctx.nested_parser (this->SubstanceSourceMaterial_parser_);
            }
          }
          else
          {
            if (this->SubstanceSourceMaterial_parser_ != 0)
            {
              this->SubstanceSourceMaterial_parser_->post_SubstanceSourceMaterial ();
              this->SubstanceSourceMaterial ();
            }

            count = 0;
            state = 135UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 135UL;
          // Fall through.
        }
      }
      case 135UL:
      {
        if (n == "SubstanceSpecification" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SubstanceSpecification_parser_)
            {
              this->SubstanceSpecification_parser_->pre ();
              ctx.nested_parser (this->SubstanceSpecification_parser_);
            }
          }
          else
          {
            if (this->SubstanceSpecification_parser_ != 0)
            {
              this->SubstanceSpecification_parser_->post_SubstanceSpecification ();
              this->SubstanceSpecification ();
            }

            count = 0;
            state = 136UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 136UL;
          // Fall through.
        }
      }
      case 136UL:
      {
        if (n == "SupplyDelivery" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SupplyDelivery_parser_)
            {
              this->SupplyDelivery_parser_->pre ();
              ctx.nested_parser (this->SupplyDelivery_parser_);
            }
          }
          else
          {
            if (this->SupplyDelivery_parser_ != 0)
            {
              this->SupplyDelivery_parser_->post_SupplyDelivery ();
              this->SupplyDelivery ();
            }

            count = 0;
            state = 137UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 137UL;
          // Fall through.
        }
      }
      case 137UL:
      {
        if (n == "SupplyRequest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->SupplyRequest_parser_)
            {
              this->SupplyRequest_parser_->pre ();
              ctx.nested_parser (this->SupplyRequest_parser_);
            }
          }
          else
          {
            if (this->SupplyRequest_parser_ != 0)
            {
              this->SupplyRequest_parser_->post_SupplyRequest ();
              this->SupplyRequest ();
            }

            count = 0;
            state = 138UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 138UL;
          // Fall through.
        }
      }
      case 138UL:
      {
        if (n == "Task" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Task_parser_)
            {
              this->Task_parser_->pre ();
              ctx.nested_parser (this->Task_parser_);
            }
          }
          else
          {
            if (this->Task_parser_ != 0)
            {
              this->Task_parser_->post_Task ();
              this->Task ();
            }

            count = 0;
            state = 139UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 139UL;
          // Fall through.
        }
      }
      case 139UL:
      {
        if (n == "TerminologyCapabilities" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->TerminologyCapabilities_parser_)
            {
              this->TerminologyCapabilities_parser_->pre ();
              ctx.nested_parser (this->TerminologyCapabilities_parser_);
            }
          }
          else
          {
            if (this->TerminologyCapabilities_parser_ != 0)
            {
              this->TerminologyCapabilities_parser_->post_TerminologyCapabilities ();
              this->TerminologyCapabilities ();
            }

            count = 0;
            state = 140UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 140UL;
          // Fall through.
        }
      }
      case 140UL:
      {
        if (n == "TestReport" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->TestReport_parser_)
            {
              this->TestReport_parser_->pre ();
              ctx.nested_parser (this->TestReport_parser_);
            }
          }
          else
          {
            if (this->TestReport_parser_ != 0)
            {
              this->TestReport_parser_->post_TestReport ();
              this->TestReport ();
            }

            count = 0;
            state = 141UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 141UL;
          // Fall through.
        }
      }
      case 141UL:
      {
        if (n == "TestScript" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->TestScript_parser_)
            {
              this->TestScript_parser_->pre ();
              ctx.nested_parser (this->TestScript_parser_);
            }
          }
          else
          {
            if (this->TestScript_parser_ != 0)
            {
              this->TestScript_parser_->post_TestScript ();
              this->TestScript ();
            }

            count = 0;
            state = 142UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 142UL;
          // Fall through.
        }
      }
      case 142UL:
      {
        if (n == "ValueSet" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ValueSet_parser_)
            {
              this->ValueSet_parser_->pre ();
              ctx.nested_parser (this->ValueSet_parser_);
            }
          }
          else
          {
            if (this->ValueSet_parser_ != 0)
            {
              this->ValueSet_parser_->post_ValueSet ();
              this->ValueSet ();
            }

            count = 0;
            state = 143UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 143UL;
          // Fall through.
        }
      }
      case 143UL:
      {
        if (n == "VerificationResult" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->VerificationResult_parser_)
            {
              this->VerificationResult_parser_->pre ();
              ctx.nested_parser (this->VerificationResult_parser_);
            }
          }
          else
          {
            if (this->VerificationResult_parser_ != 0)
            {
              this->VerificationResult_parser_->post_VerificationResult ();
              this->VerificationResult ();
            }

            count = 0;
            state = 144UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 144UL;
          // Fall through.
        }
      }
      case 144UL:
      {
        if (n == "VisionPrescription" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->VisionPrescription_parser_)
            {
              this->VisionPrescription_parser_->pre ();
              ctx.nested_parser (this->VisionPrescription_parser_);
            }
          }
          else
          {
            if (this->VisionPrescription_parser_ != 0)
            {
              this->VisionPrescription_parser_->post_VisionPrescription ();
              this->VisionPrescription ();
            }

            count = 0;
            state = 145UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 145UL;
          // Fall through.
        }
      }
      case 145UL:
      {
        if (n == "Parameters" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->Parameters_parser_)
            {
              this->Parameters_parser_->pre ();
              ctx.nested_parser (this->Parameters_parser_);
            }
          }
          else
          {
            if (this->Parameters_parser_ != 0)
            {
              this->Parameters_parser_->post_Parameters ();
              this->Parameters ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Extension_pskel.
  //
  bool Extension_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "valueBase64Binary" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "valueBoolean" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "valueCanonical" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "valueCode" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "valueDate" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "valueDateTime" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "valueDecimal" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "valueId" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "valueInstant" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "valueInteger" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "valueMarkdown" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "valueOid" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "valuePositiveInt" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "valueString" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;
        else if (n == "valueTime" &&
                 ns == "http://hl7.org/fhir")
          s = 14UL;
        else if (n == "valueUnsignedInt" &&
                 ns == "http://hl7.org/fhir")
          s = 15UL;
        else if (n == "valueUri" &&
                 ns == "http://hl7.org/fhir")
          s = 16UL;
        else if (n == "valueUrl" &&
                 ns == "http://hl7.org/fhir")
          s = 17UL;
        else if (n == "valueUuid" &&
                 ns == "http://hl7.org/fhir")
          s = 18UL;
        else if (n == "valueAddress" &&
                 ns == "http://hl7.org/fhir")
          s = 19UL;
        else if (n == "valueAge" &&
                 ns == "http://hl7.org/fhir")
          s = 20UL;
        else if (n == "valueAnnotation" &&
                 ns == "http://hl7.org/fhir")
          s = 21UL;
        else if (n == "valueAttachment" &&
                 ns == "http://hl7.org/fhir")
          s = 22UL;
        else if (n == "valueCodeableConcept" &&
                 ns == "http://hl7.org/fhir")
          s = 23UL;
        else if (n == "valueCoding" &&
                 ns == "http://hl7.org/fhir")
          s = 24UL;
        else if (n == "valueContactPoint" &&
                 ns == "http://hl7.org/fhir")
          s = 25UL;
        else if (n == "valueCount" &&
                 ns == "http://hl7.org/fhir")
          s = 26UL;
        else if (n == "valueDistance" &&
                 ns == "http://hl7.org/fhir")
          s = 27UL;
        else if (n == "valueDuration" &&
                 ns == "http://hl7.org/fhir")
          s = 28UL;
        else if (n == "valueHumanName" &&
                 ns == "http://hl7.org/fhir")
          s = 29UL;
        else if (n == "valueIdentifier" &&
                 ns == "http://hl7.org/fhir")
          s = 30UL;
        else if (n == "valueMoney" &&
                 ns == "http://hl7.org/fhir")
          s = 31UL;
        else if (n == "valuePeriod" &&
                 ns == "http://hl7.org/fhir")
          s = 32UL;
        else if (n == "valueQuantity" &&
                 ns == "http://hl7.org/fhir")
          s = 33UL;
        else if (n == "valueRange" &&
                 ns == "http://hl7.org/fhir")
          s = 34UL;
        else if (n == "valueRatio" &&
                 ns == "http://hl7.org/fhir")
          s = 35UL;
        else if (n == "valueReference" &&
                 ns == "http://hl7.org/fhir")
          s = 36UL;
        else if (n == "valueSampledData" &&
                 ns == "http://hl7.org/fhir")
          s = 37UL;
        else if (n == "valueSignature" &&
                 ns == "http://hl7.org/fhir")
          s = 38UL;
        else if (n == "valueTiming" &&
                 ns == "http://hl7.org/fhir")
          s = 39UL;
        else if (n == "valueContactDetail" &&
                 ns == "http://hl7.org/fhir")
          s = 40UL;
        else if (n == "valueContributor" &&
                 ns == "http://hl7.org/fhir")
          s = 41UL;
        else if (n == "valueDataRequirement" &&
                 ns == "http://hl7.org/fhir")
          s = 42UL;
        else if (n == "valueExpression" &&
                 ns == "http://hl7.org/fhir")
          s = 43UL;
        else if (n == "valueParameterDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 44UL;
        else if (n == "valueRelatedArtifact" &&
                 ns == "http://hl7.org/fhir")
          s = 45UL;
        else if (n == "valueTriggerDefinition" &&
                 ns == "http://hl7.org/fhir")
          s = 46UL;
        else if (n == "valueUsageContext" &&
                 ns == "http://hl7.org/fhir")
          s = 47UL;
        else if (n == "valueDosage" &&
                 ns == "http://hl7.org/fhir")
          s = 48UL;
        else if (n == "valueMeta" &&
                 ns == "http://hl7.org/fhir")
          s = 49UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Extension_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Extension_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Extension_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Extension_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Extension_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "valueBase64Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueBase64Binary_parser_)
            {
              this->valueBase64Binary_parser_->pre ();
              ctx.nested_parser (this->valueBase64Binary_parser_);
            }
          }
          else
          {
            if (this->valueBase64Binary_parser_ != 0)
            {
              this->valueBase64Binary_parser_->post_base64Binary ();
              this->valueBase64Binary ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "valueBoolean" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueBoolean_parser_)
            {
              this->valueBoolean_parser_->pre ();
              ctx.nested_parser (this->valueBoolean_parser_);
            }
          }
          else
          {
            if (this->valueBoolean_parser_ != 0)
            {
              this->valueBoolean_parser_->post_boolean ();
              this->valueBoolean ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueCanonical" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCanonical_parser_)
            {
              this->valueCanonical_parser_->pre ();
              ctx.nested_parser (this->valueCanonical_parser_);
            }
          }
          else
          {
            if (this->valueCanonical_parser_ != 0)
            {
              this->valueCanonical_parser_->post_canonical ();
              this->valueCanonical ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "valueCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCode_parser_)
            {
              this->valueCode_parser_->pre ();
              ctx.nested_parser (this->valueCode_parser_);
            }
          }
          else
          {
            if (this->valueCode_parser_ != 0)
            {
              this->valueCode_parser_->post_code ();
              this->valueCode ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "valueDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDate_parser_)
            {
              this->valueDate_parser_->pre ();
              ctx.nested_parser (this->valueDate_parser_);
            }
          }
          else
          {
            if (this->valueDate_parser_ != 0)
            {
              this->valueDate_parser_->post_date ();
              this->valueDate ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "valueDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDateTime_parser_)
            {
              this->valueDateTime_parser_->pre ();
              ctx.nested_parser (this->valueDateTime_parser_);
            }
          }
          else
          {
            if (this->valueDateTime_parser_ != 0)
            {
              this->valueDateTime_parser_->post_dateTime ();
              this->valueDateTime ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "valueDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDecimal_parser_)
            {
              this->valueDecimal_parser_->pre ();
              ctx.nested_parser (this->valueDecimal_parser_);
            }
          }
          else
          {
            if (this->valueDecimal_parser_ != 0)
            {
              this->valueDecimal_parser_->post_decimal ();
              this->valueDecimal ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "valueId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueId_parser_)
            {
              this->valueId_parser_->pre ();
              ctx.nested_parser (this->valueId_parser_);
            }
          }
          else
          {
            if (this->valueId_parser_ != 0)
            {
              this->valueId_parser_->post_id ();
              this->valueId ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "valueInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueInstant_parser_)
            {
              this->valueInstant_parser_->pre ();
              ctx.nested_parser (this->valueInstant_parser_);
            }
          }
          else
          {
            if (this->valueInstant_parser_ != 0)
            {
              this->valueInstant_parser_->post_instant ();
              this->valueInstant ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "valueInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueInteger_parser_)
            {
              this->valueInteger_parser_->pre ();
              ctx.nested_parser (this->valueInteger_parser_);
            }
          }
          else
          {
            if (this->valueInteger_parser_ != 0)
            {
              this->valueInteger_parser_->post_integer ();
              this->valueInteger ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "valueMarkdown" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueMarkdown_parser_)
            {
              this->valueMarkdown_parser_->pre ();
              ctx.nested_parser (this->valueMarkdown_parser_);
            }
          }
          else
          {
            if (this->valueMarkdown_parser_ != 0)
            {
              this->valueMarkdown_parser_->post_markdown ();
              this->valueMarkdown ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "valueOid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueOid_parser_)
            {
              this->valueOid_parser_->pre ();
              ctx.nested_parser (this->valueOid_parser_);
            }
          }
          else
          {
            if (this->valueOid_parser_ != 0)
            {
              this->valueOid_parser_->post_oid ();
              this->valueOid ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "valuePositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valuePositiveInt_parser_)
            {
              this->valuePositiveInt_parser_->pre ();
              ctx.nested_parser (this->valuePositiveInt_parser_);
            }
          }
          else
          {
            if (this->valuePositiveInt_parser_ != 0)
            {
              this->valuePositiveInt_parser_->post_positiveInt ();
              this->valuePositiveInt ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "valueString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueString_parser_)
            {
              this->valueString_parser_->pre ();
              ctx.nested_parser (this->valueString_parser_);
            }
          }
          else
          {
            if (this->valueString_parser_ != 0)
            {
              this->valueString_parser_->post_string ();
              this->valueString ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "valueTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueTime_parser_)
            {
              this->valueTime_parser_->pre ();
              ctx.nested_parser (this->valueTime_parser_);
            }
          }
          else
          {
            if (this->valueTime_parser_ != 0)
            {
              this->valueTime_parser_->post_time ();
              this->valueTime ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "valueUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUnsignedInt_parser_)
            {
              this->valueUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->valueUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->valueUnsignedInt_parser_ != 0)
            {
              this->valueUnsignedInt_parser_->post_unsignedInt ();
              this->valueUnsignedInt ();
            }

            count = 0;
            state = 16UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "valueUri" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUri_parser_)
            {
              this->valueUri_parser_->pre ();
              ctx.nested_parser (this->valueUri_parser_);
            }
          }
          else
          {
            if (this->valueUri_parser_ != 0)
            {
              this->valueUri_parser_->post_uri ();
              this->valueUri ();
            }

            count = 0;
            state = 17UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "valueUrl" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUrl_parser_)
            {
              this->valueUrl_parser_->pre ();
              ctx.nested_parser (this->valueUrl_parser_);
            }
          }
          else
          {
            if (this->valueUrl_parser_ != 0)
            {
              this->valueUrl_parser_->post_url ();
              this->valueUrl ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "valueUuid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUuid_parser_)
            {
              this->valueUuid_parser_->pre ();
              ctx.nested_parser (this->valueUuid_parser_);
            }
          }
          else
          {
            if (this->valueUuid_parser_ != 0)
            {
              this->valueUuid_parser_->post_uuid ();
              this->valueUuid ();
            }

            count = 0;
            state = 19UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "valueAddress" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAddress_parser_)
            {
              this->valueAddress_parser_->pre ();
              ctx.nested_parser (this->valueAddress_parser_);
            }
          }
          else
          {
            if (this->valueAddress_parser_ != 0)
            {
              this->valueAddress_parser_->post_Address ();
              this->valueAddress ();
            }

            count = 0;
            state = 20UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "valueAge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAge_parser_)
            {
              this->valueAge_parser_->pre ();
              ctx.nested_parser (this->valueAge_parser_);
            }
          }
          else
          {
            if (this->valueAge_parser_ != 0)
            {
              this->valueAge_parser_->post_Age ();
              this->valueAge ();
            }

            count = 0;
            state = 21UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "valueAnnotation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAnnotation_parser_)
            {
              this->valueAnnotation_parser_->pre ();
              ctx.nested_parser (this->valueAnnotation_parser_);
            }
          }
          else
          {
            if (this->valueAnnotation_parser_ != 0)
            {
              this->valueAnnotation_parser_->post_Annotation ();
              this->valueAnnotation ();
            }

            count = 0;
            state = 22UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 22UL;
          // Fall through.
        }
      }
      case 22UL:
      {
        if (n == "valueAttachment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAttachment_parser_)
            {
              this->valueAttachment_parser_->pre ();
              ctx.nested_parser (this->valueAttachment_parser_);
            }
          }
          else
          {
            if (this->valueAttachment_parser_ != 0)
            {
              this->valueAttachment_parser_->post_Attachment ();
              this->valueAttachment ();
            }

            count = 0;
            state = 23UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 23UL;
          // Fall through.
        }
      }
      case 23UL:
      {
        if (n == "valueCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCodeableConcept_parser_)
            {
              this->valueCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->valueCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->valueCodeableConcept_parser_ != 0)
            {
              this->valueCodeableConcept_parser_->post_CodeableConcept ();
              this->valueCodeableConcept ();
            }

            count = 0;
            state = 24UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 24UL;
          // Fall through.
        }
      }
      case 24UL:
      {
        if (n == "valueCoding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCoding_parser_)
            {
              this->valueCoding_parser_->pre ();
              ctx.nested_parser (this->valueCoding_parser_);
            }
          }
          else
          {
            if (this->valueCoding_parser_ != 0)
            {
              this->valueCoding_parser_->post_Coding ();
              this->valueCoding ();
            }

            count = 0;
            state = 25UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 25UL;
          // Fall through.
        }
      }
      case 25UL:
      {
        if (n == "valueContactPoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueContactPoint_parser_)
            {
              this->valueContactPoint_parser_->pre ();
              ctx.nested_parser (this->valueContactPoint_parser_);
            }
          }
          else
          {
            if (this->valueContactPoint_parser_ != 0)
            {
              this->valueContactPoint_parser_->post_ContactPoint ();
              this->valueContactPoint ();
            }

            count = 0;
            state = 26UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 26UL;
          // Fall through.
        }
      }
      case 26UL:
      {
        if (n == "valueCount" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCount_parser_)
            {
              this->valueCount_parser_->pre ();
              ctx.nested_parser (this->valueCount_parser_);
            }
          }
          else
          {
            if (this->valueCount_parser_ != 0)
            {
              this->valueCount_parser_->post_Count ();
              this->valueCount ();
            }

            count = 0;
            state = 27UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 27UL;
          // Fall through.
        }
      }
      case 27UL:
      {
        if (n == "valueDistance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDistance_parser_)
            {
              this->valueDistance_parser_->pre ();
              ctx.nested_parser (this->valueDistance_parser_);
            }
          }
          else
          {
            if (this->valueDistance_parser_ != 0)
            {
              this->valueDistance_parser_->post_Distance ();
              this->valueDistance ();
            }

            count = 0;
            state = 28UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 28UL;
          // Fall through.
        }
      }
      case 28UL:
      {
        if (n == "valueDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDuration_parser_)
            {
              this->valueDuration_parser_->pre ();
              ctx.nested_parser (this->valueDuration_parser_);
            }
          }
          else
          {
            if (this->valueDuration_parser_ != 0)
            {
              this->valueDuration_parser_->post_Duration ();
              this->valueDuration ();
            }

            count = 0;
            state = 29UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 29UL;
          // Fall through.
        }
      }
      case 29UL:
      {
        if (n == "valueHumanName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueHumanName_parser_)
            {
              this->valueHumanName_parser_->pre ();
              ctx.nested_parser (this->valueHumanName_parser_);
            }
          }
          else
          {
            if (this->valueHumanName_parser_ != 0)
            {
              this->valueHumanName_parser_->post_HumanName ();
              this->valueHumanName ();
            }

            count = 0;
            state = 30UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 30UL;
          // Fall through.
        }
      }
      case 30UL:
      {
        if (n == "valueIdentifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueIdentifier_parser_)
            {
              this->valueIdentifier_parser_->pre ();
              ctx.nested_parser (this->valueIdentifier_parser_);
            }
          }
          else
          {
            if (this->valueIdentifier_parser_ != 0)
            {
              this->valueIdentifier_parser_->post_Identifier ();
              this->valueIdentifier ();
            }

            count = 0;
            state = 31UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 31UL;
          // Fall through.
        }
      }
      case 31UL:
      {
        if (n == "valueMoney" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueMoney_parser_)
            {
              this->valueMoney_parser_->pre ();
              ctx.nested_parser (this->valueMoney_parser_);
            }
          }
          else
          {
            if (this->valueMoney_parser_ != 0)
            {
              this->valueMoney_parser_->post_Money ();
              this->valueMoney ();
            }

            count = 0;
            state = 32UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 32UL;
          // Fall through.
        }
      }
      case 32UL:
      {
        if (n == "valuePeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valuePeriod_parser_)
            {
              this->valuePeriod_parser_->pre ();
              ctx.nested_parser (this->valuePeriod_parser_);
            }
          }
          else
          {
            if (this->valuePeriod_parser_ != 0)
            {
              this->valuePeriod_parser_->post_Period ();
              this->valuePeriod ();
            }

            count = 0;
            state = 33UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 33UL;
          // Fall through.
        }
      }
      case 33UL:
      {
        if (n == "valueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueQuantity_parser_)
            {
              this->valueQuantity_parser_->pre ();
              ctx.nested_parser (this->valueQuantity_parser_);
            }
          }
          else
          {
            if (this->valueQuantity_parser_ != 0)
            {
              this->valueQuantity_parser_->post_Quantity ();
              this->valueQuantity ();
            }

            count = 0;
            state = 34UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 34UL;
          // Fall through.
        }
      }
      case 34UL:
      {
        if (n == "valueRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRange_parser_)
            {
              this->valueRange_parser_->pre ();
              ctx.nested_parser (this->valueRange_parser_);
            }
          }
          else
          {
            if (this->valueRange_parser_ != 0)
            {
              this->valueRange_parser_->post_Range ();
              this->valueRange ();
            }

            count = 0;
            state = 35UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 35UL;
          // Fall through.
        }
      }
      case 35UL:
      {
        if (n == "valueRatio" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRatio_parser_)
            {
              this->valueRatio_parser_->pre ();
              ctx.nested_parser (this->valueRatio_parser_);
            }
          }
          else
          {
            if (this->valueRatio_parser_ != 0)
            {
              this->valueRatio_parser_->post_Ratio ();
              this->valueRatio ();
            }

            count = 0;
            state = 36UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 36UL;
          // Fall through.
        }
      }
      case 36UL:
      {
        if (n == "valueReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueReference_parser_)
            {
              this->valueReference_parser_->pre ();
              ctx.nested_parser (this->valueReference_parser_);
            }
          }
          else
          {
            if (this->valueReference_parser_ != 0)
            {
              this->valueReference_parser_->post_Reference ();
              this->valueReference ();
            }

            count = 0;
            state = 37UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 37UL;
          // Fall through.
        }
      }
      case 37UL:
      {
        if (n == "valueSampledData" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueSampledData_parser_)
            {
              this->valueSampledData_parser_->pre ();
              ctx.nested_parser (this->valueSampledData_parser_);
            }
          }
          else
          {
            if (this->valueSampledData_parser_ != 0)
            {
              this->valueSampledData_parser_->post_SampledData ();
              this->valueSampledData ();
            }

            count = 0;
            state = 38UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 38UL;
          // Fall through.
        }
      }
      case 38UL:
      {
        if (n == "valueSignature" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueSignature_parser_)
            {
              this->valueSignature_parser_->pre ();
              ctx.nested_parser (this->valueSignature_parser_);
            }
          }
          else
          {
            if (this->valueSignature_parser_ != 0)
            {
              this->valueSignature_parser_->post_Signature ();
              this->valueSignature ();
            }

            count = 0;
            state = 39UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 39UL;
          // Fall through.
        }
      }
      case 39UL:
      {
        if (n == "valueTiming" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueTiming_parser_)
            {
              this->valueTiming_parser_->pre ();
              ctx.nested_parser (this->valueTiming_parser_);
            }
          }
          else
          {
            if (this->valueTiming_parser_ != 0)
            {
              this->valueTiming_parser_->post_Timing ();
              this->valueTiming ();
            }

            count = 0;
            state = 40UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 40UL;
          // Fall through.
        }
      }
      case 40UL:
      {
        if (n == "valueContactDetail" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueContactDetail_parser_)
            {
              this->valueContactDetail_parser_->pre ();
              ctx.nested_parser (this->valueContactDetail_parser_);
            }
          }
          else
          {
            if (this->valueContactDetail_parser_ != 0)
            {
              this->valueContactDetail_parser_->post_ContactDetail ();
              this->valueContactDetail ();
            }

            count = 0;
            state = 41UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 41UL;
          // Fall through.
        }
      }
      case 41UL:
      {
        if (n == "valueContributor" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueContributor_parser_)
            {
              this->valueContributor_parser_->pre ();
              ctx.nested_parser (this->valueContributor_parser_);
            }
          }
          else
          {
            if (this->valueContributor_parser_ != 0)
            {
              this->valueContributor_parser_->post_Contributor ();
              this->valueContributor ();
            }

            count = 0;
            state = 42UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 42UL;
          // Fall through.
        }
      }
      case 42UL:
      {
        if (n == "valueDataRequirement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDataRequirement_parser_)
            {
              this->valueDataRequirement_parser_->pre ();
              ctx.nested_parser (this->valueDataRequirement_parser_);
            }
          }
          else
          {
            if (this->valueDataRequirement_parser_ != 0)
            {
              this->valueDataRequirement_parser_->post_DataRequirement ();
              this->valueDataRequirement ();
            }

            count = 0;
            state = 43UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 43UL;
          // Fall through.
        }
      }
      case 43UL:
      {
        if (n == "valueExpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueExpression_parser_)
            {
              this->valueExpression_parser_->pre ();
              ctx.nested_parser (this->valueExpression_parser_);
            }
          }
          else
          {
            if (this->valueExpression_parser_ != 0)
            {
              this->valueExpression_parser_->post_Expression ();
              this->valueExpression ();
            }

            count = 0;
            state = 44UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 44UL;
          // Fall through.
        }
      }
      case 44UL:
      {
        if (n == "valueParameterDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueParameterDefinition_parser_)
            {
              this->valueParameterDefinition_parser_->pre ();
              ctx.nested_parser (this->valueParameterDefinition_parser_);
            }
          }
          else
          {
            if (this->valueParameterDefinition_parser_ != 0)
            {
              this->valueParameterDefinition_parser_->post_ParameterDefinition ();
              this->valueParameterDefinition ();
            }

            count = 0;
            state = 45UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 45UL;
          // Fall through.
        }
      }
      case 45UL:
      {
        if (n == "valueRelatedArtifact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRelatedArtifact_parser_)
            {
              this->valueRelatedArtifact_parser_->pre ();
              ctx.nested_parser (this->valueRelatedArtifact_parser_);
            }
          }
          else
          {
            if (this->valueRelatedArtifact_parser_ != 0)
            {
              this->valueRelatedArtifact_parser_->post_RelatedArtifact ();
              this->valueRelatedArtifact ();
            }

            count = 0;
            state = 46UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 46UL;
          // Fall through.
        }
      }
      case 46UL:
      {
        if (n == "valueTriggerDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueTriggerDefinition_parser_)
            {
              this->valueTriggerDefinition_parser_->pre ();
              ctx.nested_parser (this->valueTriggerDefinition_parser_);
            }
          }
          else
          {
            if (this->valueTriggerDefinition_parser_ != 0)
            {
              this->valueTriggerDefinition_parser_->post_TriggerDefinition ();
              this->valueTriggerDefinition ();
            }

            count = 0;
            state = 47UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 47UL;
          // Fall through.
        }
      }
      case 47UL:
      {
        if (n == "valueUsageContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUsageContext_parser_)
            {
              this->valueUsageContext_parser_->pre ();
              ctx.nested_parser (this->valueUsageContext_parser_);
            }
          }
          else
          {
            if (this->valueUsageContext_parser_ != 0)
            {
              this->valueUsageContext_parser_->post_UsageContext ();
              this->valueUsageContext ();
            }

            count = 0;
            state = 48UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 48UL;
          // Fall through.
        }
      }
      case 48UL:
      {
        if (n == "valueDosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDosage_parser_)
            {
              this->valueDosage_parser_->pre ();
              ctx.nested_parser (this->valueDosage_parser_);
            }
          }
          else
          {
            if (this->valueDosage_parser_ != 0)
            {
              this->valueDosage_parser_->post_Dosage ();
              this->valueDosage ();
            }

            count = 0;
            state = 49UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 49UL;
          // Fall through.
        }
      }
      case 49UL:
      {
        if (n == "valueMeta" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueMeta_parser_)
            {
              this->valueMeta_parser_->pre ();
              ctx.nested_parser (this->valueMeta_parser_);
            }
          }
          else
          {
            if (this->valueMeta_parser_ != 0)
            {
              this->valueMeta_parser_->post_Meta ();
              this->valueMeta ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for BackboneElement_pskel.
  //
  bool BackboneElement_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "modifierExtension" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &BackboneElement_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool BackboneElement_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void BackboneElement_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void BackboneElement_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void BackboneElement_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "modifierExtension" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->modifierExtension_parser_)
            {
              this->modifierExtension_parser_->pre ();
              ctx.nested_parser (this->modifierExtension_parser_);
            }
          }
          else
          {
            if (this->modifierExtension_parser_ != 0)
            {
              this->modifierExtension_parser_->post_Extension ();
              this->modifierExtension ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Narrative_pskel.
  //
  bool Narrative_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "status" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Narrative_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Narrative_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Narrative_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Narrative_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void Narrative_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "status" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->status_parser_)
            {
              this->status_parser_->pre ();
              ctx.nested_parser (this->status_parser_);
            }
          }
          else
          {
            if (this->status_parser_ != 0)
            {
              this->status_parser_->post_NarrativeStatus ();
              this->status ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "div" &&
            ns == "http://www.w3.org/1999/xhtml")
        {
          if (start)
          {
            if (this->div_parser_)
            {
              this->div_parser_->pre ();
              ctx.nested_parser (this->div_parser_);
            }
          }
          else
          {
            if (this->div_parser_ != 0)
            {
              this->div_parser_->post_div ();
              this->div ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Meta_pskel.
  //
  bool Meta_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "versionId" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "lastUpdated" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "source" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "profile" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "security" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "tag" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Meta_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Meta_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Meta_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Meta_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Meta_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "versionId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->versionId_parser_)
            {
              this->versionId_parser_->pre ();
              ctx.nested_parser (this->versionId_parser_);
            }
          }
          else
          {
            if (this->versionId_parser_ != 0)
            {
              this->versionId_parser_->post_id ();
              this->versionId ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "lastUpdated" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->lastUpdated_parser_)
            {
              this->lastUpdated_parser_->pre ();
              ctx.nested_parser (this->lastUpdated_parser_);
            }
          }
          else
          {
            if (this->lastUpdated_parser_ != 0)
            {
              this->lastUpdated_parser_->post_instant ();
              this->lastUpdated ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "source" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->source_parser_)
            {
              this->source_parser_->pre ();
              ctx.nested_parser (this->source_parser_);
            }
          }
          else
          {
            if (this->source_parser_ != 0)
            {
              this->source_parser_->post_uri ();
              this->source ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_canonical ();
              this->profile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "security" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->security_parser_)
            {
              this->security_parser_->pre ();
              ctx.nested_parser (this->security_parser_);
            }
          }
          else
          {
            if (this->security_parser_ != 0)
            {
              this->security_parser_->post_Coding ();
              this->security ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "tag" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->tag_parser_)
            {
              this->tag_parser_->pre ();
              ctx.nested_parser (this->tag_parser_);
            }
          }
          else
          {
            if (this->tag_parser_ != 0)
            {
              this->tag_parser_->post_Coding ();
              this->tag ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Address_pskel.
  //
  bool Address_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "use" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "text" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "line" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "city" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "district" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "state" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "postalCode" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "country" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "period" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Address_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Address_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Address_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Address_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Address_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "use" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->use_parser_)
            {
              this->use_parser_->pre ();
              ctx.nested_parser (this->use_parser_);
            }
          }
          else
          {
            if (this->use_parser_ != 0)
            {
              this->use_parser_->post_AddressUse ();
              this->use ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_AddressType ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "text" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->text_parser_)
            {
              this->text_parser_->pre ();
              ctx.nested_parser (this->text_parser_);
            }
          }
          else
          {
            if (this->text_parser_ != 0)
            {
              this->text_parser_->post_string ();
              this->text ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "line" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->line_parser_)
            {
              this->line_parser_->pre ();
              ctx.nested_parser (this->line_parser_);
            }
          }
          else
          {
            if (this->line_parser_ != 0)
            {
              this->line_parser_->post_string ();
              this->line ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "city" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->city_parser_)
            {
              this->city_parser_->pre ();
              ctx.nested_parser (this->city_parser_);
            }
          }
          else
          {
            if (this->city_parser_ != 0)
            {
              this->city_parser_->post_string ();
              this->city ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "district" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->district_parser_)
            {
              this->district_parser_->pre ();
              ctx.nested_parser (this->district_parser_);
            }
          }
          else
          {
            if (this->district_parser_ != 0)
            {
              this->district_parser_->post_string ();
              this->district ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "state" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->state_parser_)
            {
              this->state_parser_->pre ();
              ctx.nested_parser (this->state_parser_);
            }
          }
          else
          {
            if (this->state_parser_ != 0)
            {
              this->state_parser_->post_string ();
              this->state ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "postalCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->postalCode_parser_)
            {
              this->postalCode_parser_->pre ();
              ctx.nested_parser (this->postalCode_parser_);
            }
          }
          else
          {
            if (this->postalCode_parser_ != 0)
            {
              this->postalCode_parser_->post_string ();
              this->postalCode ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "country" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->country_parser_)
            {
              this->country_parser_->pre ();
              ctx.nested_parser (this->country_parser_);
            }
          }
          else
          {
            if (this->country_parser_ != 0)
            {
              this->country_parser_->post_string ();
              this->country ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_Period ();
              this->period ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Contributor_pskel.
  //
  bool Contributor_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Contributor_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Contributor_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Contributor_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Contributor_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void Contributor_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_ContributorType ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "contact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contact_parser_)
            {
              this->contact_parser_->pre ();
              ctx.nested_parser (this->contact_parser_);
            }
          }
          else
          {
            if (this->contact_parser_ != 0)
            {
              this->contact_parser_->post_ContactDetail ();
              this->contact ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Attachment_pskel.
  //
  bool Attachment_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "contentType" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "language" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "data" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "url" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "size" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "hash" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "title" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "creation" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Attachment_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Attachment_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Attachment_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Attachment_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Attachment_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "contentType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contentType_parser_)
            {
              this->contentType_parser_->pre ();
              ctx.nested_parser (this->contentType_parser_);
            }
          }
          else
          {
            if (this->contentType_parser_ != 0)
            {
              this->contentType_parser_->post_code ();
              this->contentType ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "language" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->language_parser_)
            {
              this->language_parser_->pre ();
              ctx.nested_parser (this->language_parser_);
            }
          }
          else
          {
            if (this->language_parser_ != 0)
            {
              this->language_parser_->post_code ();
              this->language ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "data" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->data_parser_)
            {
              this->data_parser_->pre ();
              ctx.nested_parser (this->data_parser_);
            }
          }
          else
          {
            if (this->data_parser_ != 0)
            {
              this->data_parser_->post_base64Binary ();
              this->data ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_url ();
              this->url ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "size" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->size_parser_)
            {
              this->size_parser_->pre ();
              ctx.nested_parser (this->size_parser_);
            }
          }
          else
          {
            if (this->size_parser_ != 0)
            {
              this->size_parser_->post_unsignedInt ();
              this->size ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "hash" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->hash_parser_)
            {
              this->hash_parser_->pre ();
              ctx.nested_parser (this->hash_parser_);
            }
          }
          else
          {
            if (this->hash_parser_ != 0)
            {
              this->hash_parser_->post_base64Binary ();
              this->hash ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "title" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->title_parser_)
            {
              this->title_parser_->pre ();
              ctx.nested_parser (this->title_parser_);
            }
          }
          else
          {
            if (this->title_parser_ != 0)
            {
              this->title_parser_->post_string ();
              this->title ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "creation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->creation_parser_)
            {
              this->creation_parser_->pre ();
              ctx.nested_parser (this->creation_parser_);
            }
          }
          else
          {
            if (this->creation_parser_ != 0)
            {
              this->creation_parser_->post_dateTime ();
              this->creation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Quantity_pskel.
  //
  bool Quantity_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "value" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "comparator" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "unit" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "system" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "code" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Quantity_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Quantity_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Quantity_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Quantity_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Quantity_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_decimal ();
              this->value ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "comparator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->comparator_parser_)
            {
              this->comparator_parser_->pre ();
              ctx.nested_parser (this->comparator_parser_);
            }
          }
          else
          {
            if (this->comparator_parser_ != 0)
            {
              this->comparator_parser_->post_QuantityComparator ();
              this->comparator ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "unit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->unit_parser_)
            {
              this->unit_parser_->pre ();
              ctx.nested_parser (this->unit_parser_);
            }
          }
          else
          {
            if (this->unit_parser_ != 0)
            {
              this->unit_parser_->post_string ();
              this->unit ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "system" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->system_parser_)
            {
              this->system_parser_->pre ();
              ctx.nested_parser (this->system_parser_);
            }
          }
          else
          {
            if (this->system_parser_ != 0)
            {
              this->system_parser_->post_uri ();
              this->system ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_code ();
              this->code ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for DataRequirement_pskel.
  //
  bool DataRequirement_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &DataRequirement_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool DataRequirement_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void DataRequirement_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void DataRequirement_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void DataRequirement_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_code ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_canonical ();
              this->profile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "subjectCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->subjectCodeableConcept_parser_)
            {
              this->subjectCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->subjectCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->subjectCodeableConcept_parser_ != 0)
            {
              this->subjectCodeableConcept_parser_->post_CodeableConcept ();
              this->subjectCodeableConcept ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "subjectReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->subjectReference_parser_)
            {
              this->subjectReference_parser_->pre ();
              ctx.nested_parser (this->subjectReference_parser_);
            }
          }
          else
          {
            if (this->subjectReference_parser_ != 0)
            {
              this->subjectReference_parser_->post_Reference ();
              this->subjectReference ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "mustSupport" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->mustSupport_parser_)
            {
              this->mustSupport_parser_->pre ();
              ctx.nested_parser (this->mustSupport_parser_);
            }
          }
          else
          {
            if (this->mustSupport_parser_ != 0)
            {
              this->mustSupport_parser_->post_string ();
              this->mustSupport ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "codeFilter" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->codeFilter_parser_)
            {
              this->codeFilter_parser_->pre ();
              ctx.nested_parser (this->codeFilter_parser_);
            }
          }
          else
          {
            if (this->codeFilter_parser_ != 0)
            {
              this->codeFilter_parser_->post_DataRequirement_CodeFilter ();
              this->codeFilter ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "dateFilter" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->dateFilter_parser_)
            {
              this->dateFilter_parser_->pre ();
              ctx.nested_parser (this->dateFilter_parser_);
            }
          }
          else
          {
            if (this->dateFilter_parser_ != 0)
            {
              this->dateFilter_parser_->post_DataRequirement_DateFilter ();
              this->dateFilter ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "limit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->limit_parser_)
            {
              this->limit_parser_->pre ();
              ctx.nested_parser (this->limit_parser_);
            }
          }
          else
          {
            if (this->limit_parser_ != 0)
            {
              this->limit_parser_->post_positiveInt ();
              this->limit ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "sort" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sort_parser_)
            {
              this->sort_parser_->pre ();
              ctx.nested_parser (this->sort_parser_);
            }
          }
          else
          {
            if (this->sort_parser_ != 0)
            {
              this->sort_parser_->post_DataRequirement_Sort ();
              this->sort ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for DataRequirement_CodeFilter_pskel.
  //
  bool DataRequirement_CodeFilter_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "path" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "searchParam" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "valueSet" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "code" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &DataRequirement_CodeFilter_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool DataRequirement_CodeFilter_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void DataRequirement_CodeFilter_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void DataRequirement_CodeFilter_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void DataRequirement_CodeFilter_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "searchParam" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->searchParam_parser_)
            {
              this->searchParam_parser_->pre ();
              ctx.nested_parser (this->searchParam_parser_);
            }
          }
          else
          {
            if (this->searchParam_parser_ != 0)
            {
              this->searchParam_parser_->post_string ();
              this->searchParam ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueSet" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueSet_parser_)
            {
              this->valueSet_parser_->pre ();
              ctx.nested_parser (this->valueSet_parser_);
            }
          }
          else
          {
            if (this->valueSet_parser_ != 0)
            {
              this->valueSet_parser_->post_canonical ();
              this->valueSet ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_Coding ();
              this->code ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for DataRequirement_DateFilter_pskel.
  //
  bool DataRequirement_DateFilter_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "path" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "searchParam" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "valueDateTime" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "valuePeriod" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "valueDuration" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &DataRequirement_DateFilter_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool DataRequirement_DateFilter_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void DataRequirement_DateFilter_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void DataRequirement_DateFilter_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void DataRequirement_DateFilter_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "searchParam" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->searchParam_parser_)
            {
              this->searchParam_parser_->pre ();
              ctx.nested_parser (this->searchParam_parser_);
            }
          }
          else
          {
            if (this->searchParam_parser_ != 0)
            {
              this->searchParam_parser_->post_string ();
              this->searchParam ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDateTime_parser_)
            {
              this->valueDateTime_parser_->pre ();
              ctx.nested_parser (this->valueDateTime_parser_);
            }
          }
          else
          {
            if (this->valueDateTime_parser_ != 0)
            {
              this->valueDateTime_parser_->post_dateTime ();
              this->valueDateTime ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "valuePeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valuePeriod_parser_)
            {
              this->valuePeriod_parser_->pre ();
              ctx.nested_parser (this->valuePeriod_parser_);
            }
          }
          else
          {
            if (this->valuePeriod_parser_ != 0)
            {
              this->valuePeriod_parser_->post_Period ();
              this->valuePeriod ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "valueDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDuration_parser_)
            {
              this->valueDuration_parser_->pre ();
              ctx.nested_parser (this->valueDuration_parser_);
            }
          }
          else
          {
            if (this->valueDuration_parser_ != 0)
            {
              this->valueDuration_parser_->post_Duration ();
              this->valueDuration ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for DataRequirement_Sort_pskel.
  //
  bool DataRequirement_Sort_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "path" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &DataRequirement_Sort_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool DataRequirement_Sort_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void DataRequirement_Sort_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void DataRequirement_Sort_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void DataRequirement_Sort_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "direction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->direction_parser_)
            {
              this->direction_parser_->pre ();
              ctx.nested_parser (this->direction_parser_);
            }
          }
          else
          {
            if (this->direction_parser_ != 0)
            {
              this->direction_parser_->post_SortDirection ();
              this->direction ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Dosage_pskel.
  //
  bool Dosage_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "sequence" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "text" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "additionalInstruction" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "patientInstruction" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "timing" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "asNeededBoolean" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "asNeededCodeableConcept" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "site" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "route" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "method" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "doseAndRate" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "maxDosePerPeriod" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "maxDosePerAdministration" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "maxDosePerLifetime" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Dosage_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Dosage_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Dosage_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void Dosage_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Dosage_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "sequence" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sequence_parser_)
            {
              this->sequence_parser_->pre ();
              ctx.nested_parser (this->sequence_parser_);
            }
          }
          else
          {
            if (this->sequence_parser_ != 0)
            {
              this->sequence_parser_->post_integer ();
              this->sequence ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "text" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->text_parser_)
            {
              this->text_parser_->pre ();
              ctx.nested_parser (this->text_parser_);
            }
          }
          else
          {
            if (this->text_parser_ != 0)
            {
              this->text_parser_->post_string ();
              this->text ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "additionalInstruction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->additionalInstruction_parser_)
            {
              this->additionalInstruction_parser_->pre ();
              ctx.nested_parser (this->additionalInstruction_parser_);
            }
          }
          else
          {
            if (this->additionalInstruction_parser_ != 0)
            {
              this->additionalInstruction_parser_->post_CodeableConcept ();
              this->additionalInstruction ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "patientInstruction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patientInstruction_parser_)
            {
              this->patientInstruction_parser_->pre ();
              ctx.nested_parser (this->patientInstruction_parser_);
            }
          }
          else
          {
            if (this->patientInstruction_parser_ != 0)
            {
              this->patientInstruction_parser_->post_string ();
              this->patientInstruction ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "timing" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timing_parser_)
            {
              this->timing_parser_->pre ();
              ctx.nested_parser (this->timing_parser_);
            }
          }
          else
          {
            if (this->timing_parser_ != 0)
            {
              this->timing_parser_->post_Timing ();
              this->timing ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "asNeededBoolean" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->asNeededBoolean_parser_)
            {
              this->asNeededBoolean_parser_->pre ();
              ctx.nested_parser (this->asNeededBoolean_parser_);
            }
          }
          else
          {
            if (this->asNeededBoolean_parser_ != 0)
            {
              this->asNeededBoolean_parser_->post_boolean ();
              this->asNeededBoolean ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "asNeededCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->asNeededCodeableConcept_parser_)
            {
              this->asNeededCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->asNeededCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->asNeededCodeableConcept_parser_ != 0)
            {
              this->asNeededCodeableConcept_parser_->post_CodeableConcept ();
              this->asNeededCodeableConcept ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "site" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->site_parser_)
            {
              this->site_parser_->pre ();
              ctx.nested_parser (this->site_parser_);
            }
          }
          else
          {
            if (this->site_parser_ != 0)
            {
              this->site_parser_->post_CodeableConcept ();
              this->site ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "route" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->route_parser_)
            {
              this->route_parser_->pre ();
              ctx.nested_parser (this->route_parser_);
            }
          }
          else
          {
            if (this->route_parser_ != 0)
            {
              this->route_parser_->post_CodeableConcept ();
              this->route ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "method" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->method_parser_)
            {
              this->method_parser_->pre ();
              ctx.nested_parser (this->method_parser_);
            }
          }
          else
          {
            if (this->method_parser_ != 0)
            {
              this->method_parser_->post_CodeableConcept ();
              this->method ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "doseAndRate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->doseAndRate_parser_)
            {
              this->doseAndRate_parser_->pre ();
              ctx.nested_parser (this->doseAndRate_parser_);
            }
          }
          else
          {
            if (this->doseAndRate_parser_ != 0)
            {
              this->doseAndRate_parser_->post_Dosage_DoseAndRate ();
              this->doseAndRate ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "maxDosePerPeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxDosePerPeriod_parser_)
            {
              this->maxDosePerPeriod_parser_->pre ();
              ctx.nested_parser (this->maxDosePerPeriod_parser_);
            }
          }
          else
          {
            if (this->maxDosePerPeriod_parser_ != 0)
            {
              this->maxDosePerPeriod_parser_->post_Ratio ();
              this->maxDosePerPeriod ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "maxDosePerAdministration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxDosePerAdministration_parser_)
            {
              this->maxDosePerAdministration_parser_->pre ();
              ctx.nested_parser (this->maxDosePerAdministration_parser_);
            }
          }
          else
          {
            if (this->maxDosePerAdministration_parser_ != 0)
            {
              this->maxDosePerAdministration_parser_->post_Quantity ();
              this->maxDosePerAdministration ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "maxDosePerLifetime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxDosePerLifetime_parser_)
            {
              this->maxDosePerLifetime_parser_->pre ();
              ctx.nested_parser (this->maxDosePerLifetime_parser_);
            }
          }
          else
          {
            if (this->maxDosePerLifetime_parser_ != 0)
            {
              this->maxDosePerLifetime_parser_->post_Quantity ();
              this->maxDosePerLifetime ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Dosage_DoseAndRate_pskel.
  //
  bool Dosage_DoseAndRate_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "doseRange" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "doseQuantity" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "rateRatio" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "rateRange" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "rateQuantity" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Dosage_DoseAndRate_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Dosage_DoseAndRate_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Dosage_DoseAndRate_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void Dosage_DoseAndRate_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Dosage_DoseAndRate_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "doseRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->doseRange_parser_)
            {
              this->doseRange_parser_->pre ();
              ctx.nested_parser (this->doseRange_parser_);
            }
          }
          else
          {
            if (this->doseRange_parser_ != 0)
            {
              this->doseRange_parser_->post_Range ();
              this->doseRange ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "doseQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->doseQuantity_parser_)
            {
              this->doseQuantity_parser_->pre ();
              ctx.nested_parser (this->doseQuantity_parser_);
            }
          }
          else
          {
            if (this->doseQuantity_parser_ != 0)
            {
              this->doseQuantity_parser_->post_Quantity ();
              this->doseQuantity ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "rateRatio" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rateRatio_parser_)
            {
              this->rateRatio_parser_->pre ();
              ctx.nested_parser (this->rateRatio_parser_);
            }
          }
          else
          {
            if (this->rateRatio_parser_ != 0)
            {
              this->rateRatio_parser_->post_Ratio ();
              this->rateRatio ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "rateRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rateRange_parser_)
            {
              this->rateRange_parser_->pre ();
              ctx.nested_parser (this->rateRange_parser_);
            }
          }
          else
          {
            if (this->rateRange_parser_ != 0)
            {
              this->rateRange_parser_->post_Range ();
              this->rateRange ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "rateQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rateQuantity_parser_)
            {
              this->rateQuantity_parser_->pre ();
              ctx.nested_parser (this->rateQuantity_parser_);
            }
          }
          else
          {
            if (this->rateQuantity_parser_ != 0)
            {
              this->rateQuantity_parser_->post_Quantity ();
              this->rateQuantity ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Money_pskel.
  //
  bool Money_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "value" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "currency" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Money_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Money_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Money_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Money_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Money_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_decimal ();
              this->value ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "currency" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->currency_parser_)
            {
              this->currency_parser_->pre ();
              ctx.nested_parser (this->currency_parser_);
            }
          }
          else
          {
            if (this->currency_parser_ != 0)
            {
              this->currency_parser_->post_code ();
              this->currency ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for HumanName_pskel.
  //
  bool HumanName_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "use" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "text" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "family" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "given" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "prefix" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "suffix" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "period" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &HumanName_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool HumanName_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void HumanName_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void HumanName_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void HumanName_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "use" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->use_parser_)
            {
              this->use_parser_->pre ();
              ctx.nested_parser (this->use_parser_);
            }
          }
          else
          {
            if (this->use_parser_ != 0)
            {
              this->use_parser_->post_NameUse ();
              this->use ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "text" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->text_parser_)
            {
              this->text_parser_->pre ();
              ctx.nested_parser (this->text_parser_);
            }
          }
          else
          {
            if (this->text_parser_ != 0)
            {
              this->text_parser_->post_string ();
              this->text ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "family" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->family_parser_)
            {
              this->family_parser_->pre ();
              ctx.nested_parser (this->family_parser_);
            }
          }
          else
          {
            if (this->family_parser_ != 0)
            {
              this->family_parser_->post_string ();
              this->family ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "given" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->given_parser_)
            {
              this->given_parser_->pre ();
              ctx.nested_parser (this->given_parser_);
            }
          }
          else
          {
            if (this->given_parser_ != 0)
            {
              this->given_parser_->post_string ();
              this->given ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "prefix" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->prefix_parser_)
            {
              this->prefix_parser_->pre ();
              ctx.nested_parser (this->prefix_parser_);
            }
          }
          else
          {
            if (this->prefix_parser_ != 0)
            {
              this->prefix_parser_->post_string ();
              this->prefix ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "suffix" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->suffix_parser_)
            {
              this->suffix_parser_->pre ();
              ctx.nested_parser (this->suffix_parser_);
            }
          }
          else
          {
            if (this->suffix_parser_ != 0)
            {
              this->suffix_parser_->post_string ();
              this->suffix ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_Period ();
              this->period ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ContactPoint_pskel.
  //
  bool ContactPoint_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "system" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "value" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "use" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "rank" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "period" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ContactPoint_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ContactPoint_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ContactPoint_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void ContactPoint_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ContactPoint_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "system" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->system_parser_)
            {
              this->system_parser_->pre ();
              ctx.nested_parser (this->system_parser_);
            }
          }
          else
          {
            if (this->system_parser_ != 0)
            {
              this->system_parser_->post_ContactPointSystem ();
              this->system ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_string ();
              this->value ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "use" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->use_parser_)
            {
              this->use_parser_->pre ();
              ctx.nested_parser (this->use_parser_);
            }
          }
          else
          {
            if (this->use_parser_ != 0)
            {
              this->use_parser_->post_ContactPointUse ();
              this->use ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "rank" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rank_parser_)
            {
              this->rank_parser_->pre ();
              ctx.nested_parser (this->rank_parser_);
            }
          }
          else
          {
            if (this->rank_parser_ != 0)
            {
              this->rank_parser_->post_positiveInt ();
              this->rank ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_Period ();
              this->period ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MarketingStatus_pskel.
  //
  bool MarketingStatus_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "country" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MarketingStatus_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MarketingStatus_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MarketingStatus_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MarketingStatus_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MarketingStatus_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "country" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->country_parser_)
            {
              this->country_parser_->pre ();
              ctx.nested_parser (this->country_parser_);
            }
          }
          else
          {
            if (this->country_parser_ != 0)
            {
              this->country_parser_->post_CodeableConcept ();
              this->country ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "jurisdiction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->jurisdiction_parser_)
            {
              this->jurisdiction_parser_->pre ();
              ctx.nested_parser (this->jurisdiction_parser_);
            }
          }
          else
          {
            if (this->jurisdiction_parser_ != 0)
            {
              this->jurisdiction_parser_->post_CodeableConcept ();
              this->jurisdiction ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "status" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->status_parser_)
            {
              this->status_parser_->pre ();
              ctx.nested_parser (this->status_parser_);
            }
          }
          else
          {
            if (this->status_parser_ != 0)
            {
              this->status_parser_->post_CodeableConcept ();
              this->status ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "dateRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->dateRange_parser_)
            {
              this->dateRange_parser_->pre ();
              ctx.nested_parser (this->dateRange_parser_);
            }
          }
          else
          {
            if (this->dateRange_parser_ != 0)
            {
              this->dateRange_parser_->post_Period ();
              this->dateRange ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "restoreDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->restoreDate_parser_)
            {
              this->restoreDate_parser_->pre ();
              ctx.nested_parser (this->restoreDate_parser_);
            }
          }
          else
          {
            if (this->restoreDate_parser_ != 0)
            {
              this->restoreDate_parser_->post_dateTime ();
              this->restoreDate ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Identifier_pskel.
  //
  bool Identifier_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "use" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "system" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "value" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "period" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "assigner" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Identifier_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Identifier_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Identifier_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Identifier_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Identifier_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "use" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->use_parser_)
            {
              this->use_parser_->pre ();
              ctx.nested_parser (this->use_parser_);
            }
          }
          else
          {
            if (this->use_parser_ != 0)
            {
              this->use_parser_->post_IdentifierUse ();
              this->use ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "system" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->system_parser_)
            {
              this->system_parser_->pre ();
              ctx.nested_parser (this->system_parser_);
            }
          }
          else
          {
            if (this->system_parser_ != 0)
            {
              this->system_parser_->post_uri ();
              this->system ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_string ();
              this->value ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_Period ();
              this->period ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "assigner" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->assigner_parser_)
            {
              this->assigner_parser_->pre ();
              ctx.nested_parser (this->assigner_parser_);
            }
          }
          else
          {
            if (this->assigner_parser_ != 0)
            {
              this->assigner_parser_->post_Reference ();
              this->assigner ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SubstanceAmount_pskel.
  //
  bool SubstanceAmount_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "amountQuantity" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "amountRange" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "amountString" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "amountType" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "amountText" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "referenceRange" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SubstanceAmount_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SubstanceAmount_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SubstanceAmount_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void SubstanceAmount_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SubstanceAmount_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "amountQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->amountQuantity_parser_)
            {
              this->amountQuantity_parser_->pre ();
              ctx.nested_parser (this->amountQuantity_parser_);
            }
          }
          else
          {
            if (this->amountQuantity_parser_ != 0)
            {
              this->amountQuantity_parser_->post_Quantity ();
              this->amountQuantity ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "amountRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->amountRange_parser_)
            {
              this->amountRange_parser_->pre ();
              ctx.nested_parser (this->amountRange_parser_);
            }
          }
          else
          {
            if (this->amountRange_parser_ != 0)
            {
              this->amountRange_parser_->post_Range ();
              this->amountRange ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "amountString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->amountString_parser_)
            {
              this->amountString_parser_->pre ();
              ctx.nested_parser (this->amountString_parser_);
            }
          }
          else
          {
            if (this->amountString_parser_ != 0)
            {
              this->amountString_parser_->post_string ();
              this->amountString ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "amountType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->amountType_parser_)
            {
              this->amountType_parser_->pre ();
              ctx.nested_parser (this->amountType_parser_);
            }
          }
          else
          {
            if (this->amountType_parser_ != 0)
            {
              this->amountType_parser_->post_CodeableConcept ();
              this->amountType ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "amountText" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->amountText_parser_)
            {
              this->amountText_parser_->pre ();
              ctx.nested_parser (this->amountText_parser_);
            }
          }
          else
          {
            if (this->amountText_parser_ != 0)
            {
              this->amountText_parser_->post_string ();
              this->amountText ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "referenceRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referenceRange_parser_)
            {
              this->referenceRange_parser_->pre ();
              ctx.nested_parser (this->referenceRange_parser_);
            }
          }
          else
          {
            if (this->referenceRange_parser_ != 0)
            {
              this->referenceRange_parser_->post_SubstanceAmount_ReferenceRange ();
              this->referenceRange ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SubstanceAmount_ReferenceRange_pskel.
  //
  bool SubstanceAmount_ReferenceRange_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "lowLimit" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "highLimit" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SubstanceAmount_ReferenceRange_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SubstanceAmount_ReferenceRange_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SubstanceAmount_ReferenceRange_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void SubstanceAmount_ReferenceRange_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void SubstanceAmount_ReferenceRange_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "lowLimit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->lowLimit_parser_)
            {
              this->lowLimit_parser_->pre ();
              ctx.nested_parser (this->lowLimit_parser_);
            }
          }
          else
          {
            if (this->lowLimit_parser_ != 0)
            {
              this->lowLimit_parser_->post_Quantity ();
              this->lowLimit ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "highLimit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->highLimit_parser_)
            {
              this->highLimit_parser_->pre ();
              ctx.nested_parser (this->highLimit_parser_);
            }
          }
          else
          {
            if (this->highLimit_parser_ != 0)
            {
              this->highLimit_parser_->post_Quantity ();
              this->highLimit ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Coding_pskel.
  //
  bool Coding_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "system" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "version" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "code" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "display" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "userSelected" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Coding_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Coding_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Coding_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Coding_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Coding_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "system" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->system_parser_)
            {
              this->system_parser_->pre ();
              ctx.nested_parser (this->system_parser_);
            }
          }
          else
          {
            if (this->system_parser_ != 0)
            {
              this->system_parser_->post_uri ();
              this->system ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "version" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->version_parser_)
            {
              this->version_parser_->pre ();
              ctx.nested_parser (this->version_parser_);
            }
          }
          else
          {
            if (this->version_parser_ != 0)
            {
              this->version_parser_->post_string ();
              this->version ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_code ();
              this->code ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "display" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->display_parser_)
            {
              this->display_parser_->pre ();
              ctx.nested_parser (this->display_parser_);
            }
          }
          else
          {
            if (this->display_parser_ != 0)
            {
              this->display_parser_->post_string ();
              this->display ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "userSelected" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->userSelected_parser_)
            {
              this->userSelected_parser_->pre ();
              ctx.nested_parser (this->userSelected_parser_);
            }
          }
          else
          {
            if (this->userSelected_parser_ != 0)
            {
              this->userSelected_parser_->post_boolean ();
              this->userSelected ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for SampledData_pskel.
  //
  bool SampledData_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "origin" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &SampledData_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool SampledData_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void SampledData_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void SampledData_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void SampledData_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "origin" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->origin_parser_)
            {
              this->origin_parser_->pre ();
              ctx.nested_parser (this->origin_parser_);
            }
          }
          else
          {
            if (this->origin_parser_ != 0)
            {
              this->origin_parser_->post_Quantity ();
              this->origin ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_decimal ();
              this->period ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "factor" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->factor_parser_)
            {
              this->factor_parser_->pre ();
              ctx.nested_parser (this->factor_parser_);
            }
          }
          else
          {
            if (this->factor_parser_ != 0)
            {
              this->factor_parser_->post_decimal ();
              this->factor ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "lowerLimit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->lowerLimit_parser_)
            {
              this->lowerLimit_parser_->pre ();
              ctx.nested_parser (this->lowerLimit_parser_);
            }
          }
          else
          {
            if (this->lowerLimit_parser_ != 0)
            {
              this->lowerLimit_parser_->post_decimal ();
              this->lowerLimit ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "upperLimit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->upperLimit_parser_)
            {
              this->upperLimit_parser_->pre ();
              ctx.nested_parser (this->upperLimit_parser_);
            }
          }
          else
          {
            if (this->upperLimit_parser_ != 0)
            {
              this->upperLimit_parser_->post_decimal ();
              this->upperLimit ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "dimensions" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->dimensions_parser_)
            {
              this->dimensions_parser_->pre ();
              ctx.nested_parser (this->dimensions_parser_);
            }
          }
          else
          {
            if (this->dimensions_parser_ != 0)
            {
              this->dimensions_parser_->post_positiveInt ();
              this->dimensions ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "data" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->data_parser_)
            {
              this->data_parser_->pre ();
              ctx.nested_parser (this->data_parser_);
            }
          }
          else
          {
            if (this->data_parser_ != 0)
            {
              this->data_parser_->post_SampledDataDataType ();
              this->data ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Population_pskel.
  //
  bool Population_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "ageRange" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "ageCodeableConcept" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "gender" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "race" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "physiologicalCondition" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Population_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Population_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Population_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void Population_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Population_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "ageRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ageRange_parser_)
            {
              this->ageRange_parser_->pre ();
              ctx.nested_parser (this->ageRange_parser_);
            }
          }
          else
          {
            if (this->ageRange_parser_ != 0)
            {
              this->ageRange_parser_->post_Range ();
              this->ageRange ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "ageCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ageCodeableConcept_parser_)
            {
              this->ageCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->ageCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->ageCodeableConcept_parser_ != 0)
            {
              this->ageCodeableConcept_parser_->post_CodeableConcept ();
              this->ageCodeableConcept ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "gender" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->gender_parser_)
            {
              this->gender_parser_->pre ();
              ctx.nested_parser (this->gender_parser_);
            }
          }
          else
          {
            if (this->gender_parser_ != 0)
            {
              this->gender_parser_->post_CodeableConcept ();
              this->gender ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "race" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->race_parser_)
            {
              this->race_parser_->pre ();
              ctx.nested_parser (this->race_parser_);
            }
          }
          else
          {
            if (this->race_parser_ != 0)
            {
              this->race_parser_->post_CodeableConcept ();
              this->race ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "physiologicalCondition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->physiologicalCondition_parser_)
            {
              this->physiologicalCondition_parser_->pre ();
              ctx.nested_parser (this->physiologicalCondition_parser_);
            }
          }
          else
          {
            if (this->physiologicalCondition_parser_ != 0)
            {
              this->physiologicalCondition_parser_->post_CodeableConcept ();
              this->physiologicalCondition ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Ratio_pskel.
  //
  bool Ratio_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "numerator" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "denominator" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Ratio_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Ratio_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Ratio_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Ratio_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Ratio_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "numerator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->numerator_parser_)
            {
              this->numerator_parser_->pre ();
              ctx.nested_parser (this->numerator_parser_);
            }
          }
          else
          {
            if (this->numerator_parser_ != 0)
            {
              this->numerator_parser_->post_Quantity ();
              this->numerator ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "denominator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->denominator_parser_)
            {
              this->denominator_parser_->pre ();
              ctx.nested_parser (this->denominator_parser_);
            }
          }
          else
          {
            if (this->denominator_parser_ != 0)
            {
              this->denominator_parser_->post_Quantity ();
              this->denominator ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Reference_pskel.
  //
  bool Reference_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "reference" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "identifier" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "display" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Reference_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Reference_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Reference_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Reference_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Reference_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "reference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->reference_parser_)
            {
              this->reference_parser_->pre ();
              ctx.nested_parser (this->reference_parser_);
            }
          }
          else
          {
            if (this->reference_parser_ != 0)
            {
              this->reference_parser_->post_string ();
              this->reference ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_uri ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "display" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->display_parser_)
            {
              this->display_parser_->pre ();
              ctx.nested_parser (this->display_parser_);
            }
          }
          else
          {
            if (this->display_parser_ != 0)
            {
              this->display_parser_->post_string ();
              this->display ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for TriggerDefinition_pskel.
  //
  bool TriggerDefinition_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &TriggerDefinition_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool TriggerDefinition_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void TriggerDefinition_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void TriggerDefinition_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void TriggerDefinition_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_TriggerType ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "timingTiming" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timingTiming_parser_)
            {
              this->timingTiming_parser_->pre ();
              ctx.nested_parser (this->timingTiming_parser_);
            }
          }
          else
          {
            if (this->timingTiming_parser_ != 0)
            {
              this->timingTiming_parser_->post_Timing ();
              this->timingTiming ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "timingReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timingReference_parser_)
            {
              this->timingReference_parser_->pre ();
              ctx.nested_parser (this->timingReference_parser_);
            }
          }
          else
          {
            if (this->timingReference_parser_ != 0)
            {
              this->timingReference_parser_->post_Reference ();
              this->timingReference ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "timingDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timingDate_parser_)
            {
              this->timingDate_parser_->pre ();
              ctx.nested_parser (this->timingDate_parser_);
            }
          }
          else
          {
            if (this->timingDate_parser_ != 0)
            {
              this->timingDate_parser_->post_date ();
              this->timingDate ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "timingDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timingDateTime_parser_)
            {
              this->timingDateTime_parser_->pre ();
              ctx.nested_parser (this->timingDateTime_parser_);
            }
          }
          else
          {
            if (this->timingDateTime_parser_ != 0)
            {
              this->timingDateTime_parser_->post_dateTime ();
              this->timingDateTime ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "data" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->data_parser_)
            {
              this->data_parser_->pre ();
              ctx.nested_parser (this->data_parser_);
            }
          }
          else
          {
            if (this->data_parser_ != 0)
            {
              this->data_parser_->post_DataRequirement ();
              this->data ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "condition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->condition_parser_)
            {
              this->condition_parser_->pre ();
              ctx.nested_parser (this->condition_parser_);
            }
          }
          else
          {
            if (this->condition_parser_ != 0)
            {
              this->condition_parser_->post_Expression ();
              this->condition ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Period_pskel.
  //
  bool Period_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "start" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "end" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Period_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Period_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Period_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Period_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Period_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "start" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->start_parser_)
            {
              this->start_parser_->pre ();
              ctx.nested_parser (this->start_parser_);
            }
          }
          else
          {
            if (this->start_parser_ != 0)
            {
              this->start_parser_->post_dateTime ();
              this->start ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "end" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->end_parser_)
            {
              this->end_parser_->pre ();
              ctx.nested_parser (this->end_parser_);
            }
          }
          else
          {
            if (this->end_parser_ != 0)
            {
              this->end_parser_->post_dateTime ();
              this->end ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Range_pskel.
  //
  bool Range_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "low" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "high" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Range_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Range_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Range_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Range_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Range_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "low" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->low_parser_)
            {
              this->low_parser_->pre ();
              ctx.nested_parser (this->low_parser_);
            }
          }
          else
          {
            if (this->low_parser_ != 0)
            {
              this->low_parser_->post_Quantity ();
              this->low ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "high" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->high_parser_)
            {
              this->high_parser_->pre ();
              ctx.nested_parser (this->high_parser_);
            }
          }
          else
          {
            if (this->high_parser_ != 0)
            {
              this->high_parser_->post_Quantity ();
              this->high ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for RelatedArtifact_pskel.
  //
  bool RelatedArtifact_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &RelatedArtifact_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool RelatedArtifact_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void RelatedArtifact_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void RelatedArtifact_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void RelatedArtifact_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_RelatedArtifactType ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "label" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->label_parser_)
            {
              this->label_parser_->pre ();
              ctx.nested_parser (this->label_parser_);
            }
          }
          else
          {
            if (this->label_parser_ != 0)
            {
              this->label_parser_->post_string ();
              this->label ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "display" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->display_parser_)
            {
              this->display_parser_->pre ();
              ctx.nested_parser (this->display_parser_);
            }
          }
          else
          {
            if (this->display_parser_ != 0)
            {
              this->display_parser_->post_string ();
              this->display ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "citation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->citation_parser_)
            {
              this->citation_parser_->pre ();
              ctx.nested_parser (this->citation_parser_);
            }
          }
          else
          {
            if (this->citation_parser_ != 0)
            {
              this->citation_parser_->post_markdown ();
              this->citation ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_url ();
              this->url ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "document" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->document_parser_)
            {
              this->document_parser_->pre ();
              ctx.nested_parser (this->document_parser_);
            }
          }
          else
          {
            if (this->document_parser_ != 0)
            {
              this->document_parser_->post_Attachment ();
              this->document ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "resource" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->resource_parser_)
            {
              this->resource_parser_->pre ();
              ctx.nested_parser (this->resource_parser_);
            }
          }
          else
          {
            if (this->resource_parser_ != 0)
            {
              this->resource_parser_->post_canonical ();
              this->resource ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Annotation_pskel.
  //
  bool Annotation_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "authorReference" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "authorString" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "time" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "text" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Annotation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Annotation_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Annotation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Annotation_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void Annotation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "authorReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->authorReference_parser_)
            {
              this->authorReference_parser_->pre ();
              ctx.nested_parser (this->authorReference_parser_);
            }
          }
          else
          {
            if (this->authorReference_parser_ != 0)
            {
              this->authorReference_parser_->post_Reference ();
              this->authorReference ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "authorString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->authorString_parser_)
            {
              this->authorString_parser_->pre ();
              ctx.nested_parser (this->authorString_parser_);
            }
          }
          else
          {
            if (this->authorString_parser_ != 0)
            {
              this->authorString_parser_->post_string ();
              this->authorString ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "time" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->time_parser_)
            {
              this->time_parser_->pre ();
              ctx.nested_parser (this->time_parser_);
            }
          }
          else
          {
            if (this->time_parser_ != 0)
            {
              this->time_parser_->post_dateTime ();
              this->time ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "text" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->text_parser_)
            {
              this->text_parser_->pre ();
              ctx.nested_parser (this->text_parser_);
            }
          }
          else
          {
            if (this->text_parser_ != 0)
            {
              this->text_parser_->post_markdown ();
              this->text ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ProductShelfLife_pskel.
  //
  bool ProductShelfLife_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ProductShelfLife_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ProductShelfLife_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ProductShelfLife_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ProductShelfLife_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ProductShelfLife_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_Quantity ();
              this->period ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "specialPrecautionsForStorage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->specialPrecautionsForStorage_parser_)
            {
              this->specialPrecautionsForStorage_parser_->pre ();
              ctx.nested_parser (this->specialPrecautionsForStorage_parser_);
            }
          }
          else
          {
            if (this->specialPrecautionsForStorage_parser_ != 0)
            {
              this->specialPrecautionsForStorage_parser_->post_CodeableConcept ();
              this->specialPrecautionsForStorage ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ContactDetail_pskel.
  //
  bool ContactDetail_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "telecom" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ContactDetail_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ContactDetail_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ContactDetail_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void ContactDetail_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ContactDetail_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "telecom" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->telecom_parser_)
            {
              this->telecom_parser_->pre ();
              ctx.nested_parser (this->telecom_parser_);
            }
          }
          else
          {
            if (this->telecom_parser_ != 0)
            {
              this->telecom_parser_->post_ContactPoint ();
              this->telecom ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for UsageContext_pskel.
  //
  bool UsageContext_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "code" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &UsageContext_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool UsageContext_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void UsageContext_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void UsageContext_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void UsageContext_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_Coding ();
              this->code ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "valueCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCodeableConcept_parser_)
            {
              this->valueCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->valueCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->valueCodeableConcept_parser_ != 0)
            {
              this->valueCodeableConcept_parser_->post_CodeableConcept ();
              this->valueCodeableConcept ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueQuantity_parser_)
            {
              this->valueQuantity_parser_->pre ();
              ctx.nested_parser (this->valueQuantity_parser_);
            }
          }
          else
          {
            if (this->valueQuantity_parser_ != 0)
            {
              this->valueQuantity_parser_->post_Quantity ();
              this->valueQuantity ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "valueRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRange_parser_)
            {
              this->valueRange_parser_->pre ();
              ctx.nested_parser (this->valueRange_parser_);
            }
          }
          else
          {
            if (this->valueRange_parser_ != 0)
            {
              this->valueRange_parser_->post_Range ();
              this->valueRange ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "valueReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueReference_parser_)
            {
              this->valueReference_parser_->pre ();
              ctx.nested_parser (this->valueReference_parser_);
            }
          }
          else
          {
            if (this->valueReference_parser_ != 0)
            {
              this->valueReference_parser_->post_Reference ();
              this->valueReference ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Expression_pskel.
  //
  bool Expression_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "name" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "language" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Expression_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Expression_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Expression_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Expression_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void Expression_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_id ();
              this->name ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "language" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->language_parser_)
            {
              this->language_parser_->pre ();
              ctx.nested_parser (this->language_parser_);
            }
          }
          else
          {
            if (this->language_parser_ != 0)
            {
              this->language_parser_->post_ExpressionLanguage ();
              this->language ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "expression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->expression_parser_)
            {
              this->expression_parser_->pre ();
              ctx.nested_parser (this->expression_parser_);
            }
          }
          else
          {
            if (this->expression_parser_ != 0)
            {
              this->expression_parser_->post_string ();
              this->expression ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "reference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->reference_parser_)
            {
              this->reference_parser_->pre ();
              ctx.nested_parser (this->reference_parser_);
            }
          }
          else
          {
            if (this->reference_parser_ != 0)
            {
              this->reference_parser_->post_uri ();
              this->reference ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Signature_pskel.
  //
  bool Signature_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Signature_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Signature_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Signature_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void Signature_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void Signature_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_Coding ();
              this->type ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "when" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->when_parser_)
            {
              this->when_parser_->pre ();
              ctx.nested_parser (this->when_parser_);
            }
          }
          else
          {
            if (this->when_parser_ != 0)
            {
              this->when_parser_->post_instant ();
              this->when ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "who" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->who_parser_)
            {
              this->who_parser_->pre ();
              ctx.nested_parser (this->who_parser_);
            }
          }
          else
          {
            if (this->who_parser_ != 0)
            {
              this->who_parser_->post_Reference ();
              this->who ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "onBehalfOf" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->onBehalfOf_parser_)
            {
              this->onBehalfOf_parser_->pre ();
              ctx.nested_parser (this->onBehalfOf_parser_);
            }
          }
          else
          {
            if (this->onBehalfOf_parser_ != 0)
            {
              this->onBehalfOf_parser_->post_Reference ();
              this->onBehalfOf ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "targetFormat" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->targetFormat_parser_)
            {
              this->targetFormat_parser_->pre ();
              ctx.nested_parser (this->targetFormat_parser_);
            }
          }
          else
          {
            if (this->targetFormat_parser_ != 0)
            {
              this->targetFormat_parser_->post_code ();
              this->targetFormat ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "sigFormat" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sigFormat_parser_)
            {
              this->sigFormat_parser_->pre ();
              ctx.nested_parser (this->sigFormat_parser_);
            }
          }
          else
          {
            if (this->sigFormat_parser_ != 0)
            {
              this->sigFormat_parser_->post_code ();
              this->sigFormat ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "data" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->data_parser_)
            {
              this->data_parser_->pre ();
              ctx.nested_parser (this->data_parser_);
            }
          }
          else
          {
            if (this->data_parser_ != 0)
            {
              this->data_parser_->post_base64Binary ();
              this->data ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Timing_pskel.
  //
  bool Timing_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "event" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "repeat" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "code" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Timing_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Timing_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Timing_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void Timing_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Timing_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "event" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->event_parser_)
            {
              this->event_parser_->pre ();
              ctx.nested_parser (this->event_parser_);
            }
          }
          else
          {
            if (this->event_parser_ != 0)
            {
              this->event_parser_->post_dateTime ();
              this->event ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "repeat" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->repeat_parser_)
            {
              this->repeat_parser_->pre ();
              ctx.nested_parser (this->repeat_parser_);
            }
          }
          else
          {
            if (this->repeat_parser_ != 0)
            {
              this->repeat_parser_->post_Timing_Repeat ();
              this->repeat ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_CodeableConcept ();
              this->code ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Timing_Repeat_pskel.
  //
  bool Timing_Repeat_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "boundsDuration" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "boundsRange" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "boundsPeriod" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "count" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "countMax" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "duration" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "durationMax" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "durationUnit" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "frequency" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "frequencyMax" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "period" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "periodMax" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "periodUnit" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "dayOfWeek" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;
        else if (n == "timeOfDay" &&
                 ns == "http://hl7.org/fhir")
          s = 14UL;
        else if (n == "when" &&
                 ns == "http://hl7.org/fhir")
          s = 15UL;
        else if (n == "offset" &&
                 ns == "http://hl7.org/fhir")
          s = 16UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Timing_Repeat_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Timing_Repeat_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Timing_Repeat_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void Timing_Repeat_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Timing_Repeat_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "boundsDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->boundsDuration_parser_)
            {
              this->boundsDuration_parser_->pre ();
              ctx.nested_parser (this->boundsDuration_parser_);
            }
          }
          else
          {
            if (this->boundsDuration_parser_ != 0)
            {
              this->boundsDuration_parser_->post_Duration ();
              this->boundsDuration ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "boundsRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->boundsRange_parser_)
            {
              this->boundsRange_parser_->pre ();
              ctx.nested_parser (this->boundsRange_parser_);
            }
          }
          else
          {
            if (this->boundsRange_parser_ != 0)
            {
              this->boundsRange_parser_->post_Range ();
              this->boundsRange ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "boundsPeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->boundsPeriod_parser_)
            {
              this->boundsPeriod_parser_->pre ();
              ctx.nested_parser (this->boundsPeriod_parser_);
            }
          }
          else
          {
            if (this->boundsPeriod_parser_ != 0)
            {
              this->boundsPeriod_parser_->post_Period ();
              this->boundsPeriod ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "count" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->count_parser_)
            {
              this->count_parser_->pre ();
              ctx.nested_parser (this->count_parser_);
            }
          }
          else
          {
            if (this->count_parser_ != 0)
            {
              this->count_parser_->post_positiveInt ();
              this->count ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "countMax" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->countMax_parser_)
            {
              this->countMax_parser_->pre ();
              ctx.nested_parser (this->countMax_parser_);
            }
          }
          else
          {
            if (this->countMax_parser_ != 0)
            {
              this->countMax_parser_->post_positiveInt ();
              this->countMax ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "duration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->duration_parser_)
            {
              this->duration_parser_->pre ();
              ctx.nested_parser (this->duration_parser_);
            }
          }
          else
          {
            if (this->duration_parser_ != 0)
            {
              this->duration_parser_->post_decimal ();
              this->duration ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "durationMax" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->durationMax_parser_)
            {
              this->durationMax_parser_->pre ();
              ctx.nested_parser (this->durationMax_parser_);
            }
          }
          else
          {
            if (this->durationMax_parser_ != 0)
            {
              this->durationMax_parser_->post_decimal ();
              this->durationMax ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "durationUnit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->durationUnit_parser_)
            {
              this->durationUnit_parser_->pre ();
              ctx.nested_parser (this->durationUnit_parser_);
            }
          }
          else
          {
            if (this->durationUnit_parser_ != 0)
            {
              this->durationUnit_parser_->post_UnitsOfTime ();
              this->durationUnit ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "frequency" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->frequency_parser_)
            {
              this->frequency_parser_->pre ();
              ctx.nested_parser (this->frequency_parser_);
            }
          }
          else
          {
            if (this->frequency_parser_ != 0)
            {
              this->frequency_parser_->post_positiveInt ();
              this->frequency ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "frequencyMax" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->frequencyMax_parser_)
            {
              this->frequencyMax_parser_->pre ();
              ctx.nested_parser (this->frequencyMax_parser_);
            }
          }
          else
          {
            if (this->frequencyMax_parser_ != 0)
            {
              this->frequencyMax_parser_->post_positiveInt ();
              this->frequencyMax ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_decimal ();
              this->period ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "periodMax" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->periodMax_parser_)
            {
              this->periodMax_parser_->pre ();
              ctx.nested_parser (this->periodMax_parser_);
            }
          }
          else
          {
            if (this->periodMax_parser_ != 0)
            {
              this->periodMax_parser_->post_decimal ();
              this->periodMax ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "periodUnit" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->periodUnit_parser_)
            {
              this->periodUnit_parser_->pre ();
              ctx.nested_parser (this->periodUnit_parser_);
            }
          }
          else
          {
            if (this->periodUnit_parser_ != 0)
            {
              this->periodUnit_parser_->post_UnitsOfTime ();
              this->periodUnit ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "dayOfWeek" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->dayOfWeek_parser_)
            {
              this->dayOfWeek_parser_->pre ();
              ctx.nested_parser (this->dayOfWeek_parser_);
            }
          }
          else
          {
            if (this->dayOfWeek_parser_ != 0)
            {
              this->dayOfWeek_parser_->post_code ();
              this->dayOfWeek ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "timeOfDay" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->timeOfDay_parser_)
            {
              this->timeOfDay_parser_->pre ();
              ctx.nested_parser (this->timeOfDay_parser_);
            }
          }
          else
          {
            if (this->timeOfDay_parser_ != 0)
            {
              this->timeOfDay_parser_->post_time ();
              this->timeOfDay ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "when" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->when_parser_)
            {
              this->when_parser_->pre ();
              ctx.nested_parser (this->when_parser_);
            }
          }
          else
          {
            if (this->when_parser_ != 0)
            {
              this->when_parser_->post_EventTiming ();
              this->when ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "offset" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->offset_parser_)
            {
              this->offset_parser_->pre ();
              ctx.nested_parser (this->offset_parser_);
            }
          }
          else
          {
            if (this->offset_parser_ != 0)
            {
              this->offset_parser_->post_unsignedInt ();
              this->offset ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ProdCharacteristic_pskel.
  //
  bool ProdCharacteristic_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "height" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "width" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "depth" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "weight" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "nominalVolume" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "externalDiameter" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "shape" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "color" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "imprint" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "image" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "scoring" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ProdCharacteristic_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ProdCharacteristic_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ProdCharacteristic_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ProdCharacteristic_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void ProdCharacteristic_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "height" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->height_parser_)
            {
              this->height_parser_->pre ();
              ctx.nested_parser (this->height_parser_);
            }
          }
          else
          {
            if (this->height_parser_ != 0)
            {
              this->height_parser_->post_Quantity ();
              this->height ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "width" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->width_parser_)
            {
              this->width_parser_->pre ();
              ctx.nested_parser (this->width_parser_);
            }
          }
          else
          {
            if (this->width_parser_ != 0)
            {
              this->width_parser_->post_Quantity ();
              this->width ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "depth" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->depth_parser_)
            {
              this->depth_parser_->pre ();
              ctx.nested_parser (this->depth_parser_);
            }
          }
          else
          {
            if (this->depth_parser_ != 0)
            {
              this->depth_parser_->post_Quantity ();
              this->depth ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "weight" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->weight_parser_)
            {
              this->weight_parser_->pre ();
              ctx.nested_parser (this->weight_parser_);
            }
          }
          else
          {
            if (this->weight_parser_ != 0)
            {
              this->weight_parser_->post_Quantity ();
              this->weight ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "nominalVolume" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->nominalVolume_parser_)
            {
              this->nominalVolume_parser_->pre ();
              ctx.nested_parser (this->nominalVolume_parser_);
            }
          }
          else
          {
            if (this->nominalVolume_parser_ != 0)
            {
              this->nominalVolume_parser_->post_Quantity ();
              this->nominalVolume ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "externalDiameter" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->externalDiameter_parser_)
            {
              this->externalDiameter_parser_->pre ();
              ctx.nested_parser (this->externalDiameter_parser_);
            }
          }
          else
          {
            if (this->externalDiameter_parser_ != 0)
            {
              this->externalDiameter_parser_->post_Quantity ();
              this->externalDiameter ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "shape" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->shape_parser_)
            {
              this->shape_parser_->pre ();
              ctx.nested_parser (this->shape_parser_);
            }
          }
          else
          {
            if (this->shape_parser_ != 0)
            {
              this->shape_parser_->post_string ();
              this->shape ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "color" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->color_parser_)
            {
              this->color_parser_->pre ();
              ctx.nested_parser (this->color_parser_);
            }
          }
          else
          {
            if (this->color_parser_ != 0)
            {
              this->color_parser_->post_string ();
              this->color ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "imprint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->imprint_parser_)
            {
              this->imprint_parser_->pre ();
              ctx.nested_parser (this->imprint_parser_);
            }
          }
          else
          {
            if (this->imprint_parser_ != 0)
            {
              this->imprint_parser_->post_string ();
              this->imprint ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "image" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->image_parser_)
            {
              this->image_parser_->pre ();
              ctx.nested_parser (this->image_parser_);
            }
          }
          else
          {
            if (this->image_parser_ != 0)
            {
              this->image_parser_->post_Attachment ();
              this->image ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "scoring" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->scoring_parser_)
            {
              this->scoring_parser_->pre ();
              ctx.nested_parser (this->scoring_parser_);
            }
          }
          else
          {
            if (this->scoring_parser_ != 0)
            {
              this->scoring_parser_->post_CodeableConcept ();
              this->scoring ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CodeableConcept_pskel.
  //
  bool CodeableConcept_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "coding" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "text" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CodeableConcept_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CodeableConcept_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CodeableConcept_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void CodeableConcept_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void CodeableConcept_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "coding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->coding_parser_)
            {
              this->coding_parser_->pre ();
              ctx.nested_parser (this->coding_parser_);
            }
          }
          else
          {
            if (this->coding_parser_ != 0)
            {
              this->coding_parser_->post_Coding ();
              this->coding ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "text" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->text_parser_)
            {
              this->text_parser_->pre ();
              ctx.nested_parser (this->text_parser_);
            }
          }
          else
          {
            if (this->text_parser_ != 0)
            {
              this->text_parser_->post_string ();
              this->text ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ParameterDefinition_pskel.
  //
  bool ParameterDefinition_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "use" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ParameterDefinition_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ParameterDefinition_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Element_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ParameterDefinition_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Element_pskel base;
    base::_pre_e_validate ();
  }

  void ParameterDefinition_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Element_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ParameterDefinition_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_code ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "use" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->use_parser_)
            {
              this->use_parser_->pre ();
              ctx.nested_parser (this->use_parser_);
            }
          }
          else
          {
            if (this->use_parser_ != 0)
            {
              this->use_parser_->post_code ();
              this->use ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "min" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->min_parser_)
            {
              this->min_parser_->pre ();
              ctx.nested_parser (this->min_parser_);
            }
          }
          else
          {
            if (this->min_parser_ != 0)
            {
              this->min_parser_->post_integer ();
              this->min ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "max" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->max_parser_)
            {
              this->max_parser_->pre ();
              ctx.nested_parser (this->max_parser_);
            }
          }
          else
          {
            if (this->max_parser_ != 0)
            {
              this->max_parser_->post_string ();
              this->max ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_string ();
              this->documentation ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_code ();
              this->type ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_canonical ();
              this->profile ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_pskel.
  //
  bool ElementDefinition_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "path" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "representation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->representation_parser_)
            {
              this->representation_parser_->pre ();
              ctx.nested_parser (this->representation_parser_);
            }
          }
          else
          {
            if (this->representation_parser_ != 0)
            {
              this->representation_parser_->post_PropertyRepresentation ();
              this->representation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "sliceName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sliceName_parser_)
            {
              this->sliceName_parser_->pre ();
              ctx.nested_parser (this->sliceName_parser_);
            }
          }
          else
          {
            if (this->sliceName_parser_ != 0)
            {
              this->sliceName_parser_->post_string ();
              this->sliceName ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "sliceIsConstraining" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sliceIsConstraining_parser_)
            {
              this->sliceIsConstraining_parser_->pre ();
              ctx.nested_parser (this->sliceIsConstraining_parser_);
            }
          }
          else
          {
            if (this->sliceIsConstraining_parser_ != 0)
            {
              this->sliceIsConstraining_parser_->post_boolean ();
              this->sliceIsConstraining ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "label" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->label_parser_)
            {
              this->label_parser_->pre ();
              ctx.nested_parser (this->label_parser_);
            }
          }
          else
          {
            if (this->label_parser_ != 0)
            {
              this->label_parser_->post_string ();
              this->label ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_Coding ();
              this->code ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "slicing" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->slicing_parser_)
            {
              this->slicing_parser_->pre ();
              ctx.nested_parser (this->slicing_parser_);
            }
          }
          else
          {
            if (this->slicing_parser_ != 0)
            {
              this->slicing_parser_->post_ElementDefinition_Slicing ();
              this->slicing ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "short" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->short__parser_)
            {
              this->short__parser_->pre ();
              ctx.nested_parser (this->short__parser_);
            }
          }
          else
          {
            if (this->short__parser_ != 0)
            {
              this->short__parser_->post_string ();
              this->short_ ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "definition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->definition_parser_)
            {
              this->definition_parser_->pre ();
              ctx.nested_parser (this->definition_parser_);
            }
          }
          else
          {
            if (this->definition_parser_ != 0)
            {
              this->definition_parser_->post_markdown ();
              this->definition ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "comment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->comment_parser_)
            {
              this->comment_parser_->pre ();
              ctx.nested_parser (this->comment_parser_);
            }
          }
          else
          {
            if (this->comment_parser_ != 0)
            {
              this->comment_parser_->post_markdown ();
              this->comment ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "requirements" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requirements_parser_)
            {
              this->requirements_parser_->pre ();
              ctx.nested_parser (this->requirements_parser_);
            }
          }
          else
          {
            if (this->requirements_parser_ != 0)
            {
              this->requirements_parser_->post_markdown ();
              this->requirements ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "alias" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->alias_parser_)
            {
              this->alias_parser_->pre ();
              ctx.nested_parser (this->alias_parser_);
            }
          }
          else
          {
            if (this->alias_parser_ != 0)
            {
              this->alias_parser_->post_string ();
              this->alias ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "min" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->min_parser_)
            {
              this->min_parser_->pre ();
              ctx.nested_parser (this->min_parser_);
            }
          }
          else
          {
            if (this->min_parser_ != 0)
            {
              this->min_parser_->post_unsignedInt ();
              this->min ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "max" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->max_parser_)
            {
              this->max_parser_->pre ();
              ctx.nested_parser (this->max_parser_);
            }
          }
          else
          {
            if (this->max_parser_ != 0)
            {
              this->max_parser_->post_string ();
              this->max ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "base" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->base_parser_)
            {
              this->base_parser_->pre ();
              ctx.nested_parser (this->base_parser_);
            }
          }
          else
          {
            if (this->base_parser_ != 0)
            {
              this->base_parser_->post_ElementDefinition_Base ();
              this->base ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "contentReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contentReference_parser_)
            {
              this->contentReference_parser_->pre ();
              ctx.nested_parser (this->contentReference_parser_);
            }
          }
          else
          {
            if (this->contentReference_parser_ != 0)
            {
              this->contentReference_parser_->post_uri ();
              this->contentReference ();
            }

            count = 0;
            state = 16UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_ElementDefinition_Type ();
              this->type ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "defaultValueBase64Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueBase64Binary_parser_)
            {
              this->defaultValueBase64Binary_parser_->pre ();
              ctx.nested_parser (this->defaultValueBase64Binary_parser_);
            }
          }
          else
          {
            if (this->defaultValueBase64Binary_parser_ != 0)
            {
              this->defaultValueBase64Binary_parser_->post_base64Binary ();
              this->defaultValueBase64Binary ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "defaultValueBoolean" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueBoolean_parser_)
            {
              this->defaultValueBoolean_parser_->pre ();
              ctx.nested_parser (this->defaultValueBoolean_parser_);
            }
          }
          else
          {
            if (this->defaultValueBoolean_parser_ != 0)
            {
              this->defaultValueBoolean_parser_->post_boolean ();
              this->defaultValueBoolean ();
            }

            count = 0;
            state = 19UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "defaultValueCanonical" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueCanonical_parser_)
            {
              this->defaultValueCanonical_parser_->pre ();
              ctx.nested_parser (this->defaultValueCanonical_parser_);
            }
          }
          else
          {
            if (this->defaultValueCanonical_parser_ != 0)
            {
              this->defaultValueCanonical_parser_->post_canonical ();
              this->defaultValueCanonical ();
            }

            count = 0;
            state = 20UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "defaultValueCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueCode_parser_)
            {
              this->defaultValueCode_parser_->pre ();
              ctx.nested_parser (this->defaultValueCode_parser_);
            }
          }
          else
          {
            if (this->defaultValueCode_parser_ != 0)
            {
              this->defaultValueCode_parser_->post_code ();
              this->defaultValueCode ();
            }

            count = 0;
            state = 21UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "defaultValueDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDate_parser_)
            {
              this->defaultValueDate_parser_->pre ();
              ctx.nested_parser (this->defaultValueDate_parser_);
            }
          }
          else
          {
            if (this->defaultValueDate_parser_ != 0)
            {
              this->defaultValueDate_parser_->post_date ();
              this->defaultValueDate ();
            }

            count = 0;
            state = 22UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 22UL;
          // Fall through.
        }
      }
      case 22UL:
      {
        if (n == "defaultValueDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDateTime_parser_)
            {
              this->defaultValueDateTime_parser_->pre ();
              ctx.nested_parser (this->defaultValueDateTime_parser_);
            }
          }
          else
          {
            if (this->defaultValueDateTime_parser_ != 0)
            {
              this->defaultValueDateTime_parser_->post_dateTime ();
              this->defaultValueDateTime ();
            }

            count = 0;
            state = 23UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 23UL;
          // Fall through.
        }
      }
      case 23UL:
      {
        if (n == "defaultValueDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDecimal_parser_)
            {
              this->defaultValueDecimal_parser_->pre ();
              ctx.nested_parser (this->defaultValueDecimal_parser_);
            }
          }
          else
          {
            if (this->defaultValueDecimal_parser_ != 0)
            {
              this->defaultValueDecimal_parser_->post_decimal ();
              this->defaultValueDecimal ();
            }

            count = 0;
            state = 24UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 24UL;
          // Fall through.
        }
      }
      case 24UL:
      {
        if (n == "defaultValueId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueId_parser_)
            {
              this->defaultValueId_parser_->pre ();
              ctx.nested_parser (this->defaultValueId_parser_);
            }
          }
          else
          {
            if (this->defaultValueId_parser_ != 0)
            {
              this->defaultValueId_parser_->post_id ();
              this->defaultValueId ();
            }

            count = 0;
            state = 25UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 25UL;
          // Fall through.
        }
      }
      case 25UL:
      {
        if (n == "defaultValueInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueInstant_parser_)
            {
              this->defaultValueInstant_parser_->pre ();
              ctx.nested_parser (this->defaultValueInstant_parser_);
            }
          }
          else
          {
            if (this->defaultValueInstant_parser_ != 0)
            {
              this->defaultValueInstant_parser_->post_instant ();
              this->defaultValueInstant ();
            }

            count = 0;
            state = 26UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 26UL;
          // Fall through.
        }
      }
      case 26UL:
      {
        if (n == "defaultValueInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueInteger_parser_)
            {
              this->defaultValueInteger_parser_->pre ();
              ctx.nested_parser (this->defaultValueInteger_parser_);
            }
          }
          else
          {
            if (this->defaultValueInteger_parser_ != 0)
            {
              this->defaultValueInteger_parser_->post_integer ();
              this->defaultValueInteger ();
            }

            count = 0;
            state = 27UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 27UL;
          // Fall through.
        }
      }
      case 27UL:
      {
        if (n == "defaultValueMarkdown" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueMarkdown_parser_)
            {
              this->defaultValueMarkdown_parser_->pre ();
              ctx.nested_parser (this->defaultValueMarkdown_parser_);
            }
          }
          else
          {
            if (this->defaultValueMarkdown_parser_ != 0)
            {
              this->defaultValueMarkdown_parser_->post_markdown ();
              this->defaultValueMarkdown ();
            }

            count = 0;
            state = 28UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 28UL;
          // Fall through.
        }
      }
      case 28UL:
      {
        if (n == "defaultValueOid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueOid_parser_)
            {
              this->defaultValueOid_parser_->pre ();
              ctx.nested_parser (this->defaultValueOid_parser_);
            }
          }
          else
          {
            if (this->defaultValueOid_parser_ != 0)
            {
              this->defaultValueOid_parser_->post_oid ();
              this->defaultValueOid ();
            }

            count = 0;
            state = 29UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 29UL;
          // Fall through.
        }
      }
      case 29UL:
      {
        if (n == "defaultValuePositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValuePositiveInt_parser_)
            {
              this->defaultValuePositiveInt_parser_->pre ();
              ctx.nested_parser (this->defaultValuePositiveInt_parser_);
            }
          }
          else
          {
            if (this->defaultValuePositiveInt_parser_ != 0)
            {
              this->defaultValuePositiveInt_parser_->post_positiveInt ();
              this->defaultValuePositiveInt ();
            }

            count = 0;
            state = 30UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 30UL;
          // Fall through.
        }
      }
      case 30UL:
      {
        if (n == "defaultValueString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueString_parser_)
            {
              this->defaultValueString_parser_->pre ();
              ctx.nested_parser (this->defaultValueString_parser_);
            }
          }
          else
          {
            if (this->defaultValueString_parser_ != 0)
            {
              this->defaultValueString_parser_->post_string ();
              this->defaultValueString ();
            }

            count = 0;
            state = 31UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 31UL;
          // Fall through.
        }
      }
      case 31UL:
      {
        if (n == "defaultValueTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueTime_parser_)
            {
              this->defaultValueTime_parser_->pre ();
              ctx.nested_parser (this->defaultValueTime_parser_);
            }
          }
          else
          {
            if (this->defaultValueTime_parser_ != 0)
            {
              this->defaultValueTime_parser_->post_time ();
              this->defaultValueTime ();
            }

            count = 0;
            state = 32UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 32UL;
          // Fall through.
        }
      }
      case 32UL:
      {
        if (n == "defaultValueUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueUnsignedInt_parser_)
            {
              this->defaultValueUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->defaultValueUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->defaultValueUnsignedInt_parser_ != 0)
            {
              this->defaultValueUnsignedInt_parser_->post_unsignedInt ();
              this->defaultValueUnsignedInt ();
            }

            count = 0;
            state = 33UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 33UL;
          // Fall through.
        }
      }
      case 33UL:
      {
        if (n == "defaultValueUri" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueUri_parser_)
            {
              this->defaultValueUri_parser_->pre ();
              ctx.nested_parser (this->defaultValueUri_parser_);
            }
          }
          else
          {
            if (this->defaultValueUri_parser_ != 0)
            {
              this->defaultValueUri_parser_->post_uri ();
              this->defaultValueUri ();
            }

            count = 0;
            state = 34UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 34UL;
          // Fall through.
        }
      }
      case 34UL:
      {
        if (n == "defaultValueUrl" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueUrl_parser_)
            {
              this->defaultValueUrl_parser_->pre ();
              ctx.nested_parser (this->defaultValueUrl_parser_);
            }
          }
          else
          {
            if (this->defaultValueUrl_parser_ != 0)
            {
              this->defaultValueUrl_parser_->post_url ();
              this->defaultValueUrl ();
            }

            count = 0;
            state = 35UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 35UL;
          // Fall through.
        }
      }
      case 35UL:
      {
        if (n == "defaultValueUuid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueUuid_parser_)
            {
              this->defaultValueUuid_parser_->pre ();
              ctx.nested_parser (this->defaultValueUuid_parser_);
            }
          }
          else
          {
            if (this->defaultValueUuid_parser_ != 0)
            {
              this->defaultValueUuid_parser_->post_uuid ();
              this->defaultValueUuid ();
            }

            count = 0;
            state = 36UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 36UL;
          // Fall through.
        }
      }
      case 36UL:
      {
        if (n == "defaultValueAddress" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueAddress_parser_)
            {
              this->defaultValueAddress_parser_->pre ();
              ctx.nested_parser (this->defaultValueAddress_parser_);
            }
          }
          else
          {
            if (this->defaultValueAddress_parser_ != 0)
            {
              this->defaultValueAddress_parser_->post_Address ();
              this->defaultValueAddress ();
            }

            count = 0;
            state = 37UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 37UL;
          // Fall through.
        }
      }
      case 37UL:
      {
        if (n == "defaultValueAge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueAge_parser_)
            {
              this->defaultValueAge_parser_->pre ();
              ctx.nested_parser (this->defaultValueAge_parser_);
            }
          }
          else
          {
            if (this->defaultValueAge_parser_ != 0)
            {
              this->defaultValueAge_parser_->post_Age ();
              this->defaultValueAge ();
            }

            count = 0;
            state = 38UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 38UL;
          // Fall through.
        }
      }
      case 38UL:
      {
        if (n == "defaultValueAnnotation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueAnnotation_parser_)
            {
              this->defaultValueAnnotation_parser_->pre ();
              ctx.nested_parser (this->defaultValueAnnotation_parser_);
            }
          }
          else
          {
            if (this->defaultValueAnnotation_parser_ != 0)
            {
              this->defaultValueAnnotation_parser_->post_Annotation ();
              this->defaultValueAnnotation ();
            }

            count = 0;
            state = 39UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 39UL;
          // Fall through.
        }
      }
      case 39UL:
      {
        if (n == "defaultValueAttachment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueAttachment_parser_)
            {
              this->defaultValueAttachment_parser_->pre ();
              ctx.nested_parser (this->defaultValueAttachment_parser_);
            }
          }
          else
          {
            if (this->defaultValueAttachment_parser_ != 0)
            {
              this->defaultValueAttachment_parser_->post_Attachment ();
              this->defaultValueAttachment ();
            }

            count = 0;
            state = 40UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 40UL;
          // Fall through.
        }
      }
      case 40UL:
      {
        if (n == "defaultValueCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueCodeableConcept_parser_)
            {
              this->defaultValueCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->defaultValueCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->defaultValueCodeableConcept_parser_ != 0)
            {
              this->defaultValueCodeableConcept_parser_->post_CodeableConcept ();
              this->defaultValueCodeableConcept ();
            }

            count = 0;
            state = 41UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 41UL;
          // Fall through.
        }
      }
      case 41UL:
      {
        if (n == "defaultValueCoding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueCoding_parser_)
            {
              this->defaultValueCoding_parser_->pre ();
              ctx.nested_parser (this->defaultValueCoding_parser_);
            }
          }
          else
          {
            if (this->defaultValueCoding_parser_ != 0)
            {
              this->defaultValueCoding_parser_->post_Coding ();
              this->defaultValueCoding ();
            }

            count = 0;
            state = 42UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 42UL;
          // Fall through.
        }
      }
      case 42UL:
      {
        if (n == "defaultValueContactPoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueContactPoint_parser_)
            {
              this->defaultValueContactPoint_parser_->pre ();
              ctx.nested_parser (this->defaultValueContactPoint_parser_);
            }
          }
          else
          {
            if (this->defaultValueContactPoint_parser_ != 0)
            {
              this->defaultValueContactPoint_parser_->post_ContactPoint ();
              this->defaultValueContactPoint ();
            }

            count = 0;
            state = 43UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 43UL;
          // Fall through.
        }
      }
      case 43UL:
      {
        if (n == "defaultValueCount" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueCount_parser_)
            {
              this->defaultValueCount_parser_->pre ();
              ctx.nested_parser (this->defaultValueCount_parser_);
            }
          }
          else
          {
            if (this->defaultValueCount_parser_ != 0)
            {
              this->defaultValueCount_parser_->post_Count ();
              this->defaultValueCount ();
            }

            count = 0;
            state = 44UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 44UL;
          // Fall through.
        }
      }
      case 44UL:
      {
        if (n == "defaultValueDistance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDistance_parser_)
            {
              this->defaultValueDistance_parser_->pre ();
              ctx.nested_parser (this->defaultValueDistance_parser_);
            }
          }
          else
          {
            if (this->defaultValueDistance_parser_ != 0)
            {
              this->defaultValueDistance_parser_->post_Distance ();
              this->defaultValueDistance ();
            }

            count = 0;
            state = 45UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 45UL;
          // Fall through.
        }
      }
      case 45UL:
      {
        if (n == "defaultValueDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDuration_parser_)
            {
              this->defaultValueDuration_parser_->pre ();
              ctx.nested_parser (this->defaultValueDuration_parser_);
            }
          }
          else
          {
            if (this->defaultValueDuration_parser_ != 0)
            {
              this->defaultValueDuration_parser_->post_Duration ();
              this->defaultValueDuration ();
            }

            count = 0;
            state = 46UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 46UL;
          // Fall through.
        }
      }
      case 46UL:
      {
        if (n == "defaultValueHumanName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueHumanName_parser_)
            {
              this->defaultValueHumanName_parser_->pre ();
              ctx.nested_parser (this->defaultValueHumanName_parser_);
            }
          }
          else
          {
            if (this->defaultValueHumanName_parser_ != 0)
            {
              this->defaultValueHumanName_parser_->post_HumanName ();
              this->defaultValueHumanName ();
            }

            count = 0;
            state = 47UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 47UL;
          // Fall through.
        }
      }
      case 47UL:
      {
        if (n == "defaultValueIdentifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueIdentifier_parser_)
            {
              this->defaultValueIdentifier_parser_->pre ();
              ctx.nested_parser (this->defaultValueIdentifier_parser_);
            }
          }
          else
          {
            if (this->defaultValueIdentifier_parser_ != 0)
            {
              this->defaultValueIdentifier_parser_->post_Identifier ();
              this->defaultValueIdentifier ();
            }

            count = 0;
            state = 48UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 48UL;
          // Fall through.
        }
      }
      case 48UL:
      {
        if (n == "defaultValueMoney" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueMoney_parser_)
            {
              this->defaultValueMoney_parser_->pre ();
              ctx.nested_parser (this->defaultValueMoney_parser_);
            }
          }
          else
          {
            if (this->defaultValueMoney_parser_ != 0)
            {
              this->defaultValueMoney_parser_->post_Money ();
              this->defaultValueMoney ();
            }

            count = 0;
            state = 49UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 49UL;
          // Fall through.
        }
      }
      case 49UL:
      {
        if (n == "defaultValuePeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValuePeriod_parser_)
            {
              this->defaultValuePeriod_parser_->pre ();
              ctx.nested_parser (this->defaultValuePeriod_parser_);
            }
          }
          else
          {
            if (this->defaultValuePeriod_parser_ != 0)
            {
              this->defaultValuePeriod_parser_->post_Period ();
              this->defaultValuePeriod ();
            }

            count = 0;
            state = 50UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 50UL;
          // Fall through.
        }
      }
      case 50UL:
      {
        if (n == "defaultValueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueQuantity_parser_)
            {
              this->defaultValueQuantity_parser_->pre ();
              ctx.nested_parser (this->defaultValueQuantity_parser_);
            }
          }
          else
          {
            if (this->defaultValueQuantity_parser_ != 0)
            {
              this->defaultValueQuantity_parser_->post_Quantity ();
              this->defaultValueQuantity ();
            }

            count = 0;
            state = 51UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 51UL;
          // Fall through.
        }
      }
      case 51UL:
      {
        if (n == "defaultValueRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueRange_parser_)
            {
              this->defaultValueRange_parser_->pre ();
              ctx.nested_parser (this->defaultValueRange_parser_);
            }
          }
          else
          {
            if (this->defaultValueRange_parser_ != 0)
            {
              this->defaultValueRange_parser_->post_Range ();
              this->defaultValueRange ();
            }

            count = 0;
            state = 52UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 52UL;
          // Fall through.
        }
      }
      case 52UL:
      {
        if (n == "defaultValueRatio" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueRatio_parser_)
            {
              this->defaultValueRatio_parser_->pre ();
              ctx.nested_parser (this->defaultValueRatio_parser_);
            }
          }
          else
          {
            if (this->defaultValueRatio_parser_ != 0)
            {
              this->defaultValueRatio_parser_->post_Ratio ();
              this->defaultValueRatio ();
            }

            count = 0;
            state = 53UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 53UL;
          // Fall through.
        }
      }
      case 53UL:
      {
        if (n == "defaultValueReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueReference_parser_)
            {
              this->defaultValueReference_parser_->pre ();
              ctx.nested_parser (this->defaultValueReference_parser_);
            }
          }
          else
          {
            if (this->defaultValueReference_parser_ != 0)
            {
              this->defaultValueReference_parser_->post_Reference ();
              this->defaultValueReference ();
            }

            count = 0;
            state = 54UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 54UL;
          // Fall through.
        }
      }
      case 54UL:
      {
        if (n == "defaultValueSampledData" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueSampledData_parser_)
            {
              this->defaultValueSampledData_parser_->pre ();
              ctx.nested_parser (this->defaultValueSampledData_parser_);
            }
          }
          else
          {
            if (this->defaultValueSampledData_parser_ != 0)
            {
              this->defaultValueSampledData_parser_->post_SampledData ();
              this->defaultValueSampledData ();
            }

            count = 0;
            state = 55UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 55UL;
          // Fall through.
        }
      }
      case 55UL:
      {
        if (n == "defaultValueSignature" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueSignature_parser_)
            {
              this->defaultValueSignature_parser_->pre ();
              ctx.nested_parser (this->defaultValueSignature_parser_);
            }
          }
          else
          {
            if (this->defaultValueSignature_parser_ != 0)
            {
              this->defaultValueSignature_parser_->post_Signature ();
              this->defaultValueSignature ();
            }

            count = 0;
            state = 56UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 56UL;
          // Fall through.
        }
      }
      case 56UL:
      {
        if (n == "defaultValueTiming" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueTiming_parser_)
            {
              this->defaultValueTiming_parser_->pre ();
              ctx.nested_parser (this->defaultValueTiming_parser_);
            }
          }
          else
          {
            if (this->defaultValueTiming_parser_ != 0)
            {
              this->defaultValueTiming_parser_->post_Timing ();
              this->defaultValueTiming ();
            }

            count = 0;
            state = 57UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 57UL;
          // Fall through.
        }
      }
      case 57UL:
      {
        if (n == "defaultValueContactDetail" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueContactDetail_parser_)
            {
              this->defaultValueContactDetail_parser_->pre ();
              ctx.nested_parser (this->defaultValueContactDetail_parser_);
            }
          }
          else
          {
            if (this->defaultValueContactDetail_parser_ != 0)
            {
              this->defaultValueContactDetail_parser_->post_ContactDetail ();
              this->defaultValueContactDetail ();
            }

            count = 0;
            state = 58UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 58UL;
          // Fall through.
        }
      }
      case 58UL:
      {
        if (n == "defaultValueContributor" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueContributor_parser_)
            {
              this->defaultValueContributor_parser_->pre ();
              ctx.nested_parser (this->defaultValueContributor_parser_);
            }
          }
          else
          {
            if (this->defaultValueContributor_parser_ != 0)
            {
              this->defaultValueContributor_parser_->post_Contributor ();
              this->defaultValueContributor ();
            }

            count = 0;
            state = 59UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 59UL;
          // Fall through.
        }
      }
      case 59UL:
      {
        if (n == "defaultValueDataRequirement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDataRequirement_parser_)
            {
              this->defaultValueDataRequirement_parser_->pre ();
              ctx.nested_parser (this->defaultValueDataRequirement_parser_);
            }
          }
          else
          {
            if (this->defaultValueDataRequirement_parser_ != 0)
            {
              this->defaultValueDataRequirement_parser_->post_DataRequirement ();
              this->defaultValueDataRequirement ();
            }

            count = 0;
            state = 60UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 60UL;
          // Fall through.
        }
      }
      case 60UL:
      {
        if (n == "defaultValueExpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueExpression_parser_)
            {
              this->defaultValueExpression_parser_->pre ();
              ctx.nested_parser (this->defaultValueExpression_parser_);
            }
          }
          else
          {
            if (this->defaultValueExpression_parser_ != 0)
            {
              this->defaultValueExpression_parser_->post_Expression ();
              this->defaultValueExpression ();
            }

            count = 0;
            state = 61UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 61UL;
          // Fall through.
        }
      }
      case 61UL:
      {
        if (n == "defaultValueParameterDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueParameterDefinition_parser_)
            {
              this->defaultValueParameterDefinition_parser_->pre ();
              ctx.nested_parser (this->defaultValueParameterDefinition_parser_);
            }
          }
          else
          {
            if (this->defaultValueParameterDefinition_parser_ != 0)
            {
              this->defaultValueParameterDefinition_parser_->post_ParameterDefinition ();
              this->defaultValueParameterDefinition ();
            }

            count = 0;
            state = 62UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 62UL;
          // Fall through.
        }
      }
      case 62UL:
      {
        if (n == "defaultValueRelatedArtifact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueRelatedArtifact_parser_)
            {
              this->defaultValueRelatedArtifact_parser_->pre ();
              ctx.nested_parser (this->defaultValueRelatedArtifact_parser_);
            }
          }
          else
          {
            if (this->defaultValueRelatedArtifact_parser_ != 0)
            {
              this->defaultValueRelatedArtifact_parser_->post_RelatedArtifact ();
              this->defaultValueRelatedArtifact ();
            }

            count = 0;
            state = 63UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 63UL;
          // Fall through.
        }
      }
      case 63UL:
      {
        if (n == "defaultValueTriggerDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueTriggerDefinition_parser_)
            {
              this->defaultValueTriggerDefinition_parser_->pre ();
              ctx.nested_parser (this->defaultValueTriggerDefinition_parser_);
            }
          }
          else
          {
            if (this->defaultValueTriggerDefinition_parser_ != 0)
            {
              this->defaultValueTriggerDefinition_parser_->post_TriggerDefinition ();
              this->defaultValueTriggerDefinition ();
            }

            count = 0;
            state = 64UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 64UL;
          // Fall through.
        }
      }
      case 64UL:
      {
        if (n == "defaultValueUsageContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueUsageContext_parser_)
            {
              this->defaultValueUsageContext_parser_->pre ();
              ctx.nested_parser (this->defaultValueUsageContext_parser_);
            }
          }
          else
          {
            if (this->defaultValueUsageContext_parser_ != 0)
            {
              this->defaultValueUsageContext_parser_->post_UsageContext ();
              this->defaultValueUsageContext ();
            }

            count = 0;
            state = 65UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 65UL;
          // Fall through.
        }
      }
      case 65UL:
      {
        if (n == "defaultValueDosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueDosage_parser_)
            {
              this->defaultValueDosage_parser_->pre ();
              ctx.nested_parser (this->defaultValueDosage_parser_);
            }
          }
          else
          {
            if (this->defaultValueDosage_parser_ != 0)
            {
              this->defaultValueDosage_parser_->post_Dosage ();
              this->defaultValueDosage ();
            }

            count = 0;
            state = 66UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 66UL;
          // Fall through.
        }
      }
      case 66UL:
      {
        if (n == "defaultValueMeta" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->defaultValueMeta_parser_)
            {
              this->defaultValueMeta_parser_->pre ();
              ctx.nested_parser (this->defaultValueMeta_parser_);
            }
          }
          else
          {
            if (this->defaultValueMeta_parser_ != 0)
            {
              this->defaultValueMeta_parser_->post_Meta ();
              this->defaultValueMeta ();
            }

            count = 0;
            state = 67UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 67UL;
          // Fall through.
        }
      }
      case 67UL:
      {
        if (n == "meaningWhenMissing" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->meaningWhenMissing_parser_)
            {
              this->meaningWhenMissing_parser_->pre ();
              ctx.nested_parser (this->meaningWhenMissing_parser_);
            }
          }
          else
          {
            if (this->meaningWhenMissing_parser_ != 0)
            {
              this->meaningWhenMissing_parser_->post_markdown ();
              this->meaningWhenMissing ();
            }

            count = 0;
            state = 68UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 68UL;
          // Fall through.
        }
      }
      case 68UL:
      {
        if (n == "orderMeaning" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->orderMeaning_parser_)
            {
              this->orderMeaning_parser_->pre ();
              ctx.nested_parser (this->orderMeaning_parser_);
            }
          }
          else
          {
            if (this->orderMeaning_parser_ != 0)
            {
              this->orderMeaning_parser_->post_string ();
              this->orderMeaning ();
            }

            count = 0;
            state = 69UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 69UL;
          // Fall through.
        }
      }
      case 69UL:
      {
        if (n == "fixedBase64Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedBase64Binary_parser_)
            {
              this->fixedBase64Binary_parser_->pre ();
              ctx.nested_parser (this->fixedBase64Binary_parser_);
            }
          }
          else
          {
            if (this->fixedBase64Binary_parser_ != 0)
            {
              this->fixedBase64Binary_parser_->post_base64Binary ();
              this->fixedBase64Binary ();
            }

            count = 0;
            state = 70UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 70UL;
          // Fall through.
        }
      }
      case 70UL:
      {
        if (n == "fixedBoolean" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedBoolean_parser_)
            {
              this->fixedBoolean_parser_->pre ();
              ctx.nested_parser (this->fixedBoolean_parser_);
            }
          }
          else
          {
            if (this->fixedBoolean_parser_ != 0)
            {
              this->fixedBoolean_parser_->post_boolean ();
              this->fixedBoolean ();
            }

            count = 0;
            state = 71UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 71UL;
          // Fall through.
        }
      }
      case 71UL:
      {
        if (n == "fixedCanonical" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedCanonical_parser_)
            {
              this->fixedCanonical_parser_->pre ();
              ctx.nested_parser (this->fixedCanonical_parser_);
            }
          }
          else
          {
            if (this->fixedCanonical_parser_ != 0)
            {
              this->fixedCanonical_parser_->post_canonical ();
              this->fixedCanonical ();
            }

            count = 0;
            state = 72UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 72UL;
          // Fall through.
        }
      }
      case 72UL:
      {
        if (n == "fixedCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedCode_parser_)
            {
              this->fixedCode_parser_->pre ();
              ctx.nested_parser (this->fixedCode_parser_);
            }
          }
          else
          {
            if (this->fixedCode_parser_ != 0)
            {
              this->fixedCode_parser_->post_code ();
              this->fixedCode ();
            }

            count = 0;
            state = 73UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 73UL;
          // Fall through.
        }
      }
      case 73UL:
      {
        if (n == "fixedDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDate_parser_)
            {
              this->fixedDate_parser_->pre ();
              ctx.nested_parser (this->fixedDate_parser_);
            }
          }
          else
          {
            if (this->fixedDate_parser_ != 0)
            {
              this->fixedDate_parser_->post_date ();
              this->fixedDate ();
            }

            count = 0;
            state = 74UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 74UL;
          // Fall through.
        }
      }
      case 74UL:
      {
        if (n == "fixedDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDateTime_parser_)
            {
              this->fixedDateTime_parser_->pre ();
              ctx.nested_parser (this->fixedDateTime_parser_);
            }
          }
          else
          {
            if (this->fixedDateTime_parser_ != 0)
            {
              this->fixedDateTime_parser_->post_dateTime ();
              this->fixedDateTime ();
            }

            count = 0;
            state = 75UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 75UL;
          // Fall through.
        }
      }
      case 75UL:
      {
        if (n == "fixedDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDecimal_parser_)
            {
              this->fixedDecimal_parser_->pre ();
              ctx.nested_parser (this->fixedDecimal_parser_);
            }
          }
          else
          {
            if (this->fixedDecimal_parser_ != 0)
            {
              this->fixedDecimal_parser_->post_decimal ();
              this->fixedDecimal ();
            }

            count = 0;
            state = 76UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 76UL;
          // Fall through.
        }
      }
      case 76UL:
      {
        if (n == "fixedId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedId_parser_)
            {
              this->fixedId_parser_->pre ();
              ctx.nested_parser (this->fixedId_parser_);
            }
          }
          else
          {
            if (this->fixedId_parser_ != 0)
            {
              this->fixedId_parser_->post_id ();
              this->fixedId ();
            }

            count = 0;
            state = 77UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 77UL;
          // Fall through.
        }
      }
      case 77UL:
      {
        if (n == "fixedInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedInstant_parser_)
            {
              this->fixedInstant_parser_->pre ();
              ctx.nested_parser (this->fixedInstant_parser_);
            }
          }
          else
          {
            if (this->fixedInstant_parser_ != 0)
            {
              this->fixedInstant_parser_->post_instant ();
              this->fixedInstant ();
            }

            count = 0;
            state = 78UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 78UL;
          // Fall through.
        }
      }
      case 78UL:
      {
        if (n == "fixedInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedInteger_parser_)
            {
              this->fixedInteger_parser_->pre ();
              ctx.nested_parser (this->fixedInteger_parser_);
            }
          }
          else
          {
            if (this->fixedInteger_parser_ != 0)
            {
              this->fixedInteger_parser_->post_integer ();
              this->fixedInteger ();
            }

            count = 0;
            state = 79UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 79UL;
          // Fall through.
        }
      }
      case 79UL:
      {
        if (n == "fixedMarkdown" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedMarkdown_parser_)
            {
              this->fixedMarkdown_parser_->pre ();
              ctx.nested_parser (this->fixedMarkdown_parser_);
            }
          }
          else
          {
            if (this->fixedMarkdown_parser_ != 0)
            {
              this->fixedMarkdown_parser_->post_markdown ();
              this->fixedMarkdown ();
            }

            count = 0;
            state = 80UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 80UL;
          // Fall through.
        }
      }
      case 80UL:
      {
        if (n == "fixedOid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedOid_parser_)
            {
              this->fixedOid_parser_->pre ();
              ctx.nested_parser (this->fixedOid_parser_);
            }
          }
          else
          {
            if (this->fixedOid_parser_ != 0)
            {
              this->fixedOid_parser_->post_oid ();
              this->fixedOid ();
            }

            count = 0;
            state = 81UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 81UL;
          // Fall through.
        }
      }
      case 81UL:
      {
        if (n == "fixedPositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedPositiveInt_parser_)
            {
              this->fixedPositiveInt_parser_->pre ();
              ctx.nested_parser (this->fixedPositiveInt_parser_);
            }
          }
          else
          {
            if (this->fixedPositiveInt_parser_ != 0)
            {
              this->fixedPositiveInt_parser_->post_positiveInt ();
              this->fixedPositiveInt ();
            }

            count = 0;
            state = 82UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 82UL;
          // Fall through.
        }
      }
      case 82UL:
      {
        if (n == "fixedString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedString_parser_)
            {
              this->fixedString_parser_->pre ();
              ctx.nested_parser (this->fixedString_parser_);
            }
          }
          else
          {
            if (this->fixedString_parser_ != 0)
            {
              this->fixedString_parser_->post_string ();
              this->fixedString ();
            }

            count = 0;
            state = 83UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 83UL;
          // Fall through.
        }
      }
      case 83UL:
      {
        if (n == "fixedTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedTime_parser_)
            {
              this->fixedTime_parser_->pre ();
              ctx.nested_parser (this->fixedTime_parser_);
            }
          }
          else
          {
            if (this->fixedTime_parser_ != 0)
            {
              this->fixedTime_parser_->post_time ();
              this->fixedTime ();
            }

            count = 0;
            state = 84UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 84UL;
          // Fall through.
        }
      }
      case 84UL:
      {
        if (n == "fixedUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedUnsignedInt_parser_)
            {
              this->fixedUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->fixedUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->fixedUnsignedInt_parser_ != 0)
            {
              this->fixedUnsignedInt_parser_->post_unsignedInt ();
              this->fixedUnsignedInt ();
            }

            count = 0;
            state = 85UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 85UL;
          // Fall through.
        }
      }
      case 85UL:
      {
        if (n == "fixedUri" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedUri_parser_)
            {
              this->fixedUri_parser_->pre ();
              ctx.nested_parser (this->fixedUri_parser_);
            }
          }
          else
          {
            if (this->fixedUri_parser_ != 0)
            {
              this->fixedUri_parser_->post_uri ();
              this->fixedUri ();
            }

            count = 0;
            state = 86UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 86UL;
          // Fall through.
        }
      }
      case 86UL:
      {
        if (n == "fixedUrl" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedUrl_parser_)
            {
              this->fixedUrl_parser_->pre ();
              ctx.nested_parser (this->fixedUrl_parser_);
            }
          }
          else
          {
            if (this->fixedUrl_parser_ != 0)
            {
              this->fixedUrl_parser_->post_url ();
              this->fixedUrl ();
            }

            count = 0;
            state = 87UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 87UL;
          // Fall through.
        }
      }
      case 87UL:
      {
        if (n == "fixedUuid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedUuid_parser_)
            {
              this->fixedUuid_parser_->pre ();
              ctx.nested_parser (this->fixedUuid_parser_);
            }
          }
          else
          {
            if (this->fixedUuid_parser_ != 0)
            {
              this->fixedUuid_parser_->post_uuid ();
              this->fixedUuid ();
            }

            count = 0;
            state = 88UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 88UL;
          // Fall through.
        }
      }
      case 88UL:
      {
        if (n == "fixedAddress" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedAddress_parser_)
            {
              this->fixedAddress_parser_->pre ();
              ctx.nested_parser (this->fixedAddress_parser_);
            }
          }
          else
          {
            if (this->fixedAddress_parser_ != 0)
            {
              this->fixedAddress_parser_->post_Address ();
              this->fixedAddress ();
            }

            count = 0;
            state = 89UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 89UL;
          // Fall through.
        }
      }
      case 89UL:
      {
        if (n == "fixedAge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedAge_parser_)
            {
              this->fixedAge_parser_->pre ();
              ctx.nested_parser (this->fixedAge_parser_);
            }
          }
          else
          {
            if (this->fixedAge_parser_ != 0)
            {
              this->fixedAge_parser_->post_Age ();
              this->fixedAge ();
            }

            count = 0;
            state = 90UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 90UL;
          // Fall through.
        }
      }
      case 90UL:
      {
        if (n == "fixedAnnotation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedAnnotation_parser_)
            {
              this->fixedAnnotation_parser_->pre ();
              ctx.nested_parser (this->fixedAnnotation_parser_);
            }
          }
          else
          {
            if (this->fixedAnnotation_parser_ != 0)
            {
              this->fixedAnnotation_parser_->post_Annotation ();
              this->fixedAnnotation ();
            }

            count = 0;
            state = 91UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 91UL;
          // Fall through.
        }
      }
      case 91UL:
      {
        if (n == "fixedAttachment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedAttachment_parser_)
            {
              this->fixedAttachment_parser_->pre ();
              ctx.nested_parser (this->fixedAttachment_parser_);
            }
          }
          else
          {
            if (this->fixedAttachment_parser_ != 0)
            {
              this->fixedAttachment_parser_->post_Attachment ();
              this->fixedAttachment ();
            }

            count = 0;
            state = 92UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 92UL;
          // Fall through.
        }
      }
      case 92UL:
      {
        if (n == "fixedCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedCodeableConcept_parser_)
            {
              this->fixedCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->fixedCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->fixedCodeableConcept_parser_ != 0)
            {
              this->fixedCodeableConcept_parser_->post_CodeableConcept ();
              this->fixedCodeableConcept ();
            }

            count = 0;
            state = 93UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 93UL;
          // Fall through.
        }
      }
      case 93UL:
      {
        if (n == "fixedCoding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedCoding_parser_)
            {
              this->fixedCoding_parser_->pre ();
              ctx.nested_parser (this->fixedCoding_parser_);
            }
          }
          else
          {
            if (this->fixedCoding_parser_ != 0)
            {
              this->fixedCoding_parser_->post_Coding ();
              this->fixedCoding ();
            }

            count = 0;
            state = 94UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 94UL;
          // Fall through.
        }
      }
      case 94UL:
      {
        if (n == "fixedContactPoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedContactPoint_parser_)
            {
              this->fixedContactPoint_parser_->pre ();
              ctx.nested_parser (this->fixedContactPoint_parser_);
            }
          }
          else
          {
            if (this->fixedContactPoint_parser_ != 0)
            {
              this->fixedContactPoint_parser_->post_ContactPoint ();
              this->fixedContactPoint ();
            }

            count = 0;
            state = 95UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 95UL;
          // Fall through.
        }
      }
      case 95UL:
      {
        if (n == "fixedCount" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedCount_parser_)
            {
              this->fixedCount_parser_->pre ();
              ctx.nested_parser (this->fixedCount_parser_);
            }
          }
          else
          {
            if (this->fixedCount_parser_ != 0)
            {
              this->fixedCount_parser_->post_Count ();
              this->fixedCount ();
            }

            count = 0;
            state = 96UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 96UL;
          // Fall through.
        }
      }
      case 96UL:
      {
        if (n == "fixedDistance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDistance_parser_)
            {
              this->fixedDistance_parser_->pre ();
              ctx.nested_parser (this->fixedDistance_parser_);
            }
          }
          else
          {
            if (this->fixedDistance_parser_ != 0)
            {
              this->fixedDistance_parser_->post_Distance ();
              this->fixedDistance ();
            }

            count = 0;
            state = 97UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 97UL;
          // Fall through.
        }
      }
      case 97UL:
      {
        if (n == "fixedDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDuration_parser_)
            {
              this->fixedDuration_parser_->pre ();
              ctx.nested_parser (this->fixedDuration_parser_);
            }
          }
          else
          {
            if (this->fixedDuration_parser_ != 0)
            {
              this->fixedDuration_parser_->post_Duration ();
              this->fixedDuration ();
            }

            count = 0;
            state = 98UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 98UL;
          // Fall through.
        }
      }
      case 98UL:
      {
        if (n == "fixedHumanName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedHumanName_parser_)
            {
              this->fixedHumanName_parser_->pre ();
              ctx.nested_parser (this->fixedHumanName_parser_);
            }
          }
          else
          {
            if (this->fixedHumanName_parser_ != 0)
            {
              this->fixedHumanName_parser_->post_HumanName ();
              this->fixedHumanName ();
            }

            count = 0;
            state = 99UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 99UL;
          // Fall through.
        }
      }
      case 99UL:
      {
        if (n == "fixedIdentifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedIdentifier_parser_)
            {
              this->fixedIdentifier_parser_->pre ();
              ctx.nested_parser (this->fixedIdentifier_parser_);
            }
          }
          else
          {
            if (this->fixedIdentifier_parser_ != 0)
            {
              this->fixedIdentifier_parser_->post_Identifier ();
              this->fixedIdentifier ();
            }

            count = 0;
            state = 100UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 100UL;
          // Fall through.
        }
      }
      case 100UL:
      {
        if (n == "fixedMoney" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedMoney_parser_)
            {
              this->fixedMoney_parser_->pre ();
              ctx.nested_parser (this->fixedMoney_parser_);
            }
          }
          else
          {
            if (this->fixedMoney_parser_ != 0)
            {
              this->fixedMoney_parser_->post_Money ();
              this->fixedMoney ();
            }

            count = 0;
            state = 101UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 101UL;
          // Fall through.
        }
      }
      case 101UL:
      {
        if (n == "fixedPeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedPeriod_parser_)
            {
              this->fixedPeriod_parser_->pre ();
              ctx.nested_parser (this->fixedPeriod_parser_);
            }
          }
          else
          {
            if (this->fixedPeriod_parser_ != 0)
            {
              this->fixedPeriod_parser_->post_Period ();
              this->fixedPeriod ();
            }

            count = 0;
            state = 102UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 102UL;
          // Fall through.
        }
      }
      case 102UL:
      {
        if (n == "fixedQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedQuantity_parser_)
            {
              this->fixedQuantity_parser_->pre ();
              ctx.nested_parser (this->fixedQuantity_parser_);
            }
          }
          else
          {
            if (this->fixedQuantity_parser_ != 0)
            {
              this->fixedQuantity_parser_->post_Quantity ();
              this->fixedQuantity ();
            }

            count = 0;
            state = 103UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 103UL;
          // Fall through.
        }
      }
      case 103UL:
      {
        if (n == "fixedRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedRange_parser_)
            {
              this->fixedRange_parser_->pre ();
              ctx.nested_parser (this->fixedRange_parser_);
            }
          }
          else
          {
            if (this->fixedRange_parser_ != 0)
            {
              this->fixedRange_parser_->post_Range ();
              this->fixedRange ();
            }

            count = 0;
            state = 104UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 104UL;
          // Fall through.
        }
      }
      case 104UL:
      {
        if (n == "fixedRatio" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedRatio_parser_)
            {
              this->fixedRatio_parser_->pre ();
              ctx.nested_parser (this->fixedRatio_parser_);
            }
          }
          else
          {
            if (this->fixedRatio_parser_ != 0)
            {
              this->fixedRatio_parser_->post_Ratio ();
              this->fixedRatio ();
            }

            count = 0;
            state = 105UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 105UL;
          // Fall through.
        }
      }
      case 105UL:
      {
        if (n == "fixedReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedReference_parser_)
            {
              this->fixedReference_parser_->pre ();
              ctx.nested_parser (this->fixedReference_parser_);
            }
          }
          else
          {
            if (this->fixedReference_parser_ != 0)
            {
              this->fixedReference_parser_->post_Reference ();
              this->fixedReference ();
            }

            count = 0;
            state = 106UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 106UL;
          // Fall through.
        }
      }
      case 106UL:
      {
        if (n == "fixedSampledData" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedSampledData_parser_)
            {
              this->fixedSampledData_parser_->pre ();
              ctx.nested_parser (this->fixedSampledData_parser_);
            }
          }
          else
          {
            if (this->fixedSampledData_parser_ != 0)
            {
              this->fixedSampledData_parser_->post_SampledData ();
              this->fixedSampledData ();
            }

            count = 0;
            state = 107UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 107UL;
          // Fall through.
        }
      }
      case 107UL:
      {
        if (n == "fixedSignature" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedSignature_parser_)
            {
              this->fixedSignature_parser_->pre ();
              ctx.nested_parser (this->fixedSignature_parser_);
            }
          }
          else
          {
            if (this->fixedSignature_parser_ != 0)
            {
              this->fixedSignature_parser_->post_Signature ();
              this->fixedSignature ();
            }

            count = 0;
            state = 108UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 108UL;
          // Fall through.
        }
      }
      case 108UL:
      {
        if (n == "fixedTiming" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedTiming_parser_)
            {
              this->fixedTiming_parser_->pre ();
              ctx.nested_parser (this->fixedTiming_parser_);
            }
          }
          else
          {
            if (this->fixedTiming_parser_ != 0)
            {
              this->fixedTiming_parser_->post_Timing ();
              this->fixedTiming ();
            }

            count = 0;
            state = 109UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 109UL;
          // Fall through.
        }
      }
      case 109UL:
      {
        if (n == "fixedContactDetail" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedContactDetail_parser_)
            {
              this->fixedContactDetail_parser_->pre ();
              ctx.nested_parser (this->fixedContactDetail_parser_);
            }
          }
          else
          {
            if (this->fixedContactDetail_parser_ != 0)
            {
              this->fixedContactDetail_parser_->post_ContactDetail ();
              this->fixedContactDetail ();
            }

            count = 0;
            state = 110UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 110UL;
          // Fall through.
        }
      }
      case 110UL:
      {
        if (n == "fixedContributor" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedContributor_parser_)
            {
              this->fixedContributor_parser_->pre ();
              ctx.nested_parser (this->fixedContributor_parser_);
            }
          }
          else
          {
            if (this->fixedContributor_parser_ != 0)
            {
              this->fixedContributor_parser_->post_Contributor ();
              this->fixedContributor ();
            }

            count = 0;
            state = 111UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 111UL;
          // Fall through.
        }
      }
      case 111UL:
      {
        if (n == "fixedDataRequirement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDataRequirement_parser_)
            {
              this->fixedDataRequirement_parser_->pre ();
              ctx.nested_parser (this->fixedDataRequirement_parser_);
            }
          }
          else
          {
            if (this->fixedDataRequirement_parser_ != 0)
            {
              this->fixedDataRequirement_parser_->post_DataRequirement ();
              this->fixedDataRequirement ();
            }

            count = 0;
            state = 112UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 112UL;
          // Fall through.
        }
      }
      case 112UL:
      {
        if (n == "fixedExpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedExpression_parser_)
            {
              this->fixedExpression_parser_->pre ();
              ctx.nested_parser (this->fixedExpression_parser_);
            }
          }
          else
          {
            if (this->fixedExpression_parser_ != 0)
            {
              this->fixedExpression_parser_->post_Expression ();
              this->fixedExpression ();
            }

            count = 0;
            state = 113UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 113UL;
          // Fall through.
        }
      }
      case 113UL:
      {
        if (n == "fixedParameterDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedParameterDefinition_parser_)
            {
              this->fixedParameterDefinition_parser_->pre ();
              ctx.nested_parser (this->fixedParameterDefinition_parser_);
            }
          }
          else
          {
            if (this->fixedParameterDefinition_parser_ != 0)
            {
              this->fixedParameterDefinition_parser_->post_ParameterDefinition ();
              this->fixedParameterDefinition ();
            }

            count = 0;
            state = 114UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 114UL;
          // Fall through.
        }
      }
      case 114UL:
      {
        if (n == "fixedRelatedArtifact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedRelatedArtifact_parser_)
            {
              this->fixedRelatedArtifact_parser_->pre ();
              ctx.nested_parser (this->fixedRelatedArtifact_parser_);
            }
          }
          else
          {
            if (this->fixedRelatedArtifact_parser_ != 0)
            {
              this->fixedRelatedArtifact_parser_->post_RelatedArtifact ();
              this->fixedRelatedArtifact ();
            }

            count = 0;
            state = 115UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 115UL;
          // Fall through.
        }
      }
      case 115UL:
      {
        if (n == "fixedTriggerDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedTriggerDefinition_parser_)
            {
              this->fixedTriggerDefinition_parser_->pre ();
              ctx.nested_parser (this->fixedTriggerDefinition_parser_);
            }
          }
          else
          {
            if (this->fixedTriggerDefinition_parser_ != 0)
            {
              this->fixedTriggerDefinition_parser_->post_TriggerDefinition ();
              this->fixedTriggerDefinition ();
            }

            count = 0;
            state = 116UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 116UL;
          // Fall through.
        }
      }
      case 116UL:
      {
        if (n == "fixedUsageContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedUsageContext_parser_)
            {
              this->fixedUsageContext_parser_->pre ();
              ctx.nested_parser (this->fixedUsageContext_parser_);
            }
          }
          else
          {
            if (this->fixedUsageContext_parser_ != 0)
            {
              this->fixedUsageContext_parser_->post_UsageContext ();
              this->fixedUsageContext ();
            }

            count = 0;
            state = 117UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 117UL;
          // Fall through.
        }
      }
      case 117UL:
      {
        if (n == "fixedDosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedDosage_parser_)
            {
              this->fixedDosage_parser_->pre ();
              ctx.nested_parser (this->fixedDosage_parser_);
            }
          }
          else
          {
            if (this->fixedDosage_parser_ != 0)
            {
              this->fixedDosage_parser_->post_Dosage ();
              this->fixedDosage ();
            }

            count = 0;
            state = 118UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 118UL;
          // Fall through.
        }
      }
      case 118UL:
      {
        if (n == "fixedMeta" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fixedMeta_parser_)
            {
              this->fixedMeta_parser_->pre ();
              ctx.nested_parser (this->fixedMeta_parser_);
            }
          }
          else
          {
            if (this->fixedMeta_parser_ != 0)
            {
              this->fixedMeta_parser_->post_Meta ();
              this->fixedMeta ();
            }

            count = 0;
            state = 119UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 119UL;
          // Fall through.
        }
      }
      case 119UL:
      {
        if (n == "patternBase64Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternBase64Binary_parser_)
            {
              this->patternBase64Binary_parser_->pre ();
              ctx.nested_parser (this->patternBase64Binary_parser_);
            }
          }
          else
          {
            if (this->patternBase64Binary_parser_ != 0)
            {
              this->patternBase64Binary_parser_->post_base64Binary ();
              this->patternBase64Binary ();
            }

            count = 0;
            state = 120UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 120UL;
          // Fall through.
        }
      }
      case 120UL:
      {
        if (n == "patternBoolean" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternBoolean_parser_)
            {
              this->patternBoolean_parser_->pre ();
              ctx.nested_parser (this->patternBoolean_parser_);
            }
          }
          else
          {
            if (this->patternBoolean_parser_ != 0)
            {
              this->patternBoolean_parser_->post_boolean ();
              this->patternBoolean ();
            }

            count = 0;
            state = 121UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 121UL;
          // Fall through.
        }
      }
      case 121UL:
      {
        if (n == "patternCanonical" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternCanonical_parser_)
            {
              this->patternCanonical_parser_->pre ();
              ctx.nested_parser (this->patternCanonical_parser_);
            }
          }
          else
          {
            if (this->patternCanonical_parser_ != 0)
            {
              this->patternCanonical_parser_->post_canonical ();
              this->patternCanonical ();
            }

            count = 0;
            state = 122UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 122UL;
          // Fall through.
        }
      }
      case 122UL:
      {
        if (n == "patternCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternCode_parser_)
            {
              this->patternCode_parser_->pre ();
              ctx.nested_parser (this->patternCode_parser_);
            }
          }
          else
          {
            if (this->patternCode_parser_ != 0)
            {
              this->patternCode_parser_->post_code ();
              this->patternCode ();
            }

            count = 0;
            state = 123UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 123UL;
          // Fall through.
        }
      }
      case 123UL:
      {
        if (n == "patternDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDate_parser_)
            {
              this->patternDate_parser_->pre ();
              ctx.nested_parser (this->patternDate_parser_);
            }
          }
          else
          {
            if (this->patternDate_parser_ != 0)
            {
              this->patternDate_parser_->post_date ();
              this->patternDate ();
            }

            count = 0;
            state = 124UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 124UL;
          // Fall through.
        }
      }
      case 124UL:
      {
        if (n == "patternDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDateTime_parser_)
            {
              this->patternDateTime_parser_->pre ();
              ctx.nested_parser (this->patternDateTime_parser_);
            }
          }
          else
          {
            if (this->patternDateTime_parser_ != 0)
            {
              this->patternDateTime_parser_->post_dateTime ();
              this->patternDateTime ();
            }

            count = 0;
            state = 125UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 125UL;
          // Fall through.
        }
      }
      case 125UL:
      {
        if (n == "patternDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDecimal_parser_)
            {
              this->patternDecimal_parser_->pre ();
              ctx.nested_parser (this->patternDecimal_parser_);
            }
          }
          else
          {
            if (this->patternDecimal_parser_ != 0)
            {
              this->patternDecimal_parser_->post_decimal ();
              this->patternDecimal ();
            }

            count = 0;
            state = 126UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 126UL;
          // Fall through.
        }
      }
      case 126UL:
      {
        if (n == "patternId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternId_parser_)
            {
              this->patternId_parser_->pre ();
              ctx.nested_parser (this->patternId_parser_);
            }
          }
          else
          {
            if (this->patternId_parser_ != 0)
            {
              this->patternId_parser_->post_id ();
              this->patternId ();
            }

            count = 0;
            state = 127UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 127UL;
          // Fall through.
        }
      }
      case 127UL:
      {
        if (n == "patternInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternInstant_parser_)
            {
              this->patternInstant_parser_->pre ();
              ctx.nested_parser (this->patternInstant_parser_);
            }
          }
          else
          {
            if (this->patternInstant_parser_ != 0)
            {
              this->patternInstant_parser_->post_instant ();
              this->patternInstant ();
            }

            count = 0;
            state = 128UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 128UL;
          // Fall through.
        }
      }
      case 128UL:
      {
        if (n == "patternInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternInteger_parser_)
            {
              this->patternInteger_parser_->pre ();
              ctx.nested_parser (this->patternInteger_parser_);
            }
          }
          else
          {
            if (this->patternInteger_parser_ != 0)
            {
              this->patternInteger_parser_->post_integer ();
              this->patternInteger ();
            }

            count = 0;
            state = 129UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 129UL;
          // Fall through.
        }
      }
      case 129UL:
      {
        if (n == "patternMarkdown" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternMarkdown_parser_)
            {
              this->patternMarkdown_parser_->pre ();
              ctx.nested_parser (this->patternMarkdown_parser_);
            }
          }
          else
          {
            if (this->patternMarkdown_parser_ != 0)
            {
              this->patternMarkdown_parser_->post_markdown ();
              this->patternMarkdown ();
            }

            count = 0;
            state = 130UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 130UL;
          // Fall through.
        }
      }
      case 130UL:
      {
        if (n == "patternOid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternOid_parser_)
            {
              this->patternOid_parser_->pre ();
              ctx.nested_parser (this->patternOid_parser_);
            }
          }
          else
          {
            if (this->patternOid_parser_ != 0)
            {
              this->patternOid_parser_->post_oid ();
              this->patternOid ();
            }

            count = 0;
            state = 131UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 131UL;
          // Fall through.
        }
      }
      case 131UL:
      {
        if (n == "patternPositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternPositiveInt_parser_)
            {
              this->patternPositiveInt_parser_->pre ();
              ctx.nested_parser (this->patternPositiveInt_parser_);
            }
          }
          else
          {
            if (this->patternPositiveInt_parser_ != 0)
            {
              this->patternPositiveInt_parser_->post_positiveInt ();
              this->patternPositiveInt ();
            }

            count = 0;
            state = 132UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 132UL;
          // Fall through.
        }
      }
      case 132UL:
      {
        if (n == "patternString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternString_parser_)
            {
              this->patternString_parser_->pre ();
              ctx.nested_parser (this->patternString_parser_);
            }
          }
          else
          {
            if (this->patternString_parser_ != 0)
            {
              this->patternString_parser_->post_string ();
              this->patternString ();
            }

            count = 0;
            state = 133UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 133UL;
          // Fall through.
        }
      }
      case 133UL:
      {
        if (n == "patternTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternTime_parser_)
            {
              this->patternTime_parser_->pre ();
              ctx.nested_parser (this->patternTime_parser_);
            }
          }
          else
          {
            if (this->patternTime_parser_ != 0)
            {
              this->patternTime_parser_->post_time ();
              this->patternTime ();
            }

            count = 0;
            state = 134UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 134UL;
          // Fall through.
        }
      }
      case 134UL:
      {
        if (n == "patternUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternUnsignedInt_parser_)
            {
              this->patternUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->patternUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->patternUnsignedInt_parser_ != 0)
            {
              this->patternUnsignedInt_parser_->post_unsignedInt ();
              this->patternUnsignedInt ();
            }

            count = 0;
            state = 135UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 135UL;
          // Fall through.
        }
      }
      case 135UL:
      {
        if (n == "patternUri" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternUri_parser_)
            {
              this->patternUri_parser_->pre ();
              ctx.nested_parser (this->patternUri_parser_);
            }
          }
          else
          {
            if (this->patternUri_parser_ != 0)
            {
              this->patternUri_parser_->post_uri ();
              this->patternUri ();
            }

            count = 0;
            state = 136UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 136UL;
          // Fall through.
        }
      }
      case 136UL:
      {
        if (n == "patternUrl" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternUrl_parser_)
            {
              this->patternUrl_parser_->pre ();
              ctx.nested_parser (this->patternUrl_parser_);
            }
          }
          else
          {
            if (this->patternUrl_parser_ != 0)
            {
              this->patternUrl_parser_->post_url ();
              this->patternUrl ();
            }

            count = 0;
            state = 137UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 137UL;
          // Fall through.
        }
      }
      case 137UL:
      {
        if (n == "patternUuid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternUuid_parser_)
            {
              this->patternUuid_parser_->pre ();
              ctx.nested_parser (this->patternUuid_parser_);
            }
          }
          else
          {
            if (this->patternUuid_parser_ != 0)
            {
              this->patternUuid_parser_->post_uuid ();
              this->patternUuid ();
            }

            count = 0;
            state = 138UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 138UL;
          // Fall through.
        }
      }
      case 138UL:
      {
        if (n == "patternAddress" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternAddress_parser_)
            {
              this->patternAddress_parser_->pre ();
              ctx.nested_parser (this->patternAddress_parser_);
            }
          }
          else
          {
            if (this->patternAddress_parser_ != 0)
            {
              this->patternAddress_parser_->post_Address ();
              this->patternAddress ();
            }

            count = 0;
            state = 139UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 139UL;
          // Fall through.
        }
      }
      case 139UL:
      {
        if (n == "patternAge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternAge_parser_)
            {
              this->patternAge_parser_->pre ();
              ctx.nested_parser (this->patternAge_parser_);
            }
          }
          else
          {
            if (this->patternAge_parser_ != 0)
            {
              this->patternAge_parser_->post_Age ();
              this->patternAge ();
            }

            count = 0;
            state = 140UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 140UL;
          // Fall through.
        }
      }
      case 140UL:
      {
        if (n == "patternAnnotation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternAnnotation_parser_)
            {
              this->patternAnnotation_parser_->pre ();
              ctx.nested_parser (this->patternAnnotation_parser_);
            }
          }
          else
          {
            if (this->patternAnnotation_parser_ != 0)
            {
              this->patternAnnotation_parser_->post_Annotation ();
              this->patternAnnotation ();
            }

            count = 0;
            state = 141UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 141UL;
          // Fall through.
        }
      }
      case 141UL:
      {
        if (n == "patternAttachment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternAttachment_parser_)
            {
              this->patternAttachment_parser_->pre ();
              ctx.nested_parser (this->patternAttachment_parser_);
            }
          }
          else
          {
            if (this->patternAttachment_parser_ != 0)
            {
              this->patternAttachment_parser_->post_Attachment ();
              this->patternAttachment ();
            }

            count = 0;
            state = 142UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 142UL;
          // Fall through.
        }
      }
      case 142UL:
      {
        if (n == "patternCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternCodeableConcept_parser_)
            {
              this->patternCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->patternCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->patternCodeableConcept_parser_ != 0)
            {
              this->patternCodeableConcept_parser_->post_CodeableConcept ();
              this->patternCodeableConcept ();
            }

            count = 0;
            state = 143UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 143UL;
          // Fall through.
        }
      }
      case 143UL:
      {
        if (n == "patternCoding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternCoding_parser_)
            {
              this->patternCoding_parser_->pre ();
              ctx.nested_parser (this->patternCoding_parser_);
            }
          }
          else
          {
            if (this->patternCoding_parser_ != 0)
            {
              this->patternCoding_parser_->post_Coding ();
              this->patternCoding ();
            }

            count = 0;
            state = 144UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 144UL;
          // Fall through.
        }
      }
      case 144UL:
      {
        if (n == "patternContactPoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternContactPoint_parser_)
            {
              this->patternContactPoint_parser_->pre ();
              ctx.nested_parser (this->patternContactPoint_parser_);
            }
          }
          else
          {
            if (this->patternContactPoint_parser_ != 0)
            {
              this->patternContactPoint_parser_->post_ContactPoint ();
              this->patternContactPoint ();
            }

            count = 0;
            state = 145UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 145UL;
          // Fall through.
        }
      }
      case 145UL:
      {
        if (n == "patternCount" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternCount_parser_)
            {
              this->patternCount_parser_->pre ();
              ctx.nested_parser (this->patternCount_parser_);
            }
          }
          else
          {
            if (this->patternCount_parser_ != 0)
            {
              this->patternCount_parser_->post_Count ();
              this->patternCount ();
            }

            count = 0;
            state = 146UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 146UL;
          // Fall through.
        }
      }
      case 146UL:
      {
        if (n == "patternDistance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDistance_parser_)
            {
              this->patternDistance_parser_->pre ();
              ctx.nested_parser (this->patternDistance_parser_);
            }
          }
          else
          {
            if (this->patternDistance_parser_ != 0)
            {
              this->patternDistance_parser_->post_Distance ();
              this->patternDistance ();
            }

            count = 0;
            state = 147UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 147UL;
          // Fall through.
        }
      }
      case 147UL:
      {
        if (n == "patternDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDuration_parser_)
            {
              this->patternDuration_parser_->pre ();
              ctx.nested_parser (this->patternDuration_parser_);
            }
          }
          else
          {
            if (this->patternDuration_parser_ != 0)
            {
              this->patternDuration_parser_->post_Duration ();
              this->patternDuration ();
            }

            count = 0;
            state = 148UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 148UL;
          // Fall through.
        }
      }
      case 148UL:
      {
        if (n == "patternHumanName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternHumanName_parser_)
            {
              this->patternHumanName_parser_->pre ();
              ctx.nested_parser (this->patternHumanName_parser_);
            }
          }
          else
          {
            if (this->patternHumanName_parser_ != 0)
            {
              this->patternHumanName_parser_->post_HumanName ();
              this->patternHumanName ();
            }

            count = 0;
            state = 149UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 149UL;
          // Fall through.
        }
      }
      case 149UL:
      {
        if (n == "patternIdentifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternIdentifier_parser_)
            {
              this->patternIdentifier_parser_->pre ();
              ctx.nested_parser (this->patternIdentifier_parser_);
            }
          }
          else
          {
            if (this->patternIdentifier_parser_ != 0)
            {
              this->patternIdentifier_parser_->post_Identifier ();
              this->patternIdentifier ();
            }

            count = 0;
            state = 150UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 150UL;
          // Fall through.
        }
      }
      case 150UL:
      {
        if (n == "patternMoney" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternMoney_parser_)
            {
              this->patternMoney_parser_->pre ();
              ctx.nested_parser (this->patternMoney_parser_);
            }
          }
          else
          {
            if (this->patternMoney_parser_ != 0)
            {
              this->patternMoney_parser_->post_Money ();
              this->patternMoney ();
            }

            count = 0;
            state = 151UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 151UL;
          // Fall through.
        }
      }
      case 151UL:
      {
        if (n == "patternPeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternPeriod_parser_)
            {
              this->patternPeriod_parser_->pre ();
              ctx.nested_parser (this->patternPeriod_parser_);
            }
          }
          else
          {
            if (this->patternPeriod_parser_ != 0)
            {
              this->patternPeriod_parser_->post_Period ();
              this->patternPeriod ();
            }

            count = 0;
            state = 152UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 152UL;
          // Fall through.
        }
      }
      case 152UL:
      {
        if (n == "patternQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternQuantity_parser_)
            {
              this->patternQuantity_parser_->pre ();
              ctx.nested_parser (this->patternQuantity_parser_);
            }
          }
          else
          {
            if (this->patternQuantity_parser_ != 0)
            {
              this->patternQuantity_parser_->post_Quantity ();
              this->patternQuantity ();
            }

            count = 0;
            state = 153UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 153UL;
          // Fall through.
        }
      }
      case 153UL:
      {
        if (n == "patternRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternRange_parser_)
            {
              this->patternRange_parser_->pre ();
              ctx.nested_parser (this->patternRange_parser_);
            }
          }
          else
          {
            if (this->patternRange_parser_ != 0)
            {
              this->patternRange_parser_->post_Range ();
              this->patternRange ();
            }

            count = 0;
            state = 154UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 154UL;
          // Fall through.
        }
      }
      case 154UL:
      {
        if (n == "patternRatio" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternRatio_parser_)
            {
              this->patternRatio_parser_->pre ();
              ctx.nested_parser (this->patternRatio_parser_);
            }
          }
          else
          {
            if (this->patternRatio_parser_ != 0)
            {
              this->patternRatio_parser_->post_Ratio ();
              this->patternRatio ();
            }

            count = 0;
            state = 155UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 155UL;
          // Fall through.
        }
      }
      case 155UL:
      {
        if (n == "patternReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternReference_parser_)
            {
              this->patternReference_parser_->pre ();
              ctx.nested_parser (this->patternReference_parser_);
            }
          }
          else
          {
            if (this->patternReference_parser_ != 0)
            {
              this->patternReference_parser_->post_Reference ();
              this->patternReference ();
            }

            count = 0;
            state = 156UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 156UL;
          // Fall through.
        }
      }
      case 156UL:
      {
        if (n == "patternSampledData" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternSampledData_parser_)
            {
              this->patternSampledData_parser_->pre ();
              ctx.nested_parser (this->patternSampledData_parser_);
            }
          }
          else
          {
            if (this->patternSampledData_parser_ != 0)
            {
              this->patternSampledData_parser_->post_SampledData ();
              this->patternSampledData ();
            }

            count = 0;
            state = 157UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 157UL;
          // Fall through.
        }
      }
      case 157UL:
      {
        if (n == "patternSignature" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternSignature_parser_)
            {
              this->patternSignature_parser_->pre ();
              ctx.nested_parser (this->patternSignature_parser_);
            }
          }
          else
          {
            if (this->patternSignature_parser_ != 0)
            {
              this->patternSignature_parser_->post_Signature ();
              this->patternSignature ();
            }

            count = 0;
            state = 158UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 158UL;
          // Fall through.
        }
      }
      case 158UL:
      {
        if (n == "patternTiming" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternTiming_parser_)
            {
              this->patternTiming_parser_->pre ();
              ctx.nested_parser (this->patternTiming_parser_);
            }
          }
          else
          {
            if (this->patternTiming_parser_ != 0)
            {
              this->patternTiming_parser_->post_Timing ();
              this->patternTiming ();
            }

            count = 0;
            state = 159UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 159UL;
          // Fall through.
        }
      }
      case 159UL:
      {
        if (n == "patternContactDetail" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternContactDetail_parser_)
            {
              this->patternContactDetail_parser_->pre ();
              ctx.nested_parser (this->patternContactDetail_parser_);
            }
          }
          else
          {
            if (this->patternContactDetail_parser_ != 0)
            {
              this->patternContactDetail_parser_->post_ContactDetail ();
              this->patternContactDetail ();
            }

            count = 0;
            state = 160UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 160UL;
          // Fall through.
        }
      }
      case 160UL:
      {
        if (n == "patternContributor" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternContributor_parser_)
            {
              this->patternContributor_parser_->pre ();
              ctx.nested_parser (this->patternContributor_parser_);
            }
          }
          else
          {
            if (this->patternContributor_parser_ != 0)
            {
              this->patternContributor_parser_->post_Contributor ();
              this->patternContributor ();
            }

            count = 0;
            state = 161UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 161UL;
          // Fall through.
        }
      }
      case 161UL:
      {
        if (n == "patternDataRequirement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDataRequirement_parser_)
            {
              this->patternDataRequirement_parser_->pre ();
              ctx.nested_parser (this->patternDataRequirement_parser_);
            }
          }
          else
          {
            if (this->patternDataRequirement_parser_ != 0)
            {
              this->patternDataRequirement_parser_->post_DataRequirement ();
              this->patternDataRequirement ();
            }

            count = 0;
            state = 162UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 162UL;
          // Fall through.
        }
      }
      case 162UL:
      {
        if (n == "patternExpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternExpression_parser_)
            {
              this->patternExpression_parser_->pre ();
              ctx.nested_parser (this->patternExpression_parser_);
            }
          }
          else
          {
            if (this->patternExpression_parser_ != 0)
            {
              this->patternExpression_parser_->post_Expression ();
              this->patternExpression ();
            }

            count = 0;
            state = 163UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 163UL;
          // Fall through.
        }
      }
      case 163UL:
      {
        if (n == "patternParameterDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternParameterDefinition_parser_)
            {
              this->patternParameterDefinition_parser_->pre ();
              ctx.nested_parser (this->patternParameterDefinition_parser_);
            }
          }
          else
          {
            if (this->patternParameterDefinition_parser_ != 0)
            {
              this->patternParameterDefinition_parser_->post_ParameterDefinition ();
              this->patternParameterDefinition ();
            }

            count = 0;
            state = 164UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 164UL;
          // Fall through.
        }
      }
      case 164UL:
      {
        if (n == "patternRelatedArtifact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternRelatedArtifact_parser_)
            {
              this->patternRelatedArtifact_parser_->pre ();
              ctx.nested_parser (this->patternRelatedArtifact_parser_);
            }
          }
          else
          {
            if (this->patternRelatedArtifact_parser_ != 0)
            {
              this->patternRelatedArtifact_parser_->post_RelatedArtifact ();
              this->patternRelatedArtifact ();
            }

            count = 0;
            state = 165UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 165UL;
          // Fall through.
        }
      }
      case 165UL:
      {
        if (n == "patternTriggerDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternTriggerDefinition_parser_)
            {
              this->patternTriggerDefinition_parser_->pre ();
              ctx.nested_parser (this->patternTriggerDefinition_parser_);
            }
          }
          else
          {
            if (this->patternTriggerDefinition_parser_ != 0)
            {
              this->patternTriggerDefinition_parser_->post_TriggerDefinition ();
              this->patternTriggerDefinition ();
            }

            count = 0;
            state = 166UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 166UL;
          // Fall through.
        }
      }
      case 166UL:
      {
        if (n == "patternUsageContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternUsageContext_parser_)
            {
              this->patternUsageContext_parser_->pre ();
              ctx.nested_parser (this->patternUsageContext_parser_);
            }
          }
          else
          {
            if (this->patternUsageContext_parser_ != 0)
            {
              this->patternUsageContext_parser_->post_UsageContext ();
              this->patternUsageContext ();
            }

            count = 0;
            state = 167UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 167UL;
          // Fall through.
        }
      }
      case 167UL:
      {
        if (n == "patternDosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternDosage_parser_)
            {
              this->patternDosage_parser_->pre ();
              ctx.nested_parser (this->patternDosage_parser_);
            }
          }
          else
          {
            if (this->patternDosage_parser_ != 0)
            {
              this->patternDosage_parser_->post_Dosage ();
              this->patternDosage ();
            }

            count = 0;
            state = 168UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 168UL;
          // Fall through.
        }
      }
      case 168UL:
      {
        if (n == "patternMeta" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patternMeta_parser_)
            {
              this->patternMeta_parser_->pre ();
              ctx.nested_parser (this->patternMeta_parser_);
            }
          }
          else
          {
            if (this->patternMeta_parser_ != 0)
            {
              this->patternMeta_parser_->post_Meta ();
              this->patternMeta ();
            }

            count = 0;
            state = 169UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 169UL;
          // Fall through.
        }
      }
      case 169UL:
      {
        if (n == "example" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->example_parser_)
            {
              this->example_parser_->pre ();
              ctx.nested_parser (this->example_parser_);
            }
          }
          else
          {
            if (this->example_parser_ != 0)
            {
              this->example_parser_->post_ElementDefinition_Example ();
              this->example ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 170UL;
          // Fall through.
        }
      }
      case 170UL:
      {
        if (n == "minValueDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueDate_parser_)
            {
              this->minValueDate_parser_->pre ();
              ctx.nested_parser (this->minValueDate_parser_);
            }
          }
          else
          {
            if (this->minValueDate_parser_ != 0)
            {
              this->minValueDate_parser_->post_date ();
              this->minValueDate ();
            }

            count = 0;
            state = 171UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 171UL;
          // Fall through.
        }
      }
      case 171UL:
      {
        if (n == "minValueDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueDateTime_parser_)
            {
              this->minValueDateTime_parser_->pre ();
              ctx.nested_parser (this->minValueDateTime_parser_);
            }
          }
          else
          {
            if (this->minValueDateTime_parser_ != 0)
            {
              this->minValueDateTime_parser_->post_dateTime ();
              this->minValueDateTime ();
            }

            count = 0;
            state = 172UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 172UL;
          // Fall through.
        }
      }
      case 172UL:
      {
        if (n == "minValueInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueInstant_parser_)
            {
              this->minValueInstant_parser_->pre ();
              ctx.nested_parser (this->minValueInstant_parser_);
            }
          }
          else
          {
            if (this->minValueInstant_parser_ != 0)
            {
              this->minValueInstant_parser_->post_instant ();
              this->minValueInstant ();
            }

            count = 0;
            state = 173UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 173UL;
          // Fall through.
        }
      }
      case 173UL:
      {
        if (n == "minValueTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueTime_parser_)
            {
              this->minValueTime_parser_->pre ();
              ctx.nested_parser (this->minValueTime_parser_);
            }
          }
          else
          {
            if (this->minValueTime_parser_ != 0)
            {
              this->minValueTime_parser_->post_time ();
              this->minValueTime ();
            }

            count = 0;
            state = 174UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 174UL;
          // Fall through.
        }
      }
      case 174UL:
      {
        if (n == "minValueDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueDecimal_parser_)
            {
              this->minValueDecimal_parser_->pre ();
              ctx.nested_parser (this->minValueDecimal_parser_);
            }
          }
          else
          {
            if (this->minValueDecimal_parser_ != 0)
            {
              this->minValueDecimal_parser_->post_decimal ();
              this->minValueDecimal ();
            }

            count = 0;
            state = 175UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 175UL;
          // Fall through.
        }
      }
      case 175UL:
      {
        if (n == "minValueInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueInteger_parser_)
            {
              this->minValueInteger_parser_->pre ();
              ctx.nested_parser (this->minValueInteger_parser_);
            }
          }
          else
          {
            if (this->minValueInteger_parser_ != 0)
            {
              this->minValueInteger_parser_->post_integer ();
              this->minValueInteger ();
            }

            count = 0;
            state = 176UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 176UL;
          // Fall through.
        }
      }
      case 176UL:
      {
        if (n == "minValuePositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValuePositiveInt_parser_)
            {
              this->minValuePositiveInt_parser_->pre ();
              ctx.nested_parser (this->minValuePositiveInt_parser_);
            }
          }
          else
          {
            if (this->minValuePositiveInt_parser_ != 0)
            {
              this->minValuePositiveInt_parser_->post_positiveInt ();
              this->minValuePositiveInt ();
            }

            count = 0;
            state = 177UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 177UL;
          // Fall through.
        }
      }
      case 177UL:
      {
        if (n == "minValueUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueUnsignedInt_parser_)
            {
              this->minValueUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->minValueUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->minValueUnsignedInt_parser_ != 0)
            {
              this->minValueUnsignedInt_parser_->post_unsignedInt ();
              this->minValueUnsignedInt ();
            }

            count = 0;
            state = 178UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 178UL;
          // Fall through.
        }
      }
      case 178UL:
      {
        if (n == "minValueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->minValueQuantity_parser_)
            {
              this->minValueQuantity_parser_->pre ();
              ctx.nested_parser (this->minValueQuantity_parser_);
            }
          }
          else
          {
            if (this->minValueQuantity_parser_ != 0)
            {
              this->minValueQuantity_parser_->post_Quantity ();
              this->minValueQuantity ();
            }

            count = 0;
            state = 179UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 179UL;
          // Fall through.
        }
      }
      case 179UL:
      {
        if (n == "maxValueDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueDate_parser_)
            {
              this->maxValueDate_parser_->pre ();
              ctx.nested_parser (this->maxValueDate_parser_);
            }
          }
          else
          {
            if (this->maxValueDate_parser_ != 0)
            {
              this->maxValueDate_parser_->post_date ();
              this->maxValueDate ();
            }

            count = 0;
            state = 180UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 180UL;
          // Fall through.
        }
      }
      case 180UL:
      {
        if (n == "maxValueDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueDateTime_parser_)
            {
              this->maxValueDateTime_parser_->pre ();
              ctx.nested_parser (this->maxValueDateTime_parser_);
            }
          }
          else
          {
            if (this->maxValueDateTime_parser_ != 0)
            {
              this->maxValueDateTime_parser_->post_dateTime ();
              this->maxValueDateTime ();
            }

            count = 0;
            state = 181UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 181UL;
          // Fall through.
        }
      }
      case 181UL:
      {
        if (n == "maxValueInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueInstant_parser_)
            {
              this->maxValueInstant_parser_->pre ();
              ctx.nested_parser (this->maxValueInstant_parser_);
            }
          }
          else
          {
            if (this->maxValueInstant_parser_ != 0)
            {
              this->maxValueInstant_parser_->post_instant ();
              this->maxValueInstant ();
            }

            count = 0;
            state = 182UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 182UL;
          // Fall through.
        }
      }
      case 182UL:
      {
        if (n == "maxValueTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueTime_parser_)
            {
              this->maxValueTime_parser_->pre ();
              ctx.nested_parser (this->maxValueTime_parser_);
            }
          }
          else
          {
            if (this->maxValueTime_parser_ != 0)
            {
              this->maxValueTime_parser_->post_time ();
              this->maxValueTime ();
            }

            count = 0;
            state = 183UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 183UL;
          // Fall through.
        }
      }
      case 183UL:
      {
        if (n == "maxValueDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueDecimal_parser_)
            {
              this->maxValueDecimal_parser_->pre ();
              ctx.nested_parser (this->maxValueDecimal_parser_);
            }
          }
          else
          {
            if (this->maxValueDecimal_parser_ != 0)
            {
              this->maxValueDecimal_parser_->post_decimal ();
              this->maxValueDecimal ();
            }

            count = 0;
            state = 184UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 184UL;
          // Fall through.
        }
      }
      case 184UL:
      {
        if (n == "maxValueInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueInteger_parser_)
            {
              this->maxValueInteger_parser_->pre ();
              ctx.nested_parser (this->maxValueInteger_parser_);
            }
          }
          else
          {
            if (this->maxValueInteger_parser_ != 0)
            {
              this->maxValueInteger_parser_->post_integer ();
              this->maxValueInteger ();
            }

            count = 0;
            state = 185UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 185UL;
          // Fall through.
        }
      }
      case 185UL:
      {
        if (n == "maxValuePositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValuePositiveInt_parser_)
            {
              this->maxValuePositiveInt_parser_->pre ();
              ctx.nested_parser (this->maxValuePositiveInt_parser_);
            }
          }
          else
          {
            if (this->maxValuePositiveInt_parser_ != 0)
            {
              this->maxValuePositiveInt_parser_->post_positiveInt ();
              this->maxValuePositiveInt ();
            }

            count = 0;
            state = 186UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 186UL;
          // Fall through.
        }
      }
      case 186UL:
      {
        if (n == "maxValueUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueUnsignedInt_parser_)
            {
              this->maxValueUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->maxValueUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->maxValueUnsignedInt_parser_ != 0)
            {
              this->maxValueUnsignedInt_parser_->post_unsignedInt ();
              this->maxValueUnsignedInt ();
            }

            count = 0;
            state = 187UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 187UL;
          // Fall through.
        }
      }
      case 187UL:
      {
        if (n == "maxValueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxValueQuantity_parser_)
            {
              this->maxValueQuantity_parser_->pre ();
              ctx.nested_parser (this->maxValueQuantity_parser_);
            }
          }
          else
          {
            if (this->maxValueQuantity_parser_ != 0)
            {
              this->maxValueQuantity_parser_->post_Quantity ();
              this->maxValueQuantity ();
            }

            count = 0;
            state = 188UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 188UL;
          // Fall through.
        }
      }
      case 188UL:
      {
        if (n == "maxLength" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxLength_parser_)
            {
              this->maxLength_parser_->pre ();
              ctx.nested_parser (this->maxLength_parser_);
            }
          }
          else
          {
            if (this->maxLength_parser_ != 0)
            {
              this->maxLength_parser_->post_integer ();
              this->maxLength ();
            }

            count = 0;
            state = 189UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 189UL;
          // Fall through.
        }
      }
      case 189UL:
      {
        if (n == "condition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->condition_parser_)
            {
              this->condition_parser_->pre ();
              ctx.nested_parser (this->condition_parser_);
            }
          }
          else
          {
            if (this->condition_parser_ != 0)
            {
              this->condition_parser_->post_id ();
              this->condition ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 190UL;
          // Fall through.
        }
      }
      case 190UL:
      {
        if (n == "constraint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->constraint_parser_)
            {
              this->constraint_parser_->pre ();
              ctx.nested_parser (this->constraint_parser_);
            }
          }
          else
          {
            if (this->constraint_parser_ != 0)
            {
              this->constraint_parser_->post_ElementDefinition_Constraint ();
              this->constraint ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 191UL;
          // Fall through.
        }
      }
      case 191UL:
      {
        if (n == "mustSupport" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->mustSupport_parser_)
            {
              this->mustSupport_parser_->pre ();
              ctx.nested_parser (this->mustSupport_parser_);
            }
          }
          else
          {
            if (this->mustSupport_parser_ != 0)
            {
              this->mustSupport_parser_->post_boolean ();
              this->mustSupport ();
            }

            count = 0;
            state = 192UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 192UL;
          // Fall through.
        }
      }
      case 192UL:
      {
        if (n == "isModifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->isModifier_parser_)
            {
              this->isModifier_parser_->pre ();
              ctx.nested_parser (this->isModifier_parser_);
            }
          }
          else
          {
            if (this->isModifier_parser_ != 0)
            {
              this->isModifier_parser_->post_boolean ();
              this->isModifier ();
            }

            count = 0;
            state = 193UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 193UL;
          // Fall through.
        }
      }
      case 193UL:
      {
        if (n == "isModifierReason" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->isModifierReason_parser_)
            {
              this->isModifierReason_parser_->pre ();
              ctx.nested_parser (this->isModifierReason_parser_);
            }
          }
          else
          {
            if (this->isModifierReason_parser_ != 0)
            {
              this->isModifierReason_parser_->post_string ();
              this->isModifierReason ();
            }

            count = 0;
            state = 194UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 194UL;
          // Fall through.
        }
      }
      case 194UL:
      {
        if (n == "isSummary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->isSummary_parser_)
            {
              this->isSummary_parser_->pre ();
              ctx.nested_parser (this->isSummary_parser_);
            }
          }
          else
          {
            if (this->isSummary_parser_ != 0)
            {
              this->isSummary_parser_->post_boolean ();
              this->isSummary ();
            }

            count = 0;
            state = 195UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 195UL;
          // Fall through.
        }
      }
      case 195UL:
      {
        if (n == "binding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->binding_parser_)
            {
              this->binding_parser_->pre ();
              ctx.nested_parser (this->binding_parser_);
            }
          }
          else
          {
            if (this->binding_parser_ != 0)
            {
              this->binding_parser_->post_ElementDefinition_Binding ();
              this->binding ();
            }

            count = 0;
            state = 196UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 196UL;
          // Fall through.
        }
      }
      case 196UL:
      {
        if (n == "mapping" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->mapping_parser_)
            {
              this->mapping_parser_->pre ();
              ctx.nested_parser (this->mapping_parser_);
            }
          }
          else
          {
            if (this->mapping_parser_ != 0)
            {
              this->mapping_parser_->post_ElementDefinition_Mapping ();
              this->mapping ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Constraint_pskel.
  //
  bool ElementDefinition_Constraint_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "key" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Constraint_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Constraint_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Constraint_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Constraint_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Constraint_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "key" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->key_parser_)
            {
              this->key_parser_->pre ();
              ctx.nested_parser (this->key_parser_);
            }
          }
          else
          {
            if (this->key_parser_ != 0)
            {
              this->key_parser_->post_id ();
              this->key ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "requirements" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->requirements_parser_)
            {
              this->requirements_parser_->pre ();
              ctx.nested_parser (this->requirements_parser_);
            }
          }
          else
          {
            if (this->requirements_parser_ != 0)
            {
              this->requirements_parser_->post_string ();
              this->requirements ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "severity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->severity_parser_)
            {
              this->severity_parser_->pre ();
              ctx.nested_parser (this->severity_parser_);
            }
          }
          else
          {
            if (this->severity_parser_ != 0)
            {
              this->severity_parser_->post_ConstraintSeverity ();
              this->severity ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "human" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->human_parser_)
            {
              this->human_parser_->pre ();
              ctx.nested_parser (this->human_parser_);
            }
          }
          else
          {
            if (this->human_parser_ != 0)
            {
              this->human_parser_->post_string ();
              this->human ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "expression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->expression_parser_)
            {
              this->expression_parser_->pre ();
              ctx.nested_parser (this->expression_parser_);
            }
          }
          else
          {
            if (this->expression_parser_ != 0)
            {
              this->expression_parser_->post_string ();
              this->expression ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "xpath" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->xpath_parser_)
            {
              this->xpath_parser_->pre ();
              ctx.nested_parser (this->xpath_parser_);
            }
          }
          else
          {
            if (this->xpath_parser_ != 0)
            {
              this->xpath_parser_->post_string ();
              this->xpath ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "source" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->source_parser_)
            {
              this->source_parser_->pre ();
              ctx.nested_parser (this->source_parser_);
            }
          }
          else
          {
            if (this->source_parser_ != 0)
            {
              this->source_parser_->post_canonical ();
              this->source ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Mapping_pskel.
  //
  bool ElementDefinition_Mapping_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "identity" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Mapping_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Mapping_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Mapping_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Mapping_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Mapping_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "identity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identity_parser_)
            {
              this->identity_parser_->pre ();
              ctx.nested_parser (this->identity_parser_);
            }
          }
          else
          {
            if (this->identity_parser_ != 0)
            {
              this->identity_parser_->post_id ();
              this->identity ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "language" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->language_parser_)
            {
              this->language_parser_->pre ();
              ctx.nested_parser (this->language_parser_);
            }
          }
          else
          {
            if (this->language_parser_ != 0)
            {
              this->language_parser_->post_code ();
              this->language ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "map" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->map_parser_)
            {
              this->map_parser_->pre ();
              ctx.nested_parser (this->map_parser_);
            }
          }
          else
          {
            if (this->map_parser_ != 0)
            {
              this->map_parser_->post_string ();
              this->map ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "comment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->comment_parser_)
            {
              this->comment_parser_->pre ();
              ctx.nested_parser (this->comment_parser_);
            }
          }
          else
          {
            if (this->comment_parser_ != 0)
            {
              this->comment_parser_->post_string ();
              this->comment ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Base_pskel.
  //
  bool ElementDefinition_Base_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "path" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Base_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Base_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Base_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Base_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Base_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "min" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->min_parser_)
            {
              this->min_parser_->pre ();
              ctx.nested_parser (this->min_parser_);
            }
          }
          else
          {
            if (this->min_parser_ != 0)
            {
              this->min_parser_->post_unsignedInt ();
              this->min ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "max" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->max_parser_)
            {
              this->max_parser_->pre ();
              ctx.nested_parser (this->max_parser_);
            }
          }
          else
          {
            if (this->max_parser_ != 0)
            {
              this->max_parser_->post_string ();
              this->max ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Type_pskel.
  //
  bool ElementDefinition_Type_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "code" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Type_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Type_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Type_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Type_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Type_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_uri ();
              this->code ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_canonical ();
              this->profile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "targetProfile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->targetProfile_parser_)
            {
              this->targetProfile_parser_->pre ();
              ctx.nested_parser (this->targetProfile_parser_);
            }
          }
          else
          {
            if (this->targetProfile_parser_ != 0)
            {
              this->targetProfile_parser_->post_canonical ();
              this->targetProfile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "aggregation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->aggregation_parser_)
            {
              this->aggregation_parser_->pre ();
              ctx.nested_parser (this->aggregation_parser_);
            }
          }
          else
          {
            if (this->aggregation_parser_ != 0)
            {
              this->aggregation_parser_->post_AggregationMode ();
              this->aggregation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "versioning" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->versioning_parser_)
            {
              this->versioning_parser_->pre ();
              ctx.nested_parser (this->versioning_parser_);
            }
          }
          else
          {
            if (this->versioning_parser_ != 0)
            {
              this->versioning_parser_->post_ReferenceVersionRules ();
              this->versioning ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Example_pskel.
  //
  bool ElementDefinition_Example_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "label" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Example_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Example_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Example_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Example_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Example_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "label" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->label_parser_)
            {
              this->label_parser_->pre ();
              ctx.nested_parser (this->label_parser_);
            }
          }
          else
          {
            if (this->label_parser_ != 0)
            {
              this->label_parser_->post_string ();
              this->label ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "valueBase64Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueBase64Binary_parser_)
            {
              this->valueBase64Binary_parser_->pre ();
              ctx.nested_parser (this->valueBase64Binary_parser_);
            }
          }
          else
          {
            if (this->valueBase64Binary_parser_ != 0)
            {
              this->valueBase64Binary_parser_->post_base64Binary ();
              this->valueBase64Binary ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueBoolean" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueBoolean_parser_)
            {
              this->valueBoolean_parser_->pre ();
              ctx.nested_parser (this->valueBoolean_parser_);
            }
          }
          else
          {
            if (this->valueBoolean_parser_ != 0)
            {
              this->valueBoolean_parser_->post_boolean ();
              this->valueBoolean ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "valueCanonical" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCanonical_parser_)
            {
              this->valueCanonical_parser_->pre ();
              ctx.nested_parser (this->valueCanonical_parser_);
            }
          }
          else
          {
            if (this->valueCanonical_parser_ != 0)
            {
              this->valueCanonical_parser_->post_canonical ();
              this->valueCanonical ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "valueCode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCode_parser_)
            {
              this->valueCode_parser_->pre ();
              ctx.nested_parser (this->valueCode_parser_);
            }
          }
          else
          {
            if (this->valueCode_parser_ != 0)
            {
              this->valueCode_parser_->post_code ();
              this->valueCode ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "valueDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDate_parser_)
            {
              this->valueDate_parser_->pre ();
              ctx.nested_parser (this->valueDate_parser_);
            }
          }
          else
          {
            if (this->valueDate_parser_ != 0)
            {
              this->valueDate_parser_->post_date ();
              this->valueDate ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "valueDateTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDateTime_parser_)
            {
              this->valueDateTime_parser_->pre ();
              ctx.nested_parser (this->valueDateTime_parser_);
            }
          }
          else
          {
            if (this->valueDateTime_parser_ != 0)
            {
              this->valueDateTime_parser_->post_dateTime ();
              this->valueDateTime ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "valueDecimal" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDecimal_parser_)
            {
              this->valueDecimal_parser_->pre ();
              ctx.nested_parser (this->valueDecimal_parser_);
            }
          }
          else
          {
            if (this->valueDecimal_parser_ != 0)
            {
              this->valueDecimal_parser_->post_decimal ();
              this->valueDecimal ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "valueId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueId_parser_)
            {
              this->valueId_parser_->pre ();
              ctx.nested_parser (this->valueId_parser_);
            }
          }
          else
          {
            if (this->valueId_parser_ != 0)
            {
              this->valueId_parser_->post_id ();
              this->valueId ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "valueInstant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueInstant_parser_)
            {
              this->valueInstant_parser_->pre ();
              ctx.nested_parser (this->valueInstant_parser_);
            }
          }
          else
          {
            if (this->valueInstant_parser_ != 0)
            {
              this->valueInstant_parser_->post_instant ();
              this->valueInstant ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "valueInteger" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueInteger_parser_)
            {
              this->valueInteger_parser_->pre ();
              ctx.nested_parser (this->valueInteger_parser_);
            }
          }
          else
          {
            if (this->valueInteger_parser_ != 0)
            {
              this->valueInteger_parser_->post_integer ();
              this->valueInteger ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "valueMarkdown" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueMarkdown_parser_)
            {
              this->valueMarkdown_parser_->pre ();
              ctx.nested_parser (this->valueMarkdown_parser_);
            }
          }
          else
          {
            if (this->valueMarkdown_parser_ != 0)
            {
              this->valueMarkdown_parser_->post_markdown ();
              this->valueMarkdown ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "valueOid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueOid_parser_)
            {
              this->valueOid_parser_->pre ();
              ctx.nested_parser (this->valueOid_parser_);
            }
          }
          else
          {
            if (this->valueOid_parser_ != 0)
            {
              this->valueOid_parser_->post_oid ();
              this->valueOid ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "valuePositiveInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valuePositiveInt_parser_)
            {
              this->valuePositiveInt_parser_->pre ();
              ctx.nested_parser (this->valuePositiveInt_parser_);
            }
          }
          else
          {
            if (this->valuePositiveInt_parser_ != 0)
            {
              this->valuePositiveInt_parser_->post_positiveInt ();
              this->valuePositiveInt ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "valueString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueString_parser_)
            {
              this->valueString_parser_->pre ();
              ctx.nested_parser (this->valueString_parser_);
            }
          }
          else
          {
            if (this->valueString_parser_ != 0)
            {
              this->valueString_parser_->post_string ();
              this->valueString ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "valueTime" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueTime_parser_)
            {
              this->valueTime_parser_->pre ();
              ctx.nested_parser (this->valueTime_parser_);
            }
          }
          else
          {
            if (this->valueTime_parser_ != 0)
            {
              this->valueTime_parser_->post_time ();
              this->valueTime ();
            }

            count = 0;
            state = 16UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "valueUnsignedInt" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUnsignedInt_parser_)
            {
              this->valueUnsignedInt_parser_->pre ();
              ctx.nested_parser (this->valueUnsignedInt_parser_);
            }
          }
          else
          {
            if (this->valueUnsignedInt_parser_ != 0)
            {
              this->valueUnsignedInt_parser_->post_unsignedInt ();
              this->valueUnsignedInt ();
            }

            count = 0;
            state = 17UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "valueUri" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUri_parser_)
            {
              this->valueUri_parser_->pre ();
              ctx.nested_parser (this->valueUri_parser_);
            }
          }
          else
          {
            if (this->valueUri_parser_ != 0)
            {
              this->valueUri_parser_->post_uri ();
              this->valueUri ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "valueUrl" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUrl_parser_)
            {
              this->valueUrl_parser_->pre ();
              ctx.nested_parser (this->valueUrl_parser_);
            }
          }
          else
          {
            if (this->valueUrl_parser_ != 0)
            {
              this->valueUrl_parser_->post_url ();
              this->valueUrl ();
            }

            count = 0;
            state = 19UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "valueUuid" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUuid_parser_)
            {
              this->valueUuid_parser_->pre ();
              ctx.nested_parser (this->valueUuid_parser_);
            }
          }
          else
          {
            if (this->valueUuid_parser_ != 0)
            {
              this->valueUuid_parser_->post_uuid ();
              this->valueUuid ();
            }

            count = 0;
            state = 20UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "valueAddress" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAddress_parser_)
            {
              this->valueAddress_parser_->pre ();
              ctx.nested_parser (this->valueAddress_parser_);
            }
          }
          else
          {
            if (this->valueAddress_parser_ != 0)
            {
              this->valueAddress_parser_->post_Address ();
              this->valueAddress ();
            }

            count = 0;
            state = 21UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "valueAge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAge_parser_)
            {
              this->valueAge_parser_->pre ();
              ctx.nested_parser (this->valueAge_parser_);
            }
          }
          else
          {
            if (this->valueAge_parser_ != 0)
            {
              this->valueAge_parser_->post_Age ();
              this->valueAge ();
            }

            count = 0;
            state = 22UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 22UL;
          // Fall through.
        }
      }
      case 22UL:
      {
        if (n == "valueAnnotation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAnnotation_parser_)
            {
              this->valueAnnotation_parser_->pre ();
              ctx.nested_parser (this->valueAnnotation_parser_);
            }
          }
          else
          {
            if (this->valueAnnotation_parser_ != 0)
            {
              this->valueAnnotation_parser_->post_Annotation ();
              this->valueAnnotation ();
            }

            count = 0;
            state = 23UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 23UL;
          // Fall through.
        }
      }
      case 23UL:
      {
        if (n == "valueAttachment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueAttachment_parser_)
            {
              this->valueAttachment_parser_->pre ();
              ctx.nested_parser (this->valueAttachment_parser_);
            }
          }
          else
          {
            if (this->valueAttachment_parser_ != 0)
            {
              this->valueAttachment_parser_->post_Attachment ();
              this->valueAttachment ();
            }

            count = 0;
            state = 24UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 24UL;
          // Fall through.
        }
      }
      case 24UL:
      {
        if (n == "valueCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCodeableConcept_parser_)
            {
              this->valueCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->valueCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->valueCodeableConcept_parser_ != 0)
            {
              this->valueCodeableConcept_parser_->post_CodeableConcept ();
              this->valueCodeableConcept ();
            }

            count = 0;
            state = 25UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 25UL;
          // Fall through.
        }
      }
      case 25UL:
      {
        if (n == "valueCoding" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCoding_parser_)
            {
              this->valueCoding_parser_->pre ();
              ctx.nested_parser (this->valueCoding_parser_);
            }
          }
          else
          {
            if (this->valueCoding_parser_ != 0)
            {
              this->valueCoding_parser_->post_Coding ();
              this->valueCoding ();
            }

            count = 0;
            state = 26UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 26UL;
          // Fall through.
        }
      }
      case 26UL:
      {
        if (n == "valueContactPoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueContactPoint_parser_)
            {
              this->valueContactPoint_parser_->pre ();
              ctx.nested_parser (this->valueContactPoint_parser_);
            }
          }
          else
          {
            if (this->valueContactPoint_parser_ != 0)
            {
              this->valueContactPoint_parser_->post_ContactPoint ();
              this->valueContactPoint ();
            }

            count = 0;
            state = 27UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 27UL;
          // Fall through.
        }
      }
      case 27UL:
      {
        if (n == "valueCount" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCount_parser_)
            {
              this->valueCount_parser_->pre ();
              ctx.nested_parser (this->valueCount_parser_);
            }
          }
          else
          {
            if (this->valueCount_parser_ != 0)
            {
              this->valueCount_parser_->post_Count ();
              this->valueCount ();
            }

            count = 0;
            state = 28UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 28UL;
          // Fall through.
        }
      }
      case 28UL:
      {
        if (n == "valueDistance" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDistance_parser_)
            {
              this->valueDistance_parser_->pre ();
              ctx.nested_parser (this->valueDistance_parser_);
            }
          }
          else
          {
            if (this->valueDistance_parser_ != 0)
            {
              this->valueDistance_parser_->post_Distance ();
              this->valueDistance ();
            }

            count = 0;
            state = 29UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 29UL;
          // Fall through.
        }
      }
      case 29UL:
      {
        if (n == "valueDuration" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDuration_parser_)
            {
              this->valueDuration_parser_->pre ();
              ctx.nested_parser (this->valueDuration_parser_);
            }
          }
          else
          {
            if (this->valueDuration_parser_ != 0)
            {
              this->valueDuration_parser_->post_Duration ();
              this->valueDuration ();
            }

            count = 0;
            state = 30UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 30UL;
          // Fall through.
        }
      }
      case 30UL:
      {
        if (n == "valueHumanName" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueHumanName_parser_)
            {
              this->valueHumanName_parser_->pre ();
              ctx.nested_parser (this->valueHumanName_parser_);
            }
          }
          else
          {
            if (this->valueHumanName_parser_ != 0)
            {
              this->valueHumanName_parser_->post_HumanName ();
              this->valueHumanName ();
            }

            count = 0;
            state = 31UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 31UL;
          // Fall through.
        }
      }
      case 31UL:
      {
        if (n == "valueIdentifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueIdentifier_parser_)
            {
              this->valueIdentifier_parser_->pre ();
              ctx.nested_parser (this->valueIdentifier_parser_);
            }
          }
          else
          {
            if (this->valueIdentifier_parser_ != 0)
            {
              this->valueIdentifier_parser_->post_Identifier ();
              this->valueIdentifier ();
            }

            count = 0;
            state = 32UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 32UL;
          // Fall through.
        }
      }
      case 32UL:
      {
        if (n == "valueMoney" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueMoney_parser_)
            {
              this->valueMoney_parser_->pre ();
              ctx.nested_parser (this->valueMoney_parser_);
            }
          }
          else
          {
            if (this->valueMoney_parser_ != 0)
            {
              this->valueMoney_parser_->post_Money ();
              this->valueMoney ();
            }

            count = 0;
            state = 33UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 33UL;
          // Fall through.
        }
      }
      case 33UL:
      {
        if (n == "valuePeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valuePeriod_parser_)
            {
              this->valuePeriod_parser_->pre ();
              ctx.nested_parser (this->valuePeriod_parser_);
            }
          }
          else
          {
            if (this->valuePeriod_parser_ != 0)
            {
              this->valuePeriod_parser_->post_Period ();
              this->valuePeriod ();
            }

            count = 0;
            state = 34UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 34UL;
          // Fall through.
        }
      }
      case 34UL:
      {
        if (n == "valueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueQuantity_parser_)
            {
              this->valueQuantity_parser_->pre ();
              ctx.nested_parser (this->valueQuantity_parser_);
            }
          }
          else
          {
            if (this->valueQuantity_parser_ != 0)
            {
              this->valueQuantity_parser_->post_Quantity ();
              this->valueQuantity ();
            }

            count = 0;
            state = 35UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 35UL;
          // Fall through.
        }
      }
      case 35UL:
      {
        if (n == "valueRange" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRange_parser_)
            {
              this->valueRange_parser_->pre ();
              ctx.nested_parser (this->valueRange_parser_);
            }
          }
          else
          {
            if (this->valueRange_parser_ != 0)
            {
              this->valueRange_parser_->post_Range ();
              this->valueRange ();
            }

            count = 0;
            state = 36UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 36UL;
          // Fall through.
        }
      }
      case 36UL:
      {
        if (n == "valueRatio" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRatio_parser_)
            {
              this->valueRatio_parser_->pre ();
              ctx.nested_parser (this->valueRatio_parser_);
            }
          }
          else
          {
            if (this->valueRatio_parser_ != 0)
            {
              this->valueRatio_parser_->post_Ratio ();
              this->valueRatio ();
            }

            count = 0;
            state = 37UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 37UL;
          // Fall through.
        }
      }
      case 37UL:
      {
        if (n == "valueReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueReference_parser_)
            {
              this->valueReference_parser_->pre ();
              ctx.nested_parser (this->valueReference_parser_);
            }
          }
          else
          {
            if (this->valueReference_parser_ != 0)
            {
              this->valueReference_parser_->post_Reference ();
              this->valueReference ();
            }

            count = 0;
            state = 38UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 38UL;
          // Fall through.
        }
      }
      case 38UL:
      {
        if (n == "valueSampledData" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueSampledData_parser_)
            {
              this->valueSampledData_parser_->pre ();
              ctx.nested_parser (this->valueSampledData_parser_);
            }
          }
          else
          {
            if (this->valueSampledData_parser_ != 0)
            {
              this->valueSampledData_parser_->post_SampledData ();
              this->valueSampledData ();
            }

            count = 0;
            state = 39UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 39UL;
          // Fall through.
        }
      }
      case 39UL:
      {
        if (n == "valueSignature" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueSignature_parser_)
            {
              this->valueSignature_parser_->pre ();
              ctx.nested_parser (this->valueSignature_parser_);
            }
          }
          else
          {
            if (this->valueSignature_parser_ != 0)
            {
              this->valueSignature_parser_->post_Signature ();
              this->valueSignature ();
            }

            count = 0;
            state = 40UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 40UL;
          // Fall through.
        }
      }
      case 40UL:
      {
        if (n == "valueTiming" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueTiming_parser_)
            {
              this->valueTiming_parser_->pre ();
              ctx.nested_parser (this->valueTiming_parser_);
            }
          }
          else
          {
            if (this->valueTiming_parser_ != 0)
            {
              this->valueTiming_parser_->post_Timing ();
              this->valueTiming ();
            }

            count = 0;
            state = 41UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 41UL;
          // Fall through.
        }
      }
      case 41UL:
      {
        if (n == "valueContactDetail" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueContactDetail_parser_)
            {
              this->valueContactDetail_parser_->pre ();
              ctx.nested_parser (this->valueContactDetail_parser_);
            }
          }
          else
          {
            if (this->valueContactDetail_parser_ != 0)
            {
              this->valueContactDetail_parser_->post_ContactDetail ();
              this->valueContactDetail ();
            }

            count = 0;
            state = 42UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 42UL;
          // Fall through.
        }
      }
      case 42UL:
      {
        if (n == "valueContributor" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueContributor_parser_)
            {
              this->valueContributor_parser_->pre ();
              ctx.nested_parser (this->valueContributor_parser_);
            }
          }
          else
          {
            if (this->valueContributor_parser_ != 0)
            {
              this->valueContributor_parser_->post_Contributor ();
              this->valueContributor ();
            }

            count = 0;
            state = 43UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 43UL;
          // Fall through.
        }
      }
      case 43UL:
      {
        if (n == "valueDataRequirement" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDataRequirement_parser_)
            {
              this->valueDataRequirement_parser_->pre ();
              ctx.nested_parser (this->valueDataRequirement_parser_);
            }
          }
          else
          {
            if (this->valueDataRequirement_parser_ != 0)
            {
              this->valueDataRequirement_parser_->post_DataRequirement ();
              this->valueDataRequirement ();
            }

            count = 0;
            state = 44UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 44UL;
          // Fall through.
        }
      }
      case 44UL:
      {
        if (n == "valueExpression" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueExpression_parser_)
            {
              this->valueExpression_parser_->pre ();
              ctx.nested_parser (this->valueExpression_parser_);
            }
          }
          else
          {
            if (this->valueExpression_parser_ != 0)
            {
              this->valueExpression_parser_->post_Expression ();
              this->valueExpression ();
            }

            count = 0;
            state = 45UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 45UL;
          // Fall through.
        }
      }
      case 45UL:
      {
        if (n == "valueParameterDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueParameterDefinition_parser_)
            {
              this->valueParameterDefinition_parser_->pre ();
              ctx.nested_parser (this->valueParameterDefinition_parser_);
            }
          }
          else
          {
            if (this->valueParameterDefinition_parser_ != 0)
            {
              this->valueParameterDefinition_parser_->post_ParameterDefinition ();
              this->valueParameterDefinition ();
            }

            count = 0;
            state = 46UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 46UL;
          // Fall through.
        }
      }
      case 46UL:
      {
        if (n == "valueRelatedArtifact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueRelatedArtifact_parser_)
            {
              this->valueRelatedArtifact_parser_->pre ();
              ctx.nested_parser (this->valueRelatedArtifact_parser_);
            }
          }
          else
          {
            if (this->valueRelatedArtifact_parser_ != 0)
            {
              this->valueRelatedArtifact_parser_->post_RelatedArtifact ();
              this->valueRelatedArtifact ();
            }

            count = 0;
            state = 47UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 47UL;
          // Fall through.
        }
      }
      case 47UL:
      {
        if (n == "valueTriggerDefinition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueTriggerDefinition_parser_)
            {
              this->valueTriggerDefinition_parser_->pre ();
              ctx.nested_parser (this->valueTriggerDefinition_parser_);
            }
          }
          else
          {
            if (this->valueTriggerDefinition_parser_ != 0)
            {
              this->valueTriggerDefinition_parser_->post_TriggerDefinition ();
              this->valueTriggerDefinition ();
            }

            count = 0;
            state = 48UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 48UL;
          // Fall through.
        }
      }
      case 48UL:
      {
        if (n == "valueUsageContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueUsageContext_parser_)
            {
              this->valueUsageContext_parser_->pre ();
              ctx.nested_parser (this->valueUsageContext_parser_);
            }
          }
          else
          {
            if (this->valueUsageContext_parser_ != 0)
            {
              this->valueUsageContext_parser_->post_UsageContext ();
              this->valueUsageContext ();
            }

            count = 0;
            state = 49UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 49UL;
          // Fall through.
        }
      }
      case 49UL:
      {
        if (n == "valueDosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueDosage_parser_)
            {
              this->valueDosage_parser_->pre ();
              ctx.nested_parser (this->valueDosage_parser_);
            }
          }
          else
          {
            if (this->valueDosage_parser_ != 0)
            {
              this->valueDosage_parser_->post_Dosage ();
              this->valueDosage ();
            }

            count = 0;
            state = 50UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 50UL;
          // Fall through.
        }
      }
      case 50UL:
      {
        if (n == "valueMeta" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueMeta_parser_)
            {
              this->valueMeta_parser_->pre ();
              ctx.nested_parser (this->valueMeta_parser_);
            }
          }
          else
          {
            if (this->valueMeta_parser_ != 0)
            {
              this->valueMeta_parser_->post_Meta ();
              this->valueMeta ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Slicing_pskel.
  //
  bool ElementDefinition_Slicing_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "discriminator" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "description" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "ordered" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "rules" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Slicing_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Slicing_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Slicing_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Slicing_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Slicing_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "discriminator" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->discriminator_parser_)
            {
              this->discriminator_parser_->pre ();
              ctx.nested_parser (this->discriminator_parser_);
            }
          }
          else
          {
            if (this->discriminator_parser_ != 0)
            {
              this->discriminator_parser_->post_ElementDefinition_Discriminator ();
              this->discriminator ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "ordered" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ordered_parser_)
            {
              this->ordered_parser_->pre ();
              ctx.nested_parser (this->ordered_parser_);
            }
          }
          else
          {
            if (this->ordered_parser_ != 0)
            {
              this->ordered_parser_->post_boolean ();
              this->ordered ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "rules" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rules_parser_)
            {
              this->rules_parser_->pre ();
              ctx.nested_parser (this->rules_parser_);
            }
          }
          else
          {
            if (this->rules_parser_ != 0)
            {
              this->rules_parser_->post_SlicingRules ();
              this->rules ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Binding_pskel.
  //
  bool ElementDefinition_Binding_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "strength" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Binding_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Binding_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Binding_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Binding_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Binding_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "strength" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->strength_parser_)
            {
              this->strength_parser_->pre ();
              ctx.nested_parser (this->strength_parser_);
            }
          }
          else
          {
            if (this->strength_parser_ != 0)
            {
              this->strength_parser_->post_BindingStrength ();
              this->strength ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueSet" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueSet_parser_)
            {
              this->valueSet_parser_->pre ();
              ctx.nested_parser (this->valueSet_parser_);
            }
          }
          else
          {
            if (this->valueSet_parser_ != 0)
            {
              this->valueSet_parser_->post_canonical ();
              this->valueSet ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for ElementDefinition_Discriminator_pskel.
  //
  bool ElementDefinition_Discriminator_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &ElementDefinition_Discriminator_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool ElementDefinition_Discriminator_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void ElementDefinition_Discriminator_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void ElementDefinition_Discriminator_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void ElementDefinition_Discriminator_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_DiscriminatorType ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "path" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->path_parser_)
            {
              this->path_parser_->pre ();
              ctx.nested_parser (this->path_parser_);
            }
          }
          else
          {
            if (this->path_parser_ != 0)
            {
              this->path_parser_->post_string ();
              this->path ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for Resource_pskel.
  //
  bool Resource_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "id" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "meta" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "implicitRules" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "language" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &Resource_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool Resource_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::xsde::cxx::parser::validating::complex_content base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void Resource_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void Resource_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void Resource_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "id" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->id_parser_)
            {
              this->id_parser_->pre ();
              ctx.nested_parser (this->id_parser_);
            }
          }
          else
          {
            if (this->id_parser_ != 0)
            {
              this->id_parser_->post_id ();
              this->id ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "meta" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->meta_parser_)
            {
              this->meta_parser_->pre ();
              ctx.nested_parser (this->meta_parser_);
            }
          }
          else
          {
            if (this->meta_parser_ != 0)
            {
              this->meta_parser_->post_Meta ();
              this->meta ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "implicitRules" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->implicitRules_parser_)
            {
              this->implicitRules_parser_->pre ();
              ctx.nested_parser (this->implicitRules_parser_);
            }
          }
          else
          {
            if (this->implicitRules_parser_ != 0)
            {
              this->implicitRules_parser_->post_uri ();
              this->implicitRules ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "language" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->language_parser_)
            {
              this->language_parser_->pre ();
              ctx.nested_parser (this->language_parser_);
            }
          }
          else
          {
            if (this->language_parser_ != 0)
            {
              this->language_parser_->post_code ();
              this->language ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for DomainResource_pskel.
  //
  bool DomainResource_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::Resource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "text" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "contained" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "extension" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "modifierExtension" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &DomainResource_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool DomainResource_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::Resource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void DomainResource_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::Resource_pskel base;
    base::_pre_e_validate ();
  }

  void DomainResource_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::Resource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void DomainResource_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "text" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->text_parser_)
            {
              this->text_parser_->pre ();
              ctx.nested_parser (this->text_parser_);
            }
          }
          else
          {
            if (this->text_parser_ != 0)
            {
              this->text_parser_->post_Narrative ();
              this->text ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "contained" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contained_parser_)
            {
              this->contained_parser_->pre ();
              ctx.nested_parser (this->contained_parser_);
            }
          }
          else
          {
            if (this->contained_parser_ != 0)
            {
              this->contained_parser_->post_ResourceContainer ();
              this->contained ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "extension" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->extension_parser_)
            {
              this->extension_parser_->pre ();
              ctx.nested_parser (this->extension_parser_);
            }
          }
          else
          {
            if (this->extension_parser_ != 0)
            {
              this->extension_parser_->post_Extension ();
              this->extension ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "modifierExtension" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->modifierExtension_parser_)
            {
              this->modifierExtension_parser_->pre ();
              ctx.nested_parser (this->modifierExtension_parser_);
            }
          }
          else
          {
            if (this->modifierExtension_parser_ != 0)
            {
              this->modifierExtension_parser_->post_Extension ();
              this->modifierExtension ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
  // Attribute validation and dispatch functions for Element_pskel.
  //
  bool Element_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();

        this->id_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->id_parser_->_characters (s);

        if (!ctx.error_type ())
          this->id_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->id_parser_->post_string_primitive ();

        this->id ();
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for date_pskel.
  //
  bool date_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_date_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for dateTime_pskel.
  //
  bool dateTime_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_dateTime_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for code_pskel.
  //
  bool code_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_code_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for string_pskel.
  //
  bool string_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_string_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for integer_pskel.
  //
  bool integer_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_integer_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for oid_pskel.
  //
  bool oid_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_oid_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for canonical_pskel.
  //
  bool canonical_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_canonical_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for uri_pskel.
  //
  bool uri_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_uri_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for uuid_pskel.
  //
  bool uuid_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_uuid_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for url_pskel.
  //
  bool url_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_url_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for instant_pskel.
  //
  bool instant_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_instant_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for boolean_pskel.
  //
  bool boolean_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_boolean_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for base64Binary_pskel.
  //
  bool base64Binary_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_base64Binary_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for unsignedInt_pskel.
  //
  bool unsignedInt_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_unsignedInt_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for markdown_pskel.
  //
  bool markdown_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_markdown_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for time_pskel.
  //
  bool time_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_time_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for id_pskel.
  //
  bool id_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_id_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for positiveInt_pskel.
  //
  bool positiveInt_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_positiveInt_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for decimal_pskel.
  //
  bool decimal_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_decimal_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for Extension_pskel.
  //
  bool Extension_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "url" && ns.empty ())
    {
      if (this->url_parser_)
      {
        this->url_parser_->pre ();

        this->url_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->url_parser_->_characters (s);

        if (!ctx.error_type ())
          this->url_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->url_parser_->post_uri_primitive ();

        this->url ();
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->url = true;
      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  void Extension_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.url = false;
    typedef ::fhir::Element_pskel base;
    base::_pre_a_validate ();
  }

  void Extension_pskel::
  _post_a_validate ()
  {
    typedef ::fhir::Element_pskel base;
    base::_post_a_validate ();

    if (this->_context ().error_type ())
      return;

    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.url)
    {
      this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
      return;
    }


    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for NarrativeStatus_pskel.
  //
  bool NarrativeStatus_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_NarrativeStatus_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for AddressUse_pskel.
  //
  bool AddressUse_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AddressUse_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for AddressType_pskel.
  //
  bool AddressType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AddressType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ContributorType_pskel.
  //
  bool ContributorType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ContributorType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for SortDirection_pskel.
  //
  bool SortDirection_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_SortDirection_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for NameUse_pskel.
  //
  bool NameUse_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_NameUse_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ContactPointSystem_pskel.
  //
  bool ContactPointSystem_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ContactPointSystem_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ContactPointUse_pskel.
  //
  bool ContactPointUse_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ContactPointUse_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for IdentifierUse_pskel.
  //
  bool IdentifierUse_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_IdentifierUse_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for SampledDataDataType_pskel.
  //
  bool SampledDataDataType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_SampledDataDataType_primitive ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for TriggerType_pskel.
  //
  bool TriggerType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_TriggerType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for QuantityComparator_pskel.
  //
  bool QuantityComparator_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_QuantityComparator_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for RelatedArtifactType_pskel.
  //
  bool RelatedArtifactType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_RelatedArtifactType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ExpressionLanguage_pskel.
  //
  bool ExpressionLanguage_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ExpressionLanguage_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for UnitsOfTime_pskel.
  //
  bool UnitsOfTime_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_UnitsOfTime_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for EventTiming_pskel.
  //
  bool EventTiming_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_EventTiming_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for PropertyRepresentation_pskel.
  //
  bool PropertyRepresentation_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_PropertyRepresentation_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ConstraintSeverity_pskel.
  //
  bool ConstraintSeverity_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ConstraintSeverity_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for AggregationMode_pskel.
  //
  bool AggregationMode_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AggregationMode_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ReferenceVersionRules_pskel.
  //
  bool ReferenceVersionRules_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ReferenceVersionRules_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for SlicingRules_pskel.
  //
  bool SlicingRules_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_SlicingRules_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for BindingStrength_pskel.
  //
  bool BindingStrength_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_BindingStrength_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for DiscriminatorType_pskel.
  //
  bool DiscriminatorType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_DiscriminatorType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for PublicationStatus_pskel.
  //
  bool PublicationStatus_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_PublicationStatus_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for SearchParamType_pskel.
  //
  bool SearchParamType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_SearchParamType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for AdministrativeGender_pskel.
  //
  bool AdministrativeGender_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_AdministrativeGender_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for FHIRVersion_pskel.
  //
  bool FHIRVersion_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_FHIRVersion_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for NoteType_pskel.
  //
  bool NoteType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_NoteType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for RemittanceOutcome_pskel.
  //
  bool RemittanceOutcome_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_RemittanceOutcome_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ConceptMapEquivalence_pskel.
  //
  bool ConceptMapEquivalence_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ConceptMapEquivalence_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for DocumentReferenceStatus_pskel.
  //
  bool DocumentReferenceStatus_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_DocumentReferenceStatus_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


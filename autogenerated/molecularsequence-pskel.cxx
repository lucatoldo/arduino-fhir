// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "molecularsequence-pskel.hxx"

namespace fhir
{
  // MolecularSequence_pskel
  //

  void MolecularSequence_pskel::
  identifier_parser (::fhir::Identifier_pskel& p)
  {
    this->identifier_parser_ = &p;
  }

  void MolecularSequence_pskel::
  type_parser (::fhir::sequenceType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MolecularSequence_pskel::
  coordinateSystem_parser (::fhir::integer_pskel& p)
  {
    this->coordinateSystem_parser_ = &p;
  }

  void MolecularSequence_pskel::
  patient_parser (::fhir::Reference_pskel& p)
  {
    this->patient_parser_ = &p;
  }

  void MolecularSequence_pskel::
  specimen_parser (::fhir::Reference_pskel& p)
  {
    this->specimen_parser_ = &p;
  }

  void MolecularSequence_pskel::
  device_parser (::fhir::Reference_pskel& p)
  {
    this->device_parser_ = &p;
  }

  void MolecularSequence_pskel::
  performer_parser (::fhir::Reference_pskel& p)
  {
    this->performer_parser_ = &p;
  }

  void MolecularSequence_pskel::
  quantity_parser (::fhir::Quantity_pskel& p)
  {
    this->quantity_parser_ = &p;
  }

  void MolecularSequence_pskel::
  referenceSeq_parser (::fhir::MolecularSequence_ReferenceSeq_pskel& p)
  {
    this->referenceSeq_parser_ = &p;
  }

  void MolecularSequence_pskel::
  variant_parser (::fhir::MolecularSequence_Variant_pskel& p)
  {
    this->variant_parser_ = &p;
  }

  void MolecularSequence_pskel::
  observedSeq_parser (::fhir::string_pskel& p)
  {
    this->observedSeq_parser_ = &p;
  }

  void MolecularSequence_pskel::
  quality_parser (::fhir::MolecularSequence_Quality_pskel& p)
  {
    this->quality_parser_ = &p;
  }

  void MolecularSequence_pskel::
  readCoverage_parser (::fhir::integer_pskel& p)
  {
    this->readCoverage_parser_ = &p;
  }

  void MolecularSequence_pskel::
  repository_parser (::fhir::MolecularSequence_Repository_pskel& p)
  {
    this->repository_parser_ = &p;
  }

  void MolecularSequence_pskel::
  pointer_parser (::fhir::Reference_pskel& p)
  {
    this->pointer_parser_ = &p;
  }

  void MolecularSequence_pskel::
  structureVariant_parser (::fhir::MolecularSequence_StructureVariant_pskel& p)
  {
    this->structureVariant_parser_ = &p;
  }

  void MolecularSequence_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Identifier_pskel& identifier,
           ::fhir::sequenceType_pskel& type,
           ::fhir::integer_pskel& coordinateSystem,
           ::fhir::Reference_pskel& patient,
           ::fhir::Reference_pskel& specimen,
           ::fhir::Reference_pskel& device,
           ::fhir::Reference_pskel& performer,
           ::fhir::Quantity_pskel& quantity,
           ::fhir::MolecularSequence_ReferenceSeq_pskel& referenceSeq,
           ::fhir::MolecularSequence_Variant_pskel& variant,
           ::fhir::string_pskel& observedSeq,
           ::fhir::MolecularSequence_Quality_pskel& quality,
           ::fhir::integer_pskel& readCoverage,
           ::fhir::MolecularSequence_Repository_pskel& repository,
           ::fhir::Reference_pskel& pointer,
           ::fhir::MolecularSequence_StructureVariant_pskel& structureVariant)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->identifier_parser_ = &identifier;
    this->type_parser_ = &type;
    this->coordinateSystem_parser_ = &coordinateSystem;
    this->patient_parser_ = &patient;
    this->specimen_parser_ = &specimen;
    this->device_parser_ = &device;
    this->performer_parser_ = &performer;
    this->quantity_parser_ = &quantity;
    this->referenceSeq_parser_ = &referenceSeq;
    this->variant_parser_ = &variant;
    this->observedSeq_parser_ = &observedSeq;
    this->quality_parser_ = &quality;
    this->readCoverage_parser_ = &readCoverage;
    this->repository_parser_ = &repository;
    this->pointer_parser_ = &pointer;
    this->structureVariant_parser_ = &structureVariant;
  }

  MolecularSequence_pskel::
  MolecularSequence_pskel (::fhir::DomainResource_pskel* tiein)
  : ::fhir::DomainResource_pskel (tiein, 0),
    MolecularSequence_impl_ (0),
    identifier_parser_ (0),
    type_parser_ (0),
    coordinateSystem_parser_ (0),
    patient_parser_ (0),
    specimen_parser_ (0),
    device_parser_ (0),
    performer_parser_ (0),
    quantity_parser_ (0),
    referenceSeq_parser_ (0),
    variant_parser_ (0),
    observedSeq_parser_ (0),
    quality_parser_ (0),
    readCoverage_parser_ (0),
    repository_parser_ (0),
    pointer_parser_ (0),
    structureVariant_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_pskel::
  MolecularSequence_pskel (MolecularSequence_pskel* impl, void*)
  : ::fhir::DomainResource_pskel (impl, 0),
    MolecularSequence_impl_ (impl),
    identifier_parser_ (0),
    type_parser_ (0),
    coordinateSystem_parser_ (0),
    patient_parser_ (0),
    specimen_parser_ (0),
    device_parser_ (0),
    performer_parser_ (0),
    quantity_parser_ (0),
    referenceSeq_parser_ (0),
    variant_parser_ (0),
    observedSeq_parser_ (0),
    quality_parser_ (0),
    readCoverage_parser_ (0),
    repository_parser_ (0),
    pointer_parser_ (0),
    structureVariant_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_ReferenceSeq_pskel
  //

  void MolecularSequence_ReferenceSeq_pskel::
  chromosome_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->chromosome_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  genomeBuild_parser (::fhir::string_pskel& p)
  {
    this->genomeBuild_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  orientation_parser (::fhir::orientationType_pskel& p)
  {
    this->orientation_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  referenceSeqId_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->referenceSeqId_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  referenceSeqPointer_parser (::fhir::Reference_pskel& p)
  {
    this->referenceSeqPointer_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  referenceSeqString_parser (::fhir::string_pskel& p)
  {
    this->referenceSeqString_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  strand_parser (::fhir::strandType_pskel& p)
  {
    this->strand_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  windowStart_parser (::fhir::integer_pskel& p)
  {
    this->windowStart_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  windowEnd_parser (::fhir::integer_pskel& p)
  {
    this->windowEnd_parser_ = &p;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& chromosome,
           ::fhir::string_pskel& genomeBuild,
           ::fhir::orientationType_pskel& orientation,
           ::fhir::CodeableConcept_pskel& referenceSeqId,
           ::fhir::Reference_pskel& referenceSeqPointer,
           ::fhir::string_pskel& referenceSeqString,
           ::fhir::strandType_pskel& strand,
           ::fhir::integer_pskel& windowStart,
           ::fhir::integer_pskel& windowEnd)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->chromosome_parser_ = &chromosome;
    this->genomeBuild_parser_ = &genomeBuild;
    this->orientation_parser_ = &orientation;
    this->referenceSeqId_parser_ = &referenceSeqId;
    this->referenceSeqPointer_parser_ = &referenceSeqPointer;
    this->referenceSeqString_parser_ = &referenceSeqString;
    this->strand_parser_ = &strand;
    this->windowStart_parser_ = &windowStart;
    this->windowEnd_parser_ = &windowEnd;
  }

  MolecularSequence_ReferenceSeq_pskel::
  MolecularSequence_ReferenceSeq_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_ReferenceSeq_impl_ (0),
    chromosome_parser_ (0),
    genomeBuild_parser_ (0),
    orientation_parser_ (0),
    referenceSeqId_parser_ (0),
    referenceSeqPointer_parser_ (0),
    referenceSeqString_parser_ (0),
    strand_parser_ (0),
    windowStart_parser_ (0),
    windowEnd_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_ReferenceSeq_pskel::
  MolecularSequence_ReferenceSeq_pskel (MolecularSequence_ReferenceSeq_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_ReferenceSeq_impl_ (impl),
    chromosome_parser_ (0),
    genomeBuild_parser_ (0),
    orientation_parser_ (0),
    referenceSeqId_parser_ (0),
    referenceSeqPointer_parser_ (0),
    referenceSeqString_parser_ (0),
    strand_parser_ (0),
    windowStart_parser_ (0),
    windowEnd_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_Variant_pskel
  //

  void MolecularSequence_Variant_pskel::
  start_parser (::fhir::integer_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void MolecularSequence_Variant_pskel::
  end_parser (::fhir::integer_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void MolecularSequence_Variant_pskel::
  observedAllele_parser (::fhir::string_pskel& p)
  {
    this->observedAllele_parser_ = &p;
  }

  void MolecularSequence_Variant_pskel::
  referenceAllele_parser (::fhir::string_pskel& p)
  {
    this->referenceAllele_parser_ = &p;
  }

  void MolecularSequence_Variant_pskel::
  cigar_parser (::fhir::string_pskel& p)
  {
    this->cigar_parser_ = &p;
  }

  void MolecularSequence_Variant_pskel::
  variantPointer_parser (::fhir::Reference_pskel& p)
  {
    this->variantPointer_parser_ = &p;
  }

  void MolecularSequence_Variant_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& start,
           ::fhir::integer_pskel& end,
           ::fhir::string_pskel& observedAllele,
           ::fhir::string_pskel& referenceAllele,
           ::fhir::string_pskel& cigar,
           ::fhir::Reference_pskel& variantPointer)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->observedAllele_parser_ = &observedAllele;
    this->referenceAllele_parser_ = &referenceAllele;
    this->cigar_parser_ = &cigar;
    this->variantPointer_parser_ = &variantPointer;
  }

  MolecularSequence_Variant_pskel::
  MolecularSequence_Variant_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_Variant_impl_ (0),
    start_parser_ (0),
    end_parser_ (0),
    observedAllele_parser_ (0),
    referenceAllele_parser_ (0),
    cigar_parser_ (0),
    variantPointer_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_Variant_pskel::
  MolecularSequence_Variant_pskel (MolecularSequence_Variant_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_Variant_impl_ (impl),
    start_parser_ (0),
    end_parser_ (0),
    observedAllele_parser_ (0),
    referenceAllele_parser_ (0),
    cigar_parser_ (0),
    variantPointer_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_Quality_pskel
  //

  void MolecularSequence_Quality_pskel::
  type_parser (::fhir::qualityType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  standardSequence_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->standardSequence_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  start_parser (::fhir::integer_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  end_parser (::fhir::integer_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  score_parser (::fhir::Quantity_pskel& p)
  {
    this->score_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  method_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->method_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  truthTP_parser (::fhir::decimal_pskel& p)
  {
    this->truthTP_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  queryTP_parser (::fhir::decimal_pskel& p)
  {
    this->queryTP_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  truthFN_parser (::fhir::decimal_pskel& p)
  {
    this->truthFN_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  queryFP_parser (::fhir::decimal_pskel& p)
  {
    this->queryFP_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  gtFP_parser (::fhir::decimal_pskel& p)
  {
    this->gtFP_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  precision_parser (::fhir::decimal_pskel& p)
  {
    this->precision_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  recall_parser (::fhir::decimal_pskel& p)
  {
    this->recall_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  fScore_parser (::fhir::decimal_pskel& p)
  {
    this->fScore_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  roc_parser (::fhir::MolecularSequence_Roc_pskel& p)
  {
    this->roc_parser_ = &p;
  }

  void MolecularSequence_Quality_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::qualityType_pskel& type,
           ::fhir::CodeableConcept_pskel& standardSequence,
           ::fhir::integer_pskel& start,
           ::fhir::integer_pskel& end,
           ::fhir::Quantity_pskel& score,
           ::fhir::CodeableConcept_pskel& method,
           ::fhir::decimal_pskel& truthTP,
           ::fhir::decimal_pskel& queryTP,
           ::fhir::decimal_pskel& truthFN,
           ::fhir::decimal_pskel& queryFP,
           ::fhir::decimal_pskel& gtFP,
           ::fhir::decimal_pskel& precision,
           ::fhir::decimal_pskel& recall,
           ::fhir::decimal_pskel& fScore,
           ::fhir::MolecularSequence_Roc_pskel& roc)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->standardSequence_parser_ = &standardSequence;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->score_parser_ = &score;
    this->method_parser_ = &method;
    this->truthTP_parser_ = &truthTP;
    this->queryTP_parser_ = &queryTP;
    this->truthFN_parser_ = &truthFN;
    this->queryFP_parser_ = &queryFP;
    this->gtFP_parser_ = &gtFP;
    this->precision_parser_ = &precision;
    this->recall_parser_ = &recall;
    this->fScore_parser_ = &fScore;
    this->roc_parser_ = &roc;
  }

  MolecularSequence_Quality_pskel::
  MolecularSequence_Quality_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_Quality_impl_ (0),
    type_parser_ (0),
    standardSequence_parser_ (0),
    start_parser_ (0),
    end_parser_ (0),
    score_parser_ (0),
    method_parser_ (0),
    truthTP_parser_ (0),
    queryTP_parser_ (0),
    truthFN_parser_ (0),
    queryFP_parser_ (0),
    gtFP_parser_ (0),
    precision_parser_ (0),
    recall_parser_ (0),
    fScore_parser_ (0),
    roc_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_Quality_pskel::
  MolecularSequence_Quality_pskel (MolecularSequence_Quality_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_Quality_impl_ (impl),
    type_parser_ (0),
    standardSequence_parser_ (0),
    start_parser_ (0),
    end_parser_ (0),
    score_parser_ (0),
    method_parser_ (0),
    truthTP_parser_ (0),
    queryTP_parser_ (0),
    truthFN_parser_ (0),
    queryFP_parser_ (0),
    gtFP_parser_ (0),
    precision_parser_ (0),
    recall_parser_ (0),
    fScore_parser_ (0),
    roc_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_Roc_pskel
  //

  void MolecularSequence_Roc_pskel::
  score_parser (::fhir::integer_pskel& p)
  {
    this->score_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  numTP_parser (::fhir::integer_pskel& p)
  {
    this->numTP_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  numFP_parser (::fhir::integer_pskel& p)
  {
    this->numFP_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  numFN_parser (::fhir::integer_pskel& p)
  {
    this->numFN_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  precision_parser (::fhir::decimal_pskel& p)
  {
    this->precision_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  sensitivity_parser (::fhir::decimal_pskel& p)
  {
    this->sensitivity_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  fMeasure_parser (::fhir::decimal_pskel& p)
  {
    this->fMeasure_parser_ = &p;
  }

  void MolecularSequence_Roc_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& score,
           ::fhir::integer_pskel& numTP,
           ::fhir::integer_pskel& numFP,
           ::fhir::integer_pskel& numFN,
           ::fhir::decimal_pskel& precision,
           ::fhir::decimal_pskel& sensitivity,
           ::fhir::decimal_pskel& fMeasure)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->score_parser_ = &score;
    this->numTP_parser_ = &numTP;
    this->numFP_parser_ = &numFP;
    this->numFN_parser_ = &numFN;
    this->precision_parser_ = &precision;
    this->sensitivity_parser_ = &sensitivity;
    this->fMeasure_parser_ = &fMeasure;
  }

  MolecularSequence_Roc_pskel::
  MolecularSequence_Roc_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_Roc_impl_ (0),
    score_parser_ (0),
    numTP_parser_ (0),
    numFP_parser_ (0),
    numFN_parser_ (0),
    precision_parser_ (0),
    sensitivity_parser_ (0),
    fMeasure_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_Roc_pskel::
  MolecularSequence_Roc_pskel (MolecularSequence_Roc_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_Roc_impl_ (impl),
    score_parser_ (0),
    numTP_parser_ (0),
    numFP_parser_ (0),
    numFN_parser_ (0),
    precision_parser_ (0),
    sensitivity_parser_ (0),
    fMeasure_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_Repository_pskel
  //

  void MolecularSequence_Repository_pskel::
  type_parser (::fhir::repositoryType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MolecularSequence_Repository_pskel::
  url_parser (::fhir::uri_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void MolecularSequence_Repository_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void MolecularSequence_Repository_pskel::
  datasetId_parser (::fhir::string_pskel& p)
  {
    this->datasetId_parser_ = &p;
  }

  void MolecularSequence_Repository_pskel::
  variantsetId_parser (::fhir::string_pskel& p)
  {
    this->variantsetId_parser_ = &p;
  }

  void MolecularSequence_Repository_pskel::
  readsetId_parser (::fhir::string_pskel& p)
  {
    this->readsetId_parser_ = &p;
  }

  void MolecularSequence_Repository_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::repositoryType_pskel& type,
           ::fhir::uri_pskel& url,
           ::fhir::string_pskel& name,
           ::fhir::string_pskel& datasetId,
           ::fhir::string_pskel& variantsetId,
           ::fhir::string_pskel& readsetId)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->url_parser_ = &url;
    this->name_parser_ = &name;
    this->datasetId_parser_ = &datasetId;
    this->variantsetId_parser_ = &variantsetId;
    this->readsetId_parser_ = &readsetId;
  }

  MolecularSequence_Repository_pskel::
  MolecularSequence_Repository_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_Repository_impl_ (0),
    type_parser_ (0),
    url_parser_ (0),
    name_parser_ (0),
    datasetId_parser_ (0),
    variantsetId_parser_ (0),
    readsetId_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_Repository_pskel::
  MolecularSequence_Repository_pskel (MolecularSequence_Repository_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_Repository_impl_ (impl),
    type_parser_ (0),
    url_parser_ (0),
    name_parser_ (0),
    datasetId_parser_ (0),
    variantsetId_parser_ (0),
    readsetId_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_StructureVariant_pskel
  //

  void MolecularSequence_StructureVariant_pskel::
  variantType_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->variantType_parser_ = &p;
  }

  void MolecularSequence_StructureVariant_pskel::
  exact_parser (::fhir::boolean_pskel& p)
  {
    this->exact_parser_ = &p;
  }

  void MolecularSequence_StructureVariant_pskel::
  length_parser (::fhir::integer_pskel& p)
  {
    this->length_parser_ = &p;
  }

  void MolecularSequence_StructureVariant_pskel::
  outer_parser (::fhir::MolecularSequence_Outer_pskel& p)
  {
    this->outer_parser_ = &p;
  }

  void MolecularSequence_StructureVariant_pskel::
  inner_parser (::fhir::MolecularSequence_Inner_pskel& p)
  {
    this->inner_parser_ = &p;
  }

  void MolecularSequence_StructureVariant_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& variantType,
           ::fhir::boolean_pskel& exact,
           ::fhir::integer_pskel& length,
           ::fhir::MolecularSequence_Outer_pskel& outer,
           ::fhir::MolecularSequence_Inner_pskel& inner)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->variantType_parser_ = &variantType;
    this->exact_parser_ = &exact;
    this->length_parser_ = &length;
    this->outer_parser_ = &outer;
    this->inner_parser_ = &inner;
  }

  MolecularSequence_StructureVariant_pskel::
  MolecularSequence_StructureVariant_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_StructureVariant_impl_ (0),
    variantType_parser_ (0),
    exact_parser_ (0),
    length_parser_ (0),
    outer_parser_ (0),
    inner_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_StructureVariant_pskel::
  MolecularSequence_StructureVariant_pskel (MolecularSequence_StructureVariant_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_StructureVariant_impl_ (impl),
    variantType_parser_ (0),
    exact_parser_ (0),
    length_parser_ (0),
    outer_parser_ (0),
    inner_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_Outer_pskel
  //

  void MolecularSequence_Outer_pskel::
  start_parser (::fhir::integer_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void MolecularSequence_Outer_pskel::
  end_parser (::fhir::integer_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void MolecularSequence_Outer_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& start,
           ::fhir::integer_pskel& end)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  MolecularSequence_Outer_pskel::
  MolecularSequence_Outer_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_Outer_impl_ (0),
    start_parser_ (0),
    end_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_Outer_pskel::
  MolecularSequence_Outer_pskel (MolecularSequence_Outer_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_Outer_impl_ (impl),
    start_parser_ (0),
    end_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MolecularSequence_Inner_pskel
  //

  void MolecularSequence_Inner_pskel::
  start_parser (::fhir::integer_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void MolecularSequence_Inner_pskel::
  end_parser (::fhir::integer_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void MolecularSequence_Inner_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::integer_pskel& start,
           ::fhir::integer_pskel& end)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  MolecularSequence_Inner_pskel::
  MolecularSequence_Inner_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MolecularSequence_Inner_impl_ (0),
    start_parser_ (0),
    end_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MolecularSequence_Inner_pskel::
  MolecularSequence_Inner_pskel (MolecularSequence_Inner_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MolecularSequence_Inner_impl_ (impl),
    start_parser_ (0),
    end_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // strandType_list_pskel
  //

  strandType_list_pskel::
  strandType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    strandType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_strandType_list_pskel_enums_, 2UL);
  }

  strandType_list_pskel::
  strandType_list_pskel (strandType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    strandType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_strandType_list_pskel_enums_, 2UL);
  }

  // strandType_pskel
  //

  void strandType_pskel::
  value_parser (::fhir::strandType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void strandType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::strandType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  strandType_pskel::
  strandType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    strandType_impl_ (0),
    value_parser_ (0)
  {
  }

  strandType_pskel::
  strandType_pskel (strandType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    strandType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // orientationType_list_pskel
  //

  orientationType_list_pskel::
  orientationType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    orientationType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_orientationType_list_pskel_enums_, 2UL);
  }

  orientationType_list_pskel::
  orientationType_list_pskel (orientationType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    orientationType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_orientationType_list_pskel_enums_, 2UL);
  }

  // orientationType_pskel
  //

  void orientationType_pskel::
  value_parser (::fhir::orientationType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void orientationType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::orientationType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  orientationType_pskel::
  orientationType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    orientationType_impl_ (0),
    value_parser_ (0)
  {
  }

  orientationType_pskel::
  orientationType_pskel (orientationType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    orientationType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // repositoryType_list_pskel
  //

  repositoryType_list_pskel::
  repositoryType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    repositoryType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_repositoryType_list_pskel_enums_, 5UL);
  }

  repositoryType_list_pskel::
  repositoryType_list_pskel (repositoryType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    repositoryType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_repositoryType_list_pskel_enums_, 5UL);
  }

  // repositoryType_pskel
  //

  void repositoryType_pskel::
  value_parser (::fhir::repositoryType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void repositoryType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::repositoryType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  repositoryType_pskel::
  repositoryType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    repositoryType_impl_ (0),
    value_parser_ (0)
  {
  }

  repositoryType_pskel::
  repositoryType_pskel (repositoryType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    repositoryType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // qualityType_list_pskel
  //

  qualityType_list_pskel::
  qualityType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    qualityType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_qualityType_list_pskel_enums_, 3UL);
  }

  qualityType_list_pskel::
  qualityType_list_pskel (qualityType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    qualityType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_qualityType_list_pskel_enums_, 3UL);
  }

  // qualityType_pskel
  //

  void qualityType_pskel::
  value_parser (::fhir::qualityType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void qualityType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::qualityType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  qualityType_pskel::
  qualityType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    qualityType_impl_ (0),
    value_parser_ (0)
  {
  }

  qualityType_pskel::
  qualityType_pskel (qualityType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    qualityType_impl_ (impl),
    value_parser_ (0)
  {
  }

  // sequenceType_list_pskel
  //

  sequenceType_list_pskel::
  sequenceType_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    sequenceType_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_sequenceType_list_pskel_enums_, 3UL);
  }

  sequenceType_list_pskel::
  sequenceType_list_pskel (sequenceType_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    sequenceType_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_sequenceType_list_pskel_enums_, 3UL);
  }

  // sequenceType_pskel
  //

  void sequenceType_pskel::
  value_parser (::fhir::sequenceType_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void sequenceType_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::sequenceType_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  sequenceType_pskel::
  sequenceType_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    sequenceType_impl_ (0),
    value_parser_ (0)
  {
  }

  sequenceType_pskel::
  sequenceType_pskel (sequenceType_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    sequenceType_impl_ (impl),
    value_parser_ (0)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // MolecularSequence_pskel
  //

  void MolecularSequence_pskel::
  identifier ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->identifier ();
  }

  void MolecularSequence_pskel::
  type ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->type ();
  }

  void MolecularSequence_pskel::
  coordinateSystem ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->coordinateSystem ();
  }

  void MolecularSequence_pskel::
  patient ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->patient ();
  }

  void MolecularSequence_pskel::
  specimen ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->specimen ();
  }

  void MolecularSequence_pskel::
  device ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->device ();
  }

  void MolecularSequence_pskel::
  performer ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->performer ();
  }

  void MolecularSequence_pskel::
  quantity ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->quantity ();
  }

  void MolecularSequence_pskel::
  referenceSeq ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->referenceSeq ();
  }

  void MolecularSequence_pskel::
  variant ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->variant ();
  }

  void MolecularSequence_pskel::
  observedSeq ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->observedSeq ();
  }

  void MolecularSequence_pskel::
  quality ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->quality ();
  }

  void MolecularSequence_pskel::
  readCoverage ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->readCoverage ();
  }

  void MolecularSequence_pskel::
  repository ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->repository ();
  }

  void MolecularSequence_pskel::
  pointer ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->pointer ();
  }

  void MolecularSequence_pskel::
  structureVariant ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->structureVariant ();
  }

  void MolecularSequence_pskel::
  post_MolecularSequence ()
  {
    if (this->MolecularSequence_impl_)
      this->MolecularSequence_impl_->post_MolecularSequence ();
    else
      post_DomainResource ();
  }

  void MolecularSequence_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::DomainResource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->identifier_parser_)
      this->identifier_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->coordinateSystem_parser_)
      this->coordinateSystem_parser_->_reset ();

    if (this->patient_parser_)
      this->patient_parser_->_reset ();

    if (this->specimen_parser_)
      this->specimen_parser_->_reset ();

    if (this->device_parser_)
      this->device_parser_->_reset ();

    if (this->performer_parser_)
      this->performer_parser_->_reset ();

    if (this->quantity_parser_)
      this->quantity_parser_->_reset ();

    if (this->referenceSeq_parser_)
      this->referenceSeq_parser_->_reset ();

    if (this->variant_parser_)
      this->variant_parser_->_reset ();

    if (this->observedSeq_parser_)
      this->observedSeq_parser_->_reset ();

    if (this->quality_parser_)
      this->quality_parser_->_reset ();

    if (this->readCoverage_parser_)
      this->readCoverage_parser_->_reset ();

    if (this->repository_parser_)
      this->repository_parser_->_reset ();

    if (this->pointer_parser_)
      this->pointer_parser_->_reset ();

    if (this->structureVariant_parser_)
      this->structureVariant_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_ReferenceSeq_pskel
  //

  void MolecularSequence_ReferenceSeq_pskel::
  chromosome ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->chromosome ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  genomeBuild ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->genomeBuild ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  orientation ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->orientation ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  referenceSeqId ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->referenceSeqId ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  referenceSeqPointer ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->referenceSeqPointer ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  referenceSeqString ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->referenceSeqString ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  strand ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->strand ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  windowStart ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->windowStart ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  windowEnd ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->windowEnd ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  post_MolecularSequence_ReferenceSeq ()
  {
    if (this->MolecularSequence_ReferenceSeq_impl_)
      this->MolecularSequence_ReferenceSeq_impl_->post_MolecularSequence_ReferenceSeq ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->chromosome_parser_)
      this->chromosome_parser_->_reset ();

    if (this->genomeBuild_parser_)
      this->genomeBuild_parser_->_reset ();

    if (this->orientation_parser_)
      this->orientation_parser_->_reset ();

    if (this->referenceSeqId_parser_)
      this->referenceSeqId_parser_->_reset ();

    if (this->referenceSeqPointer_parser_)
      this->referenceSeqPointer_parser_->_reset ();

    if (this->referenceSeqString_parser_)
      this->referenceSeqString_parser_->_reset ();

    if (this->strand_parser_)
      this->strand_parser_->_reset ();

    if (this->windowStart_parser_)
      this->windowStart_parser_->_reset ();

    if (this->windowEnd_parser_)
      this->windowEnd_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_Variant_pskel
  //

  void MolecularSequence_Variant_pskel::
  start ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->start ();
  }

  void MolecularSequence_Variant_pskel::
  end ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->end ();
  }

  void MolecularSequence_Variant_pskel::
  observedAllele ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->observedAllele ();
  }

  void MolecularSequence_Variant_pskel::
  referenceAllele ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->referenceAllele ();
  }

  void MolecularSequence_Variant_pskel::
  cigar ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->cigar ();
  }

  void MolecularSequence_Variant_pskel::
  variantPointer ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->variantPointer ();
  }

  void MolecularSequence_Variant_pskel::
  post_MolecularSequence_Variant ()
  {
    if (this->MolecularSequence_Variant_impl_)
      this->MolecularSequence_Variant_impl_->post_MolecularSequence_Variant ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_Variant_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->start_parser_)
      this->start_parser_->_reset ();

    if (this->end_parser_)
      this->end_parser_->_reset ();

    if (this->observedAllele_parser_)
      this->observedAllele_parser_->_reset ();

    if (this->referenceAllele_parser_)
      this->referenceAllele_parser_->_reset ();

    if (this->cigar_parser_)
      this->cigar_parser_->_reset ();

    if (this->variantPointer_parser_)
      this->variantPointer_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_Quality_pskel
  //

  void MolecularSequence_Quality_pskel::
  type ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->type ();
  }

  void MolecularSequence_Quality_pskel::
  standardSequence ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->standardSequence ();
  }

  void MolecularSequence_Quality_pskel::
  start ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->start ();
  }

  void MolecularSequence_Quality_pskel::
  end ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->end ();
  }

  void MolecularSequence_Quality_pskel::
  score ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->score ();
  }

  void MolecularSequence_Quality_pskel::
  method ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->method ();
  }

  void MolecularSequence_Quality_pskel::
  truthTP ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->truthTP ();
  }

  void MolecularSequence_Quality_pskel::
  queryTP ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->queryTP ();
  }

  void MolecularSequence_Quality_pskel::
  truthFN ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->truthFN ();
  }

  void MolecularSequence_Quality_pskel::
  queryFP ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->queryFP ();
  }

  void MolecularSequence_Quality_pskel::
  gtFP ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->gtFP ();
  }

  void MolecularSequence_Quality_pskel::
  precision ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->precision ();
  }

  void MolecularSequence_Quality_pskel::
  recall ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->recall ();
  }

  void MolecularSequence_Quality_pskel::
  fScore ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->fScore ();
  }

  void MolecularSequence_Quality_pskel::
  roc ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->roc ();
  }

  void MolecularSequence_Quality_pskel::
  post_MolecularSequence_Quality ()
  {
    if (this->MolecularSequence_Quality_impl_)
      this->MolecularSequence_Quality_impl_->post_MolecularSequence_Quality ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_Quality_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->standardSequence_parser_)
      this->standardSequence_parser_->_reset ();

    if (this->start_parser_)
      this->start_parser_->_reset ();

    if (this->end_parser_)
      this->end_parser_->_reset ();

    if (this->score_parser_)
      this->score_parser_->_reset ();

    if (this->method_parser_)
      this->method_parser_->_reset ();

    if (this->truthTP_parser_)
      this->truthTP_parser_->_reset ();

    if (this->queryTP_parser_)
      this->queryTP_parser_->_reset ();

    if (this->truthFN_parser_)
      this->truthFN_parser_->_reset ();

    if (this->queryFP_parser_)
      this->queryFP_parser_->_reset ();

    if (this->gtFP_parser_)
      this->gtFP_parser_->_reset ();

    if (this->precision_parser_)
      this->precision_parser_->_reset ();

    if (this->recall_parser_)
      this->recall_parser_->_reset ();

    if (this->fScore_parser_)
      this->fScore_parser_->_reset ();

    if (this->roc_parser_)
      this->roc_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_Roc_pskel
  //

  void MolecularSequence_Roc_pskel::
  score ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->score ();
  }

  void MolecularSequence_Roc_pskel::
  numTP ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->numTP ();
  }

  void MolecularSequence_Roc_pskel::
  numFP ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->numFP ();
  }

  void MolecularSequence_Roc_pskel::
  numFN ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->numFN ();
  }

  void MolecularSequence_Roc_pskel::
  precision ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->precision ();
  }

  void MolecularSequence_Roc_pskel::
  sensitivity ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->sensitivity ();
  }

  void MolecularSequence_Roc_pskel::
  fMeasure ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->fMeasure ();
  }

  void MolecularSequence_Roc_pskel::
  post_MolecularSequence_Roc ()
  {
    if (this->MolecularSequence_Roc_impl_)
      this->MolecularSequence_Roc_impl_->post_MolecularSequence_Roc ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_Roc_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->score_parser_)
      this->score_parser_->_reset ();

    if (this->numTP_parser_)
      this->numTP_parser_->_reset ();

    if (this->numFP_parser_)
      this->numFP_parser_->_reset ();

    if (this->numFN_parser_)
      this->numFN_parser_->_reset ();

    if (this->precision_parser_)
      this->precision_parser_->_reset ();

    if (this->sensitivity_parser_)
      this->sensitivity_parser_->_reset ();

    if (this->fMeasure_parser_)
      this->fMeasure_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_Repository_pskel
  //

  void MolecularSequence_Repository_pskel::
  type ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->type ();
  }

  void MolecularSequence_Repository_pskel::
  url ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->url ();
  }

  void MolecularSequence_Repository_pskel::
  name ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->name ();
  }

  void MolecularSequence_Repository_pskel::
  datasetId ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->datasetId ();
  }

  void MolecularSequence_Repository_pskel::
  variantsetId ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->variantsetId ();
  }

  void MolecularSequence_Repository_pskel::
  readsetId ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->readsetId ();
  }

  void MolecularSequence_Repository_pskel::
  post_MolecularSequence_Repository ()
  {
    if (this->MolecularSequence_Repository_impl_)
      this->MolecularSequence_Repository_impl_->post_MolecularSequence_Repository ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_Repository_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->datasetId_parser_)
      this->datasetId_parser_->_reset ();

    if (this->variantsetId_parser_)
      this->variantsetId_parser_->_reset ();

    if (this->readsetId_parser_)
      this->readsetId_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_StructureVariant_pskel
  //

  void MolecularSequence_StructureVariant_pskel::
  variantType ()
  {
    if (this->MolecularSequence_StructureVariant_impl_)
      this->MolecularSequence_StructureVariant_impl_->variantType ();
  }

  void MolecularSequence_StructureVariant_pskel::
  exact ()
  {
    if (this->MolecularSequence_StructureVariant_impl_)
      this->MolecularSequence_StructureVariant_impl_->exact ();
  }

  void MolecularSequence_StructureVariant_pskel::
  length ()
  {
    if (this->MolecularSequence_StructureVariant_impl_)
      this->MolecularSequence_StructureVariant_impl_->length ();
  }

  void MolecularSequence_StructureVariant_pskel::
  outer ()
  {
    if (this->MolecularSequence_StructureVariant_impl_)
      this->MolecularSequence_StructureVariant_impl_->outer ();
  }

  void MolecularSequence_StructureVariant_pskel::
  inner ()
  {
    if (this->MolecularSequence_StructureVariant_impl_)
      this->MolecularSequence_StructureVariant_impl_->inner ();
  }

  void MolecularSequence_StructureVariant_pskel::
  post_MolecularSequence_StructureVariant ()
  {
    if (this->MolecularSequence_StructureVariant_impl_)
      this->MolecularSequence_StructureVariant_impl_->post_MolecularSequence_StructureVariant ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_StructureVariant_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->variantType_parser_)
      this->variantType_parser_->_reset ();

    if (this->exact_parser_)
      this->exact_parser_->_reset ();

    if (this->length_parser_)
      this->length_parser_->_reset ();

    if (this->outer_parser_)
      this->outer_parser_->_reset ();

    if (this->inner_parser_)
      this->inner_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_Outer_pskel
  //

  void MolecularSequence_Outer_pskel::
  start ()
  {
    if (this->MolecularSequence_Outer_impl_)
      this->MolecularSequence_Outer_impl_->start ();
  }

  void MolecularSequence_Outer_pskel::
  end ()
  {
    if (this->MolecularSequence_Outer_impl_)
      this->MolecularSequence_Outer_impl_->end ();
  }

  void MolecularSequence_Outer_pskel::
  post_MolecularSequence_Outer ()
  {
    if (this->MolecularSequence_Outer_impl_)
      this->MolecularSequence_Outer_impl_->post_MolecularSequence_Outer ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_Outer_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->start_parser_)
      this->start_parser_->_reset ();

    if (this->end_parser_)
      this->end_parser_->_reset ();

    this->resetting_ = false;
  }

  // MolecularSequence_Inner_pskel
  //

  void MolecularSequence_Inner_pskel::
  start ()
  {
    if (this->MolecularSequence_Inner_impl_)
      this->MolecularSequence_Inner_impl_->start ();
  }

  void MolecularSequence_Inner_pskel::
  end ()
  {
    if (this->MolecularSequence_Inner_impl_)
      this->MolecularSequence_Inner_impl_->end ();
  }

  void MolecularSequence_Inner_pskel::
  post_MolecularSequence_Inner ()
  {
    if (this->MolecularSequence_Inner_impl_)
      this->MolecularSequence_Inner_impl_->post_MolecularSequence_Inner ();
    else
      post_BackboneElement ();
  }

  void MolecularSequence_Inner_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->start_parser_)
      this->start_parser_->_reset ();

    if (this->end_parser_)
      this->end_parser_->_reset ();

    this->resetting_ = false;
  }

  // strandType_list_pskel
  //

  void strandType_list_pskel::
  post_strandType_list ()
  {
    if (this->strandType_list_impl_)
      this->strandType_list_impl_->post_strandType_list ();
    else
      post_code_primitive ();
  }

  const char* const strandType_list_pskel::_xsde_strandType_list_pskel_enums_[2UL] = 
  {
    "crick",
    "watson"
  };

  // strandType_pskel
  //

  void strandType_pskel::
  value ()
  {
    if (this->strandType_impl_)
      this->strandType_impl_->value ();
  }

  void strandType_pskel::
  post_strandType ()
  {
    if (this->strandType_impl_)
      this->strandType_impl_->post_strandType ();
    else
      post_Element ();
  }

  void strandType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // orientationType_list_pskel
  //

  void orientationType_list_pskel::
  post_orientationType_list ()
  {
    if (this->orientationType_list_impl_)
      this->orientationType_list_impl_->post_orientationType_list ();
    else
      post_code_primitive ();
  }

  const char* const orientationType_list_pskel::_xsde_orientationType_list_pskel_enums_[2UL] = 
  {
    "antisense",
    "sense"
  };

  // orientationType_pskel
  //

  void orientationType_pskel::
  value ()
  {
    if (this->orientationType_impl_)
      this->orientationType_impl_->value ();
  }

  void orientationType_pskel::
  post_orientationType ()
  {
    if (this->orientationType_impl_)
      this->orientationType_impl_->post_orientationType ();
    else
      post_Element ();
  }

  void orientationType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // repositoryType_list_pskel
  //

  void repositoryType_list_pskel::
  post_repositoryType_list ()
  {
    if (this->repositoryType_list_impl_)
      this->repositoryType_list_impl_->post_repositoryType_list ();
    else
      post_code_primitive ();
  }

  const char* const repositoryType_list_pskel::_xsde_repositoryType_list_pskel_enums_[5UL] = 
  {
    "directlink",
    "login",
    "oauth",
    "openapi",
    "other"
  };

  // repositoryType_pskel
  //

  void repositoryType_pskel::
  value ()
  {
    if (this->repositoryType_impl_)
      this->repositoryType_impl_->value ();
  }

  void repositoryType_pskel::
  post_repositoryType ()
  {
    if (this->repositoryType_impl_)
      this->repositoryType_impl_->post_repositoryType ();
    else
      post_Element ();
  }

  void repositoryType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // qualityType_list_pskel
  //

  void qualityType_list_pskel::
  post_qualityType_list ()
  {
    if (this->qualityType_list_impl_)
      this->qualityType_list_impl_->post_qualityType_list ();
    else
      post_code_primitive ();
  }

  const char* const qualityType_list_pskel::_xsde_qualityType_list_pskel_enums_[3UL] = 
  {
    "indel",
    "snp",
    "unknown"
  };

  // qualityType_pskel
  //

  void qualityType_pskel::
  value ()
  {
    if (this->qualityType_impl_)
      this->qualityType_impl_->value ();
  }

  void qualityType_pskel::
  post_qualityType ()
  {
    if (this->qualityType_impl_)
      this->qualityType_impl_->post_qualityType ();
    else
      post_Element ();
  }

  void qualityType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // sequenceType_list_pskel
  //

  void sequenceType_list_pskel::
  post_sequenceType_list ()
  {
    if (this->sequenceType_list_impl_)
      this->sequenceType_list_impl_->post_sequenceType_list ();
    else
      post_code_primitive ();
  }

  const char* const sequenceType_list_pskel::_xsde_sequenceType_list_pskel_enums_[3UL] = 
  {
    "aa",
    "dna",
    "rna"
  };

  // sequenceType_pskel
  //

  void sequenceType_pskel::
  value ()
  {
    if (this->sequenceType_impl_)
      this->sequenceType_impl_->value ();
  }

  void sequenceType_pskel::
  post_sequenceType ()
  {
    if (this->sequenceType_impl_)
      this->sequenceType_impl_->post_sequenceType ();
    else
      post_Element ();
  }

  void sequenceType_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for MolecularSequence_pskel.
  //
  bool MolecularSequence_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "type" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "coordinateSystem" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::DomainResource_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::DomainResource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MolecularSequence_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "identifier" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->identifier_parser_)
            {
              this->identifier_parser_->pre ();
              ctx.nested_parser (this->identifier_parser_);
            }
          }
          else
          {
            if (this->identifier_parser_ != 0)
            {
              this->identifier_parser_->post_Identifier ();
              this->identifier ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_sequenceType ();
              this->type ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "coordinateSystem" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->coordinateSystem_parser_)
            {
              this->coordinateSystem_parser_->pre ();
              ctx.nested_parser (this->coordinateSystem_parser_);
            }
          }
          else
          {
            if (this->coordinateSystem_parser_ != 0)
            {
              this->coordinateSystem_parser_->post_integer ();
              this->coordinateSystem ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "patient" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patient_parser_)
            {
              this->patient_parser_->pre ();
              ctx.nested_parser (this->patient_parser_);
            }
          }
          else
          {
            if (this->patient_parser_ != 0)
            {
              this->patient_parser_->post_Reference ();
              this->patient ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "specimen" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->specimen_parser_)
            {
              this->specimen_parser_->pre ();
              ctx.nested_parser (this->specimen_parser_);
            }
          }
          else
          {
            if (this->specimen_parser_ != 0)
            {
              this->specimen_parser_->post_Reference ();
              this->specimen ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "device" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->device_parser_)
            {
              this->device_parser_->pre ();
              ctx.nested_parser (this->device_parser_);
            }
          }
          else
          {
            if (this->device_parser_ != 0)
            {
              this->device_parser_->post_Reference ();
              this->device ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "performer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->performer_parser_)
            {
              this->performer_parser_->pre ();
              ctx.nested_parser (this->performer_parser_);
            }
          }
          else
          {
            if (this->performer_parser_ != 0)
            {
              this->performer_parser_->post_Reference ();
              this->performer ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "quantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->quantity_parser_)
            {
              this->quantity_parser_->pre ();
              ctx.nested_parser (this->quantity_parser_);
            }
          }
          else
          {
            if (this->quantity_parser_ != 0)
            {
              this->quantity_parser_->post_Quantity ();
              this->quantity ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "referenceSeq" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referenceSeq_parser_)
            {
              this->referenceSeq_parser_->pre ();
              ctx.nested_parser (this->referenceSeq_parser_);
            }
          }
          else
          {
            if (this->referenceSeq_parser_ != 0)
            {
              this->referenceSeq_parser_->post_MolecularSequence_ReferenceSeq ();
              this->referenceSeq ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "variant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->variant_parser_)
            {
              this->variant_parser_->pre ();
              ctx.nested_parser (this->variant_parser_);
            }
          }
          else
          {
            if (this->variant_parser_ != 0)
            {
              this->variant_parser_->post_MolecularSequence_Variant ();
              this->variant ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "observedSeq" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->observedSeq_parser_)
            {
              this->observedSeq_parser_->pre ();
              ctx.nested_parser (this->observedSeq_parser_);
            }
          }
          else
          {
            if (this->observedSeq_parser_ != 0)
            {
              this->observedSeq_parser_->post_string ();
              this->observedSeq ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "quality" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->quality_parser_)
            {
              this->quality_parser_->pre ();
              ctx.nested_parser (this->quality_parser_);
            }
          }
          else
          {
            if (this->quality_parser_ != 0)
            {
              this->quality_parser_->post_MolecularSequence_Quality ();
              this->quality ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "readCoverage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->readCoverage_parser_)
            {
              this->readCoverage_parser_->pre ();
              ctx.nested_parser (this->readCoverage_parser_);
            }
          }
          else
          {
            if (this->readCoverage_parser_ != 0)
            {
              this->readCoverage_parser_->post_integer ();
              this->readCoverage ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "repository" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->repository_parser_)
            {
              this->repository_parser_->pre ();
              ctx.nested_parser (this->repository_parser_);
            }
          }
          else
          {
            if (this->repository_parser_ != 0)
            {
              this->repository_parser_->post_MolecularSequence_Repository ();
              this->repository ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "pointer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->pointer_parser_)
            {
              this->pointer_parser_->pre ();
              ctx.nested_parser (this->pointer_parser_);
            }
          }
          else
          {
            if (this->pointer_parser_ != 0)
            {
              this->pointer_parser_->post_Reference ();
              this->pointer ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "structureVariant" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->structureVariant_parser_)
            {
              this->structureVariant_parser_->pre ();
              ctx.nested_parser (this->structureVariant_parser_);
            }
          }
          else
          {
            if (this->structureVariant_parser_ != 0)
            {
              this->structureVariant_parser_->post_MolecularSequence_StructureVariant ();
              this->structureVariant ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_ReferenceSeq_pskel.
  //
  bool MolecularSequence_ReferenceSeq_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "chromosome" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "genomeBuild" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "orientation" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "referenceSeqId" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "referenceSeqPointer" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "referenceSeqString" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "strand" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "windowStart" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "windowEnd" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_ReferenceSeq_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_ReferenceSeq_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_ReferenceSeq_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MolecularSequence_ReferenceSeq_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "chromosome" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->chromosome_parser_)
            {
              this->chromosome_parser_->pre ();
              ctx.nested_parser (this->chromosome_parser_);
            }
          }
          else
          {
            if (this->chromosome_parser_ != 0)
            {
              this->chromosome_parser_->post_CodeableConcept ();
              this->chromosome ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "genomeBuild" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->genomeBuild_parser_)
            {
              this->genomeBuild_parser_->pre ();
              ctx.nested_parser (this->genomeBuild_parser_);
            }
          }
          else
          {
            if (this->genomeBuild_parser_ != 0)
            {
              this->genomeBuild_parser_->post_string ();
              this->genomeBuild ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "orientation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->orientation_parser_)
            {
              this->orientation_parser_->pre ();
              ctx.nested_parser (this->orientation_parser_);
            }
          }
          else
          {
            if (this->orientation_parser_ != 0)
            {
              this->orientation_parser_->post_orientationType ();
              this->orientation ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "referenceSeqId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referenceSeqId_parser_)
            {
              this->referenceSeqId_parser_->pre ();
              ctx.nested_parser (this->referenceSeqId_parser_);
            }
          }
          else
          {
            if (this->referenceSeqId_parser_ != 0)
            {
              this->referenceSeqId_parser_->post_CodeableConcept ();
              this->referenceSeqId ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "referenceSeqPointer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referenceSeqPointer_parser_)
            {
              this->referenceSeqPointer_parser_->pre ();
              ctx.nested_parser (this->referenceSeqPointer_parser_);
            }
          }
          else
          {
            if (this->referenceSeqPointer_parser_ != 0)
            {
              this->referenceSeqPointer_parser_->post_Reference ();
              this->referenceSeqPointer ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "referenceSeqString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referenceSeqString_parser_)
            {
              this->referenceSeqString_parser_->pre ();
              ctx.nested_parser (this->referenceSeqString_parser_);
            }
          }
          else
          {
            if (this->referenceSeqString_parser_ != 0)
            {
              this->referenceSeqString_parser_->post_string ();
              this->referenceSeqString ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "strand" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->strand_parser_)
            {
              this->strand_parser_->pre ();
              ctx.nested_parser (this->strand_parser_);
            }
          }
          else
          {
            if (this->strand_parser_ != 0)
            {
              this->strand_parser_->post_strandType ();
              this->strand ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "windowStart" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->windowStart_parser_)
            {
              this->windowStart_parser_->pre ();
              ctx.nested_parser (this->windowStart_parser_);
            }
          }
          else
          {
            if (this->windowStart_parser_ != 0)
            {
              this->windowStart_parser_->post_integer ();
              this->windowStart ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "windowEnd" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->windowEnd_parser_)
            {
              this->windowEnd_parser_->pre ();
              ctx.nested_parser (this->windowEnd_parser_);
            }
          }
          else
          {
            if (this->windowEnd_parser_ != 0)
            {
              this->windowEnd_parser_->post_integer ();
              this->windowEnd ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_Variant_pskel.
  //
  bool MolecularSequence_Variant_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "start" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "end" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "observedAllele" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "referenceAllele" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "cigar" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "variantPointer" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_Variant_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_Variant_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_Variant_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_Variant_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MolecularSequence_Variant_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "start" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->start_parser_)
            {
              this->start_parser_->pre ();
              ctx.nested_parser (this->start_parser_);
            }
          }
          else
          {
            if (this->start_parser_ != 0)
            {
              this->start_parser_->post_integer ();
              this->start ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "end" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->end_parser_)
            {
              this->end_parser_->pre ();
              ctx.nested_parser (this->end_parser_);
            }
          }
          else
          {
            if (this->end_parser_ != 0)
            {
              this->end_parser_->post_integer ();
              this->end ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "observedAllele" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->observedAllele_parser_)
            {
              this->observedAllele_parser_->pre ();
              ctx.nested_parser (this->observedAllele_parser_);
            }
          }
          else
          {
            if (this->observedAllele_parser_ != 0)
            {
              this->observedAllele_parser_->post_string ();
              this->observedAllele ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "referenceAllele" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referenceAllele_parser_)
            {
              this->referenceAllele_parser_->pre ();
              ctx.nested_parser (this->referenceAllele_parser_);
            }
          }
          else
          {
            if (this->referenceAllele_parser_ != 0)
            {
              this->referenceAllele_parser_->post_string ();
              this->referenceAllele ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "cigar" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->cigar_parser_)
            {
              this->cigar_parser_->pre ();
              ctx.nested_parser (this->cigar_parser_);
            }
          }
          else
          {
            if (this->cigar_parser_ != 0)
            {
              this->cigar_parser_->post_string ();
              this->cigar ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "variantPointer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->variantPointer_parser_)
            {
              this->variantPointer_parser_->pre ();
              ctx.nested_parser (this->variantPointer_parser_);
            }
          }
          else
          {
            if (this->variantPointer_parser_ != 0)
            {
              this->variantPointer_parser_->post_Reference ();
              this->variantPointer ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_Quality_pskel.
  //
  bool MolecularSequence_Quality_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_Quality_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_Quality_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_Quality_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_Quality_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MolecularSequence_Quality_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_qualityType ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "standardSequence" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->standardSequence_parser_)
            {
              this->standardSequence_parser_->pre ();
              ctx.nested_parser (this->standardSequence_parser_);
            }
          }
          else
          {
            if (this->standardSequence_parser_ != 0)
            {
              this->standardSequence_parser_->post_CodeableConcept ();
              this->standardSequence ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "start" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->start_parser_)
            {
              this->start_parser_->pre ();
              ctx.nested_parser (this->start_parser_);
            }
          }
          else
          {
            if (this->start_parser_ != 0)
            {
              this->start_parser_->post_integer ();
              this->start ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "end" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->end_parser_)
            {
              this->end_parser_->pre ();
              ctx.nested_parser (this->end_parser_);
            }
          }
          else
          {
            if (this->end_parser_ != 0)
            {
              this->end_parser_->post_integer ();
              this->end ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "score" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->score_parser_)
            {
              this->score_parser_->pre ();
              ctx.nested_parser (this->score_parser_);
            }
          }
          else
          {
            if (this->score_parser_ != 0)
            {
              this->score_parser_->post_Quantity ();
              this->score ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "method" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->method_parser_)
            {
              this->method_parser_->pre ();
              ctx.nested_parser (this->method_parser_);
            }
          }
          else
          {
            if (this->method_parser_ != 0)
            {
              this->method_parser_->post_CodeableConcept ();
              this->method ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "truthTP" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->truthTP_parser_)
            {
              this->truthTP_parser_->pre ();
              ctx.nested_parser (this->truthTP_parser_);
            }
          }
          else
          {
            if (this->truthTP_parser_ != 0)
            {
              this->truthTP_parser_->post_decimal ();
              this->truthTP ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "queryTP" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->queryTP_parser_)
            {
              this->queryTP_parser_->pre ();
              ctx.nested_parser (this->queryTP_parser_);
            }
          }
          else
          {
            if (this->queryTP_parser_ != 0)
            {
              this->queryTP_parser_->post_decimal ();
              this->queryTP ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "truthFN" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->truthFN_parser_)
            {
              this->truthFN_parser_->pre ();
              ctx.nested_parser (this->truthFN_parser_);
            }
          }
          else
          {
            if (this->truthFN_parser_ != 0)
            {
              this->truthFN_parser_->post_decimal ();
              this->truthFN ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "queryFP" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->queryFP_parser_)
            {
              this->queryFP_parser_->pre ();
              ctx.nested_parser (this->queryFP_parser_);
            }
          }
          else
          {
            if (this->queryFP_parser_ != 0)
            {
              this->queryFP_parser_->post_decimal ();
              this->queryFP ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "gtFP" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->gtFP_parser_)
            {
              this->gtFP_parser_->pre ();
              ctx.nested_parser (this->gtFP_parser_);
            }
          }
          else
          {
            if (this->gtFP_parser_ != 0)
            {
              this->gtFP_parser_->post_decimal ();
              this->gtFP ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "precision" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->precision_parser_)
            {
              this->precision_parser_->pre ();
              ctx.nested_parser (this->precision_parser_);
            }
          }
          else
          {
            if (this->precision_parser_ != 0)
            {
              this->precision_parser_->post_decimal ();
              this->precision ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "recall" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->recall_parser_)
            {
              this->recall_parser_->pre ();
              ctx.nested_parser (this->recall_parser_);
            }
          }
          else
          {
            if (this->recall_parser_ != 0)
            {
              this->recall_parser_->post_decimal ();
              this->recall ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "fScore" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fScore_parser_)
            {
              this->fScore_parser_->pre ();
              ctx.nested_parser (this->fScore_parser_);
            }
          }
          else
          {
            if (this->fScore_parser_ != 0)
            {
              this->fScore_parser_->post_decimal ();
              this->fScore ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "roc" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->roc_parser_)
            {
              this->roc_parser_->pre ();
              ctx.nested_parser (this->roc_parser_);
            }
          }
          else
          {
            if (this->roc_parser_ != 0)
            {
              this->roc_parser_->post_MolecularSequence_Roc ();
              this->roc ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_Roc_pskel.
  //
  bool MolecularSequence_Roc_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "score" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "numTP" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "numFP" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "numFN" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "precision" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "sensitivity" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "fMeasure" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_Roc_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_Roc_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_Roc_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_Roc_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MolecularSequence_Roc_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "score" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->score_parser_)
            {
              this->score_parser_->pre ();
              ctx.nested_parser (this->score_parser_);
            }
          }
          else
          {
            if (this->score_parser_ != 0)
            {
              this->score_parser_->post_integer ();
              this->score ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "numTP" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->numTP_parser_)
            {
              this->numTP_parser_->pre ();
              ctx.nested_parser (this->numTP_parser_);
            }
          }
          else
          {
            if (this->numTP_parser_ != 0)
            {
              this->numTP_parser_->post_integer ();
              this->numTP ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "numFP" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->numFP_parser_)
            {
              this->numFP_parser_->pre ();
              ctx.nested_parser (this->numFP_parser_);
            }
          }
          else
          {
            if (this->numFP_parser_ != 0)
            {
              this->numFP_parser_->post_integer ();
              this->numFP ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "numFN" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->numFN_parser_)
            {
              this->numFN_parser_->pre ();
              ctx.nested_parser (this->numFN_parser_);
            }
          }
          else
          {
            if (this->numFN_parser_ != 0)
            {
              this->numFN_parser_->post_integer ();
              this->numFN ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "precision" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->precision_parser_)
            {
              this->precision_parser_->pre ();
              ctx.nested_parser (this->precision_parser_);
            }
          }
          else
          {
            if (this->precision_parser_ != 0)
            {
              this->precision_parser_->post_decimal ();
              this->precision ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "sensitivity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->sensitivity_parser_)
            {
              this->sensitivity_parser_->pre ();
              ctx.nested_parser (this->sensitivity_parser_);
            }
          }
          else
          {
            if (this->sensitivity_parser_ != 0)
            {
              this->sensitivity_parser_->post_decimal ();
              this->sensitivity ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "fMeasure" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fMeasure_parser_)
            {
              this->fMeasure_parser_->pre ();
              ctx.nested_parser (this->fMeasure_parser_);
            }
          }
          else
          {
            if (this->fMeasure_parser_ != 0)
            {
              this->fMeasure_parser_->post_decimal ();
              this->fMeasure ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_Repository_pskel.
  //
  bool MolecularSequence_Repository_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_Repository_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_Repository_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_Repository_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_Repository_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MolecularSequence_Repository_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_repositoryType ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_uri ();
              this->url ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "datasetId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->datasetId_parser_)
            {
              this->datasetId_parser_->pre ();
              ctx.nested_parser (this->datasetId_parser_);
            }
          }
          else
          {
            if (this->datasetId_parser_ != 0)
            {
              this->datasetId_parser_->post_string ();
              this->datasetId ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "variantsetId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->variantsetId_parser_)
            {
              this->variantsetId_parser_->pre ();
              ctx.nested_parser (this->variantsetId_parser_);
            }
          }
          else
          {
            if (this->variantsetId_parser_ != 0)
            {
              this->variantsetId_parser_->post_string ();
              this->variantsetId ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "readsetId" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->readsetId_parser_)
            {
              this->readsetId_parser_->pre ();
              ctx.nested_parser (this->readsetId_parser_);
            }
          }
          else
          {
            if (this->readsetId_parser_ != 0)
            {
              this->readsetId_parser_->post_string ();
              this->readsetId ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_StructureVariant_pskel.
  //
  bool MolecularSequence_StructureVariant_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "variantType" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "exact" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "length" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "outer" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "inner" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_StructureVariant_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_StructureVariant_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_StructureVariant_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_StructureVariant_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MolecularSequence_StructureVariant_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "variantType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->variantType_parser_)
            {
              this->variantType_parser_->pre ();
              ctx.nested_parser (this->variantType_parser_);
            }
          }
          else
          {
            if (this->variantType_parser_ != 0)
            {
              this->variantType_parser_->post_CodeableConcept ();
              this->variantType ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "exact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->exact_parser_)
            {
              this->exact_parser_->pre ();
              ctx.nested_parser (this->exact_parser_);
            }
          }
          else
          {
            if (this->exact_parser_ != 0)
            {
              this->exact_parser_->post_boolean ();
              this->exact ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "length" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->length_parser_)
            {
              this->length_parser_->pre ();
              ctx.nested_parser (this->length_parser_);
            }
          }
          else
          {
            if (this->length_parser_ != 0)
            {
              this->length_parser_->post_integer ();
              this->length ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "outer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->outer_parser_)
            {
              this->outer_parser_->pre ();
              ctx.nested_parser (this->outer_parser_);
            }
          }
          else
          {
            if (this->outer_parser_ != 0)
            {
              this->outer_parser_->post_MolecularSequence_Outer ();
              this->outer ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "inner" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->inner_parser_)
            {
              this->inner_parser_->pre ();
              ctx.nested_parser (this->inner_parser_);
            }
          }
          else
          {
            if (this->inner_parser_ != 0)
            {
              this->inner_parser_->post_MolecularSequence_Inner ();
              this->inner ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_Outer_pskel.
  //
  bool MolecularSequence_Outer_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "start" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "end" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_Outer_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_Outer_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_Outer_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_Outer_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MolecularSequence_Outer_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "start" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->start_parser_)
            {
              this->start_parser_->pre ();
              ctx.nested_parser (this->start_parser_);
            }
          }
          else
          {
            if (this->start_parser_ != 0)
            {
              this->start_parser_->post_integer ();
              this->start ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "end" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->end_parser_)
            {
              this->end_parser_->pre ();
              ctx.nested_parser (this->end_parser_);
            }
          }
          else
          {
            if (this->end_parser_ != 0)
            {
              this->end_parser_->post_integer ();
              this->end ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MolecularSequence_Inner_pskel.
  //
  bool MolecularSequence_Inner_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "start" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "end" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MolecularSequence_Inner_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MolecularSequence_Inner_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MolecularSequence_Inner_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MolecularSequence_Inner_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MolecularSequence_Inner_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "start" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->start_parser_)
            {
              this->start_parser_->pre ();
              ctx.nested_parser (this->start_parser_);
            }
          }
          else
          {
            if (this->start_parser_ != 0)
            {
              this->start_parser_->post_integer ();
              this->start ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "end" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->end_parser_)
            {
              this->end_parser_->pre ();
              ctx.nested_parser (this->end_parser_);
            }
          }
          else
          {
            if (this->end_parser_ != 0)
            {
              this->end_parser_->post_integer ();
              this->end ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
  // Attribute validation and dispatch functions for strandType_pskel.
  //
  bool strandType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_strandType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for orientationType_pskel.
  //
  bool orientationType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_orientationType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for repositoryType_pskel.
  //
  bool repositoryType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_repositoryType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for qualityType_pskel.
  //
  bool qualityType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_qualityType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for sequenceType_pskel.
  //
  bool sequenceType_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_sequenceType_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


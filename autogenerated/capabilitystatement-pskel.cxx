// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "capabilitystatement-pskel.hxx"

namespace fhir
{
  // CapabilityStatement_pskel
  //

  void CapabilityStatement_pskel::
  url_parser (::fhir::uri_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  version_parser (::fhir::string_pskel& p)
  {
    this->version_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  title_parser (::fhir::string_pskel& p)
  {
    this->title_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  status_parser (::fhir::PublicationStatus_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  experimental_parser (::fhir::boolean_pskel& p)
  {
    this->experimental_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  date_parser (::fhir::dateTime_pskel& p)
  {
    this->date_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  publisher_parser (::fhir::string_pskel& p)
  {
    this->publisher_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  contact_parser (::fhir::ContactDetail_pskel& p)
  {
    this->contact_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  description_parser (::fhir::markdown_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  useContext_parser (::fhir::UsageContext_pskel& p)
  {
    this->useContext_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  jurisdiction_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->jurisdiction_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  purpose_parser (::fhir::markdown_pskel& p)
  {
    this->purpose_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  copyright_parser (::fhir::markdown_pskel& p)
  {
    this->copyright_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  kind_parser (::fhir::CapabilityStatementKind_pskel& p)
  {
    this->kind_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  instantiates_parser (::fhir::canonical_pskel& p)
  {
    this->instantiates_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  imports_parser (::fhir::canonical_pskel& p)
  {
    this->imports_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  software_parser (::fhir::CapabilityStatement_Software_pskel& p)
  {
    this->software_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  implementation_parser (::fhir::CapabilityStatement_Implementation_pskel& p)
  {
    this->implementation_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  fhirVersion_parser (::fhir::FHIRVersion_pskel& p)
  {
    this->fhirVersion_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  format_parser (::fhir::code_pskel& p)
  {
    this->format_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  patchFormat_parser (::fhir::code_pskel& p)
  {
    this->patchFormat_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  implementationGuide_parser (::fhir::canonical_pskel& p)
  {
    this->implementationGuide_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  rest_parser (::fhir::CapabilityStatement_Rest_pskel& p)
  {
    this->rest_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  messaging_parser (::fhir::CapabilityStatement_Messaging_pskel& p)
  {
    this->messaging_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  document_parser (::fhir::CapabilityStatement_Document_pskel& p)
  {
    this->document_parser_ = &p;
  }

  void CapabilityStatement_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::uri_pskel& url,
           ::fhir::string_pskel& version,
           ::fhir::string_pskel& name,
           ::fhir::string_pskel& title,
           ::fhir::PublicationStatus_pskel& status,
           ::fhir::boolean_pskel& experimental,
           ::fhir::dateTime_pskel& date,
           ::fhir::string_pskel& publisher,
           ::fhir::ContactDetail_pskel& contact,
           ::fhir::markdown_pskel& description,
           ::fhir::UsageContext_pskel& useContext,
           ::fhir::CodeableConcept_pskel& jurisdiction,
           ::fhir::markdown_pskel& purpose,
           ::fhir::markdown_pskel& copyright,
           ::fhir::CapabilityStatementKind_pskel& kind,
           ::fhir::canonical_pskel& instantiates,
           ::fhir::canonical_pskel& imports,
           ::fhir::CapabilityStatement_Software_pskel& software,
           ::fhir::CapabilityStatement_Implementation_pskel& implementation,
           ::fhir::FHIRVersion_pskel& fhirVersion,
           ::fhir::code_pskel& format,
           ::fhir::code_pskel& patchFormat,
           ::fhir::canonical_pskel& implementationGuide,
           ::fhir::CapabilityStatement_Rest_pskel& rest,
           ::fhir::CapabilityStatement_Messaging_pskel& messaging,
           ::fhir::CapabilityStatement_Document_pskel& document)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->url_parser_ = &url;
    this->version_parser_ = &version;
    this->name_parser_ = &name;
    this->title_parser_ = &title;
    this->status_parser_ = &status;
    this->experimental_parser_ = &experimental;
    this->date_parser_ = &date;
    this->publisher_parser_ = &publisher;
    this->contact_parser_ = &contact;
    this->description_parser_ = &description;
    this->useContext_parser_ = &useContext;
    this->jurisdiction_parser_ = &jurisdiction;
    this->purpose_parser_ = &purpose;
    this->copyright_parser_ = &copyright;
    this->kind_parser_ = &kind;
    this->instantiates_parser_ = &instantiates;
    this->imports_parser_ = &imports;
    this->software_parser_ = &software;
    this->implementation_parser_ = &implementation;
    this->fhirVersion_parser_ = &fhirVersion;
    this->format_parser_ = &format;
    this->patchFormat_parser_ = &patchFormat;
    this->implementationGuide_parser_ = &implementationGuide;
    this->rest_parser_ = &rest;
    this->messaging_parser_ = &messaging;
    this->document_parser_ = &document;
  }

  CapabilityStatement_pskel::
  CapabilityStatement_pskel (::fhir::DomainResource_pskel* tiein)
  : ::fhir::DomainResource_pskel (tiein, 0),
    CapabilityStatement_impl_ (0),
    url_parser_ (0),
    version_parser_ (0),
    name_parser_ (0),
    title_parser_ (0),
    status_parser_ (0),
    experimental_parser_ (0),
    date_parser_ (0),
    publisher_parser_ (0),
    contact_parser_ (0),
    description_parser_ (0),
    useContext_parser_ (0),
    jurisdiction_parser_ (0),
    purpose_parser_ (0),
    copyright_parser_ (0),
    kind_parser_ (0),
    instantiates_parser_ (0),
    imports_parser_ (0),
    software_parser_ (0),
    implementation_parser_ (0),
    fhirVersion_parser_ (0),
    format_parser_ (0),
    patchFormat_parser_ (0),
    implementationGuide_parser_ (0),
    rest_parser_ (0),
    messaging_parser_ (0),
    document_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_pskel::
  CapabilityStatement_pskel (CapabilityStatement_pskel* impl, void*)
  : ::fhir::DomainResource_pskel (impl, 0),
    CapabilityStatement_impl_ (impl),
    url_parser_ (0),
    version_parser_ (0),
    name_parser_ (0),
    title_parser_ (0),
    status_parser_ (0),
    experimental_parser_ (0),
    date_parser_ (0),
    publisher_parser_ (0),
    contact_parser_ (0),
    description_parser_ (0),
    useContext_parser_ (0),
    jurisdiction_parser_ (0),
    purpose_parser_ (0),
    copyright_parser_ (0),
    kind_parser_ (0),
    instantiates_parser_ (0),
    imports_parser_ (0),
    software_parser_ (0),
    implementation_parser_ (0),
    fhirVersion_parser_ (0),
    format_parser_ (0),
    patchFormat_parser_ (0),
    implementationGuide_parser_ (0),
    rest_parser_ (0),
    messaging_parser_ (0),
    document_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Software_pskel
  //

  void CapabilityStatement_Software_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void CapabilityStatement_Software_pskel::
  version_parser (::fhir::string_pskel& p)
  {
    this->version_parser_ = &p;
  }

  void CapabilityStatement_Software_pskel::
  releaseDate_parser (::fhir::dateTime_pskel& p)
  {
    this->releaseDate_parser_ = &p;
  }

  void CapabilityStatement_Software_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& name,
           ::fhir::string_pskel& version,
           ::fhir::dateTime_pskel& releaseDate)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->name_parser_ = &name;
    this->version_parser_ = &version;
    this->releaseDate_parser_ = &releaseDate;
  }

  CapabilityStatement_Software_pskel::
  CapabilityStatement_Software_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Software_impl_ (0),
    name_parser_ (0),
    version_parser_ (0),
    releaseDate_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Software_pskel::
  CapabilityStatement_Software_pskel (CapabilityStatement_Software_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Software_impl_ (impl),
    name_parser_ (0),
    version_parser_ (0),
    releaseDate_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Implementation_pskel
  //

  void CapabilityStatement_Implementation_pskel::
  description_parser (::fhir::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void CapabilityStatement_Implementation_pskel::
  url_parser (::fhir::url_pskel& p)
  {
    this->url_parser_ = &p;
  }

  void CapabilityStatement_Implementation_pskel::
  custodian_parser (::fhir::Reference_pskel& p)
  {
    this->custodian_parser_ = &p;
  }

  void CapabilityStatement_Implementation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& description,
           ::fhir::url_pskel& url,
           ::fhir::Reference_pskel& custodian)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->description_parser_ = &description;
    this->url_parser_ = &url;
    this->custodian_parser_ = &custodian;
  }

  CapabilityStatement_Implementation_pskel::
  CapabilityStatement_Implementation_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Implementation_impl_ (0),
    description_parser_ (0),
    url_parser_ (0),
    custodian_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Implementation_pskel::
  CapabilityStatement_Implementation_pskel (CapabilityStatement_Implementation_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Implementation_impl_ (impl),
    description_parser_ (0),
    url_parser_ (0),
    custodian_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Rest_pskel
  //

  void CapabilityStatement_Rest_pskel::
  mode_parser (::fhir::RestfulCapabilityMode_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  security_parser (::fhir::CapabilityStatement_Security_pskel& p)
  {
    this->security_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  resource_parser (::fhir::CapabilityStatement_Resource_pskel& p)
  {
    this->resource_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  interaction_parser (::fhir::CapabilityStatement_Interaction1_pskel& p)
  {
    this->interaction_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  searchParam_parser (::fhir::CapabilityStatement_SearchParam_pskel& p)
  {
    this->searchParam_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  operation_parser (::fhir::CapabilityStatement_Operation_pskel& p)
  {
    this->operation_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  compartment_parser (::fhir::canonical_pskel& p)
  {
    this->compartment_parser_ = &p;
  }

  void CapabilityStatement_Rest_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::RestfulCapabilityMode_pskel& mode,
           ::fhir::markdown_pskel& documentation,
           ::fhir::CapabilityStatement_Security_pskel& security,
           ::fhir::CapabilityStatement_Resource_pskel& resource,
           ::fhir::CapabilityStatement_Interaction1_pskel& interaction,
           ::fhir::CapabilityStatement_SearchParam_pskel& searchParam,
           ::fhir::CapabilityStatement_Operation_pskel& operation,
           ::fhir::canonical_pskel& compartment)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->mode_parser_ = &mode;
    this->documentation_parser_ = &documentation;
    this->security_parser_ = &security;
    this->resource_parser_ = &resource;
    this->interaction_parser_ = &interaction;
    this->searchParam_parser_ = &searchParam;
    this->operation_parser_ = &operation;
    this->compartment_parser_ = &compartment;
  }

  CapabilityStatement_Rest_pskel::
  CapabilityStatement_Rest_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Rest_impl_ (0),
    mode_parser_ (0),
    documentation_parser_ (0),
    security_parser_ (0),
    resource_parser_ (0),
    interaction_parser_ (0),
    searchParam_parser_ (0),
    operation_parser_ (0),
    compartment_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Rest_pskel::
  CapabilityStatement_Rest_pskel (CapabilityStatement_Rest_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Rest_impl_ (impl),
    mode_parser_ (0),
    documentation_parser_ (0),
    security_parser_ (0),
    resource_parser_ (0),
    interaction_parser_ (0),
    searchParam_parser_ (0),
    operation_parser_ (0),
    compartment_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Security_pskel
  //

  void CapabilityStatement_Security_pskel::
  cors_parser (::fhir::boolean_pskel& p)
  {
    this->cors_parser_ = &p;
  }

  void CapabilityStatement_Security_pskel::
  service_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->service_parser_ = &p;
  }

  void CapabilityStatement_Security_pskel::
  description_parser (::fhir::markdown_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void CapabilityStatement_Security_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::boolean_pskel& cors,
           ::fhir::CodeableConcept_pskel& service,
           ::fhir::markdown_pskel& description)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->cors_parser_ = &cors;
    this->service_parser_ = &service;
    this->description_parser_ = &description;
  }

  CapabilityStatement_Security_pskel::
  CapabilityStatement_Security_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Security_impl_ (0),
    cors_parser_ (0),
    service_parser_ (0),
    description_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Security_pskel::
  CapabilityStatement_Security_pskel (CapabilityStatement_Security_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Security_impl_ (impl),
    cors_parser_ (0),
    service_parser_ (0),
    description_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Resource_pskel
  //

  void CapabilityStatement_Resource_pskel::
  type_parser (::fhir::code_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  profile_parser (::fhir::canonical_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  supportedProfile_parser (::fhir::canonical_pskel& p)
  {
    this->supportedProfile_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  interaction_parser (::fhir::CapabilityStatement_Interaction_pskel& p)
  {
    this->interaction_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  versioning_parser (::fhir::ResourceVersionPolicy_pskel& p)
  {
    this->versioning_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  readHistory_parser (::fhir::boolean_pskel& p)
  {
    this->readHistory_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  updateCreate_parser (::fhir::boolean_pskel& p)
  {
    this->updateCreate_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  conditionalCreate_parser (::fhir::boolean_pskel& p)
  {
    this->conditionalCreate_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  conditionalRead_parser (::fhir::ConditionalReadStatus_pskel& p)
  {
    this->conditionalRead_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  conditionalUpdate_parser (::fhir::boolean_pskel& p)
  {
    this->conditionalUpdate_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  conditionalDelete_parser (::fhir::ConditionalDeleteStatus_pskel& p)
  {
    this->conditionalDelete_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  referencePolicy_parser (::fhir::ReferenceHandlingPolicy_pskel& p)
  {
    this->referencePolicy_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  searchInclude_parser (::fhir::string_pskel& p)
  {
    this->searchInclude_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  searchRevInclude_parser (::fhir::string_pskel& p)
  {
    this->searchRevInclude_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  searchParam_parser (::fhir::CapabilityStatement_SearchParam_pskel& p)
  {
    this->searchParam_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  operation_parser (::fhir::CapabilityStatement_Operation_pskel& p)
  {
    this->operation_parser_ = &p;
  }

  void CapabilityStatement_Resource_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::code_pskel& type,
           ::fhir::canonical_pskel& profile,
           ::fhir::canonical_pskel& supportedProfile,
           ::fhir::markdown_pskel& documentation,
           ::fhir::CapabilityStatement_Interaction_pskel& interaction,
           ::fhir::ResourceVersionPolicy_pskel& versioning,
           ::fhir::boolean_pskel& readHistory,
           ::fhir::boolean_pskel& updateCreate,
           ::fhir::boolean_pskel& conditionalCreate,
           ::fhir::ConditionalReadStatus_pskel& conditionalRead,
           ::fhir::boolean_pskel& conditionalUpdate,
           ::fhir::ConditionalDeleteStatus_pskel& conditionalDelete,
           ::fhir::ReferenceHandlingPolicy_pskel& referencePolicy,
           ::fhir::string_pskel& searchInclude,
           ::fhir::string_pskel& searchRevInclude,
           ::fhir::CapabilityStatement_SearchParam_pskel& searchParam,
           ::fhir::CapabilityStatement_Operation_pskel& operation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->profile_parser_ = &profile;
    this->supportedProfile_parser_ = &supportedProfile;
    this->documentation_parser_ = &documentation;
    this->interaction_parser_ = &interaction;
    this->versioning_parser_ = &versioning;
    this->readHistory_parser_ = &readHistory;
    this->updateCreate_parser_ = &updateCreate;
    this->conditionalCreate_parser_ = &conditionalCreate;
    this->conditionalRead_parser_ = &conditionalRead;
    this->conditionalUpdate_parser_ = &conditionalUpdate;
    this->conditionalDelete_parser_ = &conditionalDelete;
    this->referencePolicy_parser_ = &referencePolicy;
    this->searchInclude_parser_ = &searchInclude;
    this->searchRevInclude_parser_ = &searchRevInclude;
    this->searchParam_parser_ = &searchParam;
    this->operation_parser_ = &operation;
  }

  CapabilityStatement_Resource_pskel::
  CapabilityStatement_Resource_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Resource_impl_ (0),
    type_parser_ (0),
    profile_parser_ (0),
    supportedProfile_parser_ (0),
    documentation_parser_ (0),
    interaction_parser_ (0),
    versioning_parser_ (0),
    readHistory_parser_ (0),
    updateCreate_parser_ (0),
    conditionalCreate_parser_ (0),
    conditionalRead_parser_ (0),
    conditionalUpdate_parser_ (0),
    conditionalDelete_parser_ (0),
    referencePolicy_parser_ (0),
    searchInclude_parser_ (0),
    searchRevInclude_parser_ (0),
    searchParam_parser_ (0),
    operation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Resource_pskel::
  CapabilityStatement_Resource_pskel (CapabilityStatement_Resource_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Resource_impl_ (impl),
    type_parser_ (0),
    profile_parser_ (0),
    supportedProfile_parser_ (0),
    documentation_parser_ (0),
    interaction_parser_ (0),
    versioning_parser_ (0),
    readHistory_parser_ (0),
    updateCreate_parser_ (0),
    conditionalCreate_parser_ (0),
    conditionalRead_parser_ (0),
    conditionalUpdate_parser_ (0),
    conditionalDelete_parser_ (0),
    referencePolicy_parser_ (0),
    searchInclude_parser_ (0),
    searchRevInclude_parser_ (0),
    searchParam_parser_ (0),
    operation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Interaction_pskel
  //

  void CapabilityStatement_Interaction_pskel::
  code_parser (::fhir::TypeRestfulInteraction_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void CapabilityStatement_Interaction_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Interaction_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::TypeRestfulInteraction_pskel& code,
           ::fhir::markdown_pskel& documentation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->code_parser_ = &code;
    this->documentation_parser_ = &documentation;
  }

  CapabilityStatement_Interaction_pskel::
  CapabilityStatement_Interaction_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Interaction_impl_ (0),
    code_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Interaction_pskel::
  CapabilityStatement_Interaction_pskel (CapabilityStatement_Interaction_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Interaction_impl_ (impl),
    code_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_SearchParam_pskel
  //

  void CapabilityStatement_SearchParam_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void CapabilityStatement_SearchParam_pskel::
  definition_parser (::fhir::canonical_pskel& p)
  {
    this->definition_parser_ = &p;
  }

  void CapabilityStatement_SearchParam_pskel::
  type_parser (::fhir::SearchParamType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void CapabilityStatement_SearchParam_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_SearchParam_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& name,
           ::fhir::canonical_pskel& definition,
           ::fhir::SearchParamType_pskel& type,
           ::fhir::markdown_pskel& documentation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->name_parser_ = &name;
    this->definition_parser_ = &definition;
    this->type_parser_ = &type;
    this->documentation_parser_ = &documentation;
  }

  CapabilityStatement_SearchParam_pskel::
  CapabilityStatement_SearchParam_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_SearchParam_impl_ (0),
    name_parser_ (0),
    definition_parser_ (0),
    type_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_SearchParam_pskel::
  CapabilityStatement_SearchParam_pskel (CapabilityStatement_SearchParam_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_SearchParam_impl_ (impl),
    name_parser_ (0),
    definition_parser_ (0),
    type_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Operation_pskel
  //

  void CapabilityStatement_Operation_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void CapabilityStatement_Operation_pskel::
  definition_parser (::fhir::canonical_pskel& p)
  {
    this->definition_parser_ = &p;
  }

  void CapabilityStatement_Operation_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Operation_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::string_pskel& name,
           ::fhir::canonical_pskel& definition,
           ::fhir::markdown_pskel& documentation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->name_parser_ = &name;
    this->definition_parser_ = &definition;
    this->documentation_parser_ = &documentation;
  }

  CapabilityStatement_Operation_pskel::
  CapabilityStatement_Operation_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Operation_impl_ (0),
    name_parser_ (0),
    definition_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Operation_pskel::
  CapabilityStatement_Operation_pskel (CapabilityStatement_Operation_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Operation_impl_ (impl),
    name_parser_ (0),
    definition_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Interaction1_pskel
  //

  void CapabilityStatement_Interaction1_pskel::
  code_parser (::fhir::SystemRestfulInteraction_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void CapabilityStatement_Interaction1_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Interaction1_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::SystemRestfulInteraction_pskel& code,
           ::fhir::markdown_pskel& documentation)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->code_parser_ = &code;
    this->documentation_parser_ = &documentation;
  }

  CapabilityStatement_Interaction1_pskel::
  CapabilityStatement_Interaction1_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Interaction1_impl_ (0),
    code_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Interaction1_pskel::
  CapabilityStatement_Interaction1_pskel (CapabilityStatement_Interaction1_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Interaction1_impl_ (impl),
    code_parser_ (0),
    documentation_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Messaging_pskel
  //

  void CapabilityStatement_Messaging_pskel::
  endpoint_parser (::fhir::CapabilityStatement_Endpoint_pskel& p)
  {
    this->endpoint_parser_ = &p;
  }

  void CapabilityStatement_Messaging_pskel::
  reliableCache_parser (::fhir::unsignedInt_pskel& p)
  {
    this->reliableCache_parser_ = &p;
  }

  void CapabilityStatement_Messaging_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Messaging_pskel::
  supportedMessage_parser (::fhir::CapabilityStatement_SupportedMessage_pskel& p)
  {
    this->supportedMessage_parser_ = &p;
  }

  void CapabilityStatement_Messaging_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CapabilityStatement_Endpoint_pskel& endpoint,
           ::fhir::unsignedInt_pskel& reliableCache,
           ::fhir::markdown_pskel& documentation,
           ::fhir::CapabilityStatement_SupportedMessage_pskel& supportedMessage)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->endpoint_parser_ = &endpoint;
    this->reliableCache_parser_ = &reliableCache;
    this->documentation_parser_ = &documentation;
    this->supportedMessage_parser_ = &supportedMessage;
  }

  CapabilityStatement_Messaging_pskel::
  CapabilityStatement_Messaging_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Messaging_impl_ (0),
    endpoint_parser_ (0),
    reliableCache_parser_ (0),
    documentation_parser_ (0),
    supportedMessage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Messaging_pskel::
  CapabilityStatement_Messaging_pskel (CapabilityStatement_Messaging_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Messaging_impl_ (impl),
    endpoint_parser_ (0),
    reliableCache_parser_ (0),
    documentation_parser_ (0),
    supportedMessage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Endpoint_pskel
  //

  void CapabilityStatement_Endpoint_pskel::
  protocol_parser (::fhir::Coding_pskel& p)
  {
    this->protocol_parser_ = &p;
  }

  void CapabilityStatement_Endpoint_pskel::
  address_parser (::fhir::url_pskel& p)
  {
    this->address_parser_ = &p;
  }

  void CapabilityStatement_Endpoint_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Coding_pskel& protocol,
           ::fhir::url_pskel& address)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->protocol_parser_ = &protocol;
    this->address_parser_ = &address;
  }

  CapabilityStatement_Endpoint_pskel::
  CapabilityStatement_Endpoint_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Endpoint_impl_ (0),
    protocol_parser_ (0),
    address_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Endpoint_pskel::
  CapabilityStatement_Endpoint_pskel (CapabilityStatement_Endpoint_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Endpoint_impl_ (impl),
    protocol_parser_ (0),
    address_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_SupportedMessage_pskel
  //

  void CapabilityStatement_SupportedMessage_pskel::
  mode_parser (::fhir::EventCapabilityMode_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void CapabilityStatement_SupportedMessage_pskel::
  definition_parser (::fhir::canonical_pskel& p)
  {
    this->definition_parser_ = &p;
  }

  void CapabilityStatement_SupportedMessage_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::EventCapabilityMode_pskel& mode,
           ::fhir::canonical_pskel& definition)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->mode_parser_ = &mode;
    this->definition_parser_ = &definition;
  }

  CapabilityStatement_SupportedMessage_pskel::
  CapabilityStatement_SupportedMessage_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_SupportedMessage_impl_ (0),
    mode_parser_ (0),
    definition_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_SupportedMessage_pskel::
  CapabilityStatement_SupportedMessage_pskel (CapabilityStatement_SupportedMessage_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_SupportedMessage_impl_ (impl),
    mode_parser_ (0),
    definition_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatement_Document_pskel
  //

  void CapabilityStatement_Document_pskel::
  mode_parser (::fhir::DocumentMode_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void CapabilityStatement_Document_pskel::
  documentation_parser (::fhir::markdown_pskel& p)
  {
    this->documentation_parser_ = &p;
  }

  void CapabilityStatement_Document_pskel::
  profile_parser (::fhir::canonical_pskel& p)
  {
    this->profile_parser_ = &p;
  }

  void CapabilityStatement_Document_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::DocumentMode_pskel& mode,
           ::fhir::markdown_pskel& documentation,
           ::fhir::canonical_pskel& profile)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->mode_parser_ = &mode;
    this->documentation_parser_ = &documentation;
    this->profile_parser_ = &profile;
  }

  CapabilityStatement_Document_pskel::
  CapabilityStatement_Document_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    CapabilityStatement_Document_impl_ (0),
    mode_parser_ (0),
    documentation_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  CapabilityStatement_Document_pskel::
  CapabilityStatement_Document_pskel (CapabilityStatement_Document_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    CapabilityStatement_Document_impl_ (impl),
    mode_parser_ (0),
    documentation_parser_ (0),
    profile_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // CapabilityStatementKind_list_pskel
  //

  CapabilityStatementKind_list_pskel::
  CapabilityStatementKind_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    CapabilityStatementKind_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_CapabilityStatementKind_list_pskel_enums_, 3UL);
  }

  CapabilityStatementKind_list_pskel::
  CapabilityStatementKind_list_pskel (CapabilityStatementKind_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    CapabilityStatementKind_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_CapabilityStatementKind_list_pskel_enums_, 3UL);
  }

  // CapabilityStatementKind_pskel
  //

  void CapabilityStatementKind_pskel::
  value_parser (::fhir::CapabilityStatementKind_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void CapabilityStatementKind_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::CapabilityStatementKind_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  CapabilityStatementKind_pskel::
  CapabilityStatementKind_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    CapabilityStatementKind_impl_ (0),
    value_parser_ (0)
  {
  }

  CapabilityStatementKind_pskel::
  CapabilityStatementKind_pskel (CapabilityStatementKind_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    CapabilityStatementKind_impl_ (impl),
    value_parser_ (0)
  {
  }

  // EventCapabilityMode_list_pskel
  //

  EventCapabilityMode_list_pskel::
  EventCapabilityMode_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    EventCapabilityMode_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_EventCapabilityMode_list_pskel_enums_, 2UL);
  }

  EventCapabilityMode_list_pskel::
  EventCapabilityMode_list_pskel (EventCapabilityMode_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    EventCapabilityMode_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_EventCapabilityMode_list_pskel_enums_, 2UL);
  }

  // EventCapabilityMode_pskel
  //

  void EventCapabilityMode_pskel::
  value_parser (::fhir::EventCapabilityMode_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void EventCapabilityMode_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::EventCapabilityMode_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  EventCapabilityMode_pskel::
  EventCapabilityMode_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    EventCapabilityMode_impl_ (0),
    value_parser_ (0)
  {
  }

  EventCapabilityMode_pskel::
  EventCapabilityMode_pskel (EventCapabilityMode_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    EventCapabilityMode_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ResourceVersionPolicy_list_pskel
  //

  ResourceVersionPolicy_list_pskel::
  ResourceVersionPolicy_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ResourceVersionPolicy_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ResourceVersionPolicy_list_pskel_enums_, 3UL);
  }

  ResourceVersionPolicy_list_pskel::
  ResourceVersionPolicy_list_pskel (ResourceVersionPolicy_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ResourceVersionPolicy_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ResourceVersionPolicy_list_pskel_enums_, 3UL);
  }

  // ResourceVersionPolicy_pskel
  //

  void ResourceVersionPolicy_pskel::
  value_parser (::fhir::ResourceVersionPolicy_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ResourceVersionPolicy_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ResourceVersionPolicy_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ResourceVersionPolicy_pskel::
  ResourceVersionPolicy_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ResourceVersionPolicy_impl_ (0),
    value_parser_ (0)
  {
  }

  ResourceVersionPolicy_pskel::
  ResourceVersionPolicy_pskel (ResourceVersionPolicy_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ResourceVersionPolicy_impl_ (impl),
    value_parser_ (0)
  {
  }

  // DocumentMode_list_pskel
  //

  DocumentMode_list_pskel::
  DocumentMode_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    DocumentMode_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_DocumentMode_list_pskel_enums_, 2UL);
  }

  DocumentMode_list_pskel::
  DocumentMode_list_pskel (DocumentMode_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    DocumentMode_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_DocumentMode_list_pskel_enums_, 2UL);
  }

  // DocumentMode_pskel
  //

  void DocumentMode_pskel::
  value_parser (::fhir::DocumentMode_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void DocumentMode_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::DocumentMode_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  DocumentMode_pskel::
  DocumentMode_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    DocumentMode_impl_ (0),
    value_parser_ (0)
  {
  }

  DocumentMode_pskel::
  DocumentMode_pskel (DocumentMode_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    DocumentMode_impl_ (impl),
    value_parser_ (0)
  {
  }

  // RestfulCapabilityMode_list_pskel
  //

  RestfulCapabilityMode_list_pskel::
  RestfulCapabilityMode_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    RestfulCapabilityMode_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_RestfulCapabilityMode_list_pskel_enums_, 2UL);
  }

  RestfulCapabilityMode_list_pskel::
  RestfulCapabilityMode_list_pskel (RestfulCapabilityMode_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    RestfulCapabilityMode_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_RestfulCapabilityMode_list_pskel_enums_, 2UL);
  }

  // RestfulCapabilityMode_pskel
  //

  void RestfulCapabilityMode_pskel::
  value_parser (::fhir::RestfulCapabilityMode_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void RestfulCapabilityMode_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::RestfulCapabilityMode_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  RestfulCapabilityMode_pskel::
  RestfulCapabilityMode_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    RestfulCapabilityMode_impl_ (0),
    value_parser_ (0)
  {
  }

  RestfulCapabilityMode_pskel::
  RestfulCapabilityMode_pskel (RestfulCapabilityMode_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    RestfulCapabilityMode_impl_ (impl),
    value_parser_ (0)
  {
  }

  // TypeRestfulInteraction_list_pskel
  //

  TypeRestfulInteraction_list_pskel::
  TypeRestfulInteraction_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    TypeRestfulInteraction_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_TypeRestfulInteraction_list_pskel_enums_, 9UL);
  }

  TypeRestfulInteraction_list_pskel::
  TypeRestfulInteraction_list_pskel (TypeRestfulInteraction_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    TypeRestfulInteraction_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_TypeRestfulInteraction_list_pskel_enums_, 9UL);
  }

  // TypeRestfulInteraction_pskel
  //

  void TypeRestfulInteraction_pskel::
  value_parser (::fhir::TypeRestfulInteraction_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void TypeRestfulInteraction_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::TypeRestfulInteraction_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  TypeRestfulInteraction_pskel::
  TypeRestfulInteraction_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    TypeRestfulInteraction_impl_ (0),
    value_parser_ (0)
  {
  }

  TypeRestfulInteraction_pskel::
  TypeRestfulInteraction_pskel (TypeRestfulInteraction_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    TypeRestfulInteraction_impl_ (impl),
    value_parser_ (0)
  {
  }

  // SystemRestfulInteraction_list_pskel
  //

  SystemRestfulInteraction_list_pskel::
  SystemRestfulInteraction_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    SystemRestfulInteraction_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_SystemRestfulInteraction_list_pskel_enums_, 4UL);
  }

  SystemRestfulInteraction_list_pskel::
  SystemRestfulInteraction_list_pskel (SystemRestfulInteraction_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    SystemRestfulInteraction_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_SystemRestfulInteraction_list_pskel_enums_, 4UL);
  }

  // SystemRestfulInteraction_pskel
  //

  void SystemRestfulInteraction_pskel::
  value_parser (::fhir::SystemRestfulInteraction_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void SystemRestfulInteraction_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::SystemRestfulInteraction_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  SystemRestfulInteraction_pskel::
  SystemRestfulInteraction_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    SystemRestfulInteraction_impl_ (0),
    value_parser_ (0)
  {
  }

  SystemRestfulInteraction_pskel::
  SystemRestfulInteraction_pskel (SystemRestfulInteraction_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    SystemRestfulInteraction_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ConditionalReadStatus_list_pskel
  //

  ConditionalReadStatus_list_pskel::
  ConditionalReadStatus_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ConditionalReadStatus_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ConditionalReadStatus_list_pskel_enums_, 4UL);
  }

  ConditionalReadStatus_list_pskel::
  ConditionalReadStatus_list_pskel (ConditionalReadStatus_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ConditionalReadStatus_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ConditionalReadStatus_list_pskel_enums_, 4UL);
  }

  // ConditionalReadStatus_pskel
  //

  void ConditionalReadStatus_pskel::
  value_parser (::fhir::ConditionalReadStatus_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ConditionalReadStatus_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ConditionalReadStatus_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ConditionalReadStatus_pskel::
  ConditionalReadStatus_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ConditionalReadStatus_impl_ (0),
    value_parser_ (0)
  {
  }

  ConditionalReadStatus_pskel::
  ConditionalReadStatus_pskel (ConditionalReadStatus_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ConditionalReadStatus_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ReferenceHandlingPolicy_list_pskel
  //

  ReferenceHandlingPolicy_list_pskel::
  ReferenceHandlingPolicy_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ReferenceHandlingPolicy_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ReferenceHandlingPolicy_list_pskel_enums_, 5UL);
  }

  ReferenceHandlingPolicy_list_pskel::
  ReferenceHandlingPolicy_list_pskel (ReferenceHandlingPolicy_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ReferenceHandlingPolicy_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ReferenceHandlingPolicy_list_pskel_enums_, 5UL);
  }

  // ReferenceHandlingPolicy_pskel
  //

  void ReferenceHandlingPolicy_pskel::
  value_parser (::fhir::ReferenceHandlingPolicy_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ReferenceHandlingPolicy_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ReferenceHandlingPolicy_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ReferenceHandlingPolicy_pskel::
  ReferenceHandlingPolicy_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ReferenceHandlingPolicy_impl_ (0),
    value_parser_ (0)
  {
  }

  ReferenceHandlingPolicy_pskel::
  ReferenceHandlingPolicy_pskel (ReferenceHandlingPolicy_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ReferenceHandlingPolicy_impl_ (impl),
    value_parser_ (0)
  {
  }

  // ConditionalDeleteStatus_list_pskel
  //

  ConditionalDeleteStatus_list_pskel::
  ConditionalDeleteStatus_list_pskel (::fhir::code_primitive_pskel* tiein)
  : ::fhir::code_primitive_pskel (tiein, 0),
    ConditionalDeleteStatus_list_impl_ (0)
  {
    this->_enumeration_facet (_xsde_ConditionalDeleteStatus_list_pskel_enums_, 3UL);
  }

  ConditionalDeleteStatus_list_pskel::
  ConditionalDeleteStatus_list_pskel (ConditionalDeleteStatus_list_pskel* impl, void*)
  : ::fhir::code_primitive_pskel (impl, 0),
    ConditionalDeleteStatus_list_impl_ (impl)
  {
    this->_enumeration_facet (_xsde_ConditionalDeleteStatus_list_pskel_enums_, 3UL);
  }

  // ConditionalDeleteStatus_pskel
  //

  void ConditionalDeleteStatus_pskel::
  value_parser (::fhir::ConditionalDeleteStatus_list_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void ConditionalDeleteStatus_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::ConditionalDeleteStatus_list_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->value_parser_ = &value;
  }

  ConditionalDeleteStatus_pskel::
  ConditionalDeleteStatus_pskel (::fhir::Element_pskel* tiein)
  : ::fhir::Element_pskel (tiein, 0),
    ConditionalDeleteStatus_impl_ (0),
    value_parser_ (0)
  {
  }

  ConditionalDeleteStatus_pskel::
  ConditionalDeleteStatus_pskel (ConditionalDeleteStatus_pskel* impl, void*)
  : ::fhir::Element_pskel (impl, 0),
    ConditionalDeleteStatus_impl_ (impl),
    value_parser_ (0)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // CapabilityStatement_pskel
  //

  void CapabilityStatement_pskel::
  url ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->url ();
  }

  void CapabilityStatement_pskel::
  version ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->version ();
  }

  void CapabilityStatement_pskel::
  name ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->name ();
  }

  void CapabilityStatement_pskel::
  title ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->title ();
  }

  void CapabilityStatement_pskel::
  status ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->status ();
  }

  void CapabilityStatement_pskel::
  experimental ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->experimental ();
  }

  void CapabilityStatement_pskel::
  date ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->date ();
  }

  void CapabilityStatement_pskel::
  publisher ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->publisher ();
  }

  void CapabilityStatement_pskel::
  contact ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->contact ();
  }

  void CapabilityStatement_pskel::
  description ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->description ();
  }

  void CapabilityStatement_pskel::
  useContext ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->useContext ();
  }

  void CapabilityStatement_pskel::
  jurisdiction ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->jurisdiction ();
  }

  void CapabilityStatement_pskel::
  purpose ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->purpose ();
  }

  void CapabilityStatement_pskel::
  copyright ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->copyright ();
  }

  void CapabilityStatement_pskel::
  kind ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->kind ();
  }

  void CapabilityStatement_pskel::
  instantiates ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->instantiates ();
  }

  void CapabilityStatement_pskel::
  imports ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->imports ();
  }

  void CapabilityStatement_pskel::
  software ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->software ();
  }

  void CapabilityStatement_pskel::
  implementation ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->implementation ();
  }

  void CapabilityStatement_pskel::
  fhirVersion ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->fhirVersion ();
  }

  void CapabilityStatement_pskel::
  format ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->format ();
  }

  void CapabilityStatement_pskel::
  patchFormat ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->patchFormat ();
  }

  void CapabilityStatement_pskel::
  implementationGuide ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->implementationGuide ();
  }

  void CapabilityStatement_pskel::
  rest ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->rest ();
  }

  void CapabilityStatement_pskel::
  messaging ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->messaging ();
  }

  void CapabilityStatement_pskel::
  document ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->document ();
  }

  void CapabilityStatement_pskel::
  post_CapabilityStatement ()
  {
    if (this->CapabilityStatement_impl_)
      this->CapabilityStatement_impl_->post_CapabilityStatement ();
    else
      post_DomainResource ();
  }

  void CapabilityStatement_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::DomainResource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->version_parser_)
      this->version_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->title_parser_)
      this->title_parser_->_reset ();

    if (this->status_parser_)
      this->status_parser_->_reset ();

    if (this->experimental_parser_)
      this->experimental_parser_->_reset ();

    if (this->date_parser_)
      this->date_parser_->_reset ();

    if (this->publisher_parser_)
      this->publisher_parser_->_reset ();

    if (this->contact_parser_)
      this->contact_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->useContext_parser_)
      this->useContext_parser_->_reset ();

    if (this->jurisdiction_parser_)
      this->jurisdiction_parser_->_reset ();

    if (this->purpose_parser_)
      this->purpose_parser_->_reset ();

    if (this->copyright_parser_)
      this->copyright_parser_->_reset ();

    if (this->kind_parser_)
      this->kind_parser_->_reset ();

    if (this->instantiates_parser_)
      this->instantiates_parser_->_reset ();

    if (this->imports_parser_)
      this->imports_parser_->_reset ();

    if (this->software_parser_)
      this->software_parser_->_reset ();

    if (this->implementation_parser_)
      this->implementation_parser_->_reset ();

    if (this->fhirVersion_parser_)
      this->fhirVersion_parser_->_reset ();

    if (this->format_parser_)
      this->format_parser_->_reset ();

    if (this->patchFormat_parser_)
      this->patchFormat_parser_->_reset ();

    if (this->implementationGuide_parser_)
      this->implementationGuide_parser_->_reset ();

    if (this->rest_parser_)
      this->rest_parser_->_reset ();

    if (this->messaging_parser_)
      this->messaging_parser_->_reset ();

    if (this->document_parser_)
      this->document_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Software_pskel
  //

  void CapabilityStatement_Software_pskel::
  name ()
  {
    if (this->CapabilityStatement_Software_impl_)
      this->CapabilityStatement_Software_impl_->name ();
  }

  void CapabilityStatement_Software_pskel::
  version ()
  {
    if (this->CapabilityStatement_Software_impl_)
      this->CapabilityStatement_Software_impl_->version ();
  }

  void CapabilityStatement_Software_pskel::
  releaseDate ()
  {
    if (this->CapabilityStatement_Software_impl_)
      this->CapabilityStatement_Software_impl_->releaseDate ();
  }

  void CapabilityStatement_Software_pskel::
  post_CapabilityStatement_Software ()
  {
    if (this->CapabilityStatement_Software_impl_)
      this->CapabilityStatement_Software_impl_->post_CapabilityStatement_Software ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Software_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->version_parser_)
      this->version_parser_->_reset ();

    if (this->releaseDate_parser_)
      this->releaseDate_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Implementation_pskel
  //

  void CapabilityStatement_Implementation_pskel::
  description ()
  {
    if (this->CapabilityStatement_Implementation_impl_)
      this->CapabilityStatement_Implementation_impl_->description ();
  }

  void CapabilityStatement_Implementation_pskel::
  url ()
  {
    if (this->CapabilityStatement_Implementation_impl_)
      this->CapabilityStatement_Implementation_impl_->url ();
  }

  void CapabilityStatement_Implementation_pskel::
  custodian ()
  {
    if (this->CapabilityStatement_Implementation_impl_)
      this->CapabilityStatement_Implementation_impl_->custodian ();
  }

  void CapabilityStatement_Implementation_pskel::
  post_CapabilityStatement_Implementation ()
  {
    if (this->CapabilityStatement_Implementation_impl_)
      this->CapabilityStatement_Implementation_impl_->post_CapabilityStatement_Implementation ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Implementation_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->description_parser_)
      this->description_parser_->_reset ();

    if (this->url_parser_)
      this->url_parser_->_reset ();

    if (this->custodian_parser_)
      this->custodian_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Rest_pskel
  //

  void CapabilityStatement_Rest_pskel::
  mode ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->mode ();
  }

  void CapabilityStatement_Rest_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->documentation ();
  }

  void CapabilityStatement_Rest_pskel::
  security ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->security ();
  }

  void CapabilityStatement_Rest_pskel::
  resource ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->resource ();
  }

  void CapabilityStatement_Rest_pskel::
  interaction ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->interaction ();
  }

  void CapabilityStatement_Rest_pskel::
  searchParam ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->searchParam ();
  }

  void CapabilityStatement_Rest_pskel::
  operation ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->operation ();
  }

  void CapabilityStatement_Rest_pskel::
  compartment ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->compartment ();
  }

  void CapabilityStatement_Rest_pskel::
  post_CapabilityStatement_Rest ()
  {
    if (this->CapabilityStatement_Rest_impl_)
      this->CapabilityStatement_Rest_impl_->post_CapabilityStatement_Rest ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Rest_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->mode_parser_)
      this->mode_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    if (this->security_parser_)
      this->security_parser_->_reset ();

    if (this->resource_parser_)
      this->resource_parser_->_reset ();

    if (this->interaction_parser_)
      this->interaction_parser_->_reset ();

    if (this->searchParam_parser_)
      this->searchParam_parser_->_reset ();

    if (this->operation_parser_)
      this->operation_parser_->_reset ();

    if (this->compartment_parser_)
      this->compartment_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Security_pskel
  //

  void CapabilityStatement_Security_pskel::
  cors ()
  {
    if (this->CapabilityStatement_Security_impl_)
      this->CapabilityStatement_Security_impl_->cors ();
  }

  void CapabilityStatement_Security_pskel::
  service ()
  {
    if (this->CapabilityStatement_Security_impl_)
      this->CapabilityStatement_Security_impl_->service ();
  }

  void CapabilityStatement_Security_pskel::
  description ()
  {
    if (this->CapabilityStatement_Security_impl_)
      this->CapabilityStatement_Security_impl_->description ();
  }

  void CapabilityStatement_Security_pskel::
  post_CapabilityStatement_Security ()
  {
    if (this->CapabilityStatement_Security_impl_)
      this->CapabilityStatement_Security_impl_->post_CapabilityStatement_Security ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Security_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->cors_parser_)
      this->cors_parser_->_reset ();

    if (this->service_parser_)
      this->service_parser_->_reset ();

    if (this->description_parser_)
      this->description_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Resource_pskel
  //

  void CapabilityStatement_Resource_pskel::
  type ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->type ();
  }

  void CapabilityStatement_Resource_pskel::
  profile ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->profile ();
  }

  void CapabilityStatement_Resource_pskel::
  supportedProfile ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->supportedProfile ();
  }

  void CapabilityStatement_Resource_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->documentation ();
  }

  void CapabilityStatement_Resource_pskel::
  interaction ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->interaction ();
  }

  void CapabilityStatement_Resource_pskel::
  versioning ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->versioning ();
  }

  void CapabilityStatement_Resource_pskel::
  readHistory ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->readHistory ();
  }

  void CapabilityStatement_Resource_pskel::
  updateCreate ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->updateCreate ();
  }

  void CapabilityStatement_Resource_pskel::
  conditionalCreate ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->conditionalCreate ();
  }

  void CapabilityStatement_Resource_pskel::
  conditionalRead ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->conditionalRead ();
  }

  void CapabilityStatement_Resource_pskel::
  conditionalUpdate ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->conditionalUpdate ();
  }

  void CapabilityStatement_Resource_pskel::
  conditionalDelete ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->conditionalDelete ();
  }

  void CapabilityStatement_Resource_pskel::
  referencePolicy ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->referencePolicy ();
  }

  void CapabilityStatement_Resource_pskel::
  searchInclude ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->searchInclude ();
  }

  void CapabilityStatement_Resource_pskel::
  searchRevInclude ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->searchRevInclude ();
  }

  void CapabilityStatement_Resource_pskel::
  searchParam ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->searchParam ();
  }

  void CapabilityStatement_Resource_pskel::
  operation ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->operation ();
  }

  void CapabilityStatement_Resource_pskel::
  post_CapabilityStatement_Resource ()
  {
    if (this->CapabilityStatement_Resource_impl_)
      this->CapabilityStatement_Resource_impl_->post_CapabilityStatement_Resource ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Resource_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    if (this->supportedProfile_parser_)
      this->supportedProfile_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    if (this->interaction_parser_)
      this->interaction_parser_->_reset ();

    if (this->versioning_parser_)
      this->versioning_parser_->_reset ();

    if (this->readHistory_parser_)
      this->readHistory_parser_->_reset ();

    if (this->updateCreate_parser_)
      this->updateCreate_parser_->_reset ();

    if (this->conditionalCreate_parser_)
      this->conditionalCreate_parser_->_reset ();

    if (this->conditionalRead_parser_)
      this->conditionalRead_parser_->_reset ();

    if (this->conditionalUpdate_parser_)
      this->conditionalUpdate_parser_->_reset ();

    if (this->conditionalDelete_parser_)
      this->conditionalDelete_parser_->_reset ();

    if (this->referencePolicy_parser_)
      this->referencePolicy_parser_->_reset ();

    if (this->searchInclude_parser_)
      this->searchInclude_parser_->_reset ();

    if (this->searchRevInclude_parser_)
      this->searchRevInclude_parser_->_reset ();

    if (this->searchParam_parser_)
      this->searchParam_parser_->_reset ();

    if (this->operation_parser_)
      this->operation_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Interaction_pskel
  //

  void CapabilityStatement_Interaction_pskel::
  code ()
  {
    if (this->CapabilityStatement_Interaction_impl_)
      this->CapabilityStatement_Interaction_impl_->code ();
  }

  void CapabilityStatement_Interaction_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Interaction_impl_)
      this->CapabilityStatement_Interaction_impl_->documentation ();
  }

  void CapabilityStatement_Interaction_pskel::
  post_CapabilityStatement_Interaction ()
  {
    if (this->CapabilityStatement_Interaction_impl_)
      this->CapabilityStatement_Interaction_impl_->post_CapabilityStatement_Interaction ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Interaction_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_SearchParam_pskel
  //

  void CapabilityStatement_SearchParam_pskel::
  name ()
  {
    if (this->CapabilityStatement_SearchParam_impl_)
      this->CapabilityStatement_SearchParam_impl_->name ();
  }

  void CapabilityStatement_SearchParam_pskel::
  definition ()
  {
    if (this->CapabilityStatement_SearchParam_impl_)
      this->CapabilityStatement_SearchParam_impl_->definition ();
  }

  void CapabilityStatement_SearchParam_pskel::
  type ()
  {
    if (this->CapabilityStatement_SearchParam_impl_)
      this->CapabilityStatement_SearchParam_impl_->type ();
  }

  void CapabilityStatement_SearchParam_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_SearchParam_impl_)
      this->CapabilityStatement_SearchParam_impl_->documentation ();
  }

  void CapabilityStatement_SearchParam_pskel::
  post_CapabilityStatement_SearchParam ()
  {
    if (this->CapabilityStatement_SearchParam_impl_)
      this->CapabilityStatement_SearchParam_impl_->post_CapabilityStatement_SearchParam ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_SearchParam_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->definition_parser_)
      this->definition_parser_->_reset ();

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Operation_pskel
  //

  void CapabilityStatement_Operation_pskel::
  name ()
  {
    if (this->CapabilityStatement_Operation_impl_)
      this->CapabilityStatement_Operation_impl_->name ();
  }

  void CapabilityStatement_Operation_pskel::
  definition ()
  {
    if (this->CapabilityStatement_Operation_impl_)
      this->CapabilityStatement_Operation_impl_->definition ();
  }

  void CapabilityStatement_Operation_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Operation_impl_)
      this->CapabilityStatement_Operation_impl_->documentation ();
  }

  void CapabilityStatement_Operation_pskel::
  post_CapabilityStatement_Operation ()
  {
    if (this->CapabilityStatement_Operation_impl_)
      this->CapabilityStatement_Operation_impl_->post_CapabilityStatement_Operation ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Operation_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->name_parser_)
      this->name_parser_->_reset ();

    if (this->definition_parser_)
      this->definition_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Interaction1_pskel
  //

  void CapabilityStatement_Interaction1_pskel::
  code ()
  {
    if (this->CapabilityStatement_Interaction1_impl_)
      this->CapabilityStatement_Interaction1_impl_->code ();
  }

  void CapabilityStatement_Interaction1_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Interaction1_impl_)
      this->CapabilityStatement_Interaction1_impl_->documentation ();
  }

  void CapabilityStatement_Interaction1_pskel::
  post_CapabilityStatement_Interaction1 ()
  {
    if (this->CapabilityStatement_Interaction1_impl_)
      this->CapabilityStatement_Interaction1_impl_->post_CapabilityStatement_Interaction1 ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Interaction1_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Messaging_pskel
  //

  void CapabilityStatement_Messaging_pskel::
  endpoint ()
  {
    if (this->CapabilityStatement_Messaging_impl_)
      this->CapabilityStatement_Messaging_impl_->endpoint ();
  }

  void CapabilityStatement_Messaging_pskel::
  reliableCache ()
  {
    if (this->CapabilityStatement_Messaging_impl_)
      this->CapabilityStatement_Messaging_impl_->reliableCache ();
  }

  void CapabilityStatement_Messaging_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Messaging_impl_)
      this->CapabilityStatement_Messaging_impl_->documentation ();
  }

  void CapabilityStatement_Messaging_pskel::
  supportedMessage ()
  {
    if (this->CapabilityStatement_Messaging_impl_)
      this->CapabilityStatement_Messaging_impl_->supportedMessage ();
  }

  void CapabilityStatement_Messaging_pskel::
  post_CapabilityStatement_Messaging ()
  {
    if (this->CapabilityStatement_Messaging_impl_)
      this->CapabilityStatement_Messaging_impl_->post_CapabilityStatement_Messaging ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Messaging_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->endpoint_parser_)
      this->endpoint_parser_->_reset ();

    if (this->reliableCache_parser_)
      this->reliableCache_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    if (this->supportedMessage_parser_)
      this->supportedMessage_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Endpoint_pskel
  //

  void CapabilityStatement_Endpoint_pskel::
  protocol ()
  {
    if (this->CapabilityStatement_Endpoint_impl_)
      this->CapabilityStatement_Endpoint_impl_->protocol ();
  }

  void CapabilityStatement_Endpoint_pskel::
  address ()
  {
    if (this->CapabilityStatement_Endpoint_impl_)
      this->CapabilityStatement_Endpoint_impl_->address ();
  }

  void CapabilityStatement_Endpoint_pskel::
  post_CapabilityStatement_Endpoint ()
  {
    if (this->CapabilityStatement_Endpoint_impl_)
      this->CapabilityStatement_Endpoint_impl_->post_CapabilityStatement_Endpoint ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Endpoint_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->protocol_parser_)
      this->protocol_parser_->_reset ();

    if (this->address_parser_)
      this->address_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_SupportedMessage_pskel
  //

  void CapabilityStatement_SupportedMessage_pskel::
  mode ()
  {
    if (this->CapabilityStatement_SupportedMessage_impl_)
      this->CapabilityStatement_SupportedMessage_impl_->mode ();
  }

  void CapabilityStatement_SupportedMessage_pskel::
  definition ()
  {
    if (this->CapabilityStatement_SupportedMessage_impl_)
      this->CapabilityStatement_SupportedMessage_impl_->definition ();
  }

  void CapabilityStatement_SupportedMessage_pskel::
  post_CapabilityStatement_SupportedMessage ()
  {
    if (this->CapabilityStatement_SupportedMessage_impl_)
      this->CapabilityStatement_SupportedMessage_impl_->post_CapabilityStatement_SupportedMessage ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_SupportedMessage_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->mode_parser_)
      this->mode_parser_->_reset ();

    if (this->definition_parser_)
      this->definition_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatement_Document_pskel
  //

  void CapabilityStatement_Document_pskel::
  mode ()
  {
    if (this->CapabilityStatement_Document_impl_)
      this->CapabilityStatement_Document_impl_->mode ();
  }

  void CapabilityStatement_Document_pskel::
  documentation ()
  {
    if (this->CapabilityStatement_Document_impl_)
      this->CapabilityStatement_Document_impl_->documentation ();
  }

  void CapabilityStatement_Document_pskel::
  profile ()
  {
    if (this->CapabilityStatement_Document_impl_)
      this->CapabilityStatement_Document_impl_->profile ();
  }

  void CapabilityStatement_Document_pskel::
  post_CapabilityStatement_Document ()
  {
    if (this->CapabilityStatement_Document_impl_)
      this->CapabilityStatement_Document_impl_->post_CapabilityStatement_Document ();
    else
      post_BackboneElement ();
  }

  void CapabilityStatement_Document_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->mode_parser_)
      this->mode_parser_->_reset ();

    if (this->documentation_parser_)
      this->documentation_parser_->_reset ();

    if (this->profile_parser_)
      this->profile_parser_->_reset ();

    this->resetting_ = false;
  }

  // CapabilityStatementKind_list_pskel
  //

  void CapabilityStatementKind_list_pskel::
  post_CapabilityStatementKind_list ()
  {
    if (this->CapabilityStatementKind_list_impl_)
      this->CapabilityStatementKind_list_impl_->post_CapabilityStatementKind_list ();
    else
      post_code_primitive ();
  }

  const char* const CapabilityStatementKind_list_pskel::_xsde_CapabilityStatementKind_list_pskel_enums_[3UL] = 
  {
    "capability",
    "instance",
    "requirements"
  };

  // CapabilityStatementKind_pskel
  //

  void CapabilityStatementKind_pskel::
  value ()
  {
    if (this->CapabilityStatementKind_impl_)
      this->CapabilityStatementKind_impl_->value ();
  }

  void CapabilityStatementKind_pskel::
  post_CapabilityStatementKind ()
  {
    if (this->CapabilityStatementKind_impl_)
      this->CapabilityStatementKind_impl_->post_CapabilityStatementKind ();
    else
      post_Element ();
  }

  void CapabilityStatementKind_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // EventCapabilityMode_list_pskel
  //

  void EventCapabilityMode_list_pskel::
  post_EventCapabilityMode_list ()
  {
    if (this->EventCapabilityMode_list_impl_)
      this->EventCapabilityMode_list_impl_->post_EventCapabilityMode_list ();
    else
      post_code_primitive ();
  }

  const char* const EventCapabilityMode_list_pskel::_xsde_EventCapabilityMode_list_pskel_enums_[2UL] = 
  {
    "receiver",
    "sender"
  };

  // EventCapabilityMode_pskel
  //

  void EventCapabilityMode_pskel::
  value ()
  {
    if (this->EventCapabilityMode_impl_)
      this->EventCapabilityMode_impl_->value ();
  }

  void EventCapabilityMode_pskel::
  post_EventCapabilityMode ()
  {
    if (this->EventCapabilityMode_impl_)
      this->EventCapabilityMode_impl_->post_EventCapabilityMode ();
    else
      post_Element ();
  }

  void EventCapabilityMode_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ResourceVersionPolicy_list_pskel
  //

  void ResourceVersionPolicy_list_pskel::
  post_ResourceVersionPolicy_list ()
  {
    if (this->ResourceVersionPolicy_list_impl_)
      this->ResourceVersionPolicy_list_impl_->post_ResourceVersionPolicy_list ();
    else
      post_code_primitive ();
  }

  const char* const ResourceVersionPolicy_list_pskel::_xsde_ResourceVersionPolicy_list_pskel_enums_[3UL] = 
  {
    "no-version",
    "versioned",
    "versioned-update"
  };

  // ResourceVersionPolicy_pskel
  //

  void ResourceVersionPolicy_pskel::
  value ()
  {
    if (this->ResourceVersionPolicy_impl_)
      this->ResourceVersionPolicy_impl_->value ();
  }

  void ResourceVersionPolicy_pskel::
  post_ResourceVersionPolicy ()
  {
    if (this->ResourceVersionPolicy_impl_)
      this->ResourceVersionPolicy_impl_->post_ResourceVersionPolicy ();
    else
      post_Element ();
  }

  void ResourceVersionPolicy_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // DocumentMode_list_pskel
  //

  void DocumentMode_list_pskel::
  post_DocumentMode_list ()
  {
    if (this->DocumentMode_list_impl_)
      this->DocumentMode_list_impl_->post_DocumentMode_list ();
    else
      post_code_primitive ();
  }

  const char* const DocumentMode_list_pskel::_xsde_DocumentMode_list_pskel_enums_[2UL] = 
  {
    "consumer",
    "producer"
  };

  // DocumentMode_pskel
  //

  void DocumentMode_pskel::
  value ()
  {
    if (this->DocumentMode_impl_)
      this->DocumentMode_impl_->value ();
  }

  void DocumentMode_pskel::
  post_DocumentMode ()
  {
    if (this->DocumentMode_impl_)
      this->DocumentMode_impl_->post_DocumentMode ();
    else
      post_Element ();
  }

  void DocumentMode_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // RestfulCapabilityMode_list_pskel
  //

  void RestfulCapabilityMode_list_pskel::
  post_RestfulCapabilityMode_list ()
  {
    if (this->RestfulCapabilityMode_list_impl_)
      this->RestfulCapabilityMode_list_impl_->post_RestfulCapabilityMode_list ();
    else
      post_code_primitive ();
  }

  const char* const RestfulCapabilityMode_list_pskel::_xsde_RestfulCapabilityMode_list_pskel_enums_[2UL] = 
  {
    "client",
    "server"
  };

  // RestfulCapabilityMode_pskel
  //

  void RestfulCapabilityMode_pskel::
  value ()
  {
    if (this->RestfulCapabilityMode_impl_)
      this->RestfulCapabilityMode_impl_->value ();
  }

  void RestfulCapabilityMode_pskel::
  post_RestfulCapabilityMode ()
  {
    if (this->RestfulCapabilityMode_impl_)
      this->RestfulCapabilityMode_impl_->post_RestfulCapabilityMode ();
    else
      post_Element ();
  }

  void RestfulCapabilityMode_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // TypeRestfulInteraction_list_pskel
  //

  void TypeRestfulInteraction_list_pskel::
  post_TypeRestfulInteraction_list ()
  {
    if (this->TypeRestfulInteraction_list_impl_)
      this->TypeRestfulInteraction_list_impl_->post_TypeRestfulInteraction_list ();
    else
      post_code_primitive ();
  }

  const char* const TypeRestfulInteraction_list_pskel::_xsde_TypeRestfulInteraction_list_pskel_enums_[9UL] = 
  {
    "create",
    "delete",
    "history-instance",
    "history-type",
    "patch",
    "read",
    "search-type",
    "update",
    "vread"
  };

  // TypeRestfulInteraction_pskel
  //

  void TypeRestfulInteraction_pskel::
  value ()
  {
    if (this->TypeRestfulInteraction_impl_)
      this->TypeRestfulInteraction_impl_->value ();
  }

  void TypeRestfulInteraction_pskel::
  post_TypeRestfulInteraction ()
  {
    if (this->TypeRestfulInteraction_impl_)
      this->TypeRestfulInteraction_impl_->post_TypeRestfulInteraction ();
    else
      post_Element ();
  }

  void TypeRestfulInteraction_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // SystemRestfulInteraction_list_pskel
  //

  void SystemRestfulInteraction_list_pskel::
  post_SystemRestfulInteraction_list ()
  {
    if (this->SystemRestfulInteraction_list_impl_)
      this->SystemRestfulInteraction_list_impl_->post_SystemRestfulInteraction_list ();
    else
      post_code_primitive ();
  }

  const char* const SystemRestfulInteraction_list_pskel::_xsde_SystemRestfulInteraction_list_pskel_enums_[4UL] = 
  {
    "batch",
    "history-system",
    "search-system",
    "transaction"
  };

  // SystemRestfulInteraction_pskel
  //

  void SystemRestfulInteraction_pskel::
  value ()
  {
    if (this->SystemRestfulInteraction_impl_)
      this->SystemRestfulInteraction_impl_->value ();
  }

  void SystemRestfulInteraction_pskel::
  post_SystemRestfulInteraction ()
  {
    if (this->SystemRestfulInteraction_impl_)
      this->SystemRestfulInteraction_impl_->post_SystemRestfulInteraction ();
    else
      post_Element ();
  }

  void SystemRestfulInteraction_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ConditionalReadStatus_list_pskel
  //

  void ConditionalReadStatus_list_pskel::
  post_ConditionalReadStatus_list ()
  {
    if (this->ConditionalReadStatus_list_impl_)
      this->ConditionalReadStatus_list_impl_->post_ConditionalReadStatus_list ();
    else
      post_code_primitive ();
  }

  const char* const ConditionalReadStatus_list_pskel::_xsde_ConditionalReadStatus_list_pskel_enums_[4UL] = 
  {
    "full-support",
    "modified-since",
    "not-match",
    "not-supported"
  };

  // ConditionalReadStatus_pskel
  //

  void ConditionalReadStatus_pskel::
  value ()
  {
    if (this->ConditionalReadStatus_impl_)
      this->ConditionalReadStatus_impl_->value ();
  }

  void ConditionalReadStatus_pskel::
  post_ConditionalReadStatus ()
  {
    if (this->ConditionalReadStatus_impl_)
      this->ConditionalReadStatus_impl_->post_ConditionalReadStatus ();
    else
      post_Element ();
  }

  void ConditionalReadStatus_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ReferenceHandlingPolicy_list_pskel
  //

  void ReferenceHandlingPolicy_list_pskel::
  post_ReferenceHandlingPolicy_list ()
  {
    if (this->ReferenceHandlingPolicy_list_impl_)
      this->ReferenceHandlingPolicy_list_impl_->post_ReferenceHandlingPolicy_list ();
    else
      post_code_primitive ();
  }

  const char* const ReferenceHandlingPolicy_list_pskel::_xsde_ReferenceHandlingPolicy_list_pskel_enums_[5UL] = 
  {
    "enforced",
    "literal",
    "local",
    "logical",
    "resolves"
  };

  // ReferenceHandlingPolicy_pskel
  //

  void ReferenceHandlingPolicy_pskel::
  value ()
  {
    if (this->ReferenceHandlingPolicy_impl_)
      this->ReferenceHandlingPolicy_impl_->value ();
  }

  void ReferenceHandlingPolicy_pskel::
  post_ReferenceHandlingPolicy ()
  {
    if (this->ReferenceHandlingPolicy_impl_)
      this->ReferenceHandlingPolicy_impl_->post_ReferenceHandlingPolicy ();
    else
      post_Element ();
  }

  void ReferenceHandlingPolicy_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }

  // ConditionalDeleteStatus_list_pskel
  //

  void ConditionalDeleteStatus_list_pskel::
  post_ConditionalDeleteStatus_list ()
  {
    if (this->ConditionalDeleteStatus_list_impl_)
      this->ConditionalDeleteStatus_list_impl_->post_ConditionalDeleteStatus_list ();
    else
      post_code_primitive ();
  }

  const char* const ConditionalDeleteStatus_list_pskel::_xsde_ConditionalDeleteStatus_list_pskel_enums_[3UL] = 
  {
    "multiple",
    "not-supported",
    "single"
  };

  // ConditionalDeleteStatus_pskel
  //

  void ConditionalDeleteStatus_pskel::
  value ()
  {
    if (this->ConditionalDeleteStatus_impl_)
      this->ConditionalDeleteStatus_impl_->value ();
  }

  void ConditionalDeleteStatus_pskel::
  post_ConditionalDeleteStatus ()
  {
    if (this->ConditionalDeleteStatus_impl_)
      this->ConditionalDeleteStatus_impl_->post_ConditionalDeleteStatus ();
    else
      post_Element ();
  }

  void ConditionalDeleteStatus_pskel::
  _reset ()
  {
    typedef ::fhir::Element_pskel base;
    base::_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for CapabilityStatement_pskel.
  //
  bool CapabilityStatement_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "url" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "version" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "name" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "title" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "status" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::DomainResource_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::DomainResource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_uri ();
              this->url ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "version" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->version_parser_)
            {
              this->version_parser_->pre ();
              ctx.nested_parser (this->version_parser_);
            }
          }
          else
          {
            if (this->version_parser_ != 0)
            {
              this->version_parser_->post_string ();
              this->version ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "title" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->title_parser_)
            {
              this->title_parser_->pre ();
              ctx.nested_parser (this->title_parser_);
            }
          }
          else
          {
            if (this->title_parser_ != 0)
            {
              this->title_parser_->post_string ();
              this->title ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "status" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->status_parser_)
            {
              this->status_parser_->pre ();
              ctx.nested_parser (this->status_parser_);
            }
          }
          else
          {
            if (this->status_parser_ != 0)
            {
              this->status_parser_->post_PublicationStatus ();
              this->status ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "experimental" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->experimental_parser_)
            {
              this->experimental_parser_->pre ();
              ctx.nested_parser (this->experimental_parser_);
            }
          }
          else
          {
            if (this->experimental_parser_ != 0)
            {
              this->experimental_parser_->post_boolean ();
              this->experimental ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "date" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->date_parser_)
            {
              this->date_parser_->pre ();
              ctx.nested_parser (this->date_parser_);
            }
          }
          else
          {
            if (this->date_parser_ != 0)
            {
              this->date_parser_->post_dateTime ();
              this->date ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "publisher" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->publisher_parser_)
            {
              this->publisher_parser_->pre ();
              ctx.nested_parser (this->publisher_parser_);
            }
          }
          else
          {
            if (this->publisher_parser_ != 0)
            {
              this->publisher_parser_->post_string ();
              this->publisher ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "contact" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contact_parser_)
            {
              this->contact_parser_->pre ();
              ctx.nested_parser (this->contact_parser_);
            }
          }
          else
          {
            if (this->contact_parser_ != 0)
            {
              this->contact_parser_->post_ContactDetail ();
              this->contact ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_markdown ();
              this->description ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "useContext" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->useContext_parser_)
            {
              this->useContext_parser_->pre ();
              ctx.nested_parser (this->useContext_parser_);
            }
          }
          else
          {
            if (this->useContext_parser_ != 0)
            {
              this->useContext_parser_->post_UsageContext ();
              this->useContext ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "jurisdiction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->jurisdiction_parser_)
            {
              this->jurisdiction_parser_->pre ();
              ctx.nested_parser (this->jurisdiction_parser_);
            }
          }
          else
          {
            if (this->jurisdiction_parser_ != 0)
            {
              this->jurisdiction_parser_->post_CodeableConcept ();
              this->jurisdiction ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "purpose" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->purpose_parser_)
            {
              this->purpose_parser_->pre ();
              ctx.nested_parser (this->purpose_parser_);
            }
          }
          else
          {
            if (this->purpose_parser_ != 0)
            {
              this->purpose_parser_->post_markdown ();
              this->purpose ();
            }

            count = 0;
            state = 13UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "copyright" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->copyright_parser_)
            {
              this->copyright_parser_->pre ();
              ctx.nested_parser (this->copyright_parser_);
            }
          }
          else
          {
            if (this->copyright_parser_ != 0)
            {
              this->copyright_parser_->post_markdown ();
              this->copyright ();
            }

            count = 0;
            state = 14UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "kind" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->kind_parser_)
            {
              this->kind_parser_->pre ();
              ctx.nested_parser (this->kind_parser_);
            }
          }
          else
          {
            if (this->kind_parser_ != 0)
            {
              this->kind_parser_->post_CapabilityStatementKind ();
              this->kind ();
            }

            count = 0;
            state = 15UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "instantiates" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->instantiates_parser_)
            {
              this->instantiates_parser_->pre ();
              ctx.nested_parser (this->instantiates_parser_);
            }
          }
          else
          {
            if (this->instantiates_parser_ != 0)
            {
              this->instantiates_parser_->post_canonical ();
              this->instantiates ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "imports" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->imports_parser_)
            {
              this->imports_parser_->pre ();
              ctx.nested_parser (this->imports_parser_);
            }
          }
          else
          {
            if (this->imports_parser_ != 0)
            {
              this->imports_parser_->post_canonical ();
              this->imports ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "software" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->software_parser_)
            {
              this->software_parser_->pre ();
              ctx.nested_parser (this->software_parser_);
            }
          }
          else
          {
            if (this->software_parser_ != 0)
            {
              this->software_parser_->post_CapabilityStatement_Software ();
              this->software ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "implementation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->implementation_parser_)
            {
              this->implementation_parser_->pre ();
              ctx.nested_parser (this->implementation_parser_);
            }
          }
          else
          {
            if (this->implementation_parser_ != 0)
            {
              this->implementation_parser_->post_CapabilityStatement_Implementation ();
              this->implementation ();
            }

            count = 0;
            state = 19UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "fhirVersion" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->fhirVersion_parser_)
            {
              this->fhirVersion_parser_->pre ();
              ctx.nested_parser (this->fhirVersion_parser_);
            }
          }
          else
          {
            if (this->fhirVersion_parser_ != 0)
            {
              this->fhirVersion_parser_->post_FHIRVersion ();
              this->fhirVersion ();
            }

            count = 0;
            state = 20UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "format" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->format_parser_)
            {
              this->format_parser_->pre ();
              ctx.nested_parser (this->format_parser_);
            }
          }
          else
          {
            if (this->format_parser_ != 0)
            {
              this->format_parser_->post_code ();
              this->format ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "patchFormat" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patchFormat_parser_)
            {
              this->patchFormat_parser_->pre ();
              ctx.nested_parser (this->patchFormat_parser_);
            }
          }
          else
          {
            if (this->patchFormat_parser_ != 0)
            {
              this->patchFormat_parser_->post_code ();
              this->patchFormat ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 22UL;
          // Fall through.
        }
      }
      case 22UL:
      {
        if (n == "implementationGuide" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->implementationGuide_parser_)
            {
              this->implementationGuide_parser_->pre ();
              ctx.nested_parser (this->implementationGuide_parser_);
            }
          }
          else
          {
            if (this->implementationGuide_parser_ != 0)
            {
              this->implementationGuide_parser_->post_canonical ();
              this->implementationGuide ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 23UL;
          // Fall through.
        }
      }
      case 23UL:
      {
        if (n == "rest" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->rest_parser_)
            {
              this->rest_parser_->pre ();
              ctx.nested_parser (this->rest_parser_);
            }
          }
          else
          {
            if (this->rest_parser_ != 0)
            {
              this->rest_parser_->post_CapabilityStatement_Rest ();
              this->rest ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 24UL;
          // Fall through.
        }
      }
      case 24UL:
      {
        if (n == "messaging" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->messaging_parser_)
            {
              this->messaging_parser_->pre ();
              ctx.nested_parser (this->messaging_parser_);
            }
          }
          else
          {
            if (this->messaging_parser_ != 0)
            {
              this->messaging_parser_->post_CapabilityStatement_Messaging ();
              this->messaging ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 25UL;
          // Fall through.
        }
      }
      case 25UL:
      {
        if (n == "document" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->document_parser_)
            {
              this->document_parser_->pre ();
              ctx.nested_parser (this->document_parser_);
            }
          }
          else
          {
            if (this->document_parser_ != 0)
            {
              this->document_parser_->post_CapabilityStatement_Document ();
              this->document ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Software_pskel.
  //
  bool CapabilityStatement_Software_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Software_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Software_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Software_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Software_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Software_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "version" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->version_parser_)
            {
              this->version_parser_->pre ();
              ctx.nested_parser (this->version_parser_);
            }
          }
          else
          {
            if (this->version_parser_ != 0)
            {
              this->version_parser_->post_string ();
              this->version ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "releaseDate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->releaseDate_parser_)
            {
              this->releaseDate_parser_->pre ();
              ctx.nested_parser (this->releaseDate_parser_);
            }
          }
          else
          {
            if (this->releaseDate_parser_ != 0)
            {
              this->releaseDate_parser_->post_dateTime ();
              this->releaseDate ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Implementation_pskel.
  //
  bool CapabilityStatement_Implementation_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Implementation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Implementation_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Implementation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Implementation_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Implementation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_string ();
              this->description ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "url" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->url_parser_)
            {
              this->url_parser_->pre ();
              ctx.nested_parser (this->url_parser_);
            }
          }
          else
          {
            if (this->url_parser_ != 0)
            {
              this->url_parser_->post_url ();
              this->url ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "custodian" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->custodian_parser_)
            {
              this->custodian_parser_->pre ();
              ctx.nested_parser (this->custodian_parser_);
            }
          }
          else
          {
            if (this->custodian_parser_ != 0)
            {
              this->custodian_parser_->post_Reference ();
              this->custodian ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Rest_pskel.
  //
  bool CapabilityStatement_Rest_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "mode" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Rest_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Rest_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Rest_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Rest_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Rest_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "mode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->mode_parser_)
            {
              this->mode_parser_->pre ();
              ctx.nested_parser (this->mode_parser_);
            }
          }
          else
          {
            if (this->mode_parser_ != 0)
            {
              this->mode_parser_->post_RestfulCapabilityMode ();
              this->mode ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "security" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->security_parser_)
            {
              this->security_parser_->pre ();
              ctx.nested_parser (this->security_parser_);
            }
          }
          else
          {
            if (this->security_parser_ != 0)
            {
              this->security_parser_->post_CapabilityStatement_Security ();
              this->security ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "resource" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->resource_parser_)
            {
              this->resource_parser_->pre ();
              ctx.nested_parser (this->resource_parser_);
            }
          }
          else
          {
            if (this->resource_parser_ != 0)
            {
              this->resource_parser_->post_CapabilityStatement_Resource ();
              this->resource ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "interaction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->interaction_parser_)
            {
              this->interaction_parser_->pre ();
              ctx.nested_parser (this->interaction_parser_);
            }
          }
          else
          {
            if (this->interaction_parser_ != 0)
            {
              this->interaction_parser_->post_CapabilityStatement_Interaction1 ();
              this->interaction ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "searchParam" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->searchParam_parser_)
            {
              this->searchParam_parser_->pre ();
              ctx.nested_parser (this->searchParam_parser_);
            }
          }
          else
          {
            if (this->searchParam_parser_ != 0)
            {
              this->searchParam_parser_->post_CapabilityStatement_SearchParam ();
              this->searchParam ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operation_parser_)
            {
              this->operation_parser_->pre ();
              ctx.nested_parser (this->operation_parser_);
            }
          }
          else
          {
            if (this->operation_parser_ != 0)
            {
              this->operation_parser_->post_CapabilityStatement_Operation ();
              this->operation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "compartment" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->compartment_parser_)
            {
              this->compartment_parser_->pre ();
              ctx.nested_parser (this->compartment_parser_);
            }
          }
          else
          {
            if (this->compartment_parser_ != 0)
            {
              this->compartment_parser_->post_canonical ();
              this->compartment ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Security_pskel.
  //
  bool CapabilityStatement_Security_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "cors" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "service" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "description" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Security_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Security_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Security_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Security_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Security_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "cors" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->cors_parser_)
            {
              this->cors_parser_->pre ();
              ctx.nested_parser (this->cors_parser_);
            }
          }
          else
          {
            if (this->cors_parser_ != 0)
            {
              this->cors_parser_->post_boolean ();
              this->cors ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "service" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->service_parser_)
            {
              this->service_parser_->pre ();
              ctx.nested_parser (this->service_parser_);
            }
          }
          else
          {
            if (this->service_parser_ != 0)
            {
              this->service_parser_->post_CodeableConcept ();
              this->service ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "description" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->description_parser_)
            {
              this->description_parser_->pre ();
              ctx.nested_parser (this->description_parser_);
            }
          }
          else
          {
            if (this->description_parser_ != 0)
            {
              this->description_parser_->post_markdown ();
              this->description ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Resource_pskel.
  //
  bool CapabilityStatement_Resource_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Resource_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Resource_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Resource_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Resource_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Resource_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_code ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_canonical ();
              this->profile ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "supportedProfile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->supportedProfile_parser_)
            {
              this->supportedProfile_parser_->pre ();
              ctx.nested_parser (this->supportedProfile_parser_);
            }
          }
          else
          {
            if (this->supportedProfile_parser_ != 0)
            {
              this->supportedProfile_parser_->post_canonical ();
              this->supportedProfile ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "interaction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->interaction_parser_)
            {
              this->interaction_parser_->pre ();
              ctx.nested_parser (this->interaction_parser_);
            }
          }
          else
          {
            if (this->interaction_parser_ != 0)
            {
              this->interaction_parser_->post_CapabilityStatement_Interaction ();
              this->interaction ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "versioning" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->versioning_parser_)
            {
              this->versioning_parser_->pre ();
              ctx.nested_parser (this->versioning_parser_);
            }
          }
          else
          {
            if (this->versioning_parser_ != 0)
            {
              this->versioning_parser_->post_ResourceVersionPolicy ();
              this->versioning ();
            }

            count = 0;
            state = 6UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "readHistory" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->readHistory_parser_)
            {
              this->readHistory_parser_->pre ();
              ctx.nested_parser (this->readHistory_parser_);
            }
          }
          else
          {
            if (this->readHistory_parser_ != 0)
            {
              this->readHistory_parser_->post_boolean ();
              this->readHistory ();
            }

            count = 0;
            state = 7UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "updateCreate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->updateCreate_parser_)
            {
              this->updateCreate_parser_->pre ();
              ctx.nested_parser (this->updateCreate_parser_);
            }
          }
          else
          {
            if (this->updateCreate_parser_ != 0)
            {
              this->updateCreate_parser_->post_boolean ();
              this->updateCreate ();
            }

            count = 0;
            state = 8UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "conditionalCreate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->conditionalCreate_parser_)
            {
              this->conditionalCreate_parser_->pre ();
              ctx.nested_parser (this->conditionalCreate_parser_);
            }
          }
          else
          {
            if (this->conditionalCreate_parser_ != 0)
            {
              this->conditionalCreate_parser_->post_boolean ();
              this->conditionalCreate ();
            }

            count = 0;
            state = 9UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "conditionalRead" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->conditionalRead_parser_)
            {
              this->conditionalRead_parser_->pre ();
              ctx.nested_parser (this->conditionalRead_parser_);
            }
          }
          else
          {
            if (this->conditionalRead_parser_ != 0)
            {
              this->conditionalRead_parser_->post_ConditionalReadStatus ();
              this->conditionalRead ();
            }

            count = 0;
            state = 10UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "conditionalUpdate" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->conditionalUpdate_parser_)
            {
              this->conditionalUpdate_parser_->pre ();
              ctx.nested_parser (this->conditionalUpdate_parser_);
            }
          }
          else
          {
            if (this->conditionalUpdate_parser_ != 0)
            {
              this->conditionalUpdate_parser_->post_boolean ();
              this->conditionalUpdate ();
            }

            count = 0;
            state = 11UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "conditionalDelete" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->conditionalDelete_parser_)
            {
              this->conditionalDelete_parser_->pre ();
              ctx.nested_parser (this->conditionalDelete_parser_);
            }
          }
          else
          {
            if (this->conditionalDelete_parser_ != 0)
            {
              this->conditionalDelete_parser_->post_ConditionalDeleteStatus ();
              this->conditionalDelete ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "referencePolicy" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->referencePolicy_parser_)
            {
              this->referencePolicy_parser_->pre ();
              ctx.nested_parser (this->referencePolicy_parser_);
            }
          }
          else
          {
            if (this->referencePolicy_parser_ != 0)
            {
              this->referencePolicy_parser_->post_ReferenceHandlingPolicy ();
              this->referencePolicy ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "searchInclude" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->searchInclude_parser_)
            {
              this->searchInclude_parser_->pre ();
              ctx.nested_parser (this->searchInclude_parser_);
            }
          }
          else
          {
            if (this->searchInclude_parser_ != 0)
            {
              this->searchInclude_parser_->post_string ();
              this->searchInclude ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "searchRevInclude" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->searchRevInclude_parser_)
            {
              this->searchRevInclude_parser_->pre ();
              ctx.nested_parser (this->searchRevInclude_parser_);
            }
          }
          else
          {
            if (this->searchRevInclude_parser_ != 0)
            {
              this->searchRevInclude_parser_->post_string ();
              this->searchRevInclude ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "searchParam" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->searchParam_parser_)
            {
              this->searchParam_parser_->pre ();
              ctx.nested_parser (this->searchParam_parser_);
            }
          }
          else
          {
            if (this->searchParam_parser_ != 0)
            {
              this->searchParam_parser_->post_CapabilityStatement_SearchParam ();
              this->searchParam ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "operation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->operation_parser_)
            {
              this->operation_parser_->pre ();
              ctx.nested_parser (this->operation_parser_);
            }
          }
          else
          {
            if (this->operation_parser_ != 0)
            {
              this->operation_parser_->post_CapabilityStatement_Operation ();
              this->operation ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Interaction_pskel.
  //
  bool CapabilityStatement_Interaction_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "code" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Interaction_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Interaction_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Interaction_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Interaction_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Interaction_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_TypeRestfulInteraction ();
              this->code ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_SearchParam_pskel.
  //
  bool CapabilityStatement_SearchParam_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_SearchParam_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_SearchParam_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_SearchParam_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_SearchParam_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_SearchParam_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "definition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->definition_parser_)
            {
              this->definition_parser_->pre ();
              ctx.nested_parser (this->definition_parser_);
            }
          }
          else
          {
            if (this->definition_parser_ != 0)
            {
              this->definition_parser_->post_canonical ();
              this->definition ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_SearchParamType ();
              this->type ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Operation_pskel.
  //
  bool CapabilityStatement_Operation_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "name" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Operation_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Operation_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Operation_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Operation_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Operation_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "definition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->definition_parser_)
            {
              this->definition_parser_->pre ();
              ctx.nested_parser (this->definition_parser_);
            }
          }
          else
          {
            if (this->definition_parser_ != 0)
            {
              this->definition_parser_->post_canonical ();
              this->definition ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Interaction1_pskel.
  //
  bool CapabilityStatement_Interaction1_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "code" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Interaction1_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Interaction1_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Interaction1_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Interaction1_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Interaction1_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_SystemRestfulInteraction ();
              this->code ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Messaging_pskel.
  //
  bool CapabilityStatement_Messaging_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "endpoint" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "reliableCache" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "documentation" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "supportedMessage" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Messaging_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Messaging_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Messaging_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Messaging_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Messaging_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "endpoint" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->endpoint_parser_)
            {
              this->endpoint_parser_->pre ();
              ctx.nested_parser (this->endpoint_parser_);
            }
          }
          else
          {
            if (this->endpoint_parser_ != 0)
            {
              this->endpoint_parser_->post_CapabilityStatement_Endpoint ();
              this->endpoint ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "reliableCache" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->reliableCache_parser_)
            {
              this->reliableCache_parser_->pre ();
              ctx.nested_parser (this->reliableCache_parser_);
            }
          }
          else
          {
            if (this->reliableCache_parser_ != 0)
            {
              this->reliableCache_parser_->post_unsignedInt ();
              this->reliableCache ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "supportedMessage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->supportedMessage_parser_)
            {
              this->supportedMessage_parser_->pre ();
              ctx.nested_parser (this->supportedMessage_parser_);
            }
          }
          else
          {
            if (this->supportedMessage_parser_ != 0)
            {
              this->supportedMessage_parser_->post_CapabilityStatement_SupportedMessage ();
              this->supportedMessage ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Endpoint_pskel.
  //
  bool CapabilityStatement_Endpoint_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "protocol" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Endpoint_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Endpoint_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Endpoint_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Endpoint_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Endpoint_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "protocol" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->protocol_parser_)
            {
              this->protocol_parser_->pre ();
              ctx.nested_parser (this->protocol_parser_);
            }
          }
          else
          {
            if (this->protocol_parser_ != 0)
            {
              this->protocol_parser_->post_Coding ();
              this->protocol ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "address" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->address_parser_)
            {
              this->address_parser_->pre ();
              ctx.nested_parser (this->address_parser_);
            }
          }
          else
          {
            if (this->address_parser_ != 0)
            {
              this->address_parser_->post_url ();
              this->address ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_SupportedMessage_pskel.
  //
  bool CapabilityStatement_SupportedMessage_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "mode" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_SupportedMessage_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_SupportedMessage_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_SupportedMessage_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_SupportedMessage_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_SupportedMessage_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "mode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->mode_parser_)
            {
              this->mode_parser_->pre ();
              ctx.nested_parser (this->mode_parser_);
            }
          }
          else
          {
            if (this->mode_parser_ != 0)
            {
              this->mode_parser_->post_EventCapabilityMode ();
              this->mode ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "definition" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->definition_parser_)
            {
              this->definition_parser_->pre ();
              ctx.nested_parser (this->definition_parser_);
            }
          }
          else
          {
            if (this->definition_parser_ != 0)
            {
              this->definition_parser_->post_canonical ();
              this->definition ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for CapabilityStatement_Document_pskel.
  //
  bool CapabilityStatement_Document_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "mode" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &CapabilityStatement_Document_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool CapabilityStatement_Document_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void CapabilityStatement_Document_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void CapabilityStatement_Document_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void CapabilityStatement_Document_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "mode" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->mode_parser_)
            {
              this->mode_parser_->pre ();
              ctx.nested_parser (this->mode_parser_);
            }
          }
          else
          {
            if (this->mode_parser_ != 0)
            {
              this->mode_parser_->post_DocumentMode ();
              this->mode ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "documentation" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->documentation_parser_)
            {
              this->documentation_parser_->pre ();
              ctx.nested_parser (this->documentation_parser_);
            }
          }
          else
          {
            if (this->documentation_parser_ != 0)
            {
              this->documentation_parser_->post_markdown ();
              this->documentation ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "profile" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->profile_parser_)
            {
              this->profile_parser_->pre ();
              ctx.nested_parser (this->profile_parser_);
            }
          }
          else
          {
            if (this->profile_parser_ != 0)
            {
              this->profile_parser_->post_canonical ();
              this->profile ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
  // Attribute validation and dispatch functions for CapabilityStatementKind_pskel.
  //
  bool CapabilityStatementKind_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_CapabilityStatementKind_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for EventCapabilityMode_pskel.
  //
  bool EventCapabilityMode_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_EventCapabilityMode_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ResourceVersionPolicy_pskel.
  //
  bool ResourceVersionPolicy_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ResourceVersionPolicy_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for DocumentMode_pskel.
  //
  bool DocumentMode_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_DocumentMode_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for RestfulCapabilityMode_pskel.
  //
  bool RestfulCapabilityMode_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_RestfulCapabilityMode_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for TypeRestfulInteraction_pskel.
  //
  bool TypeRestfulInteraction_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_TypeRestfulInteraction_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for SystemRestfulInteraction_pskel.
  //
  bool SystemRestfulInteraction_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_SystemRestfulInteraction_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ConditionalReadStatus_pskel.
  //
  bool ConditionalReadStatus_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ConditionalReadStatus_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ReferenceHandlingPolicy_pskel.
  //
  bool ReferenceHandlingPolicy_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ReferenceHandlingPolicy_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }

  // Attribute validation and dispatch functions for ConditionalDeleteStatus_pskel.
  //
  bool ConditionalDeleteStatus_pskel::
  _attribute_impl_phase_one (const ::xsde::cxx::ro_string& ns,
                             const ::xsde::cxx::ro_string& n,
                             const ::xsde::cxx::ro_string& s)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();

        this->value_parser_->_pre_impl (ctx);

        if (!ctx.error_type ())
          this->value_parser_->_characters (s);

        if (!ctx.error_type ())
          this->value_parser_->_post_impl ();

        if (!ctx.error_type ())
          this->value_parser_->post_ConditionalDeleteStatus_list ();

        this->value ();
      }

      return true;
    }

    typedef ::fhir::Element_pskel base;
    return base::_attribute_impl_phase_one (ns, n, s);
  }
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


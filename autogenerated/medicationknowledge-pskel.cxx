// Copyright (c) 2005-2020 Code Synthesis Tools CC.
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
//

// Begin prologue.
//
//
// End prologue.

#include <xsde/cxx/pre.hxx>

#include "medicationknowledge-pskel.hxx"

namespace fhir
{
  // MedicationKnowledge_pskel
  //

  void MedicationKnowledge_pskel::
  code_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->code_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  status_parser (::fhir::code_pskel& p)
  {
    this->status_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  manufacturer_parser (::fhir::Reference_pskel& p)
  {
    this->manufacturer_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  doseForm_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->doseForm_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  amount_parser (::fhir::Quantity_pskel& p)
  {
    this->amount_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  synonym_parser (::fhir::string_pskel& p)
  {
    this->synonym_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  relatedMedicationKnowledge_parser (::fhir::MedicationKnowledge_RelatedMedicationKnowledge_pskel& p)
  {
    this->relatedMedicationKnowledge_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  associatedMedication_parser (::fhir::Reference_pskel& p)
  {
    this->associatedMedication_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  productType_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->productType_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  monograph_parser (::fhir::MedicationKnowledge_Monograph_pskel& p)
  {
    this->monograph_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  ingredient_parser (::fhir::MedicationKnowledge_Ingredient_pskel& p)
  {
    this->ingredient_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  preparationInstruction_parser (::fhir::markdown_pskel& p)
  {
    this->preparationInstruction_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  intendedRoute_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->intendedRoute_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  cost_parser (::fhir::MedicationKnowledge_Cost_pskel& p)
  {
    this->cost_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  monitoringProgram_parser (::fhir::MedicationKnowledge_MonitoringProgram_pskel& p)
  {
    this->monitoringProgram_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  administrationGuidelines_parser (::fhir::MedicationKnowledge_AdministrationGuidelines_pskel& p)
  {
    this->administrationGuidelines_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  medicineClassification_parser (::fhir::MedicationKnowledge_MedicineClassification_pskel& p)
  {
    this->medicineClassification_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  packaging_parser (::fhir::MedicationKnowledge_Packaging_pskel& p)
  {
    this->packaging_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  drugCharacteristic_parser (::fhir::MedicationKnowledge_DrugCharacteristic_pskel& p)
  {
    this->drugCharacteristic_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  contraindication_parser (::fhir::Reference_pskel& p)
  {
    this->contraindication_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  regulatory_parser (::fhir::MedicationKnowledge_Regulatory_pskel& p)
  {
    this->regulatory_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  kinetics_parser (::fhir::MedicationKnowledge_Kinetics_pskel& p)
  {
    this->kinetics_parser_ = &p;
  }

  void MedicationKnowledge_pskel::
  parsers (::fhir::id_pskel& id,
           ::fhir::Meta_pskel& meta,
           ::fhir::uri_pskel& implicitRules,
           ::fhir::code_pskel& language,
           ::fhir::Narrative_pskel& text,
           ::fhir::ResourceContainer_pskel& contained,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& code,
           ::fhir::code_pskel& status,
           ::fhir::Reference_pskel& manufacturer,
           ::fhir::CodeableConcept_pskel& doseForm,
           ::fhir::Quantity_pskel& amount,
           ::fhir::string_pskel& synonym,
           ::fhir::MedicationKnowledge_RelatedMedicationKnowledge_pskel& relatedMedicationKnowledge,
           ::fhir::Reference_pskel& associatedMedication,
           ::fhir::CodeableConcept_pskel& productType,
           ::fhir::MedicationKnowledge_Monograph_pskel& monograph,
           ::fhir::MedicationKnowledge_Ingredient_pskel& ingredient,
           ::fhir::markdown_pskel& preparationInstruction,
           ::fhir::CodeableConcept_pskel& intendedRoute,
           ::fhir::MedicationKnowledge_Cost_pskel& cost,
           ::fhir::MedicationKnowledge_MonitoringProgram_pskel& monitoringProgram,
           ::fhir::MedicationKnowledge_AdministrationGuidelines_pskel& administrationGuidelines,
           ::fhir::MedicationKnowledge_MedicineClassification_pskel& medicineClassification,
           ::fhir::MedicationKnowledge_Packaging_pskel& packaging,
           ::fhir::MedicationKnowledge_DrugCharacteristic_pskel& drugCharacteristic,
           ::fhir::Reference_pskel& contraindication,
           ::fhir::MedicationKnowledge_Regulatory_pskel& regulatory,
           ::fhir::MedicationKnowledge_Kinetics_pskel& kinetics)
  {
    this->id_parser_ = &id;
    this->meta_parser_ = &meta;
    this->implicitRules_parser_ = &implicitRules;
    this->language_parser_ = &language;
    this->text_parser_ = &text;
    this->contained_parser_ = &contained;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->code_parser_ = &code;
    this->status_parser_ = &status;
    this->manufacturer_parser_ = &manufacturer;
    this->doseForm_parser_ = &doseForm;
    this->amount_parser_ = &amount;
    this->synonym_parser_ = &synonym;
    this->relatedMedicationKnowledge_parser_ = &relatedMedicationKnowledge;
    this->associatedMedication_parser_ = &associatedMedication;
    this->productType_parser_ = &productType;
    this->monograph_parser_ = &monograph;
    this->ingredient_parser_ = &ingredient;
    this->preparationInstruction_parser_ = &preparationInstruction;
    this->intendedRoute_parser_ = &intendedRoute;
    this->cost_parser_ = &cost;
    this->monitoringProgram_parser_ = &monitoringProgram;
    this->administrationGuidelines_parser_ = &administrationGuidelines;
    this->medicineClassification_parser_ = &medicineClassification;
    this->packaging_parser_ = &packaging;
    this->drugCharacteristic_parser_ = &drugCharacteristic;
    this->contraindication_parser_ = &contraindication;
    this->regulatory_parser_ = &regulatory;
    this->kinetics_parser_ = &kinetics;
  }

  MedicationKnowledge_pskel::
  MedicationKnowledge_pskel (::fhir::DomainResource_pskel* tiein)
  : ::fhir::DomainResource_pskel (tiein, 0),
    MedicationKnowledge_impl_ (0),
    code_parser_ (0),
    status_parser_ (0),
    manufacturer_parser_ (0),
    doseForm_parser_ (0),
    amount_parser_ (0),
    synonym_parser_ (0),
    relatedMedicationKnowledge_parser_ (0),
    associatedMedication_parser_ (0),
    productType_parser_ (0),
    monograph_parser_ (0),
    ingredient_parser_ (0),
    preparationInstruction_parser_ (0),
    intendedRoute_parser_ (0),
    cost_parser_ (0),
    monitoringProgram_parser_ (0),
    administrationGuidelines_parser_ (0),
    medicineClassification_parser_ (0),
    packaging_parser_ (0),
    drugCharacteristic_parser_ (0),
    contraindication_parser_ (0),
    regulatory_parser_ (0),
    kinetics_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_pskel::
  MedicationKnowledge_pskel (MedicationKnowledge_pskel* impl, void*)
  : ::fhir::DomainResource_pskel (impl, 0),
    MedicationKnowledge_impl_ (impl),
    code_parser_ (0),
    status_parser_ (0),
    manufacturer_parser_ (0),
    doseForm_parser_ (0),
    amount_parser_ (0),
    synonym_parser_ (0),
    relatedMedicationKnowledge_parser_ (0),
    associatedMedication_parser_ (0),
    productType_parser_ (0),
    monograph_parser_ (0),
    ingredient_parser_ (0),
    preparationInstruction_parser_ (0),
    intendedRoute_parser_ (0),
    cost_parser_ (0),
    monitoringProgram_parser_ (0),
    administrationGuidelines_parser_ (0),
    medicineClassification_parser_ (0),
    packaging_parser_ (0),
    drugCharacteristic_parser_ (0),
    contraindication_parser_ (0),
    regulatory_parser_ (0),
    kinetics_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_RelatedMedicationKnowledge_pskel
  //

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  reference_parser (::fhir::Reference_pskel& p)
  {
    this->reference_parser_ = &p;
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Reference_pskel& reference)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->reference_parser_ = &reference;
  }

  MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  MedicationKnowledge_RelatedMedicationKnowledge_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_RelatedMedicationKnowledge_impl_ (0),
    type_parser_ (0),
    reference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  MedicationKnowledge_RelatedMedicationKnowledge_pskel (MedicationKnowledge_RelatedMedicationKnowledge_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_RelatedMedicationKnowledge_impl_ (impl),
    type_parser_ (0),
    reference_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Monograph_pskel
  //

  void MedicationKnowledge_Monograph_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_Monograph_pskel::
  source_parser (::fhir::Reference_pskel& p)
  {
    this->source_parser_ = &p;
  }

  void MedicationKnowledge_Monograph_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Reference_pskel& source)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->source_parser_ = &source;
  }

  MedicationKnowledge_Monograph_pskel::
  MedicationKnowledge_Monograph_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Monograph_impl_ (0),
    type_parser_ (0),
    source_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Monograph_pskel::
  MedicationKnowledge_Monograph_pskel (MedicationKnowledge_Monograph_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Monograph_impl_ (impl),
    type_parser_ (0),
    source_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Ingredient_pskel
  //

  void MedicationKnowledge_Ingredient_pskel::
  itemCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->itemCodeableConcept_parser_ = &p;
  }

  void MedicationKnowledge_Ingredient_pskel::
  itemReference_parser (::fhir::Reference_pskel& p)
  {
    this->itemReference_parser_ = &p;
  }

  void MedicationKnowledge_Ingredient_pskel::
  isActive_parser (::fhir::boolean_pskel& p)
  {
    this->isActive_parser_ = &p;
  }

  void MedicationKnowledge_Ingredient_pskel::
  strength_parser (::fhir::Ratio_pskel& p)
  {
    this->strength_parser_ = &p;
  }

  void MedicationKnowledge_Ingredient_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& itemCodeableConcept,
           ::fhir::Reference_pskel& itemReference,
           ::fhir::boolean_pskel& isActive,
           ::fhir::Ratio_pskel& strength)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->itemCodeableConcept_parser_ = &itemCodeableConcept;
    this->itemReference_parser_ = &itemReference;
    this->isActive_parser_ = &isActive;
    this->strength_parser_ = &strength;
  }

  MedicationKnowledge_Ingredient_pskel::
  MedicationKnowledge_Ingredient_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Ingredient_impl_ (0),
    itemCodeableConcept_parser_ (0),
    itemReference_parser_ (0),
    isActive_parser_ (0),
    strength_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Ingredient_pskel::
  MedicationKnowledge_Ingredient_pskel (MedicationKnowledge_Ingredient_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Ingredient_impl_ (impl),
    itemCodeableConcept_parser_ (0),
    itemReference_parser_ (0),
    isActive_parser_ (0),
    strength_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Cost_pskel
  //

  void MedicationKnowledge_Cost_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_Cost_pskel::
  source_parser (::fhir::string_pskel& p)
  {
    this->source_parser_ = &p;
  }

  void MedicationKnowledge_Cost_pskel::
  cost_parser (::fhir::Money_pskel& p)
  {
    this->cost_parser_ = &p;
  }

  void MedicationKnowledge_Cost_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::string_pskel& source,
           ::fhir::Money_pskel& cost)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->source_parser_ = &source;
    this->cost_parser_ = &cost;
  }

  MedicationKnowledge_Cost_pskel::
  MedicationKnowledge_Cost_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Cost_impl_ (0),
    type_parser_ (0),
    source_parser_ (0),
    cost_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Cost_pskel::
  MedicationKnowledge_Cost_pskel (MedicationKnowledge_Cost_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Cost_impl_ (impl),
    type_parser_ (0),
    source_parser_ (0),
    cost_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_MonitoringProgram_pskel
  //

  void MedicationKnowledge_MonitoringProgram_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  name_parser (::fhir::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::string_pskel& name)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->name_parser_ = &name;
  }

  MedicationKnowledge_MonitoringProgram_pskel::
  MedicationKnowledge_MonitoringProgram_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_MonitoringProgram_impl_ (0),
    type_parser_ (0),
    name_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_MonitoringProgram_pskel::
  MedicationKnowledge_MonitoringProgram_pskel (MedicationKnowledge_MonitoringProgram_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_MonitoringProgram_impl_ (impl),
    type_parser_ (0),
    name_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_AdministrationGuidelines_pskel
  //

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  dosage_parser (::fhir::MedicationKnowledge_Dosage_pskel& p)
  {
    this->dosage_parser_ = &p;
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  indicationCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->indicationCodeableConcept_parser_ = &p;
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  indicationReference_parser (::fhir::Reference_pskel& p)
  {
    this->indicationReference_parser_ = &p;
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  patientCharacteristics_parser (::fhir::MedicationKnowledge_PatientCharacteristics_pskel& p)
  {
    this->patientCharacteristics_parser_ = &p;
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::MedicationKnowledge_Dosage_pskel& dosage,
           ::fhir::CodeableConcept_pskel& indicationCodeableConcept,
           ::fhir::Reference_pskel& indicationReference,
           ::fhir::MedicationKnowledge_PatientCharacteristics_pskel& patientCharacteristics)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->dosage_parser_ = &dosage;
    this->indicationCodeableConcept_parser_ = &indicationCodeableConcept;
    this->indicationReference_parser_ = &indicationReference;
    this->patientCharacteristics_parser_ = &patientCharacteristics;
  }

  MedicationKnowledge_AdministrationGuidelines_pskel::
  MedicationKnowledge_AdministrationGuidelines_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_AdministrationGuidelines_impl_ (0),
    dosage_parser_ (0),
    indicationCodeableConcept_parser_ (0),
    indicationReference_parser_ (0),
    patientCharacteristics_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_AdministrationGuidelines_pskel::
  MedicationKnowledge_AdministrationGuidelines_pskel (MedicationKnowledge_AdministrationGuidelines_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_AdministrationGuidelines_impl_ (impl),
    dosage_parser_ (0),
    indicationCodeableConcept_parser_ (0),
    indicationReference_parser_ (0),
    patientCharacteristics_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Dosage_pskel
  //

  void MedicationKnowledge_Dosage_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_Dosage_pskel::
  dosage_parser (::fhir::Dosage_pskel& p)
  {
    this->dosage_parser_ = &p;
  }

  void MedicationKnowledge_Dosage_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Dosage_pskel& dosage)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->dosage_parser_ = &dosage;
  }

  MedicationKnowledge_Dosage_pskel::
  MedicationKnowledge_Dosage_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Dosage_impl_ (0),
    type_parser_ (0),
    dosage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Dosage_pskel::
  MedicationKnowledge_Dosage_pskel (MedicationKnowledge_Dosage_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Dosage_impl_ (impl),
    type_parser_ (0),
    dosage_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_PatientCharacteristics_pskel
  //

  void MedicationKnowledge_PatientCharacteristics_pskel::
  characteristicCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->characteristicCodeableConcept_parser_ = &p;
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  characteristicQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->characteristicQuantity_parser_ = &p;
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  value_parser (::fhir::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& characteristicCodeableConcept,
           ::fhir::Quantity_pskel& characteristicQuantity,
           ::fhir::string_pskel& value)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->characteristicCodeableConcept_parser_ = &characteristicCodeableConcept;
    this->characteristicQuantity_parser_ = &characteristicQuantity;
    this->value_parser_ = &value;
  }

  MedicationKnowledge_PatientCharacteristics_pskel::
  MedicationKnowledge_PatientCharacteristics_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_PatientCharacteristics_impl_ (0),
    characteristicCodeableConcept_parser_ (0),
    characteristicQuantity_parser_ (0),
    value_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_PatientCharacteristics_pskel::
  MedicationKnowledge_PatientCharacteristics_pskel (MedicationKnowledge_PatientCharacteristics_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_PatientCharacteristics_impl_ (impl),
    characteristicCodeableConcept_parser_ (0),
    characteristicQuantity_parser_ (0),
    value_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_MedicineClassification_pskel
  //

  void MedicationKnowledge_MedicineClassification_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  classification_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->classification_parser_ = &p;
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::CodeableConcept_pskel& classification)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->classification_parser_ = &classification;
  }

  MedicationKnowledge_MedicineClassification_pskel::
  MedicationKnowledge_MedicineClassification_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_MedicineClassification_impl_ (0),
    type_parser_ (0),
    classification_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_MedicineClassification_pskel::
  MedicationKnowledge_MedicineClassification_pskel (MedicationKnowledge_MedicineClassification_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_MedicineClassification_impl_ (impl),
    type_parser_ (0),
    classification_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Packaging_pskel
  //

  void MedicationKnowledge_Packaging_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_Packaging_pskel::
  quantity_parser (::fhir::Quantity_pskel& p)
  {
    this->quantity_parser_ = &p;
  }

  void MedicationKnowledge_Packaging_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::Quantity_pskel& quantity)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->quantity_parser_ = &quantity;
  }

  MedicationKnowledge_Packaging_pskel::
  MedicationKnowledge_Packaging_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Packaging_impl_ (0),
    type_parser_ (0),
    quantity_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Packaging_pskel::
  MedicationKnowledge_Packaging_pskel (MedicationKnowledge_Packaging_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Packaging_impl_ (impl),
    type_parser_ (0),
    quantity_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_DrugCharacteristic_pskel
  //

  void MedicationKnowledge_DrugCharacteristic_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueCodeableConcept_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->valueCodeableConcept_parser_ = &p;
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueString_parser (::fhir::string_pskel& p)
  {
    this->valueString_parser_ = &p;
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueQuantity_parser (::fhir::Quantity_pskel& p)
  {
    this->valueQuantity_parser_ = &p;
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueBase64Binary_parser (::fhir::base64Binary_pskel& p)
  {
    this->valueBase64Binary_parser_ = &p;
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::CodeableConcept_pskel& valueCodeableConcept,
           ::fhir::string_pskel& valueString,
           ::fhir::Quantity_pskel& valueQuantity,
           ::fhir::base64Binary_pskel& valueBase64Binary)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->valueCodeableConcept_parser_ = &valueCodeableConcept;
    this->valueString_parser_ = &valueString;
    this->valueQuantity_parser_ = &valueQuantity;
    this->valueBase64Binary_parser_ = &valueBase64Binary;
  }

  MedicationKnowledge_DrugCharacteristic_pskel::
  MedicationKnowledge_DrugCharacteristic_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_DrugCharacteristic_impl_ (0),
    type_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueString_parser_ (0),
    valueQuantity_parser_ (0),
    valueBase64Binary_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_DrugCharacteristic_pskel::
  MedicationKnowledge_DrugCharacteristic_pskel (MedicationKnowledge_DrugCharacteristic_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_DrugCharacteristic_impl_ (impl),
    type_parser_ (0),
    valueCodeableConcept_parser_ (0),
    valueString_parser_ (0),
    valueQuantity_parser_ (0),
    valueBase64Binary_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Regulatory_pskel
  //

  void MedicationKnowledge_Regulatory_pskel::
  regulatoryAuthority_parser (::fhir::Reference_pskel& p)
  {
    this->regulatoryAuthority_parser_ = &p;
  }

  void MedicationKnowledge_Regulatory_pskel::
  substitution_parser (::fhir::MedicationKnowledge_Substitution_pskel& p)
  {
    this->substitution_parser_ = &p;
  }

  void MedicationKnowledge_Regulatory_pskel::
  schedule_parser (::fhir::MedicationKnowledge_Schedule_pskel& p)
  {
    this->schedule_parser_ = &p;
  }

  void MedicationKnowledge_Regulatory_pskel::
  maxDispense_parser (::fhir::MedicationKnowledge_MaxDispense_pskel& p)
  {
    this->maxDispense_parser_ = &p;
  }

  void MedicationKnowledge_Regulatory_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Reference_pskel& regulatoryAuthority,
           ::fhir::MedicationKnowledge_Substitution_pskel& substitution,
           ::fhir::MedicationKnowledge_Schedule_pskel& schedule,
           ::fhir::MedicationKnowledge_MaxDispense_pskel& maxDispense)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->regulatoryAuthority_parser_ = &regulatoryAuthority;
    this->substitution_parser_ = &substitution;
    this->schedule_parser_ = &schedule;
    this->maxDispense_parser_ = &maxDispense;
  }

  MedicationKnowledge_Regulatory_pskel::
  MedicationKnowledge_Regulatory_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Regulatory_impl_ (0),
    regulatoryAuthority_parser_ (0),
    substitution_parser_ (0),
    schedule_parser_ (0),
    maxDispense_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Regulatory_pskel::
  MedicationKnowledge_Regulatory_pskel (MedicationKnowledge_Regulatory_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Regulatory_impl_ (impl),
    regulatoryAuthority_parser_ (0),
    substitution_parser_ (0),
    schedule_parser_ (0),
    maxDispense_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Substitution_pskel
  //

  void MedicationKnowledge_Substitution_pskel::
  type_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void MedicationKnowledge_Substitution_pskel::
  allowed_parser (::fhir::boolean_pskel& p)
  {
    this->allowed_parser_ = &p;
  }

  void MedicationKnowledge_Substitution_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& type,
           ::fhir::boolean_pskel& allowed)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->type_parser_ = &type;
    this->allowed_parser_ = &allowed;
  }

  MedicationKnowledge_Substitution_pskel::
  MedicationKnowledge_Substitution_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Substitution_impl_ (0),
    type_parser_ (0),
    allowed_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Substitution_pskel::
  MedicationKnowledge_Substitution_pskel (MedicationKnowledge_Substitution_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Substitution_impl_ (impl),
    type_parser_ (0),
    allowed_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Schedule_pskel
  //

  void MedicationKnowledge_Schedule_pskel::
  schedule_parser (::fhir::CodeableConcept_pskel& p)
  {
    this->schedule_parser_ = &p;
  }

  void MedicationKnowledge_Schedule_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::CodeableConcept_pskel& schedule)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->schedule_parser_ = &schedule;
  }

  MedicationKnowledge_Schedule_pskel::
  MedicationKnowledge_Schedule_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Schedule_impl_ (0),
    schedule_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Schedule_pskel::
  MedicationKnowledge_Schedule_pskel (MedicationKnowledge_Schedule_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Schedule_impl_ (impl),
    schedule_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_MaxDispense_pskel
  //

  void MedicationKnowledge_MaxDispense_pskel::
  quantity_parser (::fhir::Quantity_pskel& p)
  {
    this->quantity_parser_ = &p;
  }

  void MedicationKnowledge_MaxDispense_pskel::
  period_parser (::fhir::Duration_pskel& p)
  {
    this->period_parser_ = &p;
  }

  void MedicationKnowledge_MaxDispense_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Quantity_pskel& quantity,
           ::fhir::Duration_pskel& period)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->quantity_parser_ = &quantity;
    this->period_parser_ = &period;
  }

  MedicationKnowledge_MaxDispense_pskel::
  MedicationKnowledge_MaxDispense_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_MaxDispense_impl_ (0),
    quantity_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_MaxDispense_pskel::
  MedicationKnowledge_MaxDispense_pskel (MedicationKnowledge_MaxDispense_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_MaxDispense_impl_ (impl),
    quantity_parser_ (0),
    period_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // MedicationKnowledge_Kinetics_pskel
  //

  void MedicationKnowledge_Kinetics_pskel::
  areaUnderCurve_parser (::fhir::Quantity_pskel& p)
  {
    this->areaUnderCurve_parser_ = &p;
  }

  void MedicationKnowledge_Kinetics_pskel::
  lethalDose50_parser (::fhir::Quantity_pskel& p)
  {
    this->lethalDose50_parser_ = &p;
  }

  void MedicationKnowledge_Kinetics_pskel::
  halfLifePeriod_parser (::fhir::Duration_pskel& p)
  {
    this->halfLifePeriod_parser_ = &p;
  }

  void MedicationKnowledge_Kinetics_pskel::
  parsers (::fhir::string_primitive_pskel& id,
           ::fhir::Extension_pskel& extension,
           ::fhir::Extension_pskel& modifierExtension,
           ::fhir::Quantity_pskel& areaUnderCurve,
           ::fhir::Quantity_pskel& lethalDose50,
           ::fhir::Duration_pskel& halfLifePeriod)
  {
    this->id_parser_ = &id;
    this->extension_parser_ = &extension;
    this->modifierExtension_parser_ = &modifierExtension;
    this->areaUnderCurve_parser_ = &areaUnderCurve;
    this->lethalDose50_parser_ = &lethalDose50;
    this->halfLifePeriod_parser_ = &halfLifePeriod;
  }

  MedicationKnowledge_Kinetics_pskel::
  MedicationKnowledge_Kinetics_pskel (::fhir::BackboneElement_pskel* tiein)
  : ::fhir::BackboneElement_pskel (tiein, 0),
    MedicationKnowledge_Kinetics_impl_ (0),
    areaUnderCurve_parser_ (0),
    lethalDose50_parser_ (0),
    halfLifePeriod_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  MedicationKnowledge_Kinetics_pskel::
  MedicationKnowledge_Kinetics_pskel (MedicationKnowledge_Kinetics_pskel* impl, void*)
  : ::fhir::BackboneElement_pskel (impl, 0),
    MedicationKnowledge_Kinetics_impl_ (impl),
    areaUnderCurve_parser_ (0),
    lethalDose50_parser_ (0),
    halfLifePeriod_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }
}

#include <assert.h>

namespace fhir
{
  // MedicationKnowledge_pskel
  //

  void MedicationKnowledge_pskel::
  code ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->code ();
  }

  void MedicationKnowledge_pskel::
  status ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->status ();
  }

  void MedicationKnowledge_pskel::
  manufacturer ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->manufacturer ();
  }

  void MedicationKnowledge_pskel::
  doseForm ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->doseForm ();
  }

  void MedicationKnowledge_pskel::
  amount ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->amount ();
  }

  void MedicationKnowledge_pskel::
  synonym ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->synonym ();
  }

  void MedicationKnowledge_pskel::
  relatedMedicationKnowledge ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->relatedMedicationKnowledge ();
  }

  void MedicationKnowledge_pskel::
  associatedMedication ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->associatedMedication ();
  }

  void MedicationKnowledge_pskel::
  productType ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->productType ();
  }

  void MedicationKnowledge_pskel::
  monograph ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->monograph ();
  }

  void MedicationKnowledge_pskel::
  ingredient ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->ingredient ();
  }

  void MedicationKnowledge_pskel::
  preparationInstruction ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->preparationInstruction ();
  }

  void MedicationKnowledge_pskel::
  intendedRoute ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->intendedRoute ();
  }

  void MedicationKnowledge_pskel::
  cost ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->cost ();
  }

  void MedicationKnowledge_pskel::
  monitoringProgram ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->monitoringProgram ();
  }

  void MedicationKnowledge_pskel::
  administrationGuidelines ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->administrationGuidelines ();
  }

  void MedicationKnowledge_pskel::
  medicineClassification ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->medicineClassification ();
  }

  void MedicationKnowledge_pskel::
  packaging ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->packaging ();
  }

  void MedicationKnowledge_pskel::
  drugCharacteristic ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->drugCharacteristic ();
  }

  void MedicationKnowledge_pskel::
  contraindication ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->contraindication ();
  }

  void MedicationKnowledge_pskel::
  regulatory ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->regulatory ();
  }

  void MedicationKnowledge_pskel::
  kinetics ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->kinetics ();
  }

  void MedicationKnowledge_pskel::
  post_MedicationKnowledge ()
  {
    if (this->MedicationKnowledge_impl_)
      this->MedicationKnowledge_impl_->post_MedicationKnowledge ();
    else
      post_DomainResource ();
  }

  void MedicationKnowledge_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::DomainResource_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->code_parser_)
      this->code_parser_->_reset ();

    if (this->status_parser_)
      this->status_parser_->_reset ();

    if (this->manufacturer_parser_)
      this->manufacturer_parser_->_reset ();

    if (this->doseForm_parser_)
      this->doseForm_parser_->_reset ();

    if (this->amount_parser_)
      this->amount_parser_->_reset ();

    if (this->synonym_parser_)
      this->synonym_parser_->_reset ();

    if (this->relatedMedicationKnowledge_parser_)
      this->relatedMedicationKnowledge_parser_->_reset ();

    if (this->associatedMedication_parser_)
      this->associatedMedication_parser_->_reset ();

    if (this->productType_parser_)
      this->productType_parser_->_reset ();

    if (this->monograph_parser_)
      this->monograph_parser_->_reset ();

    if (this->ingredient_parser_)
      this->ingredient_parser_->_reset ();

    if (this->preparationInstruction_parser_)
      this->preparationInstruction_parser_->_reset ();

    if (this->intendedRoute_parser_)
      this->intendedRoute_parser_->_reset ();

    if (this->cost_parser_)
      this->cost_parser_->_reset ();

    if (this->monitoringProgram_parser_)
      this->monitoringProgram_parser_->_reset ();

    if (this->administrationGuidelines_parser_)
      this->administrationGuidelines_parser_->_reset ();

    if (this->medicineClassification_parser_)
      this->medicineClassification_parser_->_reset ();

    if (this->packaging_parser_)
      this->packaging_parser_->_reset ();

    if (this->drugCharacteristic_parser_)
      this->drugCharacteristic_parser_->_reset ();

    if (this->contraindication_parser_)
      this->contraindication_parser_->_reset ();

    if (this->regulatory_parser_)
      this->regulatory_parser_->_reset ();

    if (this->kinetics_parser_)
      this->kinetics_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_RelatedMedicationKnowledge_pskel
  //

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  type ()
  {
    if (this->MedicationKnowledge_RelatedMedicationKnowledge_impl_)
      this->MedicationKnowledge_RelatedMedicationKnowledge_impl_->type ();
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  reference ()
  {
    if (this->MedicationKnowledge_RelatedMedicationKnowledge_impl_)
      this->MedicationKnowledge_RelatedMedicationKnowledge_impl_->reference ();
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  post_MedicationKnowledge_RelatedMedicationKnowledge ()
  {
    if (this->MedicationKnowledge_RelatedMedicationKnowledge_impl_)
      this->MedicationKnowledge_RelatedMedicationKnowledge_impl_->post_MedicationKnowledge_RelatedMedicationKnowledge ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->reference_parser_)
      this->reference_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Monograph_pskel
  //

  void MedicationKnowledge_Monograph_pskel::
  type ()
  {
    if (this->MedicationKnowledge_Monograph_impl_)
      this->MedicationKnowledge_Monograph_impl_->type ();
  }

  void MedicationKnowledge_Monograph_pskel::
  source ()
  {
    if (this->MedicationKnowledge_Monograph_impl_)
      this->MedicationKnowledge_Monograph_impl_->source ();
  }

  void MedicationKnowledge_Monograph_pskel::
  post_MedicationKnowledge_Monograph ()
  {
    if (this->MedicationKnowledge_Monograph_impl_)
      this->MedicationKnowledge_Monograph_impl_->post_MedicationKnowledge_Monograph ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Monograph_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->source_parser_)
      this->source_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Ingredient_pskel
  //

  void MedicationKnowledge_Ingredient_pskel::
  itemCodeableConcept ()
  {
    if (this->MedicationKnowledge_Ingredient_impl_)
      this->MedicationKnowledge_Ingredient_impl_->itemCodeableConcept ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  itemReference ()
  {
    if (this->MedicationKnowledge_Ingredient_impl_)
      this->MedicationKnowledge_Ingredient_impl_->itemReference ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  isActive ()
  {
    if (this->MedicationKnowledge_Ingredient_impl_)
      this->MedicationKnowledge_Ingredient_impl_->isActive ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  strength ()
  {
    if (this->MedicationKnowledge_Ingredient_impl_)
      this->MedicationKnowledge_Ingredient_impl_->strength ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  post_MedicationKnowledge_Ingredient ()
  {
    if (this->MedicationKnowledge_Ingredient_impl_)
      this->MedicationKnowledge_Ingredient_impl_->post_MedicationKnowledge_Ingredient ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->itemCodeableConcept_parser_)
      this->itemCodeableConcept_parser_->_reset ();

    if (this->itemReference_parser_)
      this->itemReference_parser_->_reset ();

    if (this->isActive_parser_)
      this->isActive_parser_->_reset ();

    if (this->strength_parser_)
      this->strength_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Cost_pskel
  //

  void MedicationKnowledge_Cost_pskel::
  type ()
  {
    if (this->MedicationKnowledge_Cost_impl_)
      this->MedicationKnowledge_Cost_impl_->type ();
  }

  void MedicationKnowledge_Cost_pskel::
  source ()
  {
    if (this->MedicationKnowledge_Cost_impl_)
      this->MedicationKnowledge_Cost_impl_->source ();
  }

  void MedicationKnowledge_Cost_pskel::
  cost ()
  {
    if (this->MedicationKnowledge_Cost_impl_)
      this->MedicationKnowledge_Cost_impl_->cost ();
  }

  void MedicationKnowledge_Cost_pskel::
  post_MedicationKnowledge_Cost ()
  {
    if (this->MedicationKnowledge_Cost_impl_)
      this->MedicationKnowledge_Cost_impl_->post_MedicationKnowledge_Cost ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Cost_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->source_parser_)
      this->source_parser_->_reset ();

    if (this->cost_parser_)
      this->cost_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_MonitoringProgram_pskel
  //

  void MedicationKnowledge_MonitoringProgram_pskel::
  type ()
  {
    if (this->MedicationKnowledge_MonitoringProgram_impl_)
      this->MedicationKnowledge_MonitoringProgram_impl_->type ();
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  name ()
  {
    if (this->MedicationKnowledge_MonitoringProgram_impl_)
      this->MedicationKnowledge_MonitoringProgram_impl_->name ();
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  post_MedicationKnowledge_MonitoringProgram ()
  {
    if (this->MedicationKnowledge_MonitoringProgram_impl_)
      this->MedicationKnowledge_MonitoringProgram_impl_->post_MedicationKnowledge_MonitoringProgram ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->name_parser_)
      this->name_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_AdministrationGuidelines_pskel
  //

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  dosage ()
  {
    if (this->MedicationKnowledge_AdministrationGuidelines_impl_)
      this->MedicationKnowledge_AdministrationGuidelines_impl_->dosage ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  indicationCodeableConcept ()
  {
    if (this->MedicationKnowledge_AdministrationGuidelines_impl_)
      this->MedicationKnowledge_AdministrationGuidelines_impl_->indicationCodeableConcept ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  indicationReference ()
  {
    if (this->MedicationKnowledge_AdministrationGuidelines_impl_)
      this->MedicationKnowledge_AdministrationGuidelines_impl_->indicationReference ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  patientCharacteristics ()
  {
    if (this->MedicationKnowledge_AdministrationGuidelines_impl_)
      this->MedicationKnowledge_AdministrationGuidelines_impl_->patientCharacteristics ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  post_MedicationKnowledge_AdministrationGuidelines ()
  {
    if (this->MedicationKnowledge_AdministrationGuidelines_impl_)
      this->MedicationKnowledge_AdministrationGuidelines_impl_->post_MedicationKnowledge_AdministrationGuidelines ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->dosage_parser_)
      this->dosage_parser_->_reset ();

    if (this->indicationCodeableConcept_parser_)
      this->indicationCodeableConcept_parser_->_reset ();

    if (this->indicationReference_parser_)
      this->indicationReference_parser_->_reset ();

    if (this->patientCharacteristics_parser_)
      this->patientCharacteristics_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Dosage_pskel
  //

  void MedicationKnowledge_Dosage_pskel::
  type ()
  {
    if (this->MedicationKnowledge_Dosage_impl_)
      this->MedicationKnowledge_Dosage_impl_->type ();
  }

  void MedicationKnowledge_Dosage_pskel::
  dosage ()
  {
    if (this->MedicationKnowledge_Dosage_impl_)
      this->MedicationKnowledge_Dosage_impl_->dosage ();
  }

  void MedicationKnowledge_Dosage_pskel::
  post_MedicationKnowledge_Dosage ()
  {
    if (this->MedicationKnowledge_Dosage_impl_)
      this->MedicationKnowledge_Dosage_impl_->post_MedicationKnowledge_Dosage ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Dosage_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->dosage_parser_)
      this->dosage_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_PatientCharacteristics_pskel
  //

  void MedicationKnowledge_PatientCharacteristics_pskel::
  characteristicCodeableConcept ()
  {
    if (this->MedicationKnowledge_PatientCharacteristics_impl_)
      this->MedicationKnowledge_PatientCharacteristics_impl_->characteristicCodeableConcept ();
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  characteristicQuantity ()
  {
    if (this->MedicationKnowledge_PatientCharacteristics_impl_)
      this->MedicationKnowledge_PatientCharacteristics_impl_->characteristicQuantity ();
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  value ()
  {
    if (this->MedicationKnowledge_PatientCharacteristics_impl_)
      this->MedicationKnowledge_PatientCharacteristics_impl_->value ();
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  post_MedicationKnowledge_PatientCharacteristics ()
  {
    if (this->MedicationKnowledge_PatientCharacteristics_impl_)
      this->MedicationKnowledge_PatientCharacteristics_impl_->post_MedicationKnowledge_PatientCharacteristics ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->characteristicCodeableConcept_parser_)
      this->characteristicCodeableConcept_parser_->_reset ();

    if (this->characteristicQuantity_parser_)
      this->characteristicQuantity_parser_->_reset ();

    if (this->value_parser_)
      this->value_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_MedicineClassification_pskel
  //

  void MedicationKnowledge_MedicineClassification_pskel::
  type ()
  {
    if (this->MedicationKnowledge_MedicineClassification_impl_)
      this->MedicationKnowledge_MedicineClassification_impl_->type ();
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  classification ()
  {
    if (this->MedicationKnowledge_MedicineClassification_impl_)
      this->MedicationKnowledge_MedicineClassification_impl_->classification ();
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  post_MedicationKnowledge_MedicineClassification ()
  {
    if (this->MedicationKnowledge_MedicineClassification_impl_)
      this->MedicationKnowledge_MedicineClassification_impl_->post_MedicationKnowledge_MedicineClassification ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->classification_parser_)
      this->classification_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Packaging_pskel
  //

  void MedicationKnowledge_Packaging_pskel::
  type ()
  {
    if (this->MedicationKnowledge_Packaging_impl_)
      this->MedicationKnowledge_Packaging_impl_->type ();
  }

  void MedicationKnowledge_Packaging_pskel::
  quantity ()
  {
    if (this->MedicationKnowledge_Packaging_impl_)
      this->MedicationKnowledge_Packaging_impl_->quantity ();
  }

  void MedicationKnowledge_Packaging_pskel::
  post_MedicationKnowledge_Packaging ()
  {
    if (this->MedicationKnowledge_Packaging_impl_)
      this->MedicationKnowledge_Packaging_impl_->post_MedicationKnowledge_Packaging ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Packaging_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->quantity_parser_)
      this->quantity_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_DrugCharacteristic_pskel
  //

  void MedicationKnowledge_DrugCharacteristic_pskel::
  type ()
  {
    if (this->MedicationKnowledge_DrugCharacteristic_impl_)
      this->MedicationKnowledge_DrugCharacteristic_impl_->type ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueCodeableConcept ()
  {
    if (this->MedicationKnowledge_DrugCharacteristic_impl_)
      this->MedicationKnowledge_DrugCharacteristic_impl_->valueCodeableConcept ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueString ()
  {
    if (this->MedicationKnowledge_DrugCharacteristic_impl_)
      this->MedicationKnowledge_DrugCharacteristic_impl_->valueString ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueQuantity ()
  {
    if (this->MedicationKnowledge_DrugCharacteristic_impl_)
      this->MedicationKnowledge_DrugCharacteristic_impl_->valueQuantity ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  valueBase64Binary ()
  {
    if (this->MedicationKnowledge_DrugCharacteristic_impl_)
      this->MedicationKnowledge_DrugCharacteristic_impl_->valueBase64Binary ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  post_MedicationKnowledge_DrugCharacteristic ()
  {
    if (this->MedicationKnowledge_DrugCharacteristic_impl_)
      this->MedicationKnowledge_DrugCharacteristic_impl_->post_MedicationKnowledge_DrugCharacteristic ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->valueCodeableConcept_parser_)
      this->valueCodeableConcept_parser_->_reset ();

    if (this->valueString_parser_)
      this->valueString_parser_->_reset ();

    if (this->valueQuantity_parser_)
      this->valueQuantity_parser_->_reset ();

    if (this->valueBase64Binary_parser_)
      this->valueBase64Binary_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Regulatory_pskel
  //

  void MedicationKnowledge_Regulatory_pskel::
  regulatoryAuthority ()
  {
    if (this->MedicationKnowledge_Regulatory_impl_)
      this->MedicationKnowledge_Regulatory_impl_->regulatoryAuthority ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  substitution ()
  {
    if (this->MedicationKnowledge_Regulatory_impl_)
      this->MedicationKnowledge_Regulatory_impl_->substitution ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  schedule ()
  {
    if (this->MedicationKnowledge_Regulatory_impl_)
      this->MedicationKnowledge_Regulatory_impl_->schedule ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  maxDispense ()
  {
    if (this->MedicationKnowledge_Regulatory_impl_)
      this->MedicationKnowledge_Regulatory_impl_->maxDispense ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  post_MedicationKnowledge_Regulatory ()
  {
    if (this->MedicationKnowledge_Regulatory_impl_)
      this->MedicationKnowledge_Regulatory_impl_->post_MedicationKnowledge_Regulatory ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->regulatoryAuthority_parser_)
      this->regulatoryAuthority_parser_->_reset ();

    if (this->substitution_parser_)
      this->substitution_parser_->_reset ();

    if (this->schedule_parser_)
      this->schedule_parser_->_reset ();

    if (this->maxDispense_parser_)
      this->maxDispense_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Substitution_pskel
  //

  void MedicationKnowledge_Substitution_pskel::
  type ()
  {
    if (this->MedicationKnowledge_Substitution_impl_)
      this->MedicationKnowledge_Substitution_impl_->type ();
  }

  void MedicationKnowledge_Substitution_pskel::
  allowed ()
  {
    if (this->MedicationKnowledge_Substitution_impl_)
      this->MedicationKnowledge_Substitution_impl_->allowed ();
  }

  void MedicationKnowledge_Substitution_pskel::
  post_MedicationKnowledge_Substitution ()
  {
    if (this->MedicationKnowledge_Substitution_impl_)
      this->MedicationKnowledge_Substitution_impl_->post_MedicationKnowledge_Substitution ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Substitution_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->type_parser_)
      this->type_parser_->_reset ();

    if (this->allowed_parser_)
      this->allowed_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Schedule_pskel
  //

  void MedicationKnowledge_Schedule_pskel::
  schedule ()
  {
    if (this->MedicationKnowledge_Schedule_impl_)
      this->MedicationKnowledge_Schedule_impl_->schedule ();
  }

  void MedicationKnowledge_Schedule_pskel::
  post_MedicationKnowledge_Schedule ()
  {
    if (this->MedicationKnowledge_Schedule_impl_)
      this->MedicationKnowledge_Schedule_impl_->post_MedicationKnowledge_Schedule ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Schedule_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->schedule_parser_)
      this->schedule_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_MaxDispense_pskel
  //

  void MedicationKnowledge_MaxDispense_pskel::
  quantity ()
  {
    if (this->MedicationKnowledge_MaxDispense_impl_)
      this->MedicationKnowledge_MaxDispense_impl_->quantity ();
  }

  void MedicationKnowledge_MaxDispense_pskel::
  period ()
  {
    if (this->MedicationKnowledge_MaxDispense_impl_)
      this->MedicationKnowledge_MaxDispense_impl_->period ();
  }

  void MedicationKnowledge_MaxDispense_pskel::
  post_MedicationKnowledge_MaxDispense ()
  {
    if (this->MedicationKnowledge_MaxDispense_impl_)
      this->MedicationKnowledge_MaxDispense_impl_->post_MedicationKnowledge_MaxDispense ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_MaxDispense_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->quantity_parser_)
      this->quantity_parser_->_reset ();

    if (this->period_parser_)
      this->period_parser_->_reset ();

    this->resetting_ = false;
  }

  // MedicationKnowledge_Kinetics_pskel
  //

  void MedicationKnowledge_Kinetics_pskel::
  areaUnderCurve ()
  {
    if (this->MedicationKnowledge_Kinetics_impl_)
      this->MedicationKnowledge_Kinetics_impl_->areaUnderCurve ();
  }

  void MedicationKnowledge_Kinetics_pskel::
  lethalDose50 ()
  {
    if (this->MedicationKnowledge_Kinetics_impl_)
      this->MedicationKnowledge_Kinetics_impl_->lethalDose50 ();
  }

  void MedicationKnowledge_Kinetics_pskel::
  halfLifePeriod ()
  {
    if (this->MedicationKnowledge_Kinetics_impl_)
      this->MedicationKnowledge_Kinetics_impl_->halfLifePeriod ();
  }

  void MedicationKnowledge_Kinetics_pskel::
  post_MedicationKnowledge_Kinetics ()
  {
    if (this->MedicationKnowledge_Kinetics_impl_)
      this->MedicationKnowledge_Kinetics_impl_->post_MedicationKnowledge_Kinetics ();
    else
      post_BackboneElement ();
  }

  void MedicationKnowledge_Kinetics_pskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::fhir::BackboneElement_pskel base;
    base::_reset ();

    this->v_state_stack_.clear ();

    this->resetting_ = true;

    if (this->areaUnderCurve_parser_)
      this->areaUnderCurve_parser_->_reset ();

    if (this->lethalDose50_parser_)
      this->lethalDose50_parser_->_reset ();

    if (this->halfLifePeriod_parser_)
      this->halfLifePeriod_parser_->_reset ();

    this->resetting_ = false;
  }
}

#include <assert.h>

namespace fhir
{
  // Element validation and dispatch functions for MedicationKnowledge_pskel.
  //
  bool MedicationKnowledge_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "code" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "status" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "manufacturer" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "doseForm" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "amount" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;
        else if (n == "synonym" &&
                 ns == "http://hl7.org/fhir")
          s = 5UL;
        else if (n == "relatedMedicationKnowledge" &&
                 ns == "http://hl7.org/fhir")
          s = 6UL;
        else if (n == "associatedMedication" &&
                 ns == "http://hl7.org/fhir")
          s = 7UL;
        else if (n == "productType" &&
                 ns == "http://hl7.org/fhir")
          s = 8UL;
        else if (n == "monograph" &&
                 ns == "http://hl7.org/fhir")
          s = 9UL;
        else if (n == "ingredient" &&
                 ns == "http://hl7.org/fhir")
          s = 10UL;
        else if (n == "preparationInstruction" &&
                 ns == "http://hl7.org/fhir")
          s = 11UL;
        else if (n == "intendedRoute" &&
                 ns == "http://hl7.org/fhir")
          s = 12UL;
        else if (n == "cost" &&
                 ns == "http://hl7.org/fhir")
          s = 13UL;
        else if (n == "monitoringProgram" &&
                 ns == "http://hl7.org/fhir")
          s = 14UL;
        else if (n == "administrationGuidelines" &&
                 ns == "http://hl7.org/fhir")
          s = 15UL;
        else if (n == "medicineClassification" &&
                 ns == "http://hl7.org/fhir")
          s = 16UL;
        else if (n == "packaging" &&
                 ns == "http://hl7.org/fhir")
          s = 17UL;
        else if (n == "drugCharacteristic" &&
                 ns == "http://hl7.org/fhir")
          s = 18UL;
        else if (n == "contraindication" &&
                 ns == "http://hl7.org/fhir")
          s = 19UL;
        else if (n == "regulatory" &&
                 ns == "http://hl7.org/fhir")
          s = 20UL;
        else if (n == "kinetics" &&
                 ns == "http://hl7.org/fhir")
          s = 21UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::DomainResource_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::DomainResource_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::DomainResource_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "code" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->code_parser_)
            {
              this->code_parser_->pre ();
              ctx.nested_parser (this->code_parser_);
            }
          }
          else
          {
            if (this->code_parser_ != 0)
            {
              this->code_parser_->post_CodeableConcept ();
              this->code ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "status" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->status_parser_)
            {
              this->status_parser_->pre ();
              ctx.nested_parser (this->status_parser_);
            }
          }
          else
          {
            if (this->status_parser_ != 0)
            {
              this->status_parser_->post_code ();
              this->status ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "manufacturer" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->manufacturer_parser_)
            {
              this->manufacturer_parser_->pre ();
              ctx.nested_parser (this->manufacturer_parser_);
            }
          }
          else
          {
            if (this->manufacturer_parser_ != 0)
            {
              this->manufacturer_parser_->post_Reference ();
              this->manufacturer ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "doseForm" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->doseForm_parser_)
            {
              this->doseForm_parser_->pre ();
              ctx.nested_parser (this->doseForm_parser_);
            }
          }
          else
          {
            if (this->doseForm_parser_ != 0)
            {
              this->doseForm_parser_->post_CodeableConcept ();
              this->doseForm ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "amount" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->amount_parser_)
            {
              this->amount_parser_->pre ();
              ctx.nested_parser (this->amount_parser_);
            }
          }
          else
          {
            if (this->amount_parser_ != 0)
            {
              this->amount_parser_->post_Quantity ();
              this->amount ();
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "synonym" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->synonym_parser_)
            {
              this->synonym_parser_->pre ();
              ctx.nested_parser (this->synonym_parser_);
            }
          }
          else
          {
            if (this->synonym_parser_ != 0)
            {
              this->synonym_parser_->post_string ();
              this->synonym ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "relatedMedicationKnowledge" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->relatedMedicationKnowledge_parser_)
            {
              this->relatedMedicationKnowledge_parser_->pre ();
              ctx.nested_parser (this->relatedMedicationKnowledge_parser_);
            }
          }
          else
          {
            if (this->relatedMedicationKnowledge_parser_ != 0)
            {
              this->relatedMedicationKnowledge_parser_->post_MedicationKnowledge_RelatedMedicationKnowledge ();
              this->relatedMedicationKnowledge ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 7UL;
          // Fall through.
        }
      }
      case 7UL:
      {
        if (n == "associatedMedication" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->associatedMedication_parser_)
            {
              this->associatedMedication_parser_->pre ();
              ctx.nested_parser (this->associatedMedication_parser_);
            }
          }
          else
          {
            if (this->associatedMedication_parser_ != 0)
            {
              this->associatedMedication_parser_->post_Reference ();
              this->associatedMedication ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 8UL;
          // Fall through.
        }
      }
      case 8UL:
      {
        if (n == "productType" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->productType_parser_)
            {
              this->productType_parser_->pre ();
              ctx.nested_parser (this->productType_parser_);
            }
          }
          else
          {
            if (this->productType_parser_ != 0)
            {
              this->productType_parser_->post_CodeableConcept ();
              this->productType ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 9UL;
          // Fall through.
        }
      }
      case 9UL:
      {
        if (n == "monograph" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->monograph_parser_)
            {
              this->monograph_parser_->pre ();
              ctx.nested_parser (this->monograph_parser_);
            }
          }
          else
          {
            if (this->monograph_parser_ != 0)
            {
              this->monograph_parser_->post_MedicationKnowledge_Monograph ();
              this->monograph ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 10UL;
          // Fall through.
        }
      }
      case 10UL:
      {
        if (n == "ingredient" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->ingredient_parser_)
            {
              this->ingredient_parser_->pre ();
              ctx.nested_parser (this->ingredient_parser_);
            }
          }
          else
          {
            if (this->ingredient_parser_ != 0)
            {
              this->ingredient_parser_->post_MedicationKnowledge_Ingredient ();
              this->ingredient ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 11UL;
          // Fall through.
        }
      }
      case 11UL:
      {
        if (n == "preparationInstruction" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->preparationInstruction_parser_)
            {
              this->preparationInstruction_parser_->pre ();
              ctx.nested_parser (this->preparationInstruction_parser_);
            }
          }
          else
          {
            if (this->preparationInstruction_parser_ != 0)
            {
              this->preparationInstruction_parser_->post_markdown ();
              this->preparationInstruction ();
            }

            count = 0;
            state = 12UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 12UL;
          // Fall through.
        }
      }
      case 12UL:
      {
        if (n == "intendedRoute" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->intendedRoute_parser_)
            {
              this->intendedRoute_parser_->pre ();
              ctx.nested_parser (this->intendedRoute_parser_);
            }
          }
          else
          {
            if (this->intendedRoute_parser_ != 0)
            {
              this->intendedRoute_parser_->post_CodeableConcept ();
              this->intendedRoute ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 13UL;
          // Fall through.
        }
      }
      case 13UL:
      {
        if (n == "cost" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->cost_parser_)
            {
              this->cost_parser_->pre ();
              ctx.nested_parser (this->cost_parser_);
            }
          }
          else
          {
            if (this->cost_parser_ != 0)
            {
              this->cost_parser_->post_MedicationKnowledge_Cost ();
              this->cost ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 14UL;
          // Fall through.
        }
      }
      case 14UL:
      {
        if (n == "monitoringProgram" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->monitoringProgram_parser_)
            {
              this->monitoringProgram_parser_->pre ();
              ctx.nested_parser (this->monitoringProgram_parser_);
            }
          }
          else
          {
            if (this->monitoringProgram_parser_ != 0)
            {
              this->monitoringProgram_parser_->post_MedicationKnowledge_MonitoringProgram ();
              this->monitoringProgram ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 15UL;
          // Fall through.
        }
      }
      case 15UL:
      {
        if (n == "administrationGuidelines" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->administrationGuidelines_parser_)
            {
              this->administrationGuidelines_parser_->pre ();
              ctx.nested_parser (this->administrationGuidelines_parser_);
            }
          }
          else
          {
            if (this->administrationGuidelines_parser_ != 0)
            {
              this->administrationGuidelines_parser_->post_MedicationKnowledge_AdministrationGuidelines ();
              this->administrationGuidelines ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 16UL;
          // Fall through.
        }
      }
      case 16UL:
      {
        if (n == "medicineClassification" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->medicineClassification_parser_)
            {
              this->medicineClassification_parser_->pre ();
              ctx.nested_parser (this->medicineClassification_parser_);
            }
          }
          else
          {
            if (this->medicineClassification_parser_ != 0)
            {
              this->medicineClassification_parser_->post_MedicationKnowledge_MedicineClassification ();
              this->medicineClassification ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 17UL;
          // Fall through.
        }
      }
      case 17UL:
      {
        if (n == "packaging" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->packaging_parser_)
            {
              this->packaging_parser_->pre ();
              ctx.nested_parser (this->packaging_parser_);
            }
          }
          else
          {
            if (this->packaging_parser_ != 0)
            {
              this->packaging_parser_->post_MedicationKnowledge_Packaging ();
              this->packaging ();
            }

            count = 0;
            state = 18UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 18UL;
          // Fall through.
        }
      }
      case 18UL:
      {
        if (n == "drugCharacteristic" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->drugCharacteristic_parser_)
            {
              this->drugCharacteristic_parser_->pre ();
              ctx.nested_parser (this->drugCharacteristic_parser_);
            }
          }
          else
          {
            if (this->drugCharacteristic_parser_ != 0)
            {
              this->drugCharacteristic_parser_->post_MedicationKnowledge_DrugCharacteristic ();
              this->drugCharacteristic ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 19UL;
          // Fall through.
        }
      }
      case 19UL:
      {
        if (n == "contraindication" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->contraindication_parser_)
            {
              this->contraindication_parser_->pre ();
              ctx.nested_parser (this->contraindication_parser_);
            }
          }
          else
          {
            if (this->contraindication_parser_ != 0)
            {
              this->contraindication_parser_->post_Reference ();
              this->contraindication ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 20UL;
          // Fall through.
        }
      }
      case 20UL:
      {
        if (n == "regulatory" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->regulatory_parser_)
            {
              this->regulatory_parser_->pre ();
              ctx.nested_parser (this->regulatory_parser_);
            }
          }
          else
          {
            if (this->regulatory_parser_ != 0)
            {
              this->regulatory_parser_->post_MedicationKnowledge_Regulatory ();
              this->regulatory ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 21UL;
          // Fall through.
        }
      }
      case 21UL:
      {
        if (n == "kinetics" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->kinetics_parser_)
            {
              this->kinetics_parser_->pre ();
              ctx.nested_parser (this->kinetics_parser_);
            }
          }
          else
          {
            if (this->kinetics_parser_ != 0)
            {
              this->kinetics_parser_->post_MedicationKnowledge_Kinetics ();
              this->kinetics ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_RelatedMedicationKnowledge_pskel.
  //
  bool MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_RelatedMedicationKnowledge_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_RelatedMedicationKnowledge_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "reference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->reference_parser_)
            {
              this->reference_parser_->pre ();
              ctx.nested_parser (this->reference_parser_);
            }
          }
          else
          {
            if (this->reference_parser_ != 0)
            {
              this->reference_parser_->post_Reference ();
              this->reference ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Monograph_pskel.
  //
  bool MedicationKnowledge_Monograph_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "source" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Monograph_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Monograph_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Monograph_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Monograph_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Monograph_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "source" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->source_parser_)
            {
              this->source_parser_->pre ();
              ctx.nested_parser (this->source_parser_);
            }
          }
          else
          {
            if (this->source_parser_ != 0)
            {
              this->source_parser_->post_Reference ();
              this->source ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Ingredient_pskel.
  //
  bool MedicationKnowledge_Ingredient_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "itemCodeableConcept" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "itemReference" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "isActive" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "strength" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Ingredient_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Ingredient_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Ingredient_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Ingredient_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "itemCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->itemCodeableConcept_parser_)
            {
              this->itemCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->itemCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->itemCodeableConcept_parser_ != 0)
            {
              this->itemCodeableConcept_parser_->post_CodeableConcept ();
              this->itemCodeableConcept ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "itemReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->itemReference_parser_)
            {
              this->itemReference_parser_->pre ();
              ctx.nested_parser (this->itemReference_parser_);
            }
          }
          else
          {
            if (this->itemReference_parser_ != 0)
            {
              this->itemReference_parser_->post_Reference ();
              this->itemReference ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "isActive" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->isActive_parser_)
            {
              this->isActive_parser_->pre ();
              ctx.nested_parser (this->isActive_parser_);
            }
          }
          else
          {
            if (this->isActive_parser_ != 0)
            {
              this->isActive_parser_->post_boolean ();
              this->isActive ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "strength" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->strength_parser_)
            {
              this->strength_parser_->pre ();
              ctx.nested_parser (this->strength_parser_);
            }
          }
          else
          {
            if (this->strength_parser_ != 0)
            {
              this->strength_parser_->post_Ratio ();
              this->strength ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Cost_pskel.
  //
  bool MedicationKnowledge_Cost_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Cost_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Cost_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Cost_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Cost_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Cost_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "source" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->source_parser_)
            {
              this->source_parser_->pre ();
              ctx.nested_parser (this->source_parser_);
            }
          }
          else
          {
            if (this->source_parser_ != 0)
            {
              this->source_parser_->post_string ();
              this->source ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "cost" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->cost_parser_)
            {
              this->cost_parser_->pre ();
              ctx.nested_parser (this->cost_parser_);
            }
          }
          else
          {
            if (this->cost_parser_ != 0)
            {
              this->cost_parser_->post_Money ();
              this->cost ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_MonitoringProgram_pskel.
  //
  bool MedicationKnowledge_MonitoringProgram_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "name" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_MonitoringProgram_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_MonitoringProgram_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_MonitoringProgram_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "name" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->name_parser_)
            {
              this->name_parser_->pre ();
              ctx.nested_parser (this->name_parser_);
            }
          }
          else
          {
            if (this->name_parser_ != 0)
            {
              this->name_parser_->post_string ();
              this->name ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_AdministrationGuidelines_pskel.
  //
  bool MedicationKnowledge_AdministrationGuidelines_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "dosage" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "indicationCodeableConcept" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "indicationReference" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "patientCharacteristics" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_AdministrationGuidelines_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_AdministrationGuidelines_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_AdministrationGuidelines_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "dosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->dosage_parser_)
            {
              this->dosage_parser_->pre ();
              ctx.nested_parser (this->dosage_parser_);
            }
          }
          else
          {
            if (this->dosage_parser_ != 0)
            {
              this->dosage_parser_->post_MedicationKnowledge_Dosage ();
              this->dosage ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "indicationCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->indicationCodeableConcept_parser_)
            {
              this->indicationCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->indicationCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->indicationCodeableConcept_parser_ != 0)
            {
              this->indicationCodeableConcept_parser_->post_CodeableConcept ();
              this->indicationCodeableConcept ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "indicationReference" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->indicationReference_parser_)
            {
              this->indicationReference_parser_->pre ();
              ctx.nested_parser (this->indicationReference_parser_);
            }
          }
          else
          {
            if (this->indicationReference_parser_ != 0)
            {
              this->indicationReference_parser_->post_Reference ();
              this->indicationReference ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "patientCharacteristics" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->patientCharacteristics_parser_)
            {
              this->patientCharacteristics_parser_->pre ();
              ctx.nested_parser (this->patientCharacteristics_parser_);
            }
          }
          else
          {
            if (this->patientCharacteristics_parser_ != 0)
            {
              this->patientCharacteristics_parser_->post_MedicationKnowledge_PatientCharacteristics ();
              this->patientCharacteristics ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Dosage_pskel.
  //
  bool MedicationKnowledge_Dosage_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Dosage_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Dosage_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Dosage_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Dosage_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Dosage_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "dosage" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->dosage_parser_)
            {
              this->dosage_parser_->pre ();
              ctx.nested_parser (this->dosage_parser_);
            }
          }
          else
          {
            if (this->dosage_parser_ != 0)
            {
              this->dosage_parser_->post_Dosage ();
              this->dosage ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_PatientCharacteristics_pskel.
  //
  bool MedicationKnowledge_PatientCharacteristics_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "characteristicCodeableConcept" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "characteristicQuantity" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "value" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_PatientCharacteristics_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_PatientCharacteristics_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_PatientCharacteristics_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "characteristicCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->characteristicCodeableConcept_parser_)
            {
              this->characteristicCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->characteristicCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->characteristicCodeableConcept_parser_ != 0)
            {
              this->characteristicCodeableConcept_parser_->post_CodeableConcept ();
              this->characteristicCodeableConcept ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "characteristicQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->characteristicQuantity_parser_)
            {
              this->characteristicQuantity_parser_->pre ();
              ctx.nested_parser (this->characteristicQuantity_parser_);
            }
          }
          else
          {
            if (this->characteristicQuantity_parser_ != 0)
            {
              this->characteristicQuantity_parser_->post_Quantity ();
              this->characteristicQuantity ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "value" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->value_parser_)
            {
              this->value_parser_->pre ();
              ctx.nested_parser (this->value_parser_);
            }
          }
          else
          {
            if (this->value_parser_ != 0)
            {
              this->value_parser_->post_string ();
              this->value ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_MedicineClassification_pskel.
  //
  bool MedicationKnowledge_MedicineClassification_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_MedicineClassification_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_MedicineClassification_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_MedicineClassification_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "classification" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->classification_parser_)
            {
              this->classification_parser_->pre ();
              ctx.nested_parser (this->classification_parser_);
            }
          }
          else
          {
            if (this->classification_parser_ != 0)
            {
              this->classification_parser_->post_CodeableConcept ();
              this->classification ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Packaging_pskel.
  //
  bool MedicationKnowledge_Packaging_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "quantity" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Packaging_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Packaging_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Packaging_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Packaging_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Packaging_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "quantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->quantity_parser_)
            {
              this->quantity_parser_->pre ();
              ctx.nested_parser (this->quantity_parser_);
            }
          }
          else
          {
            if (this->quantity_parser_ != 0)
            {
              this->quantity_parser_->post_Quantity ();
              this->quantity ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_DrugCharacteristic_pskel.
  //
  bool MedicationKnowledge_DrugCharacteristic_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "valueCodeableConcept" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "valueString" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;
        else if (n == "valueQuantity" &&
                 ns == "http://hl7.org/fhir")
          s = 3UL;
        else if (n == "valueBase64Binary" &&
                 ns == "http://hl7.org/fhir")
          s = 4UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_DrugCharacteristic_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_DrugCharacteristic_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_DrugCharacteristic_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "valueCodeableConcept" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueCodeableConcept_parser_)
            {
              this->valueCodeableConcept_parser_->pre ();
              ctx.nested_parser (this->valueCodeableConcept_parser_);
            }
          }
          else
          {
            if (this->valueCodeableConcept_parser_ != 0)
            {
              this->valueCodeableConcept_parser_->post_CodeableConcept ();
              this->valueCodeableConcept ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "valueString" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueString_parser_)
            {
              this->valueString_parser_->pre ();
              ctx.nested_parser (this->valueString_parser_);
            }
          }
          else
          {
            if (this->valueString_parser_ != 0)
            {
              this->valueString_parser_->post_string ();
              this->valueString ();
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "valueQuantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueQuantity_parser_)
            {
              this->valueQuantity_parser_->pre ();
              ctx.nested_parser (this->valueQuantity_parser_);
            }
          }
          else
          {
            if (this->valueQuantity_parser_ != 0)
            {
              this->valueQuantity_parser_->post_Quantity ();
              this->valueQuantity ();
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "valueBase64Binary" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->valueBase64Binary_parser_)
            {
              this->valueBase64Binary_parser_->pre ();
              ctx.nested_parser (this->valueBase64Binary_parser_);
            }
          }
          else
          {
            if (this->valueBase64Binary_parser_ != 0)
            {
              this->valueBase64Binary_parser_->post_base64Binary ();
              this->valueBase64Binary ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Regulatory_pskel.
  //
  bool MedicationKnowledge_Regulatory_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "regulatoryAuthority" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Regulatory_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Regulatory_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Regulatory_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Regulatory_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "regulatoryAuthority" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->regulatoryAuthority_parser_)
            {
              this->regulatoryAuthority_parser_->pre ();
              ctx.nested_parser (this->regulatoryAuthority_parser_);
            }
          }
          else
          {
            if (this->regulatoryAuthority_parser_ != 0)
            {
              this->regulatoryAuthority_parser_->post_Reference ();
              this->regulatoryAuthority ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "substitution" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->substitution_parser_)
            {
              this->substitution_parser_->pre ();
              ctx.nested_parser (this->substitution_parser_);
            }
          }
          else
          {
            if (this->substitution_parser_ != 0)
            {
              this->substitution_parser_->post_MedicationKnowledge_Substitution ();
              this->substitution ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "schedule" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->schedule_parser_)
            {
              this->schedule_parser_->pre ();
              ctx.nested_parser (this->schedule_parser_);
            }
          }
          else
          {
            if (this->schedule_parser_ != 0)
            {
              this->schedule_parser_->post_MedicationKnowledge_Schedule ();
              this->schedule ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "maxDispense" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->maxDispense_parser_)
            {
              this->maxDispense_parser_->pre ();
              ctx.nested_parser (this->maxDispense_parser_);
            }
          }
          else
          {
            if (this->maxDispense_parser_ != 0)
            {
              this->maxDispense_parser_->post_MedicationKnowledge_MaxDispense ();
              this->maxDispense ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Substitution_pskel.
  //
  bool MedicationKnowledge_Substitution_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "type" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Substitution_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Substitution_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Substitution_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Substitution_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Substitution_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "type" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->type_parser_)
            {
              this->type_parser_->pre ();
              ctx.nested_parser (this->type_parser_);
            }
          }
          else
          {
            if (this->type_parser_ != 0)
            {
              this->type_parser_->post_CodeableConcept ();
              this->type ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "allowed" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->allowed_parser_)
            {
              this->allowed_parser_->pre ();
              ctx.nested_parser (this->allowed_parser_);
            }
          }
          else
          {
            if (this->allowed_parser_ != 0)
            {
              this->allowed_parser_->post_boolean ();
              this->allowed ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Schedule_pskel.
  //
  bool MedicationKnowledge_Schedule_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "schedule" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Schedule_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Schedule_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Schedule_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Schedule_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Schedule_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "schedule" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->schedule_parser_)
            {
              this->schedule_parser_->pre ();
              ctx.nested_parser (this->schedule_parser_);
            }
          }
          else
          {
            if (this->schedule_parser_ != 0)
            {
              this->schedule_parser_->post_CodeableConcept ();
              this->schedule ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_MaxDispense_pskel.
  //
  bool MedicationKnowledge_MaxDispense_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "quantity" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_MaxDispense_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          if (vd->count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return true;
          }

          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_MaxDispense_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_MaxDispense_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_MaxDispense_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_schema_error (::xsde::cxx::schema_error::expected_element);

    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_MaxDispense_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "quantity" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->quantity_parser_)
            {
              this->quantity_parser_->pre ();
              ctx.nested_parser (this->quantity_parser_);
            }
          }
          else
          {
            if (this->quantity_parser_ != 0)
            {
              this->quantity_parser_->post_Quantity ();
              this->quantity ();
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            break;
          }

          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "period" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->period_parser_)
            {
              this->period_parser_->pre ();
              ctx.nested_parser (this->period_parser_);
            }
          }
          else
          {
            if (this->period_parser_ != 0)
            {
              this->period_parser_->post_Duration ();
              this->period ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for MedicationKnowledge_Kinetics_pskel.
  //
  bool MedicationKnowledge_Kinetics_pskel::
  _start_element_impl (const ::xsde::cxx::ro_string& ns,
                       const ::xsde::cxx::ro_string& n)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (base::_start_element_impl (ns, n))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL && !ctx.error_type ())
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "areaUnderCurve" &&
            ns == "http://hl7.org/fhir")
          s = 0UL;
        else if (n == "lethalDose50" &&
                 ns == "http://hl7.org/fhir")
          s = 1UL;
        else if (n == "halfLifePeriod" &&
                 ns == "http://hl7.org/fhir")
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &MedicationKnowledge_Kinetics_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool MedicationKnowledge_Kinetics_pskel::
  _end_element_impl (const ::xsde::cxx::ro_string& ns,
                     const ::xsde::cxx::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      typedef ::fhir::BackboneElement_pskel base;
      if (!base::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void MedicationKnowledge_Kinetics_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
    typedef ::fhir::BackboneElement_pskel base;
    base::_pre_e_validate ();
  }

  void MedicationKnowledge_Kinetics_pskel::
  _post_e_validate ()
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    typedef ::fhir::BackboneElement_pskel base;
    base::_post_e_validate ();

    if (ctx.error_type ())
      return;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xsde::cxx::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, true);

      if (ctx.error_type ())
        return;

      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void MedicationKnowledge_Kinetics_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xsde::cxx::ro_string& ns,
              const ::xsde::cxx::ro_string& n,
              bool start)
  {
    ::xsde::cxx::parser::context& ctx = this->_context ();

    XSDE_UNUSED (ctx);

    switch (state)
    {
      case 0UL:
      {
        if (n == "areaUnderCurve" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->areaUnderCurve_parser_)
            {
              this->areaUnderCurve_parser_->pre ();
              ctx.nested_parser (this->areaUnderCurve_parser_);
            }
          }
          else
          {
            if (this->areaUnderCurve_parser_ != 0)
            {
              this->areaUnderCurve_parser_->post_Quantity ();
              this->areaUnderCurve ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "lethalDose50" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->lethalDose50_parser_)
            {
              this->lethalDose50_parser_->pre ();
              ctx.nested_parser (this->lethalDose50_parser_);
            }
          }
          else
          {
            if (this->lethalDose50_parser_ != 0)
            {
              this->lethalDose50_parser_->post_Quantity ();
              this->lethalDose50 ();
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "halfLifePeriod" &&
            ns == "http://hl7.org/fhir")
        {
          if (start)
          {
            if (this->halfLifePeriod_parser_)
            {
              this->halfLifePeriod_parser_->pre ();
              ctx.nested_parser (this->halfLifePeriod_parser_);
            }
          }
          else
          {
            if (this->halfLifePeriod_parser_ != 0)
            {
              this->halfLifePeriod_parser_->post_Duration ();
              this->halfLifePeriod ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace fhir
{
}

namespace fhir
{
}

#include <xsde/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

